This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.env.example
backend/src/app.ts
backend/src/config/database.ts
backend/src/config/environment.ts
backend/src/config/jwt.ts
backend/src/config/redis.ts
backend/src/config/websocket.ts
backend/src/controllers/authController.ts
backend/src/controllers/roomController.ts
backend/src/database/init.sql
backend/src/database/seeds/index.ts
backend/src/game/ActionManager.ts
backend/src/game/Game.ts
backend/src/game/GameEngine.ts
backend/src/game/PhaseManager.ts
backend/src/game/RoleSystem.ts
backend/src/game/TimerManager.ts
backend/src/middleware/auth.ts
backend/src/routes/auth.ts
backend/src/routes/rooms.ts
backend/src/server.ts
backend/src/types/index.ts
backend/src/utils/constants.ts
backend/src/utils/helper.ts
backend/src/utils/logger.ts
backend/src/utils/simpleValidators.ts
backend/src/utils/validators.ts
backend/src/websocket/ChannelManager.ts
backend/src/websocket/ConnectionManager.ts
backend/src/websocket/HeartbeatManager.ts
backend/src/websocket/index.ts
backend/src/websocket/MessageRouter.ts
backend/src/websocket/ServiceFactory.ts
backend/src/websocket/WebSocketManager.ts
database/init.sql
frontend/.env.example
frontend/src/components/common/Button.tsx
frontend/src/components/common/ErrorBoundary.tsx
frontend/src/components/common/Layout.tsx
frontend/src/components/common/LoadingSpinner.tsx
frontend/src/components/common/Modal.tsx
frontend/src/components/game/ActionPanel.tsx
frontend/src/components/game/ChatGigante.tsx
frontend/src/components/game/GameBoard.tsx
frontend/src/components/game/PhaseIndicator.tsx
frontend/src/components/game/PlayerCircle.tsx
frontend/src/components/game/PlayerList.tsx
frontend/src/components/game/RoleCard.tsx
frontend/src/components/game/TimerDisplay.tsx
frontend/src/components/game/WillNotes.tsx
frontend/src/components/lobby/CreateRoomModal.tsx
frontend/src/components/lobby/JoinRoomModal.tsx
frontend/src/components/room/ActionButtons.tsx
frontend/src/components/room/PlayerList.tsx
frontend/src/components/room/RoomChat.tsx
frontend/src/components/room/WaitingRoom.tsx
frontend/src/context/AuthContext.tsx
frontend/src/context/GameContext.tsx
frontend/src/context/SocketContext.tsx
frontend/src/context/ThemeContext.tsx
frontend/src/hooks/index.ts
frontend/src/pages/_app.tsx
frontend/src/pages/_document.tsx
frontend/src/pages/auth/forgot-password.tsx
frontend/src/pages/auth/login.tsx
frontend/src/pages/auth/register.tsx
frontend/src/pages/game/[gameId].tsx
frontend/src/pages/game/mock.tsx
frontend/src/pages/index.tsx
frontend/src/pages/lobby.tsx
frontend/src/pages/room/[id].tsx
frontend/src/types/index.ts
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# üê∫ LOBISOMEM ONLINE - Environment Variables

# =============================================================================
# CORE SETTINGS
# =============================================================================
NODE_ENV=development
PORT=3001

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
DATABASE_URL=postgresql://werewolf:werewolf123@localhost:5432/werewolf_dev
REDIS_URL=redis://localhost:6379

# =============================================================================
# AUTHENTICATION
# =============================================================================
JWT_SECRET=your-super-secret-jwt-key-change-in-production
JWT_EXPIRES_IN=7d

# =============================================================================
# ARCHITECTURE MODE (CR√çTICO PARA MIGRA√á√ÉO)
# =============================================================================
# Fase 1: false | Fase 2: true
DISTRIBUTED_MODE=false

# memory (Fase 1) | redis (Fase 2)
STORAGE_TYPE=memory

# =============================================================================
# SERVICE DISCOVERY (FASE 2)
# =============================================================================
SERVICE_ID=local-server
SERVICE_TYPE=monolith
# monolith | lobby | game

# =============================================================================
# WEBSOCKET CONFIGURATION
# =============================================================================
WS_BASE_PATH=/ws
WS_PORT=3001

# =============================================================================
# GAME SETTINGS
# =============================================================================
MIN_PLAYERS=6
MAX_PLAYERS=15
MAX_SPECTATORS=5
NIGHT_DURATION=60000
DAY_DURATION=120000
VOTING_DURATION=30000

# =============================================================================
# EMAIL (OPCIONAL)
# =============================================================================
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# =============================================================================
# FRONTEND CONFIGURATION
# =============================================================================
NEXT_PUBLIC_API_URL=http://localhost:3001
NEXT_PUBLIC_WS_URL=ws://localhost:3001
</file>

<file path="backend/src/database/init.sql">
-- Garante que a extens√£o para UUIDs seja criada
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tabela de usu√°rios com UUID como chave prim√°ria
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(50) UNIQUE NOT NULL,
    "passwordHash" TEXT NOT NULL, -- "passwordHash" entre aspas por causa do case
    avatar TEXT,
    level INTEGER DEFAULT 1 NOT NULL,
    "totalGames" INTEGER DEFAULT 0 NOT NULL,
    "totalWins" INTEGER DEFAULT 0 NOT NULL,
    "totalLosses" INTEGER DEFAULT 0 NOT NULL,
    "winRate" DECIMAL(5, 4) DEFAULT 0.0000 NOT NULL, -- Maior precis√£o
    "createdAt" TIMESTAMPTZ DEFAULT NOW(), -- TIMESTAMPTZ √© melhor para fusos hor√°rios
    "updatedAt" TIMESTAMPTZ DEFAULT NOW(),
    "lastLoginAt" TIMESTAMPTZ
);

-- Tabela de salas
CREATE TABLE IF NOT EXISTS rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    code VARCHAR(6) UNIQUE,
    "isPrivate" BOOLEAN DEFAULT false NOT NULL,
    "maxPlayers" INTEGER DEFAULT 15 NOT NULL,
    "maxSpectators" INTEGER DEFAULT 5 NOT NULL,
    status VARCHAR(20) DEFAULT 'WAITING' NOT NULL,
    "hostId" UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL, -- Evitar apagar salas se o host for deletado
    "serverId" VARCHAR(50) DEFAULT 'local-server',
    "createdAt" TIMESTAMPTZ DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ DEFAULT NOW()
);

-- √çndices para melhor performance
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_rooms_code ON rooms(code);
CREATE INDEX IF NOT EXISTS idx_rooms_status ON rooms(status);

-- Fun√ß√£o para atualizar o campo "updatedAt" automaticamente
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW."updatedAt" = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers para usar a fun√ß√£o acima
-- Dropa o trigger se ele j√° existir, para evitar erros ao rodar o script de novo
DROP TRIGGER IF EXISTS update_users_updated_at ON users;
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_rooms_updated_at ON rooms;
CREATE TRIGGER update_rooms_updated_at BEFORE UPDATE ON rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="backend/src/game/ActionManager.ts">
// üê∫ LOBISOMEM ONLINE - Action Manager (CORRIGIDO DEFINITIVAMENTE)
import { GameState, Player } from './Game';
import { ROLE_CONFIGURATIONS } from './RoleSystem';
import type { Role, Faction, GamePhase, GameStatus, GameConfig, IGameEngine } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// ACTION INTERFACES (CORRIGIDAS PARA exactOptionalPropertyTypes)
//====================================================================
export interface GameAction {
    id: string;
    playerId: string;
    type: string;
    targetId?: string; // Opcional, pode n√£o existir
    data?: any;
    timestamp: Date;
    phase: string;
    day: number;
    priority: number;
    isValid: boolean;
    processed: boolean;
}

export interface ActionResult {
    success: boolean;
    actionId: string;
    message?: string;
    data?: any;
    errors?: string[];
}

// CORRE√á√ÉO: Interface para NightAction que aceita targetId opcional
export interface NightAction {
    playerId: string;
    type: string;
    targetId?: string; // CORRE√á√ÉO: Opcional, n√£o undefined expl√≠cito
    data?: any;
    priority: number;
}

//====================================================================
// ACTION MANAGER CLASS - CORRIGIDA PARA exactOptionalPropertyTypes
//====================================================================
export class ActionManager {
    private gameState: GameState;
    private pendingActions = new Map<string, GameAction>();
    private processedActions = new Map<string, GameAction>();

    constructor(gameState: GameState) {
        this.gameState = gameState;
    }

    //====================================================================
    // ACTION SUBMISSION
    //====================================================================
    async performAction(playerId: string, actionData: any): Promise<ActionResult> {
        try {
            // Validate player
            const player = this.gameState.getPlayer(playerId);
            if (!player) {
                return {
                    success: false,
                    actionId: '',
                    message: 'Jogador n√£o encontrado',
                    errors: ['PLAYER_NOT_FOUND'],
                };
            }

            // Validate basic requirements
            const validation = this.validateAction(player, actionData);
            if (!validation.success) {
                return validation;
            }

            // Create action
            const action = this.createAction(player, actionData);

            // Process action based on phase
            if (this.gameState.phase === 'NIGHT') {
                return await this.processNightAction(action);
            } else if (this.gameState.phase === 'VOTING') {
                return await this.processVotingAction(action);
            } else {
                return {
                    success: false,
                    actionId: action.id,
                    message: 'A√ß√µes n√£o permitidas nesta fase',
                    errors: ['INVALID_PHASE'],
                };
            }

        } catch (error) {
            logger.error('Error performing action', error instanceof Error ? error : new Error('Unknown action error'), {
                playerId,
                actionData,
                gameId: this.gameState.gameId,
            });

            return {
                success: false,
                actionId: '',
                message: 'Erro interno ao processar a√ß√£o',
                errors: ['INTERNAL_ERROR'],
            };
        }
    }

    //====================================================================
    // ACTION VALIDATION
    //====================================================================
    private validateAction(player: Player, actionData: any): ActionResult {
        // Check if player is alive
        if (!player.isAlive && actionData.type !== 'SPECTATE') {
            return {
                success: false,
                actionId: '',
                message: 'Jogadores mortos n√£o podem realizar a√ß√µes',
                errors: ['PLAYER_DEAD'],
            };
        }

        // Check if player can act
        if (!player.canAct() && actionData.type !== 'VOTE' && actionData.type !== 'UNVOTE') {
            return {
                success: false,
                actionId: '',
                message: 'Voc√™ n√£o pode realizar a√ß√µes neste momento',
                errors: ['CANNOT_ACT'],
            };
        }

        // Check action type validity
        if (!this.isValidActionType(actionData.type)) {
            return {
                success: false,
                actionId: '',
                message: 'Tipo de a√ß√£o inv√°lido',
                errors: ['INVALID_ACTION_TYPE'],
            };
        }

        // Check phase-specific permissions
        if (!this.canPerformActionInPhase(player.role, actionData.type, this.gameState.phase)) {
            return {
                success: false,
                actionId: '',
                message: 'A√ß√£o n√£o permitida nesta fase',
                errors: ['INVALID_PHASE_FOR_ACTION'],
            };
        }

        // Check if target is valid (if action requires target)
        if (this.requiresTarget(actionData.type)) {
            const targetValidation = this.validateTarget(player, actionData);
            if (!targetValidation.success) {
                return targetValidation;
            }
        }

        return { success: true, actionId: '' };
    }

    private validateTarget(player: Player, actionData: any): ActionResult {
        if (!actionData.targetId) {
            return {
                success: false,
                actionId: '',
                message: 'Alvo √© obrigat√≥rio para esta a√ß√£o',
                errors: ['TARGET_REQUIRED'],
            };
        }

        const target = this.gameState.getPlayer(actionData.targetId);
        if (!target) {
            return {
                success: false,
                actionId: '',
                message: 'Alvo n√£o encontrado',
                errors: ['TARGET_NOT_FOUND'],
            };
        }

        // Check if target is alive (for most actions)
        if (!target.isAlive && !['INVESTIGATE'].includes(actionData.type)) {
            return {
                success: false,
                actionId: '',
                message: 'N√£o √© poss√≠vel ter como alvo um jogador morto',
                errors: ['TARGET_DEAD'],
            };
        }

        // Check self-targeting rules
        if (player.id === target.id && !this.allowsSelfTarget(actionData.type)) {
            return {
                success: false,
                actionId: '',
                message: 'Voc√™ n√£o pode ter a si mesmo como alvo',
                errors: ['CANNOT_SELF_TARGET'],
            };
        }

        // Role-specific target validations
        const roleValidation = this.validateRoleSpecificTarget(player, target, actionData);
        if (!roleValidation.success) {
            return roleValidation;
        }

        return { success: true, actionId: '' };
    }

    private validateRoleSpecificTarget(player: Player, target: Player, actionData: any): ActionResult {
        switch (actionData.type) {
            case 'PROTECT':
                // Doctor can't protect same person twice in a row
                if (!target.canBeProtectedByDoctor) {
                    return {
                        success: false,
                        actionId: '',
                        message: 'N√£o √© poss√≠vel proteger a mesma pessoa duas noites seguidas',
                        errors: ['CANNOT_PROTECT_CONSECUTIVELY'],
                    };
                }
                break;

            case 'WEREWOLF_KILL':
                // Werewolves can't kill other werewolves
                if (target.faction === 'WEREWOLF') {
                    return {
                        success: false,
                        actionId: '',
                        message: 'Lobisomens n√£o podem atacar outros lobisomens',
                        errors: ['CANNOT_KILL_WEREWOLF'],
                    };
                }
                break;

            case 'VOTE':
                // Can't vote for yourself
                if (player.id === target.id) {
                    return {
                        success: false,
                        actionId: '',
                        message: 'Voc√™ n√£o pode votar em si mesmo',
                        errors: ['CANNOT_VOTE_SELF'],
                    };
                }
                break;
        }

        return { success: true, actionId: '' };
    }

    //====================================================================
    // ACTION CREATION
    //====================================================================
    private createAction(player: Player, actionData: any): GameAction {
        const actionId = `${this.gameState.gameId}-${player.id}-${actionData.type}-${Date.now()}`;

        const action: GameAction = {
            id: actionId,
            playerId: player.id,
            type: actionData.type,
            // CORRE√á√ÉO: S√≥ incluir targetId se existir, evitando undefined expl√≠cito
            ...(actionData.targetId && { targetId: actionData.targetId }),
            data: actionData.data || {},
            timestamp: new Date(),
            phase: this.gameState.phase,
            day: this.gameState.day,
            priority: this.getActionPriority(actionData.type),
            isValid: true,
            processed: false,
        };

        return action;
    }

    //====================================================================
    // NIGHT ACTIONS
    //====================================================================
    private async processNightAction(action: GameAction): Promise<ActionResult> {
        const player = this.gameState.getPlayer(action.playerId);
        if (!player) {
            return {
                success: false,
                actionId: action.id,
                message: 'Jogador n√£o encontrado',
                errors: ['PLAYER_NOT_FOUND'],
            };
        }

        // Mark player as having acted
        player.performAction(action.type, action.targetId);

        // Store action for processing at end of night
        this.pendingActions.set(action.id, action);

        // CORRE√á√ÉO: Criar NightAction corretamente, s√≥ incluindo targetId se existir
        const nightAction: NightAction = {
            playerId: action.playerId,
            type: action.type,
            // CORRE√á√ÉO: S√≥ incluir targetId se realmente existir
            ...(action.targetId && { targetId: action.targetId }),
            data: action.data,
            priority: action.priority,
        };

        this.gameState.nightActions.push(nightAction);

        // Log the action
        logger.info('Night action queued', {
            gameId: this.gameState.gameId,
            actionId: action.id,
            playerId: action.playerId,
            type: action.type,
            targetId: action.targetId,
        });

        // Send confirmation to player
        this.gameState.addEvent('ACTION_SUBMITTED', {
            actionId: action.id,
            type: action.type,
            message: this.getActionConfirmationMessage(action.type),
        }, [action.playerId]);

        return {
            success: true,
            actionId: action.id,
            message: this.getActionConfirmationMessage(action.type),
        };
    }

    //====================================================================
    // VOTING ACTIONS
    //====================================================================
    private async processVotingAction(action: GameAction): Promise<ActionResult> {
        if (action.type === 'VOTE') {
            return await this.processVote(action);
        } else if (action.type === 'UNVOTE') {
            return await this.processUnvote(action);
        } else {
            return {
                success: false,
                actionId: action.id,
                message: 'A√ß√£o n√£o permitida durante vota√ß√£o',
                errors: ['INVALID_VOTING_ACTION'],
            };
        }
    }

    private async processVote(action: GameAction): Promise<ActionResult> {
        if (!action.targetId) {
            return {
                success: false,
                actionId: action.id,
                message: 'Alvo √© obrigat√≥rio para vota√ß√£o',
                errors: ['TARGET_REQUIRED'],
            };
        }

        const success = this.gameState.addVote(action.playerId, action.targetId);

        if (success) {
            this.processedActions.set(action.id, action);

            const target = this.gameState.getPlayer(action.targetId);
            logger.info('Vote cast', {
                gameId: this.gameState.gameId,
                voterId: action.playerId,
                targetId: action.targetId,
                targetName: target?.username,
            });

            return {
                success: true,
                actionId: action.id,
                message: `Voto registrado em ${target?.username}`,
                data: {
                    targetName: target?.username,
                    voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
                },
            };
        } else {
            return {
                success: false,
                actionId: action.id,
                message: 'Falha ao registrar voto',
                errors: ['VOTE_FAILED'],
            };
        }
    }

    private async processUnvote(action: GameAction): Promise<ActionResult> {
        const success = this.gameState.removeVote(action.playerId);

        if (success) {
            this.processedActions.set(action.id, action);

            logger.info('Vote removed', {
                gameId: this.gameState.gameId,
                voterId: action.playerId,
            });

            return {
                success: true,
                actionId: action.id,
                message: 'Voto removido',
                data: {
                    voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
                },
            };
        } else {
            return {
                success: false,
                actionId: action.id,
                message: 'Falha ao remover voto',
                errors: ['UNVOTE_FAILED'],
            };
        }
    }

    //====================================================================
    // ACTION VALIDATION HELPERS
    //====================================================================
    private isValidActionType(type: string): boolean {
        const validTypes = [
            'INVESTIGATE', 'PROTECT', 'WEREWOLF_KILL', 'VIGILANTE_KILL',
            'SERIAL_KILL', 'VOTE', 'UNVOTE', 'SPECTATE'
        ];
        return validTypes.includes(type);
    }

    private canPerformActionInPhase(role: Role | undefined, actionType: string, phase: string): boolean {
        if (!role) return false;

        const roleConfig = ROLE_CONFIGURATIONS[role];

        // Special cases for voting
        if (actionType === 'VOTE' || actionType === 'UNVOTE') {
            return phase === 'VOTING';
        }

        // Night actions
        if (phase === 'NIGHT') {
            return roleConfig.actsDuring.includes('NIGHT') && this.isNightAction(actionType);
        }

        return false;
    }

    private isNightAction(actionType: string): boolean {
        const nightActions = ['INVESTIGATE', 'PROTECT', 'WEREWOLF_KILL', 'VIGILANTE_KILL', 'SERIAL_KILL'];
        return nightActions.includes(actionType);
    }

    private requiresTarget(actionType: string): boolean {
        const targetActions = ['INVESTIGATE', 'PROTECT', 'WEREWOLF_KILL', 'VIGILANTE_KILL', 'SERIAL_KILL', 'VOTE'];
        return targetActions.includes(actionType);
    }

    private allowsSelfTarget(actionType: string): boolean {
        const selfTargetActions = ['PROTECT']; // Doctor can protect themselves
        return selfTargetActions.includes(actionType);
    }

    private getActionPriority(actionType: string): number {
        const priorities: Record<string, number> = {
            'PROTECT': 1,        // Protections first
            'INVESTIGATE': 3,    // Investigations
            'WEREWOLF_KILL': 5,  // Werewolf kills
            'VIGILANTE_KILL': 4, // Vigilante kills
            'SERIAL_KILL': 6,    // Serial killer last
            'VOTE': 1,           // Votes are immediate
            'UNVOTE': 1,         // Unvotes are immediate
        };

        return priorities[actionType] || 999;
    }

    private getActionConfirmationMessage(actionType: string): string {
        const messages: Record<string, string> = {
            'INVESTIGATE': 'Investiga√ß√£o programada para esta noite',
            'PROTECT': 'Prote√ß√£o programada para esta noite',
            'WEREWOLF_KILL': 'Ataque programado para esta noite',
            'VIGILANTE_KILL': 'Execu√ß√£o programada para esta noite',
            'SERIAL_KILL': 'Assassinato programado para esta noite',
            'VOTE': 'Voto registrado',
            'UNVOTE': 'Voto removido',
        };

        return messages[actionType] || 'A√ß√£o programada';
    }

    //====================================================================
    // ACTION PROCESSING UTILITIES
    //====================================================================
    getAllPendingActions(): GameAction[] {
        return Array.from(this.pendingActions.values())
            .sort((a, b) => a.priority - b.priority);
    }

    clearPendingActions(): void {
        // Move pending to processed
        this.pendingActions.forEach((action, id) => {
            action.processed = true;
            this.processedActions.set(id, action);
        });

        this.pendingActions.clear();
    }

    getActionHistory(playerId?: string): GameAction[] {
        const allActions = Array.from(this.processedActions.values());

        if (playerId) {
            return allActions.filter(action => action.playerId === playerId);
        }

        return allActions;
    }

    //====================================================================
    // STATISTICS AND MONITORING
    //====================================================================
    getActionStats(): {
        total: number;
        pending: number;
        processed: number;
        byType: Record<string, number>;
        byPhase: Record<string, number>;
    } {
        const allActions = [
            ...Array.from(this.pendingActions.values()),
            ...Array.from(this.processedActions.values())
        ];

        const stats = {
            total: allActions.length,
            pending: this.pendingActions.size,
            processed: this.processedActions.size,
            byType: {} as Record<string, number>,
            byPhase: {} as Record<string, number>,
        };

        allActions.forEach(action => {
            stats.byType[action.type] = (stats.byType[action.type] || 0) + 1;
            stats.byPhase[action.phase] = (stats.byPhase[action.phase] || 0) + 1;
        });

        return stats;
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    cleanup(): void {
        this.pendingActions.clear();
        this.processedActions.clear();
        logger.info('ActionManager cleanup completed');
    }

    
}
</file>

<file path="backend/src/game/PhaseManager.ts">
// üê∫ LOBISOMEM ONLINE - Phase Manager (REFATORADO)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service

import { GameState } from './Game';
import { RoleDistributor, RoleRevealManager } from './RoleSystem';
import { GamePhase, Faction, Role } from '@/utils/constants';
import type { IGameEngine, NightAction, NightResults } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// PHASE MANAGER CLASS - REFATORADA
//====================================================================
export class PhaseManager {
    private gameState: GameState;
    private gameEngine: IGameEngine;
    private currentPhaseTimer?: NodeJS.Timeout;

    constructor(gameState: GameState, gameEngine: IGameEngine) {
        this.gameState = gameState;
        this.gameEngine = gameEngine;
    }

    //====================================================================
    // PHASE CONTROL
    //====================================================================
    async startFirstNight(): Promise<void> {
        logger.info('Starting first night phase', { gameId: this.gameState.gameId });

        // CORRE√á√ÉO 2: Usar o enum GamePhase
        await this.changePhase(GamePhase.NIGHT, this.gameState.config.nightDuration);

        this.gameState.addEvent('FIRST_NIGHT_STARTED', {
            message: 'A primeira noite chegou √† vila. Os poderes especiais acordam...',
            // CORRE√á√ÉO 2: Usar o enum GamePhase
            roles: this.getRolesForPhase(GamePhase.NIGHT),
        });
    }

    async nextPhase(): Promise<void> {
        const currentPhase = this.gameState.phase;

        try {
            switch (currentPhase) {
                case GamePhase.LOBBY:
                    // Should not happen during game
                    break;

                case GamePhase.NIGHT:
                    await this.processNightResults();
                    // CORRE√á√ÉO 2: Usar o enum GamePhase
                    await this.changePhase(GamePhase.DAY, this.gameState.config.dayDuration);
                    break;

                case GamePhase.DAY:
                    // CORRE√á√ÉO 2: Usar o enum GamePhase
                    await this.changePhase(GamePhase.VOTING, this.gameState.config.votingDuration);
                    break;

                case GamePhase.VOTING:
                    await this.processVotingResults();
                    // Check if game ended, otherwise go to next night
                    if (this.gameState.status === 'PLAYING') {
                        // CORRE√á√ÉO 2: Usar o enum GamePhase
                        await this.changePhase(GamePhase.NIGHT, this.gameState.config.nightDuration);
                    }
                    break;

                case GamePhase.ENDED:
                    // Game has ended, no more phases
                    break;
            }
        } catch (error) {
            logger.error('Error during phase transition', error instanceof Error ? error : new Error('Unknown phase error'), {
                gameId: this.gameState.gameId,
                currentPhase,
            });
        }
    }

    private async changePhase(newPhase: GamePhase, duration: number): Promise<void> {
        const oldPhase = this.gameState.phase;

        if (this.currentPhaseTimer) {
            clearTimeout(this.currentPhaseTimer);
        }

        this.gameState.changePhase(newPhase, duration);

        logger.info('Phase changed', {
            gameId: this.gameState.gameId,
            from: oldPhase,
            to: newPhase,
            duration,
            day: this.gameState.day,
        });

        this.currentPhaseTimer = setTimeout(() => {
            this.nextPhase();
        }, duration);

        await this.onPhaseStart(newPhase);
    }


    //====================================================================
    // PHASE-SPECIFIC LOGIC
    //====================================================================
    private async onPhaseStart(phase: GamePhase): Promise<void> {
        switch (phase) {
            case 'NIGHT':
                await this.onNightStart();
                break;

            case 'DAY':
                await this.onDayStart();
                break;

            case 'VOTING':
                await this.onVotingStart();
                break;
        }
    }

    private async onNightStart(): Promise<void> {
        this.gameState.addEvent('NIGHT_STARTED', {
            day: this.gameState.day,
            message: `Noite ${this.gameState.day} - A vila dorme, mas alguns acordam...`,
            activeRoles: this.getRolesForPhase('NIGHT'),
            duration: this.gameState.config.nightDuration,
        });

        // Clear previous night's actions
        this.gameState.nightActions = [];

        // Reset player states for night
        this.gameState.players.forEach(player => {
            if (player.isAlive) {
                player.hasActed = false;
                player.removeProtection(); // Remove previous protection
            }
        });
    }

    private async onDayStart(): Promise<void> {
        this.gameState.addEvent('DAY_STARTED', {
            day: this.gameState.day,
            message: `Dia ${this.gameState.day} - O sol nasce e a vila acorda...`,
            duration: this.gameState.config.dayDuration,
        });
    }

    private async onVotingStart(): Promise<void> {
        const alivePlayers = this.gameState.getAlivePlayers();

        this.gameState.addEvent('VOTING_STARTED', {
            day: this.gameState.day,
            message: 'Hora da vota√ß√£o! Escolham quem ser√° executado.',
            eligibleVoters: alivePlayers.map(p => ({ id: p.id, username: p.username })),
            duration: this.gameState.config.votingDuration,
        });

        this.gameState.players.forEach(player => {
            if (player.isAlive) {
                // CORRE√á√ÉO 3: Usar o m√©todo da classe Player que lida com 'undefined' corretamente
                player.unvote();
            }
        });
    }

    //====================================================================
    // NIGHT RESULTS PROCESSING
    //====================================================================
    private async processNightResults(): Promise<void> {
        logger.info('Processing night results', {
            gameId: this.gameState.gameId,
            day: this.gameState.day,
            actionsCount: this.gameState.nightActions.length,
        });

        // Get all night actions sorted by priority
        const actions = this.gameState.nightActions.sort((a, b) => a.priority - b.priority);

        // Track what happened during the night
        const nightResults = {
            protections: [] as string[],
            investigations: [] as { investigatorId: string; targetId: string; result: string }[],
            attacks: [] as { attackerId: string; targetId: string; successful: boolean }[],
            deaths: [] as { playerId: string; cause: string; killedBy?: string }[],
        };

        // Process actions by priority
        for (const action of actions) {
            await this.processNightAction(action, nightResults);
        }

        // Apply deaths
        nightResults.deaths.forEach(death => {
            const player = this.gameState.getPlayer(death.playerId);
            if (player && player.isAlive) {
                player.kill(death.cause as any, death.killedBy);
            }
        });

        // Generate night summary
        await this.generateNightSummary(nightResults);
    }

    private async processNightAction(action: any, results: any): Promise<void> {
        const actor = this.gameState.getPlayer(action.playerId);
        if (!actor || !actor.isAlive) return;

        switch (action.type) {
            case 'PROTECT':
                await this.processProtection(action, results);
                break;

            case 'INVESTIGATE':
                await this.processInvestigation(action, results);
                break;

            case 'WEREWOLF_KILL':
                await this.processWerewolfKill(action, results);
                break;

            case 'VIGILANTE_KILL':
                await this.processVigilanteKill(action, results);
                break;

            case 'SERIAL_KILL':
                await this.processSerialKill(action, results);
                break;
        }
    }

    private async processProtection(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target) return;

        // Check if doctor can protect this target
        if (!target.canBeProtectedByDoctor) {
            this.gameState.addEvent('PROTECTION_FAILED', {
                doctorId: action.playerId,
                targetId: action.targetId,
                reason: 'N√£o pode proteger a mesma pessoa duas noites seguidas',
            }, [action.playerId]);
            return;
        }

        target.protect();
        results.protections.push(action.targetId);

        this.gameState.addEvent('PROTECTION_APPLIED', {
            doctorId: action.playerId,
            targetId: action.targetId,
        }, [action.playerId]);
    }

    private async processInvestigation(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target || !target.role) return;

        // ‚úÖ USAR RoleRevealManager em vez de reimplementar
        const result = RoleRevealManager.getInvestigationResult(target.role);

        results.investigations.push({
            investigatorId: action.playerId,
            targetId: action.targetId,
            result,
        });

        this.gameState.addEvent('INVESTIGATION_RESULT', {
            investigatorId: action.playerId,
            targetId: action.targetId,
            targetName: target.username,
            result,
        }, [action.playerId]);
    }

    private async processWerewolfKill(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target || !target.isAlive) return;

        const successful = !target.isProtected;

        results.attacks.push({
            attackerId: action.playerId,
            targetId: action.targetId,
            successful,
        });

        if (successful) {
            results.deaths.push({
                playerId: action.targetId,
                cause: 'NIGHT_KILL',
                killedBy: 'werewolves',
            });
        }
    }

    private async processVigilanteKill(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        const vigilante = this.gameState.getPlayer(action.playerId);

        if (!target || !target.isAlive || !vigilante) return;

        const successful = !target.isProtected;

        results.attacks.push({
            attackerId: action.playerId,
            targetId: action.targetId,
            successful,
        });

        if (successful) {
            results.deaths.push({
                playerId: action.targetId,
                cause: 'VIGILANTE',
                killedBy: action.playerId,
            });

            // If vigilante killed a town member, they feel guilty and lose next action
            if (target.faction === 'TOWN') {
                // Mark vigilante as having guilt (would need to track this)
                this.gameState.addEvent('VIGILANTE_GUILT', {
                    vigilanteId: action.playerId,
                    killedTownMember: action.targetId,
                }, [action.playerId]);
            }
        }
    }

    private async processSerialKill(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target || !target.isAlive) return;

        // Serial Killer is immune to doctor protection on first night
        const isFirstNight = this.gameState.day === 1;
        const successful = !target.isProtected || isFirstNight;

        results.attacks.push({
            attackerId: action.playerId,
            targetId: action.targetId,
            successful,
        });

        if (successful) {
            results.deaths.push({
                playerId: action.targetId,
                cause: 'SERIAL_KILLER',
                killedBy: action.playerId,
            });
        }
    }

    //====================================================================
    // VOTING RESULTS PROCESSING
    //====================================================================
    private async processVotingResults(): Promise<void> {
        const result = this.gameState.getMostVotedPlayer();

        if (result) {
            const player = this.gameState.getPlayer(result.playerId);
            if (player && player.role) { // Garante que player e role existem
                if (player.role === Role.JESTER) {
                    // CORRE√á√ÉO 4: Usar o enum Faction
                    this.gameState.endGame(Faction.NEUTRAL, [player.id]);

                    this.gameState.addEvent('JESTER_WINS', {
                        playerId: player.id,
                        playerName: player.username,
                        message: 'O Bobo da Corte venceu ao ser executado!',
                    });

                    logger.info('Jester wins by execution', {
                        gameId: this.gameState.gameId,
                        playerId: player.id,
                        playerName: player.username,
                    });

                    return;
                }

                player.kill('EXECUTION');

                this.gameState.addEvent('PLAYER_EXECUTED', {
                    playerId: player.id,
                    playerName: player.username,
                    role: player.role,
                    faction: player.faction,
                    votes: result.votes,
                    totalVoters: this.gameState.getAlivePlayers().length,
                });

                logger.info('Player executed by vote', {
                    gameId: this.gameState.gameId,
                    playerId: player.id,
                    playerName: player.username,
                    role: player.role,
                    votes: result.votes,
                });
            }
        } else {
            this.gameState.addEvent('NO_EXECUTION', {
                reason: 'Empate na vota√ß√£o ou votos insuficientes',
                voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
            });

            logger.info('No execution - tie or insufficient votes', {
                gameId: this.gameState.gameId,
                voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
            });
        }

        const winCondition = this.gameState.checkWinCondition();
        if (winCondition.hasWinner && this.gameState.status === 'PLAYING') {
            this.gameState.endGame(winCondition.winningFaction!, winCondition.winningPlayers!);
        }
    }

    //====================================================================
    // UTILITY METHODS
    //====================================================================
    private getRolesForPhase(phase: string): string[] {
        return RoleDistributor.getRolesThatActDuring(phase);
    }

    private async generateNightSummary(results: any): Promise<void> {
        const messages = [];

        // Deaths
        if (results.deaths.length > 0) {
            results.deaths.forEach((death: any) => {
                const player = this.gameState.getPlayer(death.playerId);
                if (player) {
                    let causeMessage = '';
                    switch (death.cause) {
                        case 'NIGHT_KILL':
                            causeMessage = 'foi encontrado morto pela manh√£';
                            break;
                        case 'VIGILANTE':
                            causeMessage = 'foi executado pelo vigilante';
                            break;
                        case 'SERIAL_KILLER':
                            causeMessage = 'foi brutalmente assassinado';
                            break;
                    }
                    messages.push(`${player.username} ${causeMessage}.`);
                }
            });
        } else {
            messages.push('Ningu√©m morreu durante a noite.');
        }

        this.gameState.addEvent('NIGHT_SUMMARY', {
            day: this.gameState.day,
            deaths: results.deaths,
            messages,
            protections: results.protections.length,
            investigations: results.investigations.length,
            attacks: results.attacks.length,
        });
    }

    //====================================================================
    // TIMER MANAGEMENT
    //====================================================================
    getRemainingTime(): number {
        this.gameState.updateTimeLeft();
        return this.gameState.timeLeft;
    }

    isPhaseExpired(): boolean {
        return this.gameState.isPhaseExpired();
    }

    async forceNextPhase(): Promise<void> {
        if (this.currentPhaseTimer) {
            clearTimeout(this.currentPhaseTimer);
        }
        await this.nextPhase();
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    cleanup(): void {
        if (this.currentPhaseTimer) {
            clearTimeout(this.currentPhaseTimer);
            // CORRE√á√ÉO 5: Usar delete em vez de atribuir undefined
            delete this.currentPhaseTimer;
        }
    }
}
</file>

<file path="backend/src/game/RoleSystem.ts">
// üê∫ LOBISOMEM ONLINE - Role System and Distribution (CORRIGIDO DEFINITIVAMENTE)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service

import { Role, Faction } from '@/utils/constants';

//====================================================================
// ROLE CONFIGURATION INTERFACE
//====================================================================
export interface RoleConfiguration {
    role: Role;
    faction: Faction;
    name: string;
    description: string;
    abilities: string[];
    goalDescription: string;
    canAct: boolean;
    actsDuring: string[];
    hasNightChat: boolean;
    immuneToInvestigation: boolean;
    maxActions?: number;
    priority: number; // Action priority (lower = executes first)
}

//====================================================================
// ROLE DEFINITIONS (Based on Town of Salem)
//====================================================================
const roleConfigurations: Record<Role, RoleConfiguration> = {
    // TOWN ROLES
    [Role.VILLAGER]: {
        role: Role.VILLAGER,
        faction: Faction.TOWN,
        name: 'Alde√£o',
        description: 'Cidad√£o comum da vila sem poderes especiais',
        abilities: ['Votar durante o dia'],
        goalDescription: 'Eliminar todos os Lobisomens e inimigos da vila',
        canAct: false,
        actsDuring: [],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 999, // No actions
    },

    [Role.SHERIFF]: {
        role: Role.SHERIFF,
        faction: Faction.TOWN,
        name: 'Investigador',
        description: 'Investiga pessoas durante a noite para descobrir se s√£o suspeitas',
        abilities: [
            'Investigar uma pessoa por noite',
            'Descobre se o alvo √© "SUSPEITO" ou "N√ÉO SUSPEITO"',
            'Lobisomens e Serial Killers aparecem como SUSPEITO',
            'Vila e Neutros pac√≠ficos aparecem como N√ÉO SUSPEITO'
        ],
        goalDescription: 'Encontrar e eliminar todos os Lobisomens usando suas investiga√ß√µes',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 3, // After protections but before kills
    },

    [Role.DOCTOR]: {
        role: Role.DOCTOR,
        faction: Faction.TOWN,
        name: 'M√©dico',
        description: 'Protege pessoas da morte durante a noite',
        abilities: [
            'Proteger uma pessoa por noite de ataques',
            'N√£o pode proteger a mesma pessoa duas noites seguidas',
            'N√£o pode se proteger duas noites seguidas',
            'Prote√ß√£o impede morte por qualquer fonte noturna'
        ],
        goalDescription: 'Manter a vila viva e eliminar os Lobisomens',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 1, // First to act - protections applied before attacks
    },

    [Role.VIGILANTE]: {
        role: Role.VIGILANTE,
        faction: Faction.TOWN,
        name: 'Vigilante',
        description: 'Pode matar suspeitos durante a noite, mas tem consequ√™ncias',
        abilities: [
            'Matar uma pessoa por noite (m√°ximo 3 vezes)',
            'Se matar um inocente (Vila), fica de luto e perde a pr√≥xima a√ß√£o',
            'Pode matar Lobisomens, Serial Killers e Neutros malignos',
            'Suas balas s√£o limitadas - use com sabedoria'
        ],
        goalDescription: 'Eliminar os inimigos da vila usando for√ßa letal',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: false,
        immuneToInvestigation: false,
        maxActions: 3,
        priority: 4, // After investigations
    },

    // WEREWOLF ROLES
    [Role.WEREWOLF]: {
        role: Role.WEREWOLF,
        faction: Faction.WEREWOLF,
        name: 'Lobisomem',
        description: 'Elimina alde√µes durante a noite em coordena√ß√£o com a alcateia',
        abilities: [
            'Votar em quem matar durante a noite com outros Lobisomens',
            'Chat secreto com outros Lobisomens durante a noite',
            'Pode blefar como qualquer role durante o dia',
            'Aparece como SUSPEITO para o Investigador'
        ],
        goalDescription: 'Igualar ou superar o n√∫mero de alde√µes vivos',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: true,
        immuneToInvestigation: false,
        priority: 5, // Werewolf kills
    },

    [Role.WEREWOLF_KING]: {
        role: Role.WEREWOLF_KING,
        faction: Faction.WEREWOLF,
        name: 'Rei dos Lobisomens',
        description: 'L√≠der da alcateia com imunidade especial √† investiga√ß√£o',
        abilities: [
            'Liderar vota√ß√£o de morte noturna da alcateia',
            'IMUNE √† investiga√ß√£o do Sheriff (aparece como N√ÉO SUSPEITO)',
            'Chat secreto com outros Lobisomens durante a noite',
            'Pode coordenar estrat√©gias e bleffs da alcateia'
        ],
        goalDescription: 'Comandar a alcateia para dominar a vila',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: true,
        immuneToInvestigation: true, // SPECIAL: Immune to Sheriff
        priority: 5, // Werewolf kills (same as regular werewolf)
    },

    // NEUTRAL ROLES
    [Role.JESTER]: {
        role: Role.JESTER,
        faction: Faction.NEUTRAL,
        name: 'Bobo da Corte',
        description: 'Vence sendo executado por vota√ß√£o durante o dia',
        abilities: [
            'Objetivo √∫nico: ser executado por vota√ß√£o popular',
            'N√£o pode ser morto √† noite (prote√ß√£o b√°sica)',
            'Deve agir de forma suspeita sem ser √≥bvio demais',
            'Se executado, VENCE SOZINHO independente de outros'
        ],
        goalDescription: 'Ser executado por vota√ß√£o popular durante o dia',
        canAct: false,
        actsDuring: [],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 999, // No night actions
    },

    [Role.SERIAL_KILLER]: {
        role: Role.SERIAL_KILLER,
        faction: Faction.NEUTRAL,
        name: 'Assassino em S√©rie',
        description: 'Mata uma pessoa por noite, vence sendo o √∫ltimo sobrevivente',
        abilities: [
            'Matar uma pessoa por noite',
            'Imune a prote√ß√£o do Doctor na primeira noite',
            'Aparece como SUSPEITO para o Investigador',
            'Deve eliminar TODOS os outros jogadores para vencer'
        ],
        goalDescription: 'Ser o √∫ltimo sobrevivente - eliminar todos os outros',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 6, // After werewolf kills
    },
};

//====================================================================
// ROLE DISTRIBUTION SYSTEM
//====================================================================
export type RoleDistribution = Record<Role, number>;

const balancedRoleDistributions: Record<number, RoleDistribution> = {
    // 6 players - Minimum composition
    6: {
        [Role.VILLAGER]: 1,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 0,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 0,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 0,
    },

    // 7 players
    7: {
        [Role.VILLAGER]: 2,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 0,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 0,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 0,
    },

    // 8 players
    8: {
        [Role.VILLAGER]: 2,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 0,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 0,
    },

    // 9 players - Balanced composition
    9: {
        [Role.VILLAGER]: 2,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 1,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 10 players
    10: {
        [Role.VILLAGER]: 3,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 1,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 11 players
    11: {
        [Role.VILLAGER]: 4,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 1,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 12 players - Standard composition
    12: {
        [Role.VILLAGER]: 4,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 13 players
    13: {
        [Role.VILLAGER]: 5,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 14 players
    14: {
        [Role.VILLAGER]: 6,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 15 players - Maximum composition
    15: {
        [Role.VILLAGER]: 6,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 3,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },
};

//====================================================================
// ROLE DISTRIBUTION LOGIC - SEM EXPORT NA DECLARA√á√ÉO
//====================================================================
class RoleDistributor {
    /**
 * Get balanced role distribution for a given number of players
 */
    static getRoleDistribution(playerCount: number): RoleDistribution {
        // Use exact match if available
        if (balancedRoleDistributions[playerCount]) {
            // Adicionando '!' aqui tamb√©m por consist√™ncia e seguran√ßa m√°xima.
            return { ...balancedRoleDistributions[playerCount]! };
        }

        // 1. Prepara a lista de contagens de jogadores dispon√≠veis.
        const sortedCounts = Object.keys(balancedRoleDistributions)
            .map(Number)
            .sort((a, b) => a - b);

        // 2. "Guard Clause" para provar ao TS que o array n√£o est√° vazio.
        if (sortedCounts.length === 0) {
            throw new Error("FATAL: No balanced role distributions are defined.");
        }

        // 3. Encontra o valor mais pr√≥ximo.
        let closest: number | undefined;
        for (const count of sortedCounts) {
            if (count >= playerCount) {
                closest = count;
                break;
            }
        }

        // 4. Garante que 'lastCount' e 'chosenCount' s√£o n√∫meros.
        const lastCount = sortedCounts[sortedCounts.length - 1]!;
        const chosenCount = closest ?? lastCount;

        // 5. A SOLU√á√ÉO PARA O NOVO ERRO:
        // Afirmamos que o resultado do acesso ao objeto n√£o ser√° undefined.
        const baseDistribution = { ...balancedRoleDistributions[chosenCount]! };

        // Agora, 'baseDistribution' √© garantidamente do tipo 'RoleDistribution',
        // resolvendo os erros nas linhas seguintes.
        if (chosenCount > playerCount) {
            return this.adjustRoleDistribution(baseDistribution, playerCount);
        }

        return baseDistribution;
    }

    /**
     * Adjust role distribution to match exact player count
     */
    private static adjustRoleDistribution(distribution: RoleDistribution, targetCount: number): RoleDistribution {
        const newDistribution = { ...distribution };
        const currentTotal = Object.values(newDistribution).reduce((sum, count) => sum + count, 0);
        const difference = currentTotal - targetCount;

        if (difference > 0) {
            // Remove roles starting with villagers, then neutrals
            const removeOrder: Role[] = [Role.VILLAGER, Role.SERIAL_KILLER, Role.JESTER, Role.WEREWOLF, Role.VIGILANTE];

            let toRemove = difference;
            for (const role of removeOrder) {
                if (toRemove <= 0) break;
                const canRemove = Math.min(newDistribution[role], toRemove);
                newDistribution[role] -= canRemove;
                toRemove -= canRemove;
            }
        }

        return newDistribution;
    }

    /**
 * Distribute roles to players randomly while maintaining balance
 */
    static distributeRolesToPlayers(playerIds: string[], distribution: RoleDistribution): Map<string, Role> {
        const roles: Role[] = [];

        // Create array of roles based on distribution
        Object.entries(distribution).forEach(([role, count]) => {
            for (let i = 0; i < count; i++) {
                roles.push(role as Role);
            }
        });

        // Shuffle arrays
        const shuffledPlayers = this.shuffleArray([...playerIds]);
        const shuffledRoles = this.shuffleArray([...roles]);

        // Create assignment map
        const roleAssignment = new Map<string, Role>();
        shuffledPlayers.forEach((playerId, index) => {
            // CORRE√á√ÉO: Verificar se o √≠ndice existe no array antes de acessar
            if (index < shuffledRoles.length) {
                const role = shuffledRoles[index];
                if (role) { // Verifica√ß√£o adicional para garantir que role n√£o √© undefined
                    roleAssignment.set(playerId, role);
                }
            }
        });

        return roleAssignment;
    }

    /**
     * Validate if a role distribution is balanced
     */
    static validateDistribution(distribution: RoleDistribution): {
        isValid: boolean;
        issues: string[];
        recommendations: string[];
    } {
        const issues: string[] = [];
        const recommendations: string[] = [];

        const totalPlayers = Object.values(distribution).reduce((sum, count) => sum + count, 0);
        const townCount = distribution[Role.VILLAGER] + distribution[Role.SHERIFF] + distribution[Role.DOCTOR] + distribution[Role.VIGILANTE];
        const werewolfCount = distribution[Role.WEREWOLF] + distribution[Role.WEREWOLF_KING];
        const neutralCount = distribution[Role.JESTER] + distribution[Role.SERIAL_KILLER];

        // Basic validation
        if (totalPlayers < 6) {
            issues.push('M√≠nimo de 6 jogadores necess√°rio');
        }

        if (totalPlayers > 15) {
            issues.push('M√°ximo de 15 jogadores permitido');
        }

        // Balance validation
        const werewolfRatio = werewolfCount / totalPlayers;
        if (werewolfRatio < 0.2) {
            issues.push('Muito poucos Lobisomens - jogo pode ser desequilibrado para a Vila');
        }

        if (werewolfRatio > 0.4) {
            issues.push('Muitos Lobisomens - jogo pode ser desequilibrado para os Lobisomens');
        }

        // Essential roles validation
        if (distribution[Role.SHERIFF] === 0 && totalPlayers >= 7) {
            recommendations.push('Adicionar pelo menos 1 Investigador para jogos com 7+ jogadores');
        }

        if (distribution[Role.DOCTOR] === 0 && totalPlayers >= 8) {
            recommendations.push('Adicionar pelo menos 1 M√©dico para jogos com 8+ jogadores');
        }

        // Power roles balance
        const powerRoles = distribution[Role.SHERIFF] + distribution[Role.DOCTOR] + distribution[Role.VIGILANTE];
        if (powerRoles > werewolfCount + 1) {
            recommendations.push('Muitas roles de poder da Vila podem desequilibrar o jogo');
        }

        return {
            isValid: issues.length === 0,
            issues,
            recommendations,
        };
    }

    /**
     * Get role configuration for a specific role
     */
    static getRoleConfig(role: Role): RoleConfiguration {
        return roleConfigurations[role];
    }

    /**
     * Get all roles that can act during a specific phase
     */
    static getRolesThatActDuring(phase: string): Role[] {
        return Object.values(roleConfigurations)
            .filter(config => config.actsDuring.includes(phase))
            .map(config => config.role);
    }

    /**
     * Get roles ordered by action priority
     */
    static getRolesByPriority(): Role[] {
        return Object.values(roleConfigurations)
            .sort((a, b) => a.priority - b.priority)
            .map(config => config.role);
    }

    /**
     * Check if a role is part of a specific faction
     */
    static isRoleInFaction(role: Role, faction: Faction): boolean {
        return roleConfigurations[role].faction === faction;
    }

    /**
     * Get all roles from a specific faction
     */
    static getRolesFromFaction(faction: Faction): Role[] {
        return Object.values(roleConfigurations)
            .filter(config => config.faction === faction)
            .map(config => config.role);
    }

    /**
     * Fisher-Yates shuffle algorithm - CORRE√á√ÉO para exactOptionalPropertyTypes
     */
    private static shuffleArray<T>(array: T[]): T[] {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            // CORRE√á√ÉO: Garantir que os elementos existem antes do swap
            const temp = shuffled[i];
            const swapTarget = shuffled[j];
            if (temp !== undefined && swapTarget !== undefined) {
                shuffled[i] = swapTarget;
                shuffled[j] = temp;
            }
        }
        return shuffled;
    }
}

//====================================================================
// ROLE REVEAL UTILITIES - SEM EXPORT NA DECLARA√á√ÉO
//====================================================================
class RoleRevealManager {
    /**
     * Get information that should be revealed when a player dies
     */
    static getDeathReveal(role: Role): {
        role: Role;
        faction: Faction;
        name: string;
        description: string;
    } {
        const config = roleConfigurations[role];
        return {
            role: config.role,
            faction: config.faction,
            name: config.name,
            description: config.description,
        };
    }

    /**
     * Get investigation result for Sheriff
     */
    static getInvestigationResult(targetRole: Role): 'SUSPICIOUS' | 'NOT_SUSPICIOUS' {
        const config = roleConfigurations[targetRole];

        // Werewolf King is immune to investigation
        if (config.immuneToInvestigation) {
            return 'NOT_SUSPICIOUS';
        }

        // Werewolves and Serial Killer are suspicious
        if (config.faction === Faction.WEREWOLF || targetRole === Role.SERIAL_KILLER) {
            return 'SUSPICIOUS';
        }

        // Town and peaceful neutrals are not suspicious
        return 'NOT_SUSPICIOUS';
    }

    /**
     * Check if a role has night chat access
     */
    static hasNightChat(role: Role): boolean {
        return roleConfigurations[role].hasNightChat;
    }

    /**
     * Get roles that share night chat (Werewolves)
     */
    static getNightChatRoles(): Role[] {
        return Object.values(roleConfigurations)
            .filter(config => config.hasNightChat)
            .map(config => config.role);
    }
}

//====================================================================
// WIN CONDITION CALCULATOR - SEM EXPORT NA DECLARA√á√ÉO
//====================================================================
class WinConditionCalculator {
    /**
     * Calculate win condition based on alive players and their roles
     */
    static calculateWinCondition(alivePlayers: { playerId: string; role: Role }[]): {
        hasWinner: boolean;
        winningFaction?: Faction;
        winningPlayers?: string[];
        reason?: string;
    } {
        if (alivePlayers.length === 0) {
            return { hasWinner: false };
        }

        // Group players by faction
        const factionGroups = new Map<Faction, { playerId: string; role: Role }[]>();

        alivePlayers.forEach(player => {
            const faction = roleConfigurations[player.role].faction;
            const players = factionGroups.get(faction) || [];
            players.push(player);
            factionGroups.set(faction, players);
        });

        const townPlayers = factionGroups.get(Faction.TOWN) || [];
        const werewolfPlayers = factionGroups.get(Faction.WEREWOLF) || [];
        const neutralPlayers = factionGroups.get(Faction.NEUTRAL) || [];

        // Check for Jester win (this would be handled separately when someone is executed)
        const jester = neutralPlayers.find(p => p.role === Role.JESTER);
        // Jester win is handled in execution logic, not here

        // Werewolves win if they equal or outnumber town
        if (werewolfPlayers.length >= townPlayers.length && townPlayers.length > 0) {
            return {
                hasWinner: true,
                winningFaction: Faction.WEREWOLF,
                winningPlayers: werewolfPlayers.map(p => p.playerId),
                reason: 'Lobisomens igualam ou superam o n√∫mero da Vila',
            };
        }

        // Town wins if no werewolves left
        if (werewolfPlayers.length === 0 && townPlayers.length > 0) {
            return {
                hasWinner: true,
                winningFaction: Faction.TOWN,
                winningPlayers: townPlayers.map(p => p.playerId),
                reason: 'Todos os Lobisomens foram eliminados',
            };
        }

        // Serial Killer wins if alone
        const serialKiller = neutralPlayers.find(p => p.role === Role.SERIAL_KILLER);
        if (townPlayers.length + werewolfPlayers.length === 0 && serialKiller) {
            return {
                hasWinner: true,
                winningFaction: Faction.NEUTRAL,
                winningPlayers: [serialKiller.playerId],
                reason: 'Assassino em S√©rie eliminou todos os outros',
            };
        }

        return { hasWinner: false };
    }

    /**
     * Check if Jester wins by being executed
     */
    static checkJesterWin(executedRole: Role): boolean {
        return executedRole === Role.JESTER;
    }
}

//====================================================================
// EXPORTS (CORRIGIDOS - APENAS UMA VEZ)
//====================================================================
export {
    roleConfigurations as ROLE_CONFIGURATIONS,
    balancedRoleDistributions as BALANCED_ROLE_DISTRIBUTIONS,
    RoleDistributor,
    RoleRevealManager,
    WinConditionCalculator,
};
</file>

<file path="backend/src/game/TimerManager.ts">
// üê∫ LOBISOMEM ONLINE - Timer Manager (CORRIGIDO PARA exactOptionalPropertyTypes)
import type { GameConfig } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// TIMER INTERFACE - CORRIGIDA PARA exactOptionalPropertyTypes
//====================================================================
export interface GameTimer {
    id: string;
    type: 'PHASE' | 'WARNING' | 'CUSTOM';
    startTime: number;
    duration: number;
    remaining: number;
    isActive: boolean;
    callback?: () => void;
    timeout?: NodeJS.Timeout; // CORRE√á√ÉO: Opcional, pode n√£o existir
}

//====================================================================
// TIMER MANAGER CLASS - CORRIGIDO PARA exactOptionalPropertyTypes
//====================================================================
export class TimerManager {
    private timers = new Map<string, GameTimer>();
    private config: GameConfig;
    private updateInterval?: NodeJS.Timeout; // CORRE√á√ÉO: Opcional, pode n√£o existir

    constructor(config: GameConfig) {
        this.config = config;
        this.startUpdateLoop();

        logger.info('TimerManager initialized', {
            nightDuration: config.nightDuration,
            dayDuration: config.dayDuration,
            votingDuration: config.votingDuration,
        });
    }

    //====================================================================
    // TIMER CREATION
    //====================================================================
    createPhaseTimer(
        phase: 'NIGHT' | 'DAY' | 'VOTING',
        gameId: string,
        onComplete: () => void,
        onWarning?: (timeLeft: number) => void
    ): string {
        const duration = this.getPhaseDuration(phase);
        const timerId = `${gameId}-${phase}-${Date.now()}`;

        const timer: GameTimer = {
            id: timerId,
            type: 'PHASE',
            startTime: Date.now(),
            duration,
            remaining: duration,
            isActive: true,
            callback: onComplete,
        };

        // Set timeout for completion
        timer.timeout = setTimeout(() => {
            this.handleTimerExpired(timerId);
        }, duration);

        this.timers.set(timerId, timer);

        // Create warning timers if provided
        if (onWarning) {
            this.createWarningTimers(gameId, phase, duration, onWarning);
        }

        logger.info('Phase timer created', {
            timerId,
            phase,
            duration: this.formatTime(duration),
            gameId,
        });

        return timerId;
    }

    createCustomTimer(
        id: string,
        duration: number,
        callback: () => void,
        type: 'WARNING' | 'CUSTOM' = 'CUSTOM'
    ): string {
        const timer: GameTimer = {
            id,
            type,
            startTime: Date.now(),
            duration,
            remaining: duration,
            isActive: true,
            callback,
        };

        timer.timeout = setTimeout(() => {
            this.handleTimerExpired(id);
        }, duration);

        this.timers.set(id, timer);

        logger.debug('Custom timer created', {
            id,
            duration: this.formatTime(duration),
            type
        });

        return id;
    }

    private createWarningTimers(
        gameId: string,
        phase: string,
        duration: number,
        onWarning: (timeLeft: number) => void
    ): void {
        // 30 second warning
        if (duration > 30000) {
            const warning30Id = `${gameId}-${phase}-warning-30`;
            setTimeout(() => onWarning(30000), duration - 30000);
        }

        // 10 second warning
        if (duration > 10000) {
            const warning10Id = `${gameId}-${phase}-warning-10`;
            setTimeout(() => onWarning(10000), duration - 10000);
        }
    }

    //====================================================================
    // TIMER MANAGEMENT
    //====================================================================
    getTimer(timerId: string): GameTimer | undefined {
        return this.timers.get(timerId);
    }

    pauseTimer(timerId: string): boolean {
        const timer = this.timers.get(timerId);
        if (!timer || !timer.isActive) return false;

        timer.isActive = false;
        timer.remaining = timer.duration - (Date.now() - timer.startTime);

        // CORRE√á√ÉO: Clear timeout se existir
        if (timer.timeout) {
            clearTimeout(timer.timeout);
            // CORRE√á√ÉO: Remover propriedade ao inv√©s de atribuir undefined
            delete timer.timeout;
        }

        logger.debug('Timer paused', { timerId, remaining: this.formatTime(timer.remaining) });
        return true;
    }

    resumeTimer(timerId: string): boolean {
        const timer = this.timers.get(timerId);
        if (!timer || timer.isActive) return false;

        timer.isActive = true;
        timer.startTime = Date.now();
        timer.duration = timer.remaining;

        // Set new timeout for remaining time
        timer.timeout = setTimeout(() => {
            this.handleTimerExpired(timerId);
        }, timer.remaining);

        logger.debug('Timer resumed', { timerId, remaining: this.formatTime(timer.remaining) });
        return true;
    }

    extendTimer(timerId: string, additionalTime: number): boolean {
        const timer = this.timers.get(timerId);
        if (!timer) return false;

        timer.duration += additionalTime;

        if (timer.isActive) {
            timer.remaining = timer.duration - (Date.now() - timer.startTime);

            // Reset timeout with new duration
            if (timer.timeout) {
                clearTimeout(timer.timeout);
            }
            timer.timeout = setTimeout(() => {
                this.handleTimerExpired(timerId);
            }, timer.remaining);
        } else {
            timer.remaining += additionalTime;
        }

        logger.info('Timer extended', {
            timerId,
            additionalTime: this.formatTime(additionalTime),
            newDuration: this.formatTime(timer.duration),
            remaining: this.formatTime(timer.remaining),
        });

        return true;
    }

    stopTimer(timerId: string): boolean {
        const timer = this.timers.get(timerId);
        if (!timer) return false;

        timer.isActive = false;

        if (timer.timeout) {
            clearTimeout(timer.timeout);
            // CORRE√á√ÉO: Remover propriedade ao inv√©s de atribuir undefined
            delete timer.timeout;
        }

        this.timers.delete(timerId);

        logger.debug('Timer stopped', { timerId });
        return true;
    }

    stopAllTimers(): void {
        this.timers.forEach((timer, timerId) => {
            if (timer.timeout) {
                clearTimeout(timer.timeout);
            }
        });

        this.timers.clear();

        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            // CORRE√á√ÉO: Remover propriedade ao inv√©s de atribuir undefined
            delete this.updateInterval;
        }

        logger.info('All timers stopped');
    }

    //====================================================================
    // TIMER UPDATES
    //====================================================================
    private startUpdateLoop(): void {
        this.updateInterval = setInterval(() => {
            this.updateAllTimers();
        }, 1000); // Update every second
    }

    private updateAllTimers(): void {
        const now = Date.now();

        this.timers.forEach((timer) => {
            if (!timer.isActive) return;

            // Calculate remaining time
            timer.remaining = Math.max(0, timer.duration - (now - timer.startTime));
        });
    }

    private handleTimerExpired(timerId: string): void {
        const timer = this.timers.get(timerId);
        if (!timer) return;

        logger.debug('Timer expired', {
            timerId,
            type: timer.type,
            duration: this.formatTime(timer.duration),
        });

        // Execute callback
        if (timer.callback) {
            try {
                timer.callback();
            } catch (error) {
                logger.error('Error executing timer callback', error instanceof Error ? error : new Error('Unknown timer error'), {
                    timerId,
                    type: timer.type,
                });
            }
        }

        // Remove timer
        this.stopTimer(timerId);
    }

    //====================================================================
    // PHASE DURATION HELPERS
    //====================================================================
    private getPhaseDuration(phase: 'NIGHT' | 'DAY' | 'VOTING'): number {
        switch (phase) {
            case 'NIGHT':
                return this.config.nightDuration;
            case 'DAY':
                return this.config.dayDuration;
            case 'VOTING':
                return this.config.votingDuration;
            default:
                return 60000; // 1 minute default
        }
    }

    //====================================================================
    // TIMER INFORMATION
    //====================================================================
    getAllActiveTimers(): GameTimer[] {
        return Array.from(this.timers.values()).filter(timer => timer.isActive);
    }

    getTimersByType(type: 'PHASE' | 'WARNING' | 'CUSTOM'): GameTimer[] {
        return Array.from(this.timers.values()).filter(timer => timer.type === type);
    }

    getRemainingTime(timerId: string): number {
        const timer = this.timers.get(timerId);
        if (!timer) return 0;

        if (!timer.isActive) return timer.remaining;

        const elapsed = Date.now() - timer.startTime;
        return Math.max(0, timer.duration - elapsed);
    }

    getTimeElapsed(timerId: string): number {
        const timer = this.timers.get(timerId);
        if (!timer) return 0;

        if (!timer.isActive) return timer.duration - timer.remaining;

        return Math.min(timer.duration, Date.now() - timer.startTime);
    }

    getTimerProgress(timerId: string): number {
        const timer = this.timers.get(timerId);
        if (!timer || timer.duration === 0) return 0;

        const elapsed = this.getTimeElapsed(timerId);
        return Math.min(100, (elapsed / timer.duration) * 100);
    }

    //====================================================================
    // UTILITY METHODS
    //====================================================================
    formatTime(milliseconds: number): string {
        const totalSeconds = Math.ceil(milliseconds / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;

        if (minutes > 0) {
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        } else {
            return `${seconds}s`;
        }
    }

    //====================================================================
    // STATISTICS
    //====================================================================
    getTimerStats(): {
        total: number;
        active: number;
        paused: number;
        byType: Record<string, number>;
    } {
        const allTimers = Array.from(this.timers.values());

        const stats = {
            total: allTimers.length,
            active: allTimers.filter(t => t.isActive).length,
            paused: allTimers.filter(t => !t.isActive).length,
            byType: {
                PHASE: 0,
                WARNING: 0,
                CUSTOM: 0,
            },
        };

        allTimers.forEach(timer => {
            stats.byType[timer.type]++;
        });

        return stats;
    }

    //====================================================================
    // PHASE-SPECIFIC TIMERS
    //====================================================================
    createNightTimer(gameId: string, onComplete: () => void, onWarning?: (timeLeft: number) => void): string {
        return this.createPhaseTimer('NIGHT', gameId, onComplete, onWarning);
    }

    createDayTimer(gameId: string, onComplete: () => void, onWarning?: (timeLeft: number) => void): string {
        return this.createPhaseTimer('DAY', gameId, onComplete, onWarning);
    }

    createVotingTimer(gameId: string, onComplete: () => void, onWarning?: (timeLeft: number) => void): string {
        return this.createPhaseTimer('VOTING', gameId, onComplete, onWarning);
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    cleanup(): void {
        this.stopAllTimers();
        logger.info('TimerManager cleanup completed');
    }

    //====================================================================
    // HEALTH CHECK
    //====================================================================
    healthCheck(): {
        status: 'healthy' | 'unhealthy';
        isRunning: boolean;
        stats: any;
        issues: string[];
    } {
        const issues: string[] = [];
        const stats = this.getTimerStats();

        if (!this.updateInterval) {
            issues.push('Timer update loop is not running');
        }

        // Check for stuck timers
        const now = Date.now();
        this.timers.forEach((timer, timerId) => {
            if (timer.isActive) {
                const elapsed = now - timer.startTime;
                if (elapsed > timer.duration * 1.5) { // 50% overtime tolerance
                    issues.push(`Timer ${timerId} appears to be stuck`);
                }
            }
        });

        return {
            status: issues.length === 0 ? 'healthy' : 'unhealthy',
            isRunning: !!this.updateInterval,
            stats,
            issues,
        };
    }
}
</file>

<file path="backend/src/routes/rooms.ts">
// üê∫ LOBISOMEM ONLINE - Room Routes
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí lobby-service

import { Router } from 'express';
import {
  listRooms,
  createRoom,
  joinRoom,
  joinRoomByCode,
  getRoomDetails,
  deleteRoom
} from '@/controllers/roomController';
import { requireAuth } from '@/middleware/auth';

const router = Router();

//====================================================================
// ROOM ROUTES - ALL REQUIRE AUTHENTICATION
//====================================================================

/**
 * @route GET /api/rooms
 * @desc List public rooms
 * @access Private
 */
router.get('/', requireAuth, listRooms);

/**
 * @route POST /api/rooms
 * @desc Create new room
 * @access Private
 * @body { name, isPrivate?, maxPlayers?, maxSpectators? }
 */
router.post('/', requireAuth, createRoom);

/**
 * @route GET /api/rooms/:id
 * @desc Get room details by ID
 * @access Private
 */
router.get('/:id', requireAuth, getRoomDetails);

/**
 * @route POST /api/rooms/:id/join
 * @desc Join room by ID
 * @access Private
 * @body { asSpectator? }
 */
router.post('/:id/join', requireAuth, joinRoom);

/**
 * @route POST /api/rooms/join-by-code
 * @desc Join room by 6-digit code
 * @access Private
 * @body { code, asSpectator? }
 */
router.post('/join-by-code', requireAuth, joinRoomByCode);

/**
 * @route DELETE /api/rooms/:id
 * @desc Delete room (host only)
 * @access Private
 */
router.delete('/:id', requireAuth, deleteRoom);

export default router;
</file>

<file path="backend/src/utils/helper.ts">
// üê∫ LOBISOMEM ONLINE - Helper Utilities
// Common utility functions used throughout the application

import crypto from 'crypto';
import { THEMED_NICKNAMES, ROLE_DISTRIBUTIONS, GAME_LIMITS } from './constants';
import type { Role, RoleDistribution } from '@/types/game';

// =============================================================================
// STRING UTILITIES
// =============================================================================

/**
 * Generate a random room code
 */
export function generateRoomCode(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

/**
 * Generate a cryptographically secure random string
 */
export function generateSecureToken(length: number = 32): string {
  return crypto.randomBytes(length).toString('hex');
}

/**
 * Generate a random nickname from themed list
 */
export function generateRandomNickname(usedNicknames: Set<string> = new Set()): string {
  const availableNicknames = THEMED_NICKNAMES.filter(nickname => !usedNicknames.has(nickname));

  if (availableNicknames.length === 0) {
    // Fallback to numbered nicknames if all are used
    let counter = 1;
    let nickname = '';
    do {
      nickname = `Cidad√£o ${counter}`;
      counter++;
    } while (usedNicknames.has(nickname));

    return nickname;
  }

  return availableNicknames[Math.floor(Math.random() * availableNicknames.length)];
}

/**
 * Slugify a string for URLs
 */
export function slugify(text: string): string {
  return text
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9 -]/g, '') // Remove special characters
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-'); // Replace multiple hyphens with single
}

/**
 * Capitalize first letter of each word
 */
export function titleCase(text: string): string {
  return text.replace(/\w\S*/g, (txt) =>
    txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
  );
}

/**
 * Truncate text to specified length
 */
export function truncate(text: string, length: number, suffix: string = '...'): string {
  if (text.length <= length) return text;
  return text.substring(0, length - suffix.length) + suffix;
}

// =============================================================================
// ARRAY UTILITIES
// =============================================================================

/**
 * Shuffle an array using Fisher-Yates algorithm
 */
export function shuffleArray<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * Get random element from array
 */
export function randomElement<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)];
}

/**
 * Get multiple random elements from array
 */
export function randomElements<T>(array: T[], count: number): T[] {
  const shuffled = shuffleArray(array);
  return shuffled.slice(0, Math.min(count, array.length));
}

/**
 * Chunk array into smaller arrays
 */
export function chunkArray<T>(array: T[], chunkSize: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    chunks.push(array.slice(i, i + chunkSize));
  }
  return chunks;
}

// =============================================================================
// TIME UTILITIES
// =============================================================================

/**
 * Add milliseconds to a date
 */
export function addMilliseconds(date: Date, ms: number): Date {
  return new Date(date.getTime() + ms);
}

/**
 * Check if a date is expired
 */
export function isExpired(date: Date): boolean {
  return date.getTime() < Date.now();
}

/**
 * Format duration in milliseconds to human readable string
 */
export function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }

  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }

  return `${seconds}s`;
}

/**
 * Get time remaining until target date
 */
export function getTimeRemaining(targetDate: Date): number {
  return Math.max(0, targetDate.getTime() - Date.now());
}

// =============================================================================
// GAME UTILITIES
// =============================================================================

/**
 * Get role distribution based on player count
 */
export function getRoleDistribution(playerCount: number): RoleDistribution {
  // Find the closest predefined distribution
  const availableCounts = Object.keys(ROLE_DISTRIBUTIONS).map(Number).sort((a, b) => a - b);

  let targetCount = availableCounts.find(count => count >= playerCount);
  if (!targetCount) {
    targetCount = availableCounts[availableCounts.length - 1]; // Use largest if exceeds max
  }

  const distribution = ROLE_DISTRIBUTIONS[targetCount as keyof typeof ROLE_DISTRIBUTIONS];

  // Adjust distribution if needed to match exact player count
  if (targetCount > playerCount) {
    return adjustRoleDistribution(distribution, playerCount);
  }

  return distribution;
}

/**
 * Adjust role distribution to match exact player count
 */
function adjustRoleDistribution(distribution: RoleDistribution, targetCount: number): RoleDistribution {
  const newDistribution = { ...distribution };
  const currentTotal = Object.values(newDistribution).reduce((sum, count) => sum + count, 0);
  const difference = currentTotal - targetCount;

  if (difference > 0) {
    // Remove roles starting with villagers
    let toRemove = difference;
    const removeOrder: Role[] = ['VILLAGER', 'WEREWOLF', 'JESTER', 'SERIAL_KILLER'];

    for (const role of removeOrder) {
      if (toRemove <= 0) break;
      const canRemove = Math.min(newDistribution[role], toRemove);
      newDistribution[role] -= canRemove;
      toRemove -= canRemove;
    }
  }

  return newDistribution;
}

/**
 * Distribute roles to players randomly
 */
export function distributeRoles(playerIds: string[], distribution: RoleDistribution): Map<string, Role> {
  const roles: Role[] = [];

  // Create array of roles based on distribution
  for (const [role, count] of Object.entries(distribution)) {
    for (let i = 0; i < count; i++) {
      roles.push(role as Role);
    }
  }

  // Shuffle players and roles
  const shuffledPlayers = shuffleArray(playerIds);
  const shuffledRoles = shuffleArray(roles);

  // Create map of player to role
  const roleAssignment = new Map<string, Role>();
  shuffledPlayers.forEach((playerId, index) => {
    if (index < shuffledRoles.length) {
      roleAssignment.set(playerId, shuffledRoles[index]);
    }
  });

  return roleAssignment;
}

/**
 * Check if game can start with current player count
 */
export function canStartGame(playerCount: number): boolean {
  return playerCount >= GAME_LIMITS.MIN_PLAYERS && playerCount <= GAME_LIMITS.MAX_PLAYERS;
}

/**
 * Calculate win condition for current game state
 */
export function calculateWinCondition(alivePlayers: { role: Role; playerId: string }[]): {
  hasWinner: boolean;
  winningFaction?: string;
  winningPlayers?: string[];
} {
  const aliveByFaction = alivePlayers.reduce((acc, player) => {
    let faction: string;

    if (['VILLAGER', 'SHERIFF', 'DOCTOR', 'VIGILANTE'].includes(player.role)) {
      faction = 'TOWN';
    } else if (['WEREWOLF', 'WEREWOLF_KING'].includes(player.role)) {
      faction = 'WEREWOLF';
    } else {
      faction = 'NEUTRAL';
    }

    if (!acc[faction]) acc[faction] = [];
    acc[faction].push(player.playerId);

    return acc;
  }, {} as Record<string, string[]>);

  const townCount = aliveByFaction.TOWN?.length || 0;
  const werewolfCount = aliveByFaction.WEREWOLF?.length || 0;
  const neutralCount = aliveByFaction.NEUTRAL?.length || 0;

  // Werewolves win if they equal or outnumber town
  if (werewolfCount >= townCount && townCount > 0) {
    return {
      hasWinner: true,
      winningFaction: 'WEREWOLF',
      winningPlayers: aliveByFaction.WEREWOLF,
    };
  }

  // Town wins if no werewolves left
  if (werewolfCount === 0 && townCount > 0) {
    return {
      hasWinner: true,
      winningFaction: 'TOWN',
      winningPlayers: aliveByFaction.TOWN,
    };
  }

  // Serial killer wins if alone
  if (townCount + werewolfCount === 0 && neutralCount === 1) {
    return {
      hasWinner: true,
      winningFaction: 'SERIAL_KILLER',
      winningPlayers: aliveByFaction.NEUTRAL,
    };
  }

  return { hasWinner: false };
}

// =============================================================================
// VALIDATION UTILITIES
// =============================================================================

/**
 * Check if string contains profanity (basic filter)
 */
export function containsProfanity(text: string): boolean {
  const profanityList = [
    'fuck', 'shit', 'damn', 'bitch', 'ass', 'hell',
    'porra', 'merda', 'caralho', 'puta', 'fodase', 'buceta'
    // Add more words as needed
  ];

  const lowerText = text.toLowerCase();
  return profanityList.some(word => lowerText.includes(word));
}

/**
 * Clean profanity from text
 */
export function cleanProfanity(text: string): string {
  if (!containsProfanity(text)) return text;

  const replacements = [
    'barbaridade', 'caramba', 'nossa', 'eita', 'puxa', 'xi'
  ];

  return randomElement(replacements);
}

// =============================================================================
// OBJECT UTILITIES
// =============================================================================

/**
 * Deep clone an object
 */
export function deepClone<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Remove undefined properties from object
 */
export function removeUndefined<T extends Record<string, any>>(obj: T): Partial<T> {
  const cleaned: Partial<T> = {};

  for (const [key, value] of Object.entries(obj)) {
    if (value !== undefined) {
      cleaned[key as keyof T] = value;
    }
  }

  return cleaned;
}

/**
 * Pick specific properties from object
 */
export function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>;

  for (const key of keys) {
    if (key in obj) {
      result[key] = obj[key];
    }
  }

  return result;
}

/**
 * Omit specific properties from object
 */
export function omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {
  const result = { ...obj } as any;

  for (const key of keys) {
    delete result[key];
  }

  return result;
}
</file>

<file path="backend/src/utils/logger.ts">
// üê∫ LOBISOMEM ONLINE - Logger Utility
// Structured logging for the application

import { config } from '@/config/environment';

// =============================================================================
// LOG LEVELS
// =============================================================================
export enum LogLevel {
  ERROR = 'ERROR',
  WARN = 'WARN',
  INFO = 'INFO',
  DEBUG = 'DEBUG',
}

// =============================================================================
// LOG ENTRY INTERFACE
// =============================================================================
export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: string;
  service: string;
  module?: string;
  userId?: string;
  roomId?: string;
  gameId?: string;
  metadata?: Record<string, any>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

// =============================================================================
// LOGGER CLASS
// =============================================================================
class Logger {
  private serviceName: string;
  private moduleContext?: string;

  constructor(serviceName: string = config.SERVICE_ID, moduleContext?: string) {
    this.serviceName = serviceName;
    this.moduleContext = moduleContext;
  }

  /**
   * Create a child logger for a specific module
   */
  child(moduleContext: string): Logger {
    return new Logger(this.serviceName, moduleContext);
  }

  /**
   * Log an error message
   */
  error(message: string, error?: Error, metadata?: Record<string, any>): void {
    this.log(LogLevel.ERROR, message, { error, metadata });
  }

  /**
   * Log a warning message
   */
  warn(message: string, metadata?: Record<string, any>): void {
    this.log(LogLevel.WARN, message, { metadata });
  }

  /**
   * Log an info message
   */
  info(message: string, metadata?: Record<string, any>): void {
    this.log(LogLevel.INFO, message, { metadata });
  }

  /**
   * Log a debug message
   */
  debug(message: string, metadata?: Record<string, any>): void {
    if (config.IS_DEVELOPMENT) {
      this.log(LogLevel.DEBUG, message, { metadata });
    }
  }

  /**
   * Log game-specific events
   */
  game(
    level: LogLevel,
    message: string,
    gameContext: {
      userId?: string;
      roomId?: string;
      gameId?: string;
      phase?: string;
      action?: string;
    },
    metadata?: Record<string, any>
  ): void {
    this.log(level, message, {
      metadata: {
        ...gameContext,
        ...metadata,
      },
    });
  }

  /**
   * Log WebSocket events
   */
  websocket(
    level: LogLevel,
    message: string,
    wsContext: {
      userId?: string;
      roomId?: string;
      connectionId?: string;
      event?: string;
    },
    metadata?: Record<string, any>
  ): void {
    this.log(level, message, {
      metadata: {
        ...wsContext,
        ...metadata,
        type: 'websocket',
      },
    });
  }

  /**
   * Log authentication events
   */
  auth(
    level: LogLevel,
    message: string,
    authContext: {
      userId?: string;
      email?: string;
      action?: string;
      ip?: string;
    },
    metadata?: Record<string, any>
  ): void {
    this.log(level, message, {
      metadata: {
        ...authContext,
        ...metadata,
        type: 'auth',
      },
    });
  }

  /**
   * Core logging method
   */
  private log(
    level: LogLevel,
    message: string,
    context?: {
      error?: Error;
      metadata?: Record<string, any>;
    }
  ): void {
    const logEntry: LogEntry = {
      level,
      message,
      timestamp: new Date().toISOString(),
      service: this.serviceName,
      module: this.moduleContext,
      ...context?.metadata,
    };

    // Add error details if present
    if (context?.error) {
      logEntry.error = {
        name: context.error.name,
        message: context.error.message,
        stack: context.error.stack,
      };
    }

    // Output based on environment
    if (config.IS_PRODUCTION) {
      // Structured JSON logging for production
      console.log(JSON.stringify(logEntry));
    } else {
      // Pretty formatted logging for development
      this.prettyLog(logEntry);
    }
  }

  /**
   * Pretty print logs for development
   */
  private prettyLog(entry: LogEntry): void {
    const colors = {
      [LogLevel.ERROR]: '\x1b[31m', // Red
      [LogLevel.WARN]: '\x1b[33m',  // Yellow
      [LogLevel.INFO]: '\x1b[36m',  // Cyan
      [LogLevel.DEBUG]: '\x1b[37m', // White
    };

    const reset = '\x1b[0m';
    const color = colors[entry.level];

    const timestamp = new Date(entry.timestamp).toLocaleTimeString();
    const service = entry.service;
    const module = entry.module ? `[${entry.module}]` : '';

    let logLine = `${color}${entry.level}${reset} ${timestamp} ${service}${module}: ${entry.message}`;

    console.log(logLine);

    // Log metadata if present
    if (entry.metadata && Object.keys(entry.metadata).length > 0) {
      console.log('  Metadata:', entry.metadata);
    }

    // Log error details if present
    if (entry.error) {
      console.log('  Error:', entry.error.message);
      if (entry.error.stack && config.IS_DEVELOPMENT) {
        console.log('  Stack:', entry.error.stack);
      }
    }
  }
}

// =============================================================================
// CREATE DEFAULT LOGGER INSTANCE
// =============================================================================
export const logger = new Logger();

// =============================================================================
// SPECIALIZED LOGGERS
// =============================================================================
export const gameLogger = logger.child('game');
export const wsLogger = logger.child('websocket');
export const authLogger = logger.child('auth');
export const dbLogger = logger.child('database');
export const redisLogger = logger.child('redis');

// =============================================================================
// PERFORMANCE LOGGING
// =============================================================================
export class PerformanceLogger {
  private timers: Map<string, number> = new Map();

  /**
   * Start timing an operation
   */
  start(operationId: string): void {
    this.timers.set(operationId, Date.now());
  }

  /**
   * End timing and log the duration
   */
  end(operationId: string, description?: string): number {
    const startTime = this.timers.get(operationId);
    if (!startTime) {
      logger.warn(`Performance timer not found: ${operationId}`);
      return 0;
    }

    const duration = Date.now() - startTime;
    this.timers.delete(operationId);

    logger.debug(`Performance: ${description || operationId}`, {
      operationId,
      duration: `${duration}ms`,
    });

    return duration;
  }

  /**
   * Measure an async operation
   */
  async measure<T>(
    operationId: string,
    operation: () => Promise<T>,
    description?: string
  ): Promise<T> {
    this.start(operationId);
    try {
      const result = await operation();
      this.end(operationId, description);
      return result;
    } catch (error) {
      this.end(operationId, `${description || operationId} (failed)`);
      throw error;
    }
  }
}

export const performanceLogger = new PerformanceLogger();

// =============================================================================
// REQUEST LOGGING MIDDLEWARE HELPER
// =============================================================================
export interface RequestLogContext {
  method: string;
  url: string;
  userAgent?: string;
  ip?: string;
  userId?: string;
  statusCode?: number;
  duration?: number;
}

export function logRequest(context: RequestLogContext): void {
  const level = context.statusCode && context.statusCode >= 400 ? LogLevel.WARN : LogLevel.INFO;

  logger.log(level, `${context.method} ${context.url}`, {
    metadata: {
      type: 'http_request',
      ...context,
    },
  });
}

// =============================================================================
// EXPORT DEFAULT LOGGER
// =============================================================================
export default logger;
</file>

<file path="backend/src/utils/simpleValidators.ts">
// üê∫ LOBISOMEM ONLINE - Simple Validators for Initial Testing
// Vers√£o simplificada para evitar erros de compila√ß√£o

export interface ValidationResult {
    success: boolean;
    data?: any;
    error?: string;
}

// Simple email validation
export function validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

// Simple username validation
export function validateUsername(username: string): boolean {
    return username.length >= 3 && username.length <= 20 && /^[a-zA-Z0-9_-]+$/.test(username);
}

// Simple password validation
export function validatePassword(password: string): boolean {
    return password.length >= 6 && password.length <= 50;
}

// Simple room name validation  
export function validateRoomName(name: string): boolean {
    return name.length >= 1 && name.length <= 30;
}

// Simple room code validation
export function validateRoomCode(code: string): boolean {
    return /^\d{6}$/.test(code);
}

// WebSocket message validation
export function validateWebSocketMessage(message: any): ValidationResult {
    if (!message || typeof message !== 'object') {
        return {
            success: false,
            error: 'Message must be an object'
        };
    }

    if (!message.type || typeof message.type !== 'string') {
        return {
            success: false,
            error: 'Message must have a valid type'
        };
    }

    return {
        success: true,
        data: {
            type: message.type,
            data: message.data || {},
            timestamp: message.timestamp || new Date().toISOString(),
            messageId: message.messageId
        }
    };
}

// Simple register validation
export function validateRegisterRequest(data: any): ValidationResult {
    if (!data.email || !validateEmail(data.email)) {
        return { success: false, error: 'Invalid email' };
    }

    if (!data.username || !validateUsername(data.username)) {
        return { success: false, error: 'Invalid username' };
    }

    if (!data.password || !validatePassword(data.password)) {
        return { success: false, error: 'Invalid password' };
    }

    if (data.password !== data.confirmPassword) {
        return { success: false, error: 'Passwords do not match' };
    }

    return {
        success: true,
        data: {
            email: data.email.toLowerCase().trim(),
            username: data.username.trim(),
            password: data.password
        }
    };
}

// Simple login validation
export function validateLoginRequest(data: any): ValidationResult {
    if (!data.email || !validateEmail(data.email)) {
        return { success: false, error: 'Invalid email' };
    }

    if (!data.password || typeof data.password !== 'string') {
        return { success: false, error: 'Invalid password' };
    }

    return {
        success: true,
        data: {
            email: data.email.toLowerCase().trim(),
            password: data.password
        }
    };
}

// Simple create room validation
export function validateCreateRoomRequest(data: any): ValidationResult {
    if (!data.name || !validateRoomName(data.name)) {
        return { success: false, error: 'Invalid room name' };
    }

    return {
        success: true,
        data: {
            name: data.name.trim(),
            isPrivate: Boolean(data.isPrivate),
            maxPlayers: Math.min(Math.max(data.maxPlayers || 15, 6), 15),
            maxSpectators: Math.min(Math.max(data.maxSpectators || 5, 0), 5)
        }
    };
}
</file>

<file path="backend/src/websocket/HeartbeatManager.ts">
// üê∫ LOBISOMEM ONLINE - Heartbeat Manager
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service
import { wsConfig } from '@/config/websocket';
import { wsLogger } from '@/utils/logger';
import type { ConnectionManager } from './ConnectionManager';

//====================================================================
// HEARTBEAT STATS INTERFACE
//====================================================================
export interface HeartbeatStats {
    totalPingsSent: number;
    totalPongsReceived: number;
    currentInterval: number;
    timeout: number;
    lastCleanup: Date;
    connectionsMonitored: number;
    deadConnectionsDetected: number;
}

//====================================================================
// HEARTBEAT MANAGER CLASS
//====================================================================
export class HeartbeatManager {
    private pingInterval: NodeJS.Timeout | null = null;
    private cleanupInterval: NodeJS.Timeout | null = null;
    private isRunning = false;
    private stats: HeartbeatStats = {
        totalPingsSent: 0,
        totalPongsReceived: 0,
        currentInterval: wsConfig.heartbeat.interval,
        timeout: wsConfig.heartbeat.timeout,
        lastCleanup: new Date(),
        connectionsMonitored: 0,
        deadConnectionsDetected: 0,
    };

    constructor(private connectionManager: ConnectionManager) { }

    //====================================================================
    // LIFECYCLE MANAGEMENT
    //====================================================================
    start(): void {
        if (this.isRunning) {
            wsLogger.warn('HeartbeatManager already running');
            return;
        }

        this.isRunning = true;

        // Start ping interval
        this.pingInterval = setInterval(() => {
            this.sendPingToAllConnections();
        }, wsConfig.heartbeat.interval);

        // Start cleanup interval (check for dead connections)
        this.cleanupInterval = setInterval(() => {
            this.cleanupDeadConnections();
        }, wsConfig.heartbeat.interval * 2); // Run cleanup less frequently

        wsLogger.info('HeartbeatManager started', {
            pingInterval: wsConfig.heartbeat.interval,
            timeout: wsConfig.heartbeat.timeout,
        });
    }

    stop(): void {
        if (!this.isRunning) {
            return;
        }

        this.isRunning = false;

        if (this.pingInterval) {
            clearInterval(this.pingInterval);
            this.pingInterval = null;
        }

        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }

        wsLogger.info('HeartbeatManager stopped');
    }

    restart(): void {
        this.stop();
        this.start();
    }

    isActive(): boolean {
        return this.isRunning;
    }

    //====================================================================
    // PING OPERATIONS
    //====================================================================
    private sendPingToAllConnections(): void {
        const connections = this.connectionManager.getAllConnections();
        let sentCount = 0;
        let failedCount = 0;

        for (const connection of connections) {
            try {
                if (connection.ws.readyState === connection.ws.OPEN) {
                    // Mark as potentially dead - will be marked alive when pong is received
                    this.connectionManager.markDead(connection.id);

                    // Send ping
                    connection.ws.ping();
                    sentCount++;

                    wsLogger.debug('Ping sent', {
                        connectionId: connection.id,
                        userId: connection.context.userId,
                    });
                } else {
                    // Connection is already closed
                    failedCount++;
                    wsLogger.debug('Skipping ping for closed connection', {
                        connectionId: connection.id,
                        readyState: connection.ws.readyState,
                    });
                }
            } catch (error) {
                failedCount++;
                wsLogger.error('Failed to send ping', error instanceof Error ? error : new Error('Unknown ping error'), {
                    connectionId: connection.id,
                    userId: connection.context.userId,
                });
            }
        }

        this.stats.totalPingsSent += sentCount;
        this.stats.connectionsMonitored = connections.length;

        if (sentCount > 0 || failedCount > 0) {
            wsLogger.debug('Ping round completed', {
                sent: sentCount,
                failed: failedCount,
                total: connections.length,
            });
        }
    }

    sendPingToConnection(connectionId: string): boolean {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) {
            wsLogger.warn('Cannot ping non-existent connection', { connectionId });
            return false;
        }

        try {
            if (connection.ws.readyState === connection.ws.OPEN) {
                this.connectionManager.markDead(connectionId);
                connection.ws.ping();

                wsLogger.debug('Individual ping sent', {
                    connectionId,
                    userId: connection.context.userId,
                });

                return true;
            } else {
                wsLogger.debug('Cannot ping closed connection', {
                    connectionId,
                    readyState: connection.ws.readyState,
                });
                return false;
            }
        } catch (error) {
            wsLogger.error('Failed to send individual ping', error instanceof Error ? error : new Error('Unknown individual ping error'), {
                connectionId,
                userId: connection.context.userId,
            });
            return false;
        }
    }

    //====================================================================
    // PONG HANDLING
    //====================================================================
    handlePong(connectionId: string): void {
        const success = this.connectionManager.markAlive(connectionId);
        if (success) {
            this.stats.totalPongsReceived++;

            wsLogger.debug('Pong received', {
                connectionId,
                responseTime: Date.now(), // Could calculate actual response time if needed
            });
        } else {
            wsLogger.warn('Received pong for unknown connection', { connectionId });
        }
    }

    //====================================================================
    // DEAD CONNECTION CLEANUP
    //====================================================================
    private cleanupDeadConnections(): void {
        const deadConnections = this.connectionManager.getDeadConnections();
        let cleanedCount = 0;

        for (const connectionId of deadConnections) {
            const connection = this.connectionManager.getConnection(connectionId);
            if (!connection) continue;

            // Check if connection has been dead for too long
            const timeSinceLastPing = Date.now() - connection.lastPing;
            const isTimedOut = timeSinceLastPing > (wsConfig.heartbeat.interval + wsConfig.heartbeat.timeout);

            if (isTimedOut) {
                wsLogger.info('Removing dead connection', {
                    connectionId,
                    userId: connection.context.userId,
                    username: connection.context.username,
                    timeSinceLastPing,
                    lastPing: new Date(connection.lastPing).toISOString(),
                });

                // Close the connection and remove it
                try {
                    if (connection.ws.readyState === connection.ws.OPEN) {
                        connection.ws.terminate(); // Force close
                    }
                } catch (error) {
                    wsLogger.error('Error terminating dead connection', error instanceof Error ? error : new Error('Unknown termination error'), {
                        connectionId,
                    });
                }

                this.connectionManager.removeConnection(connectionId);
                cleanedCount++;
                this.stats.deadConnectionsDetected++;
            }
        }

        this.stats.lastCleanup = new Date();

        if (cleanedCount > 0) {
            wsLogger.info('Dead connection cleanup completed', {
                cleanedCount,
                totalDeadConnections: deadConnections.length,
                remainingConnections: this.connectionManager.getConnectionCount(),
            });
        }
    }

    forceCleanupDeadConnections(): number {
        wsLogger.info('Force cleanup requested');
        this.cleanupDeadConnections();

        const deadConnections = this.connectionManager.getDeadConnections();
        return deadConnections.length;
    }

    //====================================================================
    // CONNECTION HEALTH MONITORING
    //====================================================================
    getConnectionHealth(connectionId: string): {
        isAlive: boolean;
        lastPing: number;
        timeSinceLastPing: number;
        isHealthy: boolean;
    } | null {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) return null;

        const now = Date.now();
        const timeSinceLastPing = now - connection.lastPing;
        const isHealthy = connection.isAlive && timeSinceLastPing < wsConfig.heartbeat.interval * 2;

        return {
            isAlive: connection.isAlive,
            lastPing: connection.lastPing,
            timeSinceLastPing,
            isHealthy,
        };
    }

    getAllConnectionsHealth(): Array<{
        connectionId: string;
        userId: string;
        username: string;
        isAlive: boolean;
        lastPing: number;
        timeSinceLastPing: number;
        isHealthy: boolean;
    }> {
        const connections = this.connectionManager.getAllConnections();
        const now = Date.now();

        return connections.map(connection => {
            const timeSinceLastPing = now - connection.lastPing;
            const isHealthy = connection.isAlive && timeSinceLastPing < wsConfig.heartbeat.interval * 2;

            return {
                connectionId: connection.id,
                userId: connection.context.userId,
                username: connection.context.username,
                isAlive: connection.isAlive,
                lastPing: connection.lastPing,
                timeSinceLastPing,
                isHealthy,
            };
        });
    }

    getHealthySummary(): {
        total: number;
        alive: number;
        dead: number;
        healthy: number;
        unhealthy: number;
    } {
        const healthData = this.getAllConnectionsHealth();

        return {
            total: healthData.length,
            alive: healthData.filter(h => h.isAlive).length,
            dead: healthData.filter(h => !h.isAlive).length,
            healthy: healthData.filter(h => h.isHealthy).length,
            unhealthy: healthData.filter(h => !h.isHealthy).length,
        };
    }

    //====================================================================
    // STATISTICS AND MONITORING
    //====================================================================
    getStats(): HeartbeatStats {
        return {
            ...this.stats,
            connectionsMonitored: this.connectionManager.getConnectionCount(),
        };
    }

    getDetailedStats() {
        const healthSummary = this.getHealthySummary();
        const baseStats = this.getStats();

        return {
            ...baseStats,
            healthSummary,
            isRunning: this.isRunning,
            uptime: this.isRunning ? Date.now() - this.stats.lastCleanup.getTime() : 0,
            pingSuccessRate: baseStats.totalPingsSent > 0
                ? (baseStats.totalPongsReceived / baseStats.totalPingsSent) * 100
                : 0,
        };
    }

    resetStats(): void {
        this.stats = {
            totalPingsSent: 0,
            totalPongsReceived: 0,
            currentInterval: wsConfig.heartbeat.interval,
            timeout: wsConfig.heartbeat.timeout,
            lastCleanup: new Date(),
            connectionsMonitored: this.connectionManager.getConnectionCount(),
            deadConnectionsDetected: 0,
        };

        wsLogger.info('HeartbeatManager stats reset');
    }

    //====================================================================
    // CONFIGURATION
    //====================================================================
    updateInterval(newInterval: number): void {
        if (newInterval < 1000) {
            throw new Error('Heartbeat interval must be at least 1000ms');
        }

        this.stats.currentInterval = newInterval;

        if (this.isRunning) {
            wsLogger.info('Updating heartbeat interval', {
                oldInterval: wsConfig.heartbeat.interval,
                newInterval,
            });

            this.restart();
        }
    }

    //====================================================================
    // HEALTH CHECK
    //====================================================================
    healthCheck(): {
        status: 'healthy' | 'unhealthy';
        isRunning: boolean;
        stats: HeartbeatStats;
        issues: string[];
    } {
        const issues: string[] = [];

        if (!this.isRunning) {
            issues.push('HeartbeatManager is not running');
        }

        const healthSummary = this.getHealthySummary();
        const unhealthyPercentage = healthSummary.total > 0
            ? (healthSummary.unhealthy / healthSummary.total) * 100
            : 0;

        if (unhealthyPercentage > 50) {
            issues.push(`${unhealthyPercentage.toFixed(1)}% of connections are unhealthy`);
        }

        if (this.stats.totalPingsSent > 0) {
            const successRate = (this.stats.totalPongsReceived / this.stats.totalPingsSent) * 100;
            if (successRate < 80) {
                issues.push(`Low ping success rate: ${successRate.toFixed(1)}%`);
            }
        }

        return {
            status: issues.length === 0 ? 'healthy' : 'unhealthy',
            isRunning: this.isRunning,
            stats: this.getStats(),
            issues,
        };
    }
}
</file>

<file path="backend/src/websocket/index.ts">
export { WebSocketManager } from './WebSocketManager';
export { ConnectionManager } from './ConnectionManager';
export { ChannelManager } from './ChannelManager';
export { MessageRouter } from './MessageRouter';
export { HeartbeatManager } from './HeartbeatManager';
</file>

<file path="frontend/src/components/common/ErrorBoundary.tsx">
'use client';

import React, { Component, ReactNode } from 'react';
import { motion } from 'framer-motion';
import { RefreshCw, Home, AlertTriangle } from 'lucide-react';
import Button from './Button';

// =============================================================================
// ERROR BOUNDARY TYPES
// =============================================================================
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}

// =============================================================================
// ERROR BOUNDARY CLASS COMPONENT
// =============================================================================
export default class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    this.setState({
      error,
      errorInfo,
    });

    // Log error to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Error caught by ErrorBoundary:', error);
      console.error('Error info:', errorInfo);
    }

    // Call onError prop if provided
    this.props.onError?.(error, errorInfo);

    // In production, you might want to send this to an error reporting service
    // Example: Sentry, LogRocket, etc.
  }

  handleRetry = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });
  };

  handleGoHome = () => {
    window.location.href = '/';
  };

  render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default error UI
      return <DefaultErrorUI
        error={this.state.error}
        onRetry={this.handleRetry}
        onGoHome={this.handleGoHome}
      />;
    }

    return this.props.children;
  }
}

// =============================================================================
// DEFAULT ERROR UI
// =============================================================================
interface DefaultErrorUIProps {
  error: Error | null;
  onRetry: () => void;
  onGoHome: () => void;
}

function DefaultErrorUI({ error, onRetry, onGoHome }: DefaultErrorUIProps) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 to-red-950 flex items-center justify-center p-6">
      <motion.div
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        className="max-w-md w-full text-center"
      >
        {/* Error icon */}
        <motion.div
          animate={{
            scale: [1, 1.1, 1],
            rotate: [0, 5, -5, 0]
          }}
          transition={{
            duration: 2,
            repeat: Infinity,
            ease: 'easeInOut'
          }}
          className="text-8xl mb-6"
        >
          üíÄ
        </motion.div>

        {/* Title */}
        <h1 className="text-3xl font-medieval text-red-300 mb-4 text-glow">
          Algo deu errado!
        </h1>

        {/* Description */}
        <p className="text-white/70 mb-6 leading-relaxed">
          A vila foi atacada por um erro inesperado.
          N√£o se preocupe, podemos tentar novamente.
        </p>

        {/* Error message in development */}
        {process.env.NODE_ENV === 'development' && error && (
          <div className="bg-black/30 border border-red-500/30 rounded-lg p-4 mb-6 text-left">
            <div className="flex items-center mb-2">
              <AlertTriangle className="w-4 h-4 text-red-400 mr-2" />
              <span className="text-red-400 font-semibold text-sm">
                Erro de Desenvolvimento
              </span>
            </div>
            <pre className="text-red-300 text-xs overflow-auto max-h-32">
              {error.message}
            </pre>
          </div>
        )}

        {/* Action buttons */}
        <div className="space-y-3">
          <Button
            variant="medieval"
            size="lg"
            onClick={onRetry}
            className="w-full"
          >
            <RefreshCw className="w-5 h-5 mr-2" />
            Tentar Novamente
          </Button>

          <Button
            variant="ghost"
            size="lg"
            onClick={onGoHome}
            className="w-full"
          >
            <Home className="w-5 h-5 mr-2" />
            Voltar ao In√≠cio
          </Button>
        </div>

        {/* Footer */}
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 1 }}
          className="text-white/40 text-sm mt-8"
        >
          Se o problema persistir, recarregue a p√°gina
        </motion.p>
      </motion.div>
    </div>
  );
}

// =============================================================================
// HOOK FOR FUNCTIONAL COMPONENTS
// =============================================================================
export function useErrorHandler() {
  const [error, setError] = React.useState<Error | null>(null);

  const resetError = React.useCallback(() => {
    setError(null);
  }, []);

  const captureError = React.useCallback((error: Error) => {
    setError(error);
    console.error('Error captured:', error);
  }, []);

  // Throw error to be caught by ErrorBoundary
  React.useEffect(() => {
    if (error) {
      throw error;
    }
  }, [error]);

  return { captureError, resetError };
}

// =============================================================================
// SPECIFIC ERROR COMPONENTS
// =============================================================================

// Network Error
export function NetworkError({ onRetry }: { onRetry: () => void }) {
  return (
    <div className="text-center p-8">
      <div className="text-6xl mb-4">üì°</div>
      <h3 className="text-xl font-bold text-white mb-2">
        Erro de Conex√£o
      </h3>
      <p className="text-white/70 mb-6">
        N√£o foi poss√≠vel conectar com o servidor.
        Verifique sua internet e tente novamente.
      </p>
      <Button variant="primary" onClick={onRetry}>
        <RefreshCw className="w-4 h-4 mr-2" />
        Tentar Novamente
      </Button>
    </div>
  );
}

// Game Error
export function GameError({
  message,
  onRetry,
  onLeave
}: {
  message: string;
  onRetry?: () => void;
  onLeave?: () => void;
}) {
  return (
    <div className="text-center p-8">
      <div className="text-6xl mb-4">üéÆ</div>
      <h3 className="text-xl font-bold text-white mb-2">
        Erro no Jogo
      </h3>
      <p className="text-white/70 mb-6">
        {message}
      </p>
      <div className="space-y-3">
        {onRetry && (
          <Button variant="primary" onClick={onRetry} className="w-full">
            <RefreshCw className="w-4 h-4 mr-2" />
            Tentar Novamente
          </Button>
        )}
        {onLeave && (
          <Button variant="ghost" onClick={onLeave} className="w-full">
            <Home className="w-4 h-4 mr-2" />
            Sair do Jogo
          </Button>
        )}
      </div>
    </div>
  );
}

// 404 Error
export function NotFoundError() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 to-medieval-800 flex items-center justify-center p-6">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="text-center max-w-md"
      >
        <div className="text-8xl mb-6">üèöÔ∏è</div>
        <h1 className="text-4xl font-medieval text-white mb-4">
          404
        </h1>
        <h2 className="text-xl text-white/80 mb-6">
          Esta p√°gina foi devorada pelos lobos
        </h2>
        <p className="text-white/60 mb-8">
          A p√°gina que voc√™ procura n√£o existe ou foi movida para outro local.
        </p>
        <Button
          variant="medieval"
          size="lg"
          onClick={() => window.location.href = '/'}
        >
          <Home className="w-5 h-5 mr-2" />
          Voltar √† Vila
        </Button>
      </motion.div>
    </div>
  );
}
</file>

<file path="frontend/src/components/common/LoadingSpinner.tsx">
'use client';

import { motion } from 'framer-motion';
import { clsx } from 'clsx';

// =============================================================================
// LOADING SPINNER COMPONENT
// =============================================================================
interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg' | 'xl';
  variant?: 'default' | 'medieval' | 'werewolf' | 'dots';
  className?: string;
  text?: string;
}

function LoadingSpinner({
  size = 'md',
  variant = 'default',
  className = '',
  text,
}: LoadingSpinnerProps) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
    xl: 'w-16 h-16',
  };

  if (variant === 'medieval') {
    return <MedievalSpinner size={size} className={className} text={text} />;
  }

  if (variant === 'werewolf') {
    return <WerewolfSpinner size={size} className={className} text={text} />;
  }

  if (variant === 'dots') {
    return <DotsSpinner size={size} className={className} text={text} />;
  }

  // Default spinner
  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <motion.div
        className={clsx(
          sizeClasses[size],
          'border-3 border-salem-600 border-t-transparent rounded-full'
        )}
        animate={{ rotate: 360 }}
        transition={{
          duration: 1,
          repeat: Infinity,
          ease: 'linear',
        }}
      />
      {text && (
        <p className="mt-3 text-white/70 font-medium animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// MEDIEVAL SPINNER
// =============================================================================
function MedievalSpinner({
  size,
  className,
  text
}: Pick<LoadingSpinnerProps, 'size' | 'className' | 'text'>) {
  const iconSizes = {
    sm: 'text-2xl',
    md: 'text-4xl',
    lg: 'text-6xl',
    xl: 'text-8xl',
  };

  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <motion.div
        className={clsx('text-amber-400', iconSizes[size!])}
        animate={{
          rotate: 360,
          scale: [1, 1.1, 1],
        }}
        transition={{
          rotate: {
            duration: 2,
            repeat: Infinity,
            ease: 'linear',
          },
          scale: {
            duration: 1,
            repeat: Infinity,
            ease: 'easeInOut',
          },
        }}
      >
        ‚öîÔ∏è
      </motion.div>
      {text && (
        <p className="mt-3 text-amber-300 font-medieval animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// WEREWOLF SPINNER
// =============================================================================
function WerewolfSpinner({
  size,
  className,
  text
}: Pick<LoadingSpinnerProps, 'size' | 'className' | 'text'>) {
  const iconSizes = {
    sm: 'text-2xl',
    md: 'text-4xl',
    lg: 'text-6xl',
    xl: 'text-8xl',
  };

  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <motion.div
        className={clsx('text-red-400', iconSizes[size!])}
        animate={{
          scale: [1, 1.3, 1],
          rotate: [0, 5, -5, 0],
        }}
        transition={{
          duration: 2,
          repeat: Infinity,
          ease: 'easeInOut',
        }}
      >
        üê∫
      </motion.div>
      {text && (
        <p className="mt-3 text-red-300 font-bold animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// DOTS SPINNER
// =============================================================================
function DotsSpinner({
  size,
  className,
  text
}: Pick<LoadingSpinnerProps, 'size' | 'className' | 'text'>) {
  const dotSizes = {
    sm: 'w-2 h-2',
    md: 'w-3 h-3',
    lg: 'w-4 h-4',
    xl: 'w-6 h-6',
  };

  const dotSpacing = {
    sm: 'space-x-1',
    md: 'space-x-2',
    lg: 'space-x-3',
    xl: 'space-x-4',
  };

  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <div className={clsx('flex', dotSpacing[size!])}>
        {[0, 1, 2].map((index) => (
          <motion.div
            key={index}
            className={clsx(
              dotSizes[size!],
              'bg-salem-400 rounded-full'
            )}
            animate={{
              scale: [1, 1.5, 1],
              opacity: [0.5, 1, 0.5],
            }}
            transition={{
              duration: 1.5,
              repeat: Infinity,
              delay: index * 0.2,
              ease: 'easeInOut',
            }}
          />
        ))}
      </div>
      {text && (
        <p className="mt-3 text-white/70 font-medium animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// FULLSCREEN LOADING
// =============================================================================
interface FullscreenLoadingProps {
  variant?: LoadingSpinnerProps['variant'];
  message?: string;
  submessage?: string;
}

export function FullscreenLoading({
  variant = 'medieval',
  message = 'Carregando...',
  submessage,
}: FullscreenLoadingProps) {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="fixed inset-0 z-50 flex items-center justify-center bg-medieval-900/95 backdrop-blur-sm"
    >
      <div className="text-center">
        <LoadingSpinner
          variant={variant}
          size="xl"
          text={message}
        />
        {submessage && (
          <motion.p
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.5 }}
            className="mt-4 text-white/50 text-sm"
          >
            {submessage}
          </motion.p>
        )}
      </div>
    </motion.div>
  );
}

// =============================================================================
// PAGE LOADING
// =============================================================================
export function PageLoading() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-medieval-900">
      <div className="text-center">
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          className="text-8xl mb-8"
        >
          üê∫
        </motion.div>

        <motion.h1
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
          className="text-3xl font-medieval text-glow mb-4"
        >
          Lobisomem Online
        </motion.h1>

        <LoadingSpinner
          variant="medieval"
          size="lg"
          text="Preparando a vila..."
        />
      </div>
    </div>
  );
}

// =============================================================================
// ‚úÖ EXPORTS CORRETOS - ADICIONADOS NO FINAL
// =============================================================================
export default LoadingSpinner;
</file>

<file path="frontend/src/components/game/PhaseIndicator.tsx">
import React from 'react';
import { useGame } from '@/context/GameContext';
import type { GamePhase } from '@/types';

// =============================================================================
// PHASE CONFIGURATION
// =============================================================================
const PHASE_CONFIG = {
  LOBBY: {
    icon: 'üè∞',
    name: 'Sala de Espera',
    description: 'Aguardando jogadores',
    bgColor: 'bg-medieval-700',
    textColor: 'text-white/80',
    borderColor: 'border-medieval-600',
  },
  NIGHT: {
    icon: 'üåô',
    name: 'Noite',
    description: 'A√ß√µes secretas',
    bgColor: 'bg-blue-900',
    textColor: 'text-blue-200',
    borderColor: 'border-blue-700',
  },
  DAY: {
    icon: '‚òÄÔ∏è',
    name: 'Dia',
    description: 'Discuss√£o',
    bgColor: 'bg-amber-700',
    textColor: 'text-amber-200',
    borderColor: 'border-amber-600',
  },
  VOTING: {
    icon: 'üó≥Ô∏è',
    name: 'Vota√ß√£o',
    description: 'Execu√ß√£o',
    bgColor: 'bg-red-800',
    textColor: 'text-red-200',
    borderColor: 'border-red-600',
  },
} as const;

// =============================================================================
// PHASE INDICATOR COMPONENT - COMPACTO PARA HEADER
// =============================================================================
export default function PhaseIndicator() {
  const { gameState } = useGame();

  if (!gameState) {
    return (
      <div className="flex items-center space-x-2">
        <div className="animate-pulse bg-medieval-700 h-10 w-32 rounded-lg"></div>
      </div>
    );
  }

  const phase = gameState.phase as GamePhase;
  const config = PHASE_CONFIG[phase];
  const isNight = phase === 'NIGHT';

  return (
    <div className="flex items-center space-x-3">

      {/* Main Phase Display */}
      <div className={`
        ${config.bgColor} ${config.borderColor} ${config.textColor}
        border-2 rounded-lg px-4 py-2 flex items-center space-x-2
        ${isNight ? 'animate-pulse' : ''}
        transition-all duration-500 min-w-0
      `}>

        {/* Phase Icon */}
        <div className="text-xl flex-shrink-0">
          {config.icon}
        </div>

        {/* Phase Info */}
        <div className="min-w-0">
          <div className="flex items-center space-x-2">
            <span className="font-bold text-sm">
              {config.name}
            </span>

            {/* Day Counter */}
            {(phase === 'DAY' || phase === 'VOTING') && gameState.day > 0 && (
              <span className="bg-white/20 text-xs px-2 py-1 rounded-full font-medium">
                Dia {gameState.day}
              </span>
            )}
          </div>

          <p className="text-xs opacity-90">
            {config.description}
          </p>
        </div>
      </div>

      {/* Phase Progress Indicator */}
      <div className="hidden md:flex items-center space-x-2">
        <div className="w-1 h-8 bg-medieval-700 rounded-full overflow-hidden">
          <div
            className={`
              w-full transition-all duration-1000 ease-out
              ${phase === 'LOBBY' ? 'h-1/4 bg-medieval-500' : ''}
              ${phase === 'NIGHT' ? 'h-2/4 bg-blue-500' : ''}
              ${phase === 'DAY' ? 'h-3/4 bg-amber-500' : ''}
              ${phase === 'VOTING' ? 'h-full bg-red-500' : ''}
            `}
          />
        </div>

        {/* Quick Phase Info */}
        <div className="text-xs text-white/70 max-w-[120px]">
          {phase === 'LOBBY' && 'Preparando...'}
          {phase === 'NIGHT' && 'Roles agem'}
          {phase === 'DAY' && 'Discuss√£o livre'}
          {phase === 'VOTING' && 'Escolham um alvo'}
        </div>
      </div>

      {/* Atmospheric Effects - Only on larger screens */}
      {isNight && (
        <div className="hidden lg:flex items-center space-x-1 text-blue-400">
          <span className="animate-bounce" style={{ animationDelay: '0ms' }}>‚≠ê</span>
          <span className="animate-bounce" style={{ animationDelay: '200ms' }}>‚ú®</span>
          <span className="animate-bounce" style={{ animationDelay: '400ms' }}>üåü</span>
        </div>
      )}

      {(phase === 'DAY' || phase === 'VOTING') && (
        <div className="hidden lg:flex items-center space-x-1 text-amber-400">
          <span className="animate-pulse" style={{ animationDelay: '0ms' }}>‚òÄÔ∏è</span>
          {phase === 'VOTING' && (
            <span className="animate-pulse" style={{ animationDelay: '500ms' }}>‚öñÔ∏è</span>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/WillNotes.tsx">
import React, { useState, useEffect } from 'react';
import { useGame } from '@/context/GameContext';

// =============================================================================
// WILL NOTES COMPONENT - TESTAMENTO E ANOTA√á√ïES
// =============================================================================
export default function WillNotes() {
  const { gameState, me } = useGame();

  const [will, setWill] = useState('');
  const [notes, setNotes] = useState('');
  const [activeTab, setActiveTab] = useState<'will' | 'notes'>('will');

  // =============================================================================
  // LOAD FROM LOCALSTORAGE
  // =============================================================================
  useEffect(() => {
    if (gameState?.gameId) {
      const savedWill = localStorage.getItem(`will-${gameState.gameId}`);
      const savedNotes = localStorage.getItem(`notes-${gameState.gameId}`);

      if (savedWill) setWill(savedWill);
      if (savedNotes) setNotes(savedNotes);
    }
  }, [gameState?.gameId]);

  // =============================================================================
  // SAVE TO LOCALSTORAGE
  // =============================================================================
  useEffect(() => {
    if (gameState?.gameId) {
      localStorage.setItem(`will-${gameState.gameId}`, will);
    }
  }, [will, gameState?.gameId]);

  useEffect(() => {
    if (gameState?.gameId) {
      localStorage.setItem(`notes-${gameState.gameId}`, notes);
    }
  }, [notes, gameState?.gameId]);

  // =============================================================================
  // TEMPLATE HELPERS
  // =============================================================================
  const insertTemplate = (template: string) => {
    if (activeTab === 'will') {
      setWill(prev => prev + (prev ? '\n' : '') + template);
    } else {
      setNotes(prev => prev + (prev ? '\n' : '') + template);
    }
  };

  const getWillTemplates = () => [
    'Meu nome √© [NOME] e eu sou [ROLE].',
    'N1: [INVESTIGA√á√ÉO/A√á√ÉO]',
    'D1: [SUSPEITAS]',
    'Se eu morrer, suspeitem de: [NOMES]',
    'Confiem em: [NOMES]',
  ];

  const getNotesTemplates = () => [
    'üîç INVESTIGA√á√ïES:',
    '‚ö° SUSPEITOS:',
    '‚úÖ CONFIRMADOS:',
    'üê∫ POSS√çVEIS LOBISOMENS:',
    'üìù CLAIMS:',
  ];

  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Header with Tabs */}
      <div className="flex-shrink-0 border-b border-medieval-600 p-4">
        <div className="flex items-center justify-between mb-3">
          <h3 className="text-lg font-bold text-white flex items-center space-x-2">
            <span>üìú</span>
            <span>Anota√ß√µes</span>
          </h3>

          {/* Character count */}
          <div className="text-xs text-white/50">
            {activeTab === 'will' ? will.length : notes.length}/1000
          </div>
        </div>

        {/* Tab buttons */}
        <div className="flex space-x-1">
          <button
            onClick={() => setActiveTab('will')}
            className={`
              px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200
              ${activeTab === 'will'
                ? 'bg-amber-600 text-white'
                : 'bg-medieval-700/50 text-white/70 hover:bg-medieval-700'
              }
            `}
          >
            üìú Testamento
          </button>

          <button
            onClick={() => setActiveTab('notes')}
            className={`
              px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200
              ${activeTab === 'notes'
                ? 'bg-blue-600 text-white'
                : 'bg-medieval-700/50 text-white/70 hover:bg-medieval-700'
              }
            `}
          >
            üìù Notas
          </button>
        </div>
      </div>

      {/* Content Area */}
      <div className="flex-1 flex flex-col">

        {/* Templates */}
        <div className="flex-shrink-0 border-b border-medieval-600 p-2">
          <div className="text-xs text-white/70 mb-2">Templates r√°pidos:</div>
          <div className="flex flex-wrap gap-1">
            {(activeTab === 'will' ? getWillTemplates() : getNotesTemplates()).map((template, index) => (
              <button
                key={index}
                onClick={() => insertTemplate(template)}
                className="text-xs bg-medieval-700 hover:bg-medieval-600 text-white/80 px-2 py-1 rounded transition-all duration-200"
                title={`Inserir: ${template}`}
              >
                {template.split(':')[0] || template.substring(0, 10)}...
              </button>
            ))}
          </div>
        </div>

        {/* Text Area */}
        <div className="flex-1 p-4">
          <textarea
            value={activeTab === 'will' ? will : notes}
            onChange={(e) => {
              const value = e.target.value.substring(0, 1000); // Limit characters
              if (activeTab === 'will') {
                setWill(value);
              } else {
                setNotes(value);
              }
            }}
            placeholder={
              activeTab === 'will'
                ? `Escreva seu testamento aqui...\n\nExemplo:\nMeu nome √© ${me?.username} e eu sou ${me?.role || '[ROLE]'}.\nN1: Investiguei Jo√£o - SUSPEITO\nD1: Jo√£o est√° mentindo sobre sua role\nSe eu morrer, suspeitem de Jo√£o e Maria`
                : `Suas anota√ß√µes pessoais...\n\nüîç INVESTIGA√á√ïES:\n- Jo√£o: SUSPEITO (N1)\n- Maria: INOCENTE (N2)\n\n‚ö° SUSPEITOS:\n- Jo√£o (mentiu sobre role)\n- Pedro (comportamento estranho)\n\n‚úÖ CONFIRMADOS:\n- Ana (Doctor claim + salvou algu√©m)`
            }
            className="w-full h-full bg-medieval-900/50 border border-medieval-600 rounded-lg p-3 text-white placeholder-white/30 text-sm resize-none focus:outline-none focus:border-amber-400 font-mono leading-relaxed"
            style={{ minHeight: '200px' }}
          />
        </div>

        {/* Tips */}
        <div className="flex-shrink-0 border-t border-medieval-600 p-3">
          <div className="text-xs text-white/50">
            {activeTab === 'will' ? (
              <div>
                <div className="flex items-center space-x-1 mb-1">
                  <span>üí°</span>
                  <span>Dica: Seu testamento ser√° revelado quando voc√™ morrer</span>
                </div>
                <div>Use-o para deixar informa√ß√µes importantes para seu time!</div>
              </div>
            ) : (
              <div>
                <div className="flex items-center space-x-1 mb-1">
                  <span>üí°</span>
                  <span>Dica: Use as notas para rastrear suas investiga√ß√µes</span>
                </div>
                <div>Mantenha registro de quem √© suspeito e por qu√™!</div>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Game Info Panel */}
      <div className="flex-shrink-0 border-t border-medieval-600 p-3 bg-medieval-900/30">
        <div className="text-xs space-y-1">
          <div className="flex justify-between">
            <span className="text-white/70">Sua Role:</span>
            <span className="text-purple-300">{me?.role || 'Aguardando...'}</span>
          </div>

          <div className="flex justify-between">
            <span className="text-white/70">Fac√ß√£o:</span>
            <span className={`${me?.faction === 'TOWN' ? 'text-green-400' :
              me?.faction === 'WEREWOLF' ? 'text-red-400' :
                'text-purple-400'
              }`}>
              {me?.faction === 'TOWN' ? 'Vila' :
                me?.faction === 'WEREWOLF' ? 'Lobisomem' :
                  me?.faction === 'NEUTRAL' ? 'Neutro' : 'Aguardando...'}
            </span>
          </div>

          {gameState && (
            <div className="flex justify-between">
              <span className="text-white/70">Dia:</span>
              <span className="text-amber-400">{gameState.day}</span>
            </div>
          )}

          <div className="flex justify-between">
            <span className="text-white/70">Status:</span>
            <span className={me?.isAlive ? 'text-green-400' : 'text-red-400'}>
              {me?.isAlive ? 'Vivo' : 'Morto'}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/lobby/CreateRoomModal.tsx">
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { X, Users, Eye, Lock, Globe, Settings } from 'lucide-react';
import { useRouter } from 'next/router';
import { toast } from 'react-hot-toast';

import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';
import { apiService } from '@/services/api';

interface CreateRoomModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface RoomSettings {
  gameMode: 'CLASSIC' | 'RANKED' | 'CUSTOM';
  timeDay: number;
  timeNight: number;
  timeVoting: number;
  allowSpectators: boolean;
  autoStart: boolean;
}

export default function CreateRoomModal({
  isOpen,
  onClose,
}: CreateRoomModalProps) {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  const [formData, setFormData] = useState({
    name: '',
    isPrivate: false,
    maxPlayers: 12,
    maxSpectators: 8,
  });

  const [settings, setSettings] = useState<RoomSettings>({
    gameMode: 'CLASSIC',
    timeDay: 300,
    timeNight: 120,
    timeVoting: 180,
    allowSpectators: true,
    autoStart: false,
  });

  const [showAdvanced, setShowAdvanced] = useState(false);

  /* -------------------------------------------------------------------------- */
  /*                                 Handlers                                   */
  /* -------------------------------------------------------------------------- */
  const handleInputChange = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleSettingsChange = (field: keyof RoomSettings, value: any) => {
    setSettings(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.name.trim()) {
      toast.error('Nome da sala √© obrigat√≥rio');
      return;
    }
    if (formData.name.length < 3) {
      toast.error('Nome da sala deve ter pelo menos 3 caracteres');
      return;
    }

    setLoading(true);

    try {
      /* ------------------------------ Cria a sala ----------------------------- */
      const response = await apiService.post('/api/rooms', {
        ...formData,
        settings,
      });

      toast.success('Sala criada com sucesso!');
      onClose();

      /* ----------------------- Redireciona para a nova sala ----------------------- */
      const roomId =
        response.data?.data?.room?.id ?? response.data?.room?.id ?? null;

      if (roomId) {
        router.push(`/room/${roomId}`);
      } else {
        console.error(
          'ERRO CR√çTICO: N√£o foi poss√≠vel obter o ID da sala.',
          response.data,
        );
        toast.error('N√£o foi poss√≠vel redirecionar para a sala.');
      }
    } catch (error: any) {
      console.error('Erro ao criar sala:', error);
      toast.error(
        error.response?.data?.message || 'Erro inesperado ao criar sala',
      );
    } finally {
      setLoading(false);
    }
  };

  const handleClose = () => {
    if (!loading) {
      setFormData({
        name: '',
        isPrivate: false,
        maxPlayers: 12,
        maxSpectators: 8,
      });
      setSettings({
        gameMode: 'CLASSIC',
        timeDay: 300,
        timeNight: 120,
        timeVoting: 180,
        allowSpectators: true,
        autoStart: false,
      });
      setShowAdvanced(false);
      onClose();
    }
  };

  /* -------------------------------------------------------------------------- */
  /*                                   JSX                                      */
  /* -------------------------------------------------------------------------- */
  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title="üê∫ Criar Nova Sala"
      size="lg"
      variant="medieval"
    >
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Nome da Sala */}
        <div>
          <label className="block text-sm font-medium text-slate-300 mb-2">
            Nome da Sala *
          </label>
          <input
            type="text"
            value={formData.name}
            onChange={e => handleInputChange('name', e.target.value)}
            placeholder="Digite o nome da sua sala."
            maxLength={50}
            className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            disabled={loading}
          />
          <div className="text-xs text-slate-500 mt-1">
            {formData.name.length}/50 caracteres
          </div>
        </div>

        {/* Configura√ß√µes B√°sicas */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* M√°ximo de Jogadores */}
          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
              <Users className="w-4 h-4 inline mr-2" />
              M√°ximo de Jogadores
            </label>
            <select
              value={formData.maxPlayers}
              onChange={e =>
                handleInputChange('maxPlayers', parseInt(e.target.value))
              }
              className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={loading}
            >
              {[6, 8, 10, 12, 14, 16].map(num => (
                <option key={num} value={num}>
                  {num} jogadores
                </option>
              ))}
            </select>
          </div>

          {/* M√°ximo de Espectadores */}
          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
              <Eye className="w-4 h-4 inline mr-2" />
              M√°ximo de Espectadores
            </label>
            <select
              value={formData.maxSpectators}
              onChange={e =>
                handleInputChange('maxSpectators', parseInt(e.target.value))
              }
              className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={loading}
            >
              {[0, 4, 8, 12, 16, 20].map(num => (
                <option key={num} value={num}>
                  {num === 0 ? 'Sem espectadores' : `${num} espectadores`}
                </option>
              ))}
            </select>
          </div>
        </div>

        {/* Tipo de Sala */}
        <div>
          <label className="block text-sm font-medium text-slate-300 mb-3">
            Tipo de Sala
          </label>
          <div className="grid grid-cols-2 gap-3">
            <button
              type="button"
              onClick={() => handleInputChange('isPrivate', false)}
              className={`p-4 rounded-lg border-2 transition-all ${!formData.isPrivate
                ? 'border-green-500 bg-green-500/10 text-green-400'
                : 'border-slate-600 bg-slate-700/50 text-slate-300'
                }`}
              disabled={loading}
            >
              <Globe className="w-6 h-6 mx-auto mb-2" />
              <div className="font-medium">P√∫blica</div>
              <div className="text-xs opacity-75">Vis√≠vel no lobby</div>
            </button>

            <button
              type="button"
              onClick={() => handleInputChange('isPrivate', true)}
              className={`p-4 rounded-lg border-2 transition-all ${formData.isPrivate
                ? 'border-blue-500 bg-blue-500/10 text-blue-400'
                : 'border-slate-600 bg-slate-700/50 text-slate-300'
                }`}
              disabled={loading}
            >
              <Lock className="w-6 h-6 mx-auto mb-2" />
              <div className="font-medium">Privada</div>
              <div className="text-xs opacity-75">Apenas por c√≥digo</div>
            </button>
          </div>
        </div>

        {/* Configura√ß√µes Avan√ßadas (colapse) */}
        <div>
          <button
            type="button"
            onClick={() => setShowAdvanced(!showAdvanced)}
            className="flex items-center gap-2 text-slate-300 hover:text-white transition-colors"
            disabled={loading}
          >
            <Settings className="w-4 h-4" />
            Configura√ß√µes Avan√ßadas
            <motion.div
              animate={{ rotate: showAdvanced ? 180 : 0 }}
              transition={{ duration: 0.2 }}
            >
              <X className="w-4 h-4" />
            </motion.div>
          </button>

          {showAdvanced && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              className="mt-4 p-4 bg-slate-800/50 rounded-lg border border-slate-600 space-y-4"
            >
              {/* Modo de Jogo */}
              <div>
                <label className="block text-sm font-medium text-slate-300 mb-2">
                  Modo de Jogo
                </label>
                <select
                  value={settings.gameMode}
                  onChange={e =>
                    handleSettingsChange(
                      'gameMode',
                      e.target.value as RoomSettings['gameMode'],
                    )
                  }
                  className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded text-white"
                  disabled={loading}
                >
                  <option value="CLASSIC">Cl√°ssico</option>
                  <option value="RANKED">Ranqueado</option>
                  <option value="CUSTOM">Personalizado</option>
                </select>
              </div>

              {/* Tempos */}
              <div className="grid grid-cols-3 gap-3">
                <div>
                  <label className="block text-xs text-slate-400 mb-1">
                    Tempo Dia (seg)
                  </label>
                  <input
                    type="number"
                    min={60}
                    max={600}
                    value={settings.timeDay}
                    onChange={e =>
                      handleSettingsChange(
                        'timeDay',
                        parseInt(e.target.value, 10),
                      )
                    }
                    className="w-full px-2 py-1 bg-slate-700 border border-slate-600 rounded text-white text-sm"
                    disabled={loading}
                  />
                </div>

                <div>
                  <label className="block text-xs text-slate-400 mb-1">
                    Tempo Noite (seg)
                  </label>
                  <input
                    type="number"
                    min={30}
                    max={300}
                    value={settings.timeNight}
                    onChange={e =>
                      handleSettingsChange(
                        'timeNight',
                        parseInt(e.target.value, 10),
                      )
                    }
                    className="w-full px-2 py-1 bg-slate-700 border border-slate-600 rounded text-white text-sm"
                    disabled={loading}
                  />
                </div>

                <div>
                  <label className="block text-xs text-slate-400 mb-1">
                    Tempo Vota√ß√£o (seg)
                  </label>
                  <input
                    type="number"
                    min={60}
                    max={300}
                    value={settings.timeVoting}
                    onChange={e =>
                      handleSettingsChange(
                        'timeVoting',
                        parseInt(e.target.value, 10),
                      )
                    }
                    className="w-full px-2 py-1 bg-slate-700 border border-slate-600 rounded text-white text-sm"
                    disabled={loading}
                  />
                </div>
              </div>

              {/* Op√ß√µes */}
              <div className="space-y-2">
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={settings.allowSpectators}
                    onChange={e =>
                      handleSettingsChange('allowSpectators', e.target.checked)
                    }
                    className="rounded"
                    disabled={loading}
                  />
                  <span className="text-sm text-slate-300">
                    Permitir espectadores
                  </span>
                </label>

                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={settings.autoStart}
                    onChange={e =>
                      handleSettingsChange('autoStart', e.target.checked)
                    }
                    className="rounded"
                    disabled={loading}
                  />
                  <span className="text-sm text-slate-300">
                    In√≠cio autom√°tico quando todos estiverem prontos
                  </span>
                </label>
              </div>
            </motion.div>
          )}
        </div>

        {/* Bot√µes */}
        <div className="flex justify-end gap-3 pt-4 border-t border-slate-700">
          <Button variant="ghost" onClick={handleClose} disabled={loading}>
            Cancelar
          </Button>

          <Button
            type="submit"
            variant="primary"
            loading={loading}
            className="min-w-[120px]"
          >
            {loading ? 'Criando...' : 'Criar Sala'}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
</file>

<file path="frontend/src/components/lobby/JoinRoomModal.tsx">
import React, { useState } from 'react';
import { Eye, X } from 'lucide-react';
import { toast } from 'react-hot-toast';
import { motion } from 'framer-motion';
import { useRouter } from 'next/router';

import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';
import { apiService } from '@/services/api';

interface JoinRoomModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function JoinRoomModal({ isOpen, onClose }: JoinRoomModalProps) {
  const router = useRouter();

  const [roomCode, setRoomCode] = useState('');
  const [asSpectator, setAsSpectator] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!roomCode.trim()) {
      toast.error('Informe o c√≥digo da sala');
      return;
    }

    setLoading(true);

    try {
      const response = await apiService.post('/api/rooms/join-by-code', {
        code: roomCode.toUpperCase(),
        asSpectator,
      });

      toast.success(`${asSpectator ? 'Espectando' : 'Entrou na'} sala com sucesso!`);
      onClose();

      // ‚úÖ CORRE√á√ÉO APLICADA AQUI
      const roomId =
        response.data?.data?.room?.id ?? response.data?.room?.id ?? null;

      if (roomId) {
        router.push(`/room/${roomId}`);
      } else {
        console.error(
          'ERRO CR√çTICO: N√£o foi poss√≠vel obter o ID da sala da resposta da API.',
          response.data
        );
        toast.error('Ocorreu um erro ao redirecionar para a sala.');
      }
    } catch (error: any) {
      console.error('Erro ao entrar na sala:', error);
      toast.error(
        error.response?.data?.message || 'Erro inesperado ao entrar na sala'
      );
    } finally {
      setLoading(false);
    }
  };

  const handleClose = () => {
    if (!loading) {
      setRoomCode('');
      setAsSpectator(false);
      onClose();
    }
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title="üîë Entrar em uma Sala"
      size="md"
      variant="medieval"
    >
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* C√≥digo da Sala */}
        <div>
          <label className="block text-sm font-medium text-slate-300 mb-2">
            C√≥digo da Sala
          </label>
          <input
            type="text"
            value={roomCode}
            onChange={(e) => setRoomCode(e.target.value)}
            placeholder="Ex: ABC123"
            maxLength={10}
            className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 uppercase tracking-widest"
            disabled={loading}
          />
        </div>

        {/* Entrar como Espectador */}
        <div className="flex items-center gap-2">
          <input
            id="spectator"
            type="checkbox"
            checked={asSpectator}
            onChange={(e) => setAsSpectator(e.target.checked)}
            className="rounded"
            disabled={loading}
          />
          <label htmlFor="spectator" className="text-sm text-slate-300 flex items-center gap-2">
            <Eye className="w-4 h-4" />
            Entrar como espectador
          </label>
        </div>

        {/* Bot√µes */}
        <div className="flex justify-end gap-3 pt-4 border-t border-slate-700">
          <Button variant="ghost" onClick={handleClose} disabled={loading}>
            Cancelar
          </Button>

          <Button
            type="submit"
            variant="primary"
            loading={loading}
            className="min-w-[120px]"
          >
            {loading ? 'Entrando...' : 'Entrar'}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
</file>

<file path="frontend/src/context/GameContext.tsx">
'use client';

import React, { createContext, useContext, useReducer, useEffect, useMemo } from 'react';
import { useAuth } from './AuthContext';
import type { GameState, Player, GamePhase } from '@/types';

// =============================================================================
// TYPES & INTERFACES
// =============================================================================
interface GameContextState {
  gameState: GameState | null;
  isLoading: boolean;
  error: string | null;
  connectionStatus: 'disconnected' | 'connecting' | 'connected' | 'error';
}

interface GameContextValue extends GameContextState {
  // Dados derivados
  me: Player | null;
  alivePlayers: Player[];
  deadPlayers: Player[];
  isMyTurn: boolean;
  canVote: boolean;
  canAct: boolean;

  // Actions
  refreshGame: () => void;
  clearError: () => void;
}

// =============================================================================
// REDUCER
// =============================================================================
type GameAction =
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_CONNECTION_STATUS'; payload: GameContextState['connectionStatus'] }
  | { type: 'SET_GAME_STATE'; payload: GameState }
  | { type: 'UPDATE_PHASE'; payload: { phase: GamePhase; timeLeft: number; day: number } }
  | { type: 'UPDATE_VOTING'; payload: { votes: Record<string, string>; counts: Record<string, number> } }
  | { type: 'PLAYER_DIED'; payload: { playerId: string; role?: string; cause: string } }
  | { type: 'CLEAR_GAME' };

const initialState: GameContextState = {
  gameState: null,
  isLoading: false,
  error: null,
  connectionStatus: 'disconnected',
};

function gameReducer(state: GameContextState, action: GameAction): GameContextState {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };

    case 'SET_ERROR':
      return { ...state, error: action.payload, isLoading: false };

    case 'SET_CONNECTION_STATUS':
      return { ...state, connectionStatus: action.payload };

    case 'SET_GAME_STATE':
      return {
        ...state,
        gameState: action.payload,
        isLoading: false,
        error: null,
        connectionStatus: 'connected',
      };

    case 'UPDATE_PHASE':
      return {
        ...state,
        gameState: state.gameState ? {
          ...state.gameState,
          phase: action.payload.phase,
          timeLeft: action.payload.timeLeft,
          day: action.payload.day,
        } : null,
      };

    case 'UPDATE_VOTING':
      return {
        ...state,
        gameState: state.gameState ? {
          ...state.gameState,
          votes: action.payload.votes,
        } : null,
      };

    case 'PLAYER_DIED':
      return {
        ...state,
        gameState: state.gameState ? {
          ...state.gameState,
          players: state.gameState.players.map(player =>
            player.id === action.payload.playerId
              ? { ...player, isAlive: false, eliminationReason: action.payload.cause as any }
              : player
          ),
        } : null,
      };

    case 'CLEAR_GAME':
      return initialState;

    default:
      return state;
  }
}

// =============================================================================
// CONTEXT
// =============================================================================
const GameContext = createContext<GameContextValue | undefined>(undefined);

// =============================================================================
// PROVIDER
// =============================================================================
interface GameProviderProps {
  children: React.ReactNode;
  gameId: string;
}

export function GameProvider({ children, gameId }: GameProviderProps) {
  const [state, dispatch] = useReducer(gameReducer, initialState);
  const { user } = useAuth();

  // =============================================================================
  // WEBSOCKET MESSAGE HANDLING
  // =============================================================================
  useEffect(() => {
    const handleWebSocketMessage = (event: CustomEvent) => {
      const message = event.detail;

      if (!message?.type) return;

      try {
        console.log('üéÆ GameContext received message:', message.type, message.data);

        switch (message.type) {
          case 'game-state':
            if (message.data?.gameId === gameId) {
              dispatch({ type: 'SET_GAME_STATE', payload: message.data });
            }
            break;

          case 'phase-changed':
            if (message.data?.gameId === gameId) {
              dispatch({
                type: 'UPDATE_PHASE',
                payload: {
                  phase: message.data.phase,
                  timeLeft: message.data.timeLeft,
                  day: message.data.day,
                },
              });
            }
            break;

          case 'voting-update':
          case 'vote-cast':
          case 'vote-removed':
            if (message.data?.gameId === gameId) {
              dispatch({
                type: 'UPDATE_VOTING',
                payload: {
                  votes: message.data.votes || {},
                  counts: message.data.counts || {},
                },
              });
            }
            break;

          case 'player-died':
          case 'night-results':
            if (message.data?.gameId === gameId) {
              // Handle player deaths from night results
              if (message.data.deaths && Array.isArray(message.data.deaths)) {
                message.data.deaths.forEach((death: any) => {
                  dispatch({
                    type: 'PLAYER_DIED',
                    payload: {
                      playerId: death.playerId,
                      role: death.role,
                      cause: death.cause,
                    },
                  });
                });
              }
            }
            break;

          case 'game-ended':
            if (message.data?.gameId === gameId) {
              dispatch({ type: 'SET_GAME_STATE', payload: message.data });
            }
            break;

          case 'error':
            dispatch({ type: 'SET_ERROR', payload: message.data?.message || 'Erro desconhecido' });
            break;

          default:
            // Log unknown message types for debugging
            console.log('üîç Unknown game message type:', message.type);
        }
      } catch (error) {
        console.error('‚ùå Error handling WebSocket message:', error);
        dispatch({ type: 'SET_ERROR', payload: 'Erro ao processar mensagem do servidor' });
      }
    };

    // Listen to WebSocket messages
    window.addEventListener('websocket-message', handleWebSocketMessage as EventListener);

    return () => {
      window.removeEventListener('websocket-message', handleWebSocketMessage as EventListener);
    };
  }, [gameId]);

  // =============================================================================
  // DERIVED DATA (MEMOIZED)
  // =============================================================================
  const me = useMemo((): Player | null => {
    if (!state.gameState || !user?.id) return null;
    return state.gameState.players.find(p => p.userId === user.id) || null;
  }, [state.gameState, user?.id]);

  const alivePlayers = useMemo((): Player[] => {
    if (!state.gameState) return [];
    return state.gameState.players.filter(p => p.isAlive && !p.isSpectator);
  }, [state.gameState]);

  const deadPlayers = useMemo((): Player[] => {
    if (!state.gameState) return [];
    return state.gameState.players.filter(p => !p.isAlive && !p.isSpectator);
  }, [state.gameState]);

  const isMyTurn = useMemo((): boolean => {
    if (!me || !state.gameState) return false;

    // Durante a noite, verificar se √© a vez da role do jogador agir
    if (state.gameState.phase === 'NIGHT') {
      return me.isAlive && !me.hasActed && (me.role === 'SHERIFF' || me.role === 'DOCTOR' || me.role === 'VIGILANTE' || me.role === 'WEREWOLF');
    }

    // Durante vota√ß√£o, todos podem votar
    if (state.gameState.phase === 'VOTING') {
      return me.isAlive && !me.hasVoted;
    }

    return false;
  }, [me, state.gameState]);

  const canVote = useMemo((): boolean => {
    return Boolean(
      me &&
      state.gameState &&
      state.gameState.phase === 'VOTING' &&
      me.isAlive &&
      !me.hasVoted
    );
  }, [me, state.gameState]);

  const canAct = useMemo((): boolean => {
    return Boolean(
      me &&
      state.gameState &&
      state.gameState.phase === 'NIGHT' &&
      me.isAlive &&
      !me.hasActed &&
      (me.role === 'SHERIFF' || me.role === 'DOCTOR' || me.role === 'VIGILANTE' || me.role === 'WEREWOLF')
    );
  }, [me, state.gameState]);

  // =============================================================================
  // ACTIONS
  // =============================================================================
  const refreshGame = () => {
    dispatch({ type: 'SET_LOADING', payload: true });
    // Trigger game state refresh - could send a message to backend
    // For now, just clear loading state after a timeout
    setTimeout(() => {
      dispatch({ type: 'SET_LOADING', payload: false });
    }, 1000);
  };

  const clearError = () => {
    dispatch({ type: 'SET_ERROR', payload: null });
  };

  // =============================================================================
  // CONTEXT VALUE
  // =============================================================================
  const contextValue: GameContextValue = {
    // State
    ...state,

    // Derived data
    me,
    alivePlayers,
    deadPlayers,
    isMyTurn,
    canVote,
    canAct,

    // Actions
    refreshGame,
    clearError,
  };

  return (
    <GameContext.Provider value={contextValue}>
      {children}
    </GameContext.Provider>
  );
}

// =============================================================================
// HOOK
// =============================================================================
export function useGame(): GameContextValue {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
}

// =============================================================================
// EXPORT
// =============================================================================
export default GameContext;
</file>

<file path="frontend/src/pages/auth/forgot-password.tsx">
// üê∫ WEREWOLF - Forgot Password Page
// Werewolf inspired password recovery interface

import { useState } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { Mail, ArrowLeft, Send, CheckCircle } from 'lucide-react';

import { useForm } from '@/hooks';
import { authService } from '@/services/auth';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';

// =============================================================================
// FORGOT PASSWORD PAGE COMPONENT
// =============================================================================
export default function ForgotPasswordPage() {
  const router = useRouter();
  const [emailSent, setEmailSent] = useState(false);

  // Form management
  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleSubmit,
    setError,
    setTouched,
  } = useForm<{ email: string }>(
    { email: '' },
    async (formData) => {
      // Validate email
      if (!formData.email) {
        setError('email', 'Email √© obrigat√≥rio');
        return;
      }

      if (!authService.validateEmail(formData.email)) {
        setError('email', 'Email inv√°lido');
        return;
      }

      try {
        const response = await authService.forgotPassword(formData.email);
        if (response.success) {
          setEmailSent(true);
        } else {
          setError('email', response.error || 'Erro ao enviar email');
        }
      } catch (error) {
        setError('email', 'Erro de conex√£o. Tente novamente.');
      }
    }
  );

  if (emailSent) {
    return <EmailSentSuccess email={values.email} />;
  }

  return (
    <>
      <Head>
        <title>Esqueci Minha Senha - Werewolf</title>
        <meta name="description" content="Recupere sua senha do Werewolf" />
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="card-medieval p-8"
        >
          {/* Back Button */}
          <motion.div
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            className="mb-6"
          >
            <Button
              variant="ghost"
              size="sm"
              onClick={() => router.back()}
              className="text-white/70 hover:text-white"
            >
              <ArrowLeft className="w-4 h-4 mr-2" />
              Voltar
            </Button>
          </motion.div>

          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: 'spring' }}
              className="text-6xl mb-4"
            >
              üîë
            </motion.div>
            <h1 className="text-2xl font-medieval text-glow mb-2">
              Esqueceu sua Senha?
            </h1>
            <p className="text-white/70 leading-relaxed">
              N√£o se preocupe! Digite seu email e enviaremos
              instru√ß√µes para redefinir sua senha.
            </p>
          </div>

          {/* Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Email Field */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Email da Conta
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Mail className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="email"
                  type="email"
                  value={values.email}
                  onChange={handleChange('email')}
                  onBlur={() => setTouched('email')}
                  className={`
                    w-full pl-10 pr-4 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.email && touched.email
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seu@email.com"
                  disabled={isSubmitting}
                  autoFocus
                />
              </div>
              {errors.email && touched.email && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.email}
                </motion.p>
              )}
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="medieval"
              size="lg"
              disabled={isSubmitting}
              loading={isSubmitting}
              className="w-full"
            >
              <Send className="w-5 h-5 mr-2" />
              {isSubmitting ? 'Enviando...' : 'Enviar Instru√ß√µes'}
            </Button>
          </form>

          {/* Additional Info */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.5 }}
            className="mt-8 p-4 bg-blue-900/20 border border-blue-500/30 rounded-lg"
          >
            <h3 className="text-sm font-semibold text-blue-300 mb-2">
              üí° Dica
            </h3>
            <p className="text-xs text-blue-200/70">
              Verifique sua caixa de spam se n√£o receber o email em alguns minutos.
              O email de recupera√ß√£o ser√° enviado de noreply@werewolf.com
            </p>
          </motion.div>

          {/* Back to Login */}
          <div className="mt-8 text-center">
            <p className="text-white/50 text-sm mb-4">
              Lembrou da sua senha?
            </p>
            <Link
              href="/auth/login"
              className="text-salem-400 hover:text-salem-300 transition-colors text-sm font-medium"
            >
              Voltar para o Login
            </Link>
          </div>
        </motion.div>
      </Layout>
    </>
  );
}

// =============================================================================
// EMAIL SENT SUCCESS COMPONENT
// =============================================================================
interface EmailSentSuccessProps {
  email: string;
}

function EmailSentSuccess({ email }: EmailSentSuccessProps) {
  const router = useRouter();

  return (
    <>
      <Head>
        <title>Email Enviado - Werewolf</title>
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          className="card-medieval p-8 text-center"
        >
          {/* Success Icon */}
          <motion.div
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ delay: 0.2, type: 'spring', bounce: 0.6 }}
            className="text-6xl mb-6"
          >
            üìß
          </motion.div>

          {/* Success Message */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4 }}
            className="mb-8"
          >
            <div className="flex items-center justify-center mb-4">
              <CheckCircle className="w-8 h-8 text-green-400 mr-3" />
              <h1 className="text-2xl font-medieval text-glow">
                Email Enviado!
              </h1>
            </div>

            <p className="text-white/70 leading-relaxed mb-4">
              Enviamos instru√ß√µes de recupera√ß√£o de senha para:
            </p>

            <div className="bg-medieval-800/50 border border-medieval-600 rounded-lg p-3 mb-6">
              <span className="font-mono text-salem-300">{email}</span>
            </div>

            <p className="text-white/60 text-sm">
              Siga as instru√ß√µes no email para redefinir sua senha.
              O link √© v√°lido por 1 hora.
            </p>
          </motion.div>

          {/* Action Buttons */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.6 }}
            className="space-y-4"
          >
            <Button
              variant="medieval"
              size="lg"
              onClick={() => router.push('/auth/login')}
              className="w-full"
            >
              Voltar ao Login
            </Button>

            <Button
              variant="ghost"
              onClick={() => router.push('/auth/forgot-password')}
              className="w-full text-sm"
            >
              N√£o recebeu o email? Tentar novamente
            </Button>
          </motion.div>

          {/* Additional Help */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 1 }}
            className="mt-8 p-4 bg-amber-900/20 border border-amber-500/30 rounded-lg"
          >
            <h3 className="text-sm font-semibold text-amber-300 mb-2">
              ‚ö†Ô∏è N√£o recebeu o email?
            </h3>
            <ul className="text-xs text-amber-200/70 text-left space-y-1">
              <li>‚Ä¢ Verifique sua caixa de spam</li>
              <li>‚Ä¢ Confirme se o email est√° correto</li>
              <li>‚Ä¢ Aguarde alguns minutos</li>
              <li>‚Ä¢ Tente novamente se necess√°rio</li>
            </ul>
          </motion.div>
        </motion.div>
      </Layout>
    </>
  );
}
</file>

<file path="frontend/src/pages/game/mock.tsx">
import React, { useState, useEffect } from 'react';
import type { GameState, Player, GamePhase } from '@/types';

// =============================================================================
// MOCK DATA COMPLETO
// =============================================================================
const createMockPlayer = (id: string, userId: string, username: string, role: string, isAlive = true, isHost = false): Player => ({
  id,
  userId,
  username,
  isHost,
  isReady: true,
  isSpectator: false,
  isConnected: true,
  joinedAt: new Date(),
  lastSeen: new Date(),
  isAlive,
  role: role as any,
  faction: role === 'WEREWOLF' || role === 'WEREWOLF_KING' ? 'WEREWOLF' :
    role === 'JESTER' || role === 'SERIAL_KILLER' ? 'NEUTRAL' : 'TOWN',
  hasActed: false,
  hasVoted: false,
  isProtected: false,
});

const MOCK_PLAYERS: Player[] = [
  createMockPlayer('1', 'user1', 'Jo√£o Silva', 'SHERIFF', true, true),
  createMockPlayer('2', 'user2', 'Maria Santos', 'DOCTOR', true, false),
  createMockPlayer('3', 'user3', 'Pedro Oliveira', 'WEREWOLF', true, false),
  createMockPlayer('4', 'user4', 'Ana Costa', 'VILLAGER', true, false),
  createMockPlayer('5', 'user5', 'Carlos Lima', 'VIGILANTE', true, false),
  createMockPlayer('6', 'user6', 'Sofia Alves', 'WEREWOLF_KING', false, false), // Morta
  createMockPlayer('7', 'user7', 'Lucas Pereira', 'VILLAGER', true, false),
  createMockPlayer('8', 'user8', 'Julia Martins', 'JESTER', true, false),
  createMockPlayer('9', 'user9', 'Rafael Costa', 'SERIAL_KILLER', true, false),
];

const createMockGameState = (phase: GamePhase, day: number): GameState => ({
  gameId: 'mock-game-123',
  roomId: 'mock-room-123',
  status: 'PLAYING',
  phase,
  day,
  phaseStartTime: new Date(),
  phaseEndTime: new Date(Date.now() + 120000), // 2 minutos
  timeLeft: 120000,
  players: MOCK_PLAYERS,
  spectators: ['spectator1', 'spectator2'],
  eliminatedPlayers: MOCK_PLAYERS.filter(p => !p.isAlive),
  hostId: 'user1',
  events: [
    {
      id: '1',
      type: 'GAME_STARTED',
      phase: 'LOBBY',
      day: 0,
      timestamp: new Date(),
      data: { message: 'O jogo come√ßou!' }
    },
    {
      id: '2',
      type: 'PHASE_CHANGED',
      phase: 'NIGHT',
      day: 1,
      timestamp: new Date(),
      data: { phase: 'NIGHT', day: 1 }
    },
    {
      id: '3',
      type: 'PLAYER_DIED',
      phase: 'DAY',
      day: 2,
      timestamp: new Date(),
      data: { playerId: '6', playerName: 'Sofia Alves', role: 'WEREWOLF_KING', cause: 'NIGHT_KILL' }
    }
  ],
  votes: phase === 'VOTING' ? {
    'user1': '3', // Jo√£o vota em Pedro
    'user2': '3', // Maria vota em Pedro
    'user4': '8', // Ana vota em Julia
    'user7': '3', // Lucas vota em Pedro
  } : {},
  nightActions: [],
  config: {
    roomId: 'mock-room-123',
    maxPlayers: 15,
    maxSpectators: 5,
    nightDuration: 60000,
    dayDuration: 120000,
    votingDuration: 60000,
    allowReconnection: true,
    reconnectionTimeout: 120000,
  },
  createdAt: new Date(),
  updatedAt: new Date(),
  startedAt: new Date(),
});

// =============================================================================
// MOCK GAME CONTEXT
// =============================================================================
const MockGameContext = React.createContext<any>(null);

const MockGameProvider = ({ children, gameState }: { children: React.ReactNode; gameState: GameState }) => {
  const me = gameState.players.find(p => p.userId === 'user1'); // Jo√£o (Sheriff)
  const alivePlayers = gameState.players.filter(p => p.isAlive);
  const deadPlayers = gameState.players.filter(p => !p.isAlive);

  const contextValue = {
    gameState,
    me,
    alivePlayers,
    deadPlayers,
    isMyTurn: gameState.phase === 'NIGHT' && me?.role === 'SHERIFF' && !me.hasActed,
    canVote: gameState.phase === 'VOTING' && me?.isAlive && !me.hasVoted,
    canAct: gameState.phase === 'NIGHT' && me?.isAlive && !me.hasActed && (me?.role === 'SHERIFF' || me?.role === 'DOCTOR'),
    isLoading: false,
    error: null,
    connectionStatus: 'connected' as const,
  };

  return (
    <MockGameContext.Provider value={contextValue}>
      {children}
    </MockGameContext.Provider>
  );
};

const useGame = () => {
  const context = React.useContext(MockGameContext);
  if (!context) throw new Error('useGame must be used within MockGameProvider');
  return context;
};

// =============================================================================
// MOCK SOCKET CONTEXT
// =============================================================================
const MockSocketContext = React.createContext<any>(null);

const MockSocketProvider = ({ children }: { children: React.ReactNode }) => {
  const contextValue = {
    isConnected: true,
    sendMessage: (type: string, data?: any) => {
      console.log('üéÆ MOCK: Sending message:', type, data);
      return true;
    },
  };

  return (
    <MockSocketContext.Provider value={contextValue}>
      {children}
    </MockSocketContext.Provider>
  );
};

const useSocket = () => {
  const context = React.useContext(MockSocketContext);
  if (!context) throw new Error('useSocket must be used within MockSocketProvider');
  return context;
};

// =============================================================================
// MOCK COMPONENTS (SIMPLIFIED VERSIONS)
// =============================================================================

// Phase Indicator
const MockPhaseIndicator = ({ phase, day }: { phase: GamePhase; day: number }) => {
  const PHASE_CONFIG = {
    NIGHT: { icon: 'üåô', name: 'Noite', bgColor: 'bg-blue-900', textColor: 'text-blue-200', borderColor: 'border-blue-700' },
    DAY: { icon: '‚òÄÔ∏è', name: 'Dia', bgColor: 'bg-amber-700', textColor: 'text-amber-200', borderColor: 'border-amber-600' },
    VOTING: { icon: 'üó≥Ô∏è', name: 'Vota√ß√£o', bgColor: 'bg-red-800', textColor: 'text-red-200', borderColor: 'border-red-600' },
    LOBBY: { icon: 'üè∞', name: 'Lobby', bgColor: 'bg-gray-700', textColor: 'text-gray-300', borderColor: 'border-gray-600' },
  }[phase];

  return (
    <div className={`${PHASE_CONFIG.bgColor} ${PHASE_CONFIG.borderColor} ${PHASE_CONFIG.textColor} border-2 rounded-lg px-4 py-2 flex items-center space-x-2`}>
      <div className="text-xl">{PHASE_CONFIG.icon}</div>
      <div>
        <div className="flex items-center space-x-2">
          <span className="font-bold text-sm">{PHASE_CONFIG.name}</span>
          {day > 0 && <span className="bg-white bg-opacity-20 text-xs px-2 py-1 rounded-full">Dia {day}</span>}
        </div>
        <p className="text-xs opacity-90">Fase simulada</p>
      </div>
    </div>
  );
};

// Timer Display
const MockTimerDisplay = ({ timeLeft }: { timeLeft: number }) => {
  const minutes = Math.floor(timeLeft / 60);
  const seconds = timeLeft % 60;

  return (
    <div className="bg-gray-800 border-2 border-green-500 rounded-lg px-3 py-2 flex items-center space-x-2">
      <div className="text-lg">‚è±Ô∏è</div>
      <div className="text-center">
        <div className="text-lg font-mono font-bold text-green-400">
          {minutes.toString().padStart(2, '0')}:{seconds.toString().padStart(2, '0')}
        </div>
        <div className="text-xs text-gray-400">Restante</div>
      </div>
    </div>
  );
};

// Role Card
const MockRoleCard = () => {
  const { me } = useGame();
  const [isExpanded, setIsExpanded] = useState(false);

  if (!me?.role) {
    return (
      <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg p-4 flex items-center justify-center">
        <div className="text-center">
          <div className="text-4xl mb-2">‚ùì</div>
          <p className="text-gray-400">Aguardando role...</p>
        </div>
      </div>
    );
  }

  const roleInfo = {
    name: me.role === 'SHERIFF' ? 'Sheriff' : me.role,
    icon: me.role === 'SHERIFF' ? 'üïµÔ∏è' : 'üßë',
    faction: me.faction === 'TOWN' ? 'Vila' : me.faction,
    factionColor: me.faction === 'TOWN' ? 'text-green-400' : 'text-red-400',
  };

  return (
    <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg flex flex-col">
      <div
        className="bg-green-900 border-b border-green-600 p-4 rounded-t-lg cursor-pointer"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="text-2xl">{roleInfo.icon}</div>
            <div>
              <h3 className="text-white font-bold">{roleInfo.name}</h3>
              <p className={`text-sm ${roleInfo.factionColor}`}>{roleInfo.faction}</p>
            </div>
          </div>
          <div className="text-white">{isExpanded ? 'üìñ' : 'üìö'}</div>
        </div>
      </div>

      {isExpanded && (
        <div className="flex-1 p-4 space-y-3">
          <div>
            <h4 className="text-white font-semibold mb-2">üéØ Objetivo</h4>
            <p className="text-green-400 text-sm">Encontrar e eliminar todos os Lobisomens</p>
          </div>
          <div>
            <h4 className="text-white font-semibold mb-2">‚ö° Habilidades</h4>
            <p className="text-white/80 text-sm">‚Ä¢ Investigar um jogador por noite</p>
          </div>
          <div>
            <h4 className="text-white font-semibold mb-2">üìä Status</h4>
            <div className="space-y-1 text-xs">
              <div className="flex justify-between">
                <span className="text-white/70">Vida:</span>
                <span className="text-green-400">Vivo</span>
              </div>
              <div className="flex justify-between">
                <span className="text-white/70">A√ß√£o:</span>
                <span className="text-amber-400">Dispon√≠vel</span>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

// Player Circle
const MockPlayerCircle = () => {
  const { gameState, me } = useGame();
  const alivePlayers = gameState.players.filter(p => p.isAlive && !p.isSpectator);
  const deadPlayers = gameState.players.filter(p => !p.isAlive);

  const getPlayerPosition = (index: number, totalPlayers: number) => {
    const angle = (index * 360) / totalPlayers - 90;
    const radiusX = 35;
    const radiusY = 30;

    const x = 50 + radiusX * Math.cos((angle * Math.PI) / 180);
    const y = 50 + radiusY * Math.sin((angle * Math.PI) / 180);

    return { x, y };
  };

  return (
    <div className="w-full h-full bg-gray-800/30 border border-gray-600 rounded-lg relative overflow-hidden">
      {/* Background */}
      <div className="absolute inset-0 bg-gradient-to-b from-amber-900/20 to-gray-900/50" />

      {/* Center - Gallows */}
      <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
        <div className="text-center">
          <div className="text-6xl mb-2 filter drop-shadow-lg">ü™ì</div>
          <div className="text-amber-400 text-xs font-semibold">FORCA</div>
        </div>
      </div>

      {/* Living Players */}
      {alivePlayers.map((player, index) => {
        const position = getPlayerPosition(index, alivePlayers.length);
        const isMe = me?.userId === player.userId;
        const votesReceived = Object.values(gameState.votes || {}).filter(targetId => targetId === player.id).length;

        return (
          <div
            key={player.id}
            className="absolute transform -translate-x-1/2 -translate-y-1/2 transition-all duration-300"
            style={{ left: `${position.x}%`, top: `${position.y}%` }}
          >
            <div className={`relative w-16 h-16 rounded-full border-2 transition-all duration-200 ${isMe ? 'border-blue-400 bg-blue-900/80 ring-2 ring-blue-400/50' : 'border-gray-600 bg-gray-700/80'
              }`}>
              <div className="w-full h-full rounded-full flex items-center justify-center text-2xl">
                {player.isHost ? 'üëë' : isMe ? 'üë§' : 'üßë'}
              </div>

              {/* Connection Status */}
              <div className={`absolute -top-1 -right-1 w-4 h-4 rounded-full border-2 border-gray-900 ${player.isConnected ? 'bg-green-400' : 'bg-red-400'
                }`} />

              {/* Vote Count */}
              {votesReceived > 0 && gameState.phase === 'VOTING' && (
                <div className="absolute -bottom-2 left-1/2 transform -translate-x-1/2 bg-red-600 text-white text-xs rounded-full px-2 py-1 font-bold">
                  {votesReceived}
                </div>
              )}
            </div>

            {/* Player Name */}
            <div className="absolute top-full left-1/2 transform -translate-x-1/2 mt-1 text-center min-w-[80px]">
              <div className={`text-xs font-semibold truncate px-2 py-1 rounded ${isMe ? 'text-blue-300 bg-blue-900/50' : 'text-white bg-gray-800/50'
                }`}>
                {player.username}
              </div>
            </div>
          </div>
        );
      })}

      {/* Dead Players */}
      {deadPlayers.length > 0 && (
        <div className="absolute bottom-4 left-4 right-4">
          <div className="text-center">
            <h4 className="text-red-400 text-sm font-semibold mb-2">üíÄ Cemit√©rio ({deadPlayers.length})</h4>
            <div className="flex justify-center gap-2">
              {deadPlayers.map((player) => (
                <div key={player.id} className="relative opacity-75">
                  <div className="w-8 h-8 rounded-full border border-gray-600 bg-gray-800/50 flex items-center justify-center">
                    <span className="text-lg">üëª</span>
                  </div>
                  <div className="absolute top-full left-1/2 transform -translate-x-1/2 mt-1 text-xs text-gray-400 text-center min-w-[40px]">
                    {player.username}
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

// Chat Gigante
const MockChatGigante = () => {
  const { gameState, me } = useGame();
  const { sendMessage } = useSocket();
  const [activeTab, setActiveTab] = useState<'public' | 'werewolf' | 'dead'>('public');
  const [message, setMessage] = useState('');

  const mockMessages = [
    { id: '1', userId: 'user2', username: 'Maria Santos', message: 'Acho que o Pedro est√° muito suspeito...', channel: 'public', timestamp: new Date().toISOString() },
    { id: '2', userId: 'user4', username: 'Ana Costa', message: 'Ele n√£o falou nada durante o dia todo!', channel: 'public', timestamp: new Date().toISOString() },
    { id: '3', userId: 'user1', username: 'Jo√£o Silva', message: 'Eu investiguei ele ontem e deu SUSPEITO!', channel: 'public', timestamp: new Date().toISOString() },
    { id: '4', userId: 'user3', username: 'Pedro Oliveira', message: 'Calma pessoal, eu sou apenas um alde√£o!', channel: 'public', timestamp: new Date().toISOString() },
  ];

  const tabs = [
    { id: 'public', name: 'P√∫blico', icon: 'üó£Ô∏è', available: true },
    { id: 'werewolf', name: 'Lobisomens', icon: 'üê∫', available: me?.role === 'WEREWOLF' },
    { id: 'dead', name: 'Mortos', icon: 'üëª', available: !me?.isAlive },
  ].filter(tab => tab.available);

  const handleSendMessage = () => {
    if (!message.trim()) return;
    sendMessage('chat-message', { message: message.trim(), channel: activeTab });
    setMessage('');
  };

  return (
    <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg flex flex-col">
      {/* Header */}
      <div className="flex-shrink-0 border-b border-gray-600 p-4">
        <h2 className="text-lg font-bold text-white mb-3">üí¨ Chat do Jogo</h2>

        {/* Tabs */}
        <div className="flex space-x-1">
          {tabs.map((tab) => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id as any)}
              className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${activeTab === tab.id
                ? 'bg-blue-600 text-white'
                : 'bg-gray-700/50 text-white/70 hover:bg-gray-700'
                }`}
            >
              <span className="flex items-center space-x-1">
                <span>{tab.icon}</span>
                <span>{tab.name}</span>
              </span>
            </button>
          ))}
        </div>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto bg-gray-900/20">
        {mockMessages.map((msg) => (
          <div key={msg.id} className={`p-2 border-b border-gray-600/30 ${msg.userId === 'user1' ? 'bg-blue-900/20' : ''}`}>
            <div className="flex items-start space-x-2">
              <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center">
                {msg.userId === 'user1' ? 'üë§' : 'üßë'}
              </div>
              <div className="flex-1 min-w-0">
                <div className="flex items-center space-x-2 mb-1">
                  <span className={`font-semibold text-sm ${msg.userId === 'user1' ? 'text-blue-300' : 'text-white'}`}>
                    {msg.username}
                  </span>
                  <span className="text-xs text-white/50">
                    {new Date(msg.timestamp).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
                  </span>
                </div>
                <div className="text-white/90 text-sm">{msg.message}</div>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Input */}
      <div className="flex-shrink-0 border-t border-gray-600 p-4">
        <div className="flex space-x-2">
          <input
            type="text"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
            placeholder="Digite sua mensagem..."
            className="flex-1 bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white placeholder-white/50 focus:outline-none focus:border-blue-400"
          />
          <button
            onClick={handleSendMessage}
            disabled={!message.trim()}
            className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white px-4 py-2 rounded-lg transition-colors"
          >
            Enviar
          </button>
        </div>
      </div>
    </div>
  );
};

// Action Panel
const MockActionPanel = () => {
  const { gameState, me } = useGame();
  const { sendMessage } = useSocket();
  const [selectedTarget, setSelectedTarget] = useState<string | null>(null);

  if (!me?.isAlive) {
    return (
      <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg p-4 flex items-center justify-center">
        <div className="text-center">
          <div className="text-4xl mb-2">üëª</div>
          <h3 className="text-lg font-semibold text-white mb-2">Voc√™ est√° morto</h3>
          <p className="text-white/70">Observe o jogo em sil√™ncio</p>
        </div>
      </div>
    );
  }

  if (gameState.phase === 'DAY') {
    return (
      <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg p-4 flex items-center justify-center">
        <div className="text-center">
          <div className="text-4xl mb-2">‚òÄÔ∏è</div>
          <h3 className="text-lg font-semibold text-white mb-2">Discuss√£o do Dia</h3>
          <p className="text-white/70">Use o chat para discutir!</p>
        </div>
      </div>
    );
  }

  const validTargets = gameState.players.filter(p => p.isAlive && p.id !== me.id);

  if (gameState.phase === 'NIGHT' && me.role === 'SHERIFF') {
    return (
      <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg flex flex-col">
        <div className="flex-shrink-0 border-b border-gray-600 p-4">
          <h3 className="text-lg font-bold text-white mb-2">üîç Investiga√ß√£o</h3>
          <p className="text-white/70 text-sm">Escolha quem investigar</p>
        </div>

        <div className="flex-1 overflow-y-auto p-4">
          <div className="space-y-2">
            {validTargets.map((player) => (
              <button
                key={player.id}
                onClick={() => setSelectedTarget(player.id)}
                className={`w-full p-3 rounded-lg border-2 transition-all text-left ${selectedTarget === player.id
                  ? 'border-blue-400 bg-blue-900/30'
                  : 'border-gray-600 bg-gray-700/30 hover:border-blue-400/50'
                  }`}
              >
                <div className="flex items-center space-x-3">
                  <div className="w-8 h-8 rounded-full bg-gray-600 flex items-center justify-center">
                    {player.isHost ? 'üëë' : 'üßë'}
                  </div>
                  <div className="flex-1">
                    <div className="text-white font-medium">{player.username}</div>
                    <div className="text-white/50 text-sm">
                      {player.isConnected ? 'Conectado' : 'Desconectado'}
                    </div>
                  </div>
                </div>
              </button>
            ))}
          </div>
        </div>

        <div className="flex-shrink-0 border-t border-gray-600 p-4">
          <button
            onClick={() => {
              if (selectedTarget) {
                sendMessage('game-action', { type: 'INVESTIGATE', targetId: selectedTarget });
                setSelectedTarget(null);
              }
            }}
            disabled={!selectedTarget}
            className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white font-bold py-3 rounded-lg transition-colors"
          >
            {selectedTarget ? 'Investigar' : 'Selecione um alvo'}
          </button>
        </div>
      </div>
    );
  }

  if (gameState.phase === 'VOTING') {
    return (
      <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg flex flex-col">
        <div className="flex-shrink-0 border-b border-gray-600 p-4">
          <h3 className="text-lg font-bold text-white mb-2">üó≥Ô∏è Vota√ß√£o</h3>
          <p className="text-white/70 text-sm">Escolha quem executar</p>
        </div>

        <div className="flex-1 overflow-y-auto p-4">
          <div className="space-y-2">
            {validTargets.map((player) => {
              const votes = Object.values(gameState.votes || {}).filter(v => v === player.id).length;
              return (
                <button
                  key={player.id}
                  onClick={() => sendMessage('vote', { targetId: player.id })}
                  className="w-full p-3 rounded-lg border-2 border-gray-600 bg-gray-700/30 hover:border-red-400/50 transition-all text-left"
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                      <div className="w-8 h-8 rounded-full bg-gray-600 flex items-center justify-center">
                        {player.isHost ? 'üëë' : 'üßë'}
                      </div>
                      <div>
                        <div className="text-white font-medium">{player.username}</div>
                        <div className="text-white/50 text-sm">Clique para votar</div>
                      </div>
                    </div>
                    {votes > 0 && (
                      <div className="bg-red-600 text-white text-sm px-2 py-1 rounded-full font-bold">
                        {votes}
                      </div>
                    )}
                  </div>
                </button>
              );
            })}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg p-4 flex items-center justify-center">
      <div className="text-center">
        <div className="text-4xl mb-2">üò¥</div>
        <h3 className="text-lg font-semibold text-white mb-2">Sem A√ß√µes</h3>
        <p className="text-white/70">Aguardando sua vez...</p>
      </div>
    </div>
  );
};

// Will Notes
const MockWillNotes = () => {
  const [activeTab, setActiveTab] = useState<'will' | 'notes'>('will');
  const [will, setWill] = useState('Meu nome √© Jo√£o Silva e eu sou Sheriff.\nN1: Investiguei Pedro - SUSPEITO\nD1: Pedro est√° mentindo, vote nele!\nSe eu morrer, suspeitem de Pedro e Maria.');
  const [notes, setNotes] = useState('üîç INVESTIGA√á√ïES:\n- Pedro: SUSPEITO (N1)\n- Maria: Pendente (N2)\n\n‚ö° SUSPEITOS:\n- Pedro (resultado + comportamento)\n- Julia (muito quieta)\n\n‚úÖ CONFIRMADOS:\n- Ana (defende vila)\n- Carlos (ativo nas discuss√µes)');

  return (
    <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg flex flex-col">
      {/* Header */}
      <div className="flex-shrink-0 border-b border-gray-600 p-4">
        <h3 className="text-lg font-bold text-white mb-3">üìú Anota√ß√µes</h3>

        {/* Tabs */}
        <div className="flex space-x-1">
          <button
            onClick={() => setActiveTab('will')}
            className={`px-3 py-2 rounded-lg text-sm font-medium transition-all ${activeTab === 'will' ? 'bg-amber-600 text-white' : 'bg-gray-700/50 text-white/70'
              }`}
          >
            üìú Testamento
          </button>
          <button
            onClick={() => setActiveTab('notes')}
            className={`px-3 py-2 rounded-lg text-sm font-medium transition-all ${activeTab === 'notes' ? 'bg-blue-600 text-white' : 'bg-gray-700/50 text-white/70'
              }`}
          >
            üìù Notas
          </button>
        </div>
      </div>

      {/* Content */}
      <div className="flex-1 p-4">
        <textarea
          value={activeTab === 'will' ? will : notes}
          onChange={(e) => activeTab === 'will' ? setWill(e.target.value) : setNotes(e.target.value)}
          placeholder={activeTab === 'will' ? 'Seu testamento ser√° revelado se voc√™ morrer...' : 'Suas anota√ß√µes pessoais...'}
          className="w-full h-full bg-gray-900/50 border border-gray-600 rounded-lg p-3 text-white placeholder-white/30 text-sm resize-none focus:outline-none focus:border-amber-400 font-mono"
        />
      </div>

      {/* Footer */}
      <div className="flex-shrink-0 border-t border-gray-600 p-3">
        <div className="text-xs text-white/50">
          {activeTab === 'will' ? (
            <div>üí° Dica: Seu testamento ser√° revelado quando voc√™ morrer</div>
          ) : (
            <div>üí° Dica: Use as notas para rastrear suas investiga√ß√µes</div>
          )}
        </div>
      </div>
    </div>
  );
};

// Player List
const MockPlayerList = () => {
  const { gameState, me } = useGame();
  const alivePlayers = gameState.players.filter(p => p.isAlive && !p.isSpectator);
  const deadPlayers = gameState.players.filter(p => !p.isAlive);

  const PlayerRow = ({ player, isDead = false }: { player: Player; isDead?: boolean }) => {
    const isMe = me?.userId === player.userId;
    const votesReceived = Object.values(gameState.votes || {}).filter(v => v === player.id).length;

    return (
      <div className={`flex items-center space-x-2 p-2 rounded-lg transition-all ${isMe ? 'bg-blue-900/50 border border-blue-600' : isDead ? 'bg-gray-800/30 opacity-75' : 'bg-gray-700/30'
        }`}>
        {/* Status */}
        <div className="flex flex-col items-center space-y-1">
          <div className={`w-2 h-2 rounded-full ${player.isConnected ? 'bg-green-400' : 'bg-red-400'}`} />
          {votesReceived > 0 && (
            <div className="bg-red-600 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">
              {votesReceived}
            </div>
          )}
        </div>

        {/* Avatar */}
        <div className={`w-8 h-8 rounded-full flex items-center justify-center ${isDead ? 'bg-gray-700' : isMe ? 'bg-blue-800' : 'bg-gray-600'
          }`}>
          {isDead ? 'üíÄ' : player.isHost ? 'üëë' : isMe ? 'üë§' : 'üßë'}
        </div>

        {/* Info */}
        <div className="flex-1 min-w-0">
          <div className={`text-sm font-medium truncate ${isDead ? 'text-gray-400' : isMe ? 'text-blue-300' : 'text-white'
            }`}>
            {player.username}
          </div>
          <div className="flex flex-wrap gap-1 mt-1">
            {isMe && <span className="bg-blue-600 text-white text-xs px-1 rounded">Voc√™</span>}
            {player.isHost && <span className="bg-amber-600 text-white text-xs px-1 rounded">Host</span>}
            {isDead && player.role && <span className="bg-purple-600 text-white text-xs px-1 rounded">{player.role}</span>}
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="h-full bg-gray-800/30 border border-gray-600 rounded-lg flex flex-col">
      {/* Header */}
      <div className="flex-shrink-0 border-b border-gray-600 p-4">
        <h3 className="text-lg font-bold text-white mb-2">üë• Jogadores</h3>
        <div className="flex items-center space-x-4 text-xs">
          <div className="flex items-center space-x-1">
            <div className="w-2 h-2 bg-green-500 rounded-full"></div>
            <span className="text-green-400">Vivos: {alivePlayers.length}</span>
          </div>
          <div className="flex items-center space-x-1">
            <div className="w-2 h-2 bg-red-500 rounded-full"></div>
            <span className="text-red-400">Mortos: {deadPlayers.length}</span>
          </div>
        </div>
      </div>

      {/* Players */}
      <div className="flex-1 overflow-y-auto p-4 space-y-2">
        {/* Living Players */}
        <div>
          <h4 className="text-sm font-semibold text-green-400 mb-2">üíö Vivos ({alivePlayers.length})</h4>
          <div className="space-y-1">
            {alivePlayers.map((player) => (
              <PlayerRow key={player.id} player={player} />
            ))}
          </div>
        </div>

        {/* Dead Players */}
        {deadPlayers.length > 0 && (
          <div>
            <h4 className="text-sm font-semibold text-red-400 mb-2">üíÄ Mortos ({deadPlayers.length})</h4>
            <div className="space-y-1">
              {deadPlayers.map((player) => (
                <PlayerRow key={player.id} player={player} isDead={true} />
              ))}
            </div>
          </div>
        )}
      </div>

      {/* Vote Summary */}
      {gameState.phase === 'VOTING' && Object.keys(gameState.votes || {}).length > 0 && (
        <div className="flex-shrink-0 border-t border-gray-600 p-4">
          <h4 className="text-sm font-semibold text-white mb-2">üó≥Ô∏è Resumo dos Votos</h4>
          <div className="space-y-1">
            {Object.entries(
              Object.values(gameState.votes || {}).reduce((acc, targetId) => {
                acc[targetId] = (acc[targetId] || 0) + 1;
                return acc;
              }, {} as Record<string, number>)
            ).map(([playerId, count]) => {
              const player = alivePlayers.find(p => p.id === playerId);
              return player ? (
                <div key={playerId} className="flex justify-between text-sm">
                  <span className="text-white">{player.username}</span>
                  <span className="bg-red-700 text-white px-2 py-1 rounded text-xs">{count}</span>
                </div>
              ) : null;
            })}
          </div>
        </div>
      )}
    </div>
  );
};

// Main Game Board
const MockGameBoard = ({ gameState }: { gameState: GameState }) => {
  return (
    <div className="h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-black">
      {/* Header */}
      <header className="h-16 bg-gray-800/50 border-b border-gray-600 flex items-center justify-between px-4">
        <MockPhaseIndicator phase={gameState.phase} day={gameState.day} />

        <div className="flex items-center space-x-2">
          <span className="text-2xl">üê∫</span>
          <h1 className="text-xl font-bold text-white">Lobisomem Online - MOCK</h1>
        </div>

        <MockTimerDisplay timeLeft={Math.floor(gameState.timeLeft / 1000)} />
      </header>

      {/* Main Grid - 6 Sections */}
      <main className="h-[calc(100vh-4rem)] grid grid-cols-12 grid-rows-2 gap-4 p-4">
        {/* Left Top - Role Card */}
        <section className="col-span-3 row-span-1">
          <MockRoleCard />
        </section>

        {/* Center Top - Player Circle */}
        <section className="col-span-6 row-span-1">
          <MockPlayerCircle />
        </section>

        {/* Right Full - Chat Gigante */}
        <section className="col-span-3 row-span-2">
          <MockChatGigante />
        </section>

        {/* Left Bottom - Player List */}
        <section className="col-span-3 row-span-1">
          <MockPlayerList />
        </section>

        {/* Center Bottom - Action Panel & Will Notes */}
        <section className="col-span-6 row-span-1 grid grid-cols-2 gap-4">
          <MockActionPanel />
          <MockWillNotes />
        </section>
      </main>
    </div>
  );
};

// =============================================================================
// MAIN MOCK COMPONENT
// =============================================================================
export default function NewGameMock() {
  const [currentPhase, setCurrentPhase] = useState<GamePhase>('DAY');
  const [currentDay, setCurrentDay] = useState(2);
  const [timeLeft, setTimeLeft] = useState(120);
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  // Simulate phase changes
  useEffect(() => {
    const phaseInterval = setInterval(() => {
      setCurrentPhase(prev => {
        const phases: GamePhase[] = ['DAY', 'VOTING', 'NIGHT'];
        const currentIndex = phases.indexOf(prev);
        const nextIndex = (currentIndex + 1) % phases.length;

        if (phases[nextIndex] === 'DAY') {
          setCurrentDay(d => d + 1);
        }

        setTimeLeft(120);
        return phases[nextIndex];
      });
    }, 30000); // 30 seconds per phase

    return () => clearInterval(phaseInterval);
  }, []);

  // Timer countdown
  useEffect(() => {
    const timer = setInterval(() => {
      setTimeLeft(prev => Math.max(0, prev - 1));
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  if (!isClient) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-white">Carregando mock...</div>
      </div>
    );
  }

  const gameState = createMockGameState(currentPhase, currentDay);
  gameState.timeLeft = timeLeft * 1000; // Convert to milliseconds

  return (
    <MockSocketProvider>
      <MockGameProvider gameState={gameState}>
        <div className="relative">
          {/* Mock Warning Banner */}
          <div className="absolute top-0 left-0 right-0 bg-yellow-900 border-b border-yellow-700 px-4 py-2 z-50">
            <div className="max-w-7xl mx-auto text-center">
              <div className="text-yellow-100 text-sm">
                <strong>üß™ MODO TESTE:</strong> Interface Town of Salem com dados simulados.
                Fases mudam a cada 30s: {currentPhase} (Dia {currentDay}) ‚Ä¢
                Voc√™ √© <strong>Jo√£o Silva (Sheriff)</strong> ‚Ä¢
                <button
                  onClick={() => window.location.href = '/lobby'}
                  className="ml-2 underline hover:text-yellow-200"
                >
                  ‚Üê Voltar ao Lobby
                </button>
              </div>
            </div>
          </div>

          {/* Game Board */}
          <div className="pt-12">
            <MockGameBoard gameState={gameState} />
          </div>
        </div>
      </MockGameProvider>
    </MockSocketProvider>
  );
}
</file>

<file path="backend/src/config/database.ts">
import { Pool } from 'pg';
import { config } from './environment';

const logger = {
  info: (message: string, data?: any) => console.log(`[INFO] ${message}`, data || ''),
  error: (message: string, error?: any) => console.error(`[ERROR] ${message}`, error || ''),
};

export const pool = new Pool({
  connectionString: config.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 5000,
});

pool.on('error', (err) => {
  logger.error('Unexpected error on idle client', err);
  process.exit(-1);
});

export async function connectDatabase(): Promise<void> {
  try {
    const client = await pool.connect();
    logger.info('PostgreSQL connected successfully');

    const result = await client.query('SELECT NOW() as connected_at');
    logger.info('Database health check:', result.rows[0]);

    client.release();
  } catch (error) {
    logger.error('Failed to connect to PostgreSQL', error);
    throw error;
  }
}

export async function disconnectDatabase(): Promise<void> {
  try {
    await pool.end();
    logger.info('PostgreSQL connections closed');
  } catch (error) {
    logger.error('Error disconnecting from PostgreSQL', error);
  }
}

export async function checkDatabaseHealth(): Promise<{
  status: 'healthy' | 'unhealthy';
  message: string;
  timestamp: string;
}> {
  try {
    await pool.query('SELECT 1');
    return {
      status: 'healthy',
      message: 'PostgreSQL is responding',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      message: error instanceof Error ? error.message : 'Unknown database error',
      timestamp: new Date().toISOString(),
    };
  }
}

export async function gracefulShutdown(): Promise<void> {
  logger.info('Shutting down database connections...');
  await disconnectDatabase();
}
</file>

<file path="backend/src/config/environment.ts">
// üê∫ LOBISOMEM ONLINE - Environment Configuration
// ‚ö†Ô∏è CR√çTICO: Configuration-driven para migra√ß√£o autom√°tica Fase 1 ‚Üí Fase 2

import { z } from 'zod';
import dotenv from 'dotenv';

dotenv.config();

// =============================================================================
// VALIDATION SCHEMA
// =============================================================================

export interface AppConfig {
  NODE_ENV: string;
  PORT: number;
  IS_PRODUCTION: boolean;
  IS_DEVELOPMENT: boolean;
  DATABASE_URL: string;
  REDIS_URL: string;
  JWT_SECRET: string;
  JWT_EXPIRES_IN: string;
  DISTRIBUTED_MODE: boolean;
  STORAGE_TYPE: string;
  SERVICE_ID: string;
  SERVICE_TYPE: string;
  WS_BASE_PATH: string;
  WS_PORT: number;
  SHOULD_USE_REDIS: boolean;
  IS_GAME_SERVICE: boolean;
  IS_LOBBY_SERVICE: boolean;
  IS_MONOLITH: boolean;
}

const envSchema = z.object({
  // Core settings
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  PORT: z.coerce.number().default(3001),

  // Database
  DATABASE_URL: z.string().min(1, 'DATABASE_URL is required'),
  REDIS_URL: z.string().default('redis://localhost:6379'),

  // Authentication
  JWT_SECRET: z.string().min(1, 'JWT_SECRET is required'),
  JWT_EXPIRES_IN: z.string().default('7d'),
  // Architecture mode (CR√çTICO para migra√ß√£o)
  
  DISTRIBUTED_MODE: z.coerce.boolean().default(false),
  STORAGE_TYPE: z.enum(['memory', 'redis']).default('memory'),

  // Service discovery (Fase 2)
  SERVICE_ID: z.string().default('local-server'),
  SERVICE_TYPE: z.enum(['monolith', 'lobby', 'game']).default('monolith'),

  // WebSocket routing (Fase 2)
  WS_BASE_PATH: z.string().default('/ws'),
  WS_PORT: z.coerce.number().default(3001),

  // Game settings
  MIN_PLAYERS: z.coerce.number().default(6),
  MAX_PLAYERS: z.coerce.number().default(15),
  MAX_SPECTATORS: z.coerce.number().default(5),
  NIGHT_DURATION: z.coerce.number().default(60000),
  DAY_DURATION: z.coerce.number().default(120000),
  VOTING_DURATION: z.coerce.number().default(30000),

  // Email (opcional)
  SMTP_HOST: z.string().optional(),
  SMTP_PORT: z.coerce.number().optional(),
  SMTP_USER: z.string().optional(),
  SMTP_PASS: z.string().optional(),
});

// =============================================================================
// VALIDATE AND EXPORT CONFIG
// =============================================================================
const envVars = envSchema.parse(process.env);

export const config = {
  // Core settings
  NODE_ENV: envVars.NODE_ENV,
  PORT: envVars.PORT,
  IS_PRODUCTION: envVars.NODE_ENV === 'production',
  IS_DEVELOPMENT: envVars.NODE_ENV === 'development',

  // Database
  DATABASE_URL: envVars.DATABASE_URL,
  REDIS_URL: envVars.REDIS_URL,

  // Authentication
  JWT_SECRET: envVars.JWT_SECRET,
  JWT_EXPIRES_IN: envVars.JWT_EXPIRES_IN,

  // Architecture mode (CR√çTICO)
  DISTRIBUTED_MODE: envVars.DISTRIBUTED_MODE,
  STORAGE_TYPE: envVars.STORAGE_TYPE,

  // Service discovery (Fase 2)
  SERVICE_ID: envVars.SERVICE_ID,
  SERVICE_TYPE: envVars.SERVICE_TYPE,

  // WebSocket routing (Fase 2)
  WS_BASE_PATH: envVars.WS_BASE_PATH,
  WS_PORT: envVars.WS_PORT,

  // Game settings
  GAME: {
    MIN_PLAYERS: envVars.MIN_PLAYERS,
    MAX_PLAYERS: envVars.MAX_PLAYERS,
    MAX_SPECTATORS: envVars.MAX_SPECTATORS,
    NIGHT_DURATION: envVars.NIGHT_DURATION,
    DAY_DURATION: envVars.DAY_DURATION,
    VOTING_DURATION: envVars.VOTING_DURATION,
  },

  // Email
  EMAIL: {
    SMTP_HOST: envVars.SMTP_HOST,
    SMTP_PORT: envVars.SMTP_PORT,
    SMTP_USER: envVars.SMTP_USER,
    SMTP_PASS: envVars.SMTP_PASS,
    ENABLED: !!(envVars.SMTP_HOST && envVars.SMTP_USER && envVars.SMTP_PASS),
  },

  // Derived flags
  SHOULD_USE_REDIS: envVars.DISTRIBUTED_MODE || envVars.STORAGE_TYPE === 'redis',
  IS_GAME_SERVICE: envVars.SERVICE_TYPE === 'game',
  IS_LOBBY_SERVICE: envVars.SERVICE_TYPE === 'lobby',
  IS_MONOLITH: envVars.SERVICE_TYPE === 'monolith',
} as const;

// =============================================================================
// TYPE DEFINITIONS
// =============================================================================
export type Config = typeof config;
export type StorageType = 'memory' | 'redis';
export type ServiceType = 'monolith' | 'lobby' | 'game';

// =============================================================================
// VALIDATION HELPERS
// =============================================================================
export function validateConfig(): void {
  console.log('üîß Configuration loaded:');
  console.log(`   Mode: ${config.NODE_ENV}`);
  console.log(`   Architecture: ${config.DISTRIBUTED_MODE ? 'Distributed' : 'Monolithic'}`);
  console.log(`   Service Type: ${config.SERVICE_TYPE}`);
  console.log(`   Storage: ${config.STORAGE_TYPE}`);
  console.log(`   Port: ${config.PORT}`);

  if (config.IS_PRODUCTION && config.JWT_SECRET === 'your-super-secret-jwt-key-change-in-production') {
    throw new Error('‚ùå JWT_SECRET must be changed in production!');
  }

  if (config.DISTRIBUTED_MODE && !config.SHOULD_USE_REDIS) {
    throw new Error('‚ùå DISTRIBUTED_MODE requires Redis storage!');
  }
}
</file>

<file path="backend/src/config/jwt.ts">
// üê∫ LOBISOMEM ONLINE - JWT Configuration (ABORDAGEM DIRETA)
import jwt from 'jsonwebtoken';
import { config } from './environment';
import type { IncomingMessage } from 'http';
import type { JWTPayload, TokenPair } from '@/types';

export function generateAccessToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');

  // FOR√áA BRUTA: Usar any para quebrar o TypeScript
  const jwtSign = (jwt.sign as any);
  return jwtSign(payload, config.JWT_SECRET, { expiresIn: config.JWT_EXPIRES_IN });
}

export function generateRefreshToken(userId: string): string {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  const jwtSign = (jwt.sign as any);
  return jwtSign({ userId, type: 'refresh' }, config.JWT_SECRET, { expiresIn: '30d' });
}

export function generatePasswordResetToken(userId: string, email: string): string {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  const jwtSign = (jwt.sign as any);
  return jwtSign({ userId, email, type: 'password_reset' }, config.JWT_SECRET, { expiresIn: '1h' });
}

export function generateTokenPair(payload: Omit<JWTPayload, 'iat' | 'exp'>): TokenPair {
  return {
    accessToken: generateAccessToken(payload),
    refreshToken: generateRefreshToken(payload.userId),
  };
}

export function verifyAccessToken(token: string): JWTPayload {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  try {
    return jwt.verify(token, config.JWT_SECRET) as JWTPayload;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) throw new Error('Token expired');
    if (error instanceof jwt.JsonWebTokenError) throw new Error('Invalid token');
    throw new Error('Token verification failed');
  }
}

export function verifyPasswordResetToken(token: string): { userId: string; email: string; type: string } {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET) as any;
    if (decoded.type !== 'password_reset') throw new Error('Invalid token type');
    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) throw new Error('Reset token expired');
    if (error instanceof jwt.JsonWebTokenError) throw new Error('Invalid reset token');
    throw new Error('Reset token verification failed');
  }
}

export function extractTokenFromHeader(authorization?: string): string | null {
  if (!authorization) return null;
  const parts = authorization.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') return null;
  return parts[1] || null;
}

export function extractTokenFromCookie(cookieHeader?: string): string | null {
  if (!cookieHeader) return null;
  const cookies = cookieHeader.split(';').map(cookie => cookie.trim());
  const tokenCookie = cookies.find(cookie => cookie.startsWith('access_token='));
  if (!tokenCookie) return null;
  const tokenValue = tokenCookie.split('=')[1];
  return tokenValue || null;
}

export function extractTokenFromWebSocketRequest(request: IncomingMessage): string | null {
  const authHeader = request.headers.authorization;
  if (typeof authHeader === 'string') {
    const token = extractTokenFromHeader(authHeader);
    if (token) return token;
  }

  const cookieHeader = request.headers.cookie;
  if (typeof cookieHeader === 'string') {
    const token = extractTokenFromCookie(cookieHeader);
    if (token) return token;
  }

  if (request.url) {
    try {
      const url = new URL(request.url, 'http://localhost');
      return url.searchParams.get('token');
    } catch (e) {
      // Ignorar URL inv√°lida
    }
  }

  return null;
}
</file>

<file path="backend/src/config/redis.ts">
// üê∫ LOBISOMEM ONLINE - Redis Configuration (CORRIGIDO)
import Redis from 'ioredis';
import { config } from './environment';

// =============================================================================
// REDIS CLIENT SINGLETON
// =============================================================================
let redisClient: Redis | null = null;
let redisSubscriber: Redis | null = null;
let redisPublisher: Redis | null = null;
let isConnecting = false;

// =============================================================================
// REDIS CLIENT FACTORY
// =============================================================================
export function createRedisClient(): Redis {
  return new Redis(config.REDIS_URL);
}

// =============================================================================
// MAIN REDIS CLIENT
// =============================================================================
export function getRedisClient(): Redis {
  if (!redisClient) {
    if (!config.SHOULD_USE_REDIS) {
      throw new Error('‚ùå Redis is not enabled in current configuration');
    }

    redisClient = createRedisClient();

    redisClient.on('connect', () => {
      console.log('üîó Redis client connecting...');
    });

    redisClient.on('ready', () => {
      console.log('‚úÖ Redis client ready');
    });

    redisClient.on('error', (error) => {
      console.error('‚ùå Redis client error:', error);
    });

    redisClient.on('close', () => {
      console.log('üîå Redis client disconnected');
    });
  }

  return redisClient;
}

// =============================================================================
// PUB/SUB CLIENTS (PHASE 2)
// =============================================================================
export function getRedisSubscriber(): Redis {
  if (!redisSubscriber) {
    if (!config.SHOULD_USE_REDIS) {
      throw new Error('‚ùå Redis Pub/Sub is not enabled in current configuration');
    }

    redisSubscriber = createRedisClient();

    redisSubscriber.on('connect', () => {
      console.log('üîó Redis subscriber connecting...');
    });

    redisSubscriber.on('ready', () => {
      console.log('‚úÖ Redis subscriber ready');
    });

    redisSubscriber.on('error', (error) => {
      console.error('‚ùå Redis subscriber error:', error);
    });
  }

  return redisSubscriber;
}

export function getRedisPublisher(): Redis {
  if (!redisPublisher) {
    if (!config.SHOULD_USE_REDIS) {
      throw new Error('‚ùå Redis Pub/Sub is not enabled in current configuration');
    }

    redisPublisher = createRedisClient();

    redisPublisher.on('connect', () => {
      console.log('üîó Redis publisher connecting...');
    });

    redisPublisher.on('ready', () => {
      console.log('‚úÖ Redis publisher ready');
    });

    redisPublisher.on('error', (error) => {
      console.error('‚ùå Redis publisher error:', error);
    });
  }

  return redisPublisher;
}

// =============================================================================
// CONNECTION MANAGEMENT
// =============================================================================
export async function connectRedis(): Promise<void> {
  if (!config.SHOULD_USE_REDIS) {
    console.log('‚è≠Ô∏è  Redis disabled in current configuration');
    return;
  }

  if (isConnecting) {
    console.log('‚è≠Ô∏è  Redis connection already in progress');
    return;
  }

  if (redisClient && redisClient.status === 'ready') {
    console.log('‚è≠Ô∏è  Redis already connected');
    return;
  }

  try {
    isConnecting = true;
    const client = getRedisClient();

    // Aguardar conex√£o estar ready
    if (client.status !== 'ready') {
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Redis connection timeout'));
        }, 10000);

        client.once('ready', () => {
          clearTimeout(timeout);
          resolve(void 0);
        });

        client.once('error', (error) => {
          clearTimeout(timeout);
          reject(error);
        });
      });
    }

    // Test connection
    const pong = await client.ping();
    if (pong === 'PONG') {
      console.log('‚úÖ Redis connected successfully');
    }
  } catch (error) {
    console.error('‚ùå Failed to connect to Redis:', error);
    // N√ÉO fazer throw - deixar continuar sem Redis
    console.log('‚è≠Ô∏è  Continuing without Redis...');
  } finally {
    isConnecting = false;
  }
}

export async function disconnectRedis(): Promise<void> {
  try {
    if (redisClient) {
      redisClient.disconnect();
    }
    if (redisSubscriber) {
      redisSubscriber.disconnect();
    }
    if (redisPublisher) {
      redisPublisher.disconnect();
    }
    console.log('üëã Redis clients disconnected');
  } catch (error) {
    console.error('‚ùå Error disconnecting Redis clients:', error);
  }

  redisClient = null;
  redisSubscriber = null;
  redisPublisher = null;
  isConnecting = false;
}

// =============================================================================
// HEALTH CHECK
// =============================================================================
export async function checkRedisHealth(): Promise<{
  status: 'healthy' | 'unhealthy';
  message: string;
  timestamp: string;
}> {
  if (!config.SHOULD_USE_REDIS) {
    return {
      status: 'healthy',
      message: 'Redis disabled in configuration',
      timestamp: new Date().toISOString(),
    };
  }

  try {
    if (!redisClient || redisClient.status !== 'ready') {
      return {
        status: 'unhealthy',
        message: 'Redis not connected',
        timestamp: new Date().toISOString(),
      };
    }

    const pong = await redisClient.ping();

    return {
      status: pong === 'PONG' ? 'healthy' : 'unhealthy',
      message: pong === 'PONG' ? 'Redis is responding' : 'Redis ping failed',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      message: error instanceof Error ? error.message : 'Unknown Redis error',
      timestamp: new Date().toISOString(),
    };
  }
}

// =============================================================================
// GRACEFUL SHUTDOWN
// =============================================================================
export async function gracefulShutdown(): Promise<void> {
  console.log('üõë Shutting down Redis connections...');
  await disconnectRedis();
}
</file>

<file path="backend/src/config/websocket.ts">
// üê∫ LOBISOMEM ONLINE - WebSocket Configuration (ABORDAGEM DIRETA)
import { config } from './environment';
import type { IncomingMessage } from 'http';
import type { URLParseResult, ConnectionMetadata, MessageValidationResult, WebSocketMessage } from '@/types';

export const wsConfig = {
  path: config.WS_BASE_PATH,
  server: {
    maxPayload: 1024 * 1024, // 1MB
  },
  heartbeat: {
    interval: 30000,
    timeout: 5000,
  },
} as const;

export function parseWebSocketURL(url: string | undefined): URLParseResult {
  if (!url) {
    return { isValid: false, path: '' };
  }

  try {
    const urlObj = new URL(url, 'ws://localhost');
    const pathParts = urlObj.pathname.split('/').filter(Boolean);

    const result: URLParseResult = {
      isValid: true,
      path: urlObj.pathname
    };

    // S√≥ adicionar roomId se realmente existir
    if (pathParts.length > 1 && pathParts[0] === 'ws' && pathParts[1]) {
      result.roomId = pathParts[1];
    }

    return result;
  } catch {
    return { isValid: false, path: url };
  }
}

export function extractConnectionMetadata(request: IncomingMessage): ConnectionMetadata {
  const forwarded = request.headers['x-forwarded-for'];
  const realIp = request.headers['x-real-ip'];
  const remoteAddr = request.socket.remoteAddress;

  // L√≥gica para IP
  let ip: string | undefined;
  if (typeof forwarded === 'string') {
    const firstIp = forwarded.split(',')[0];
    ip = firstIp ? firstIp.trim() : undefined;
  } else if (typeof realIp === 'string') {
    ip = realIp;
  } else if (remoteAddr) {
    ip = remoteAddr;
  }

  // FOR√áA BRUTA: Construir como any e depois fazer cast
  const metadata: any = {
    connectedAt: new Date()
  };

  // Adicionar propriedades sem verifica√ß√£o de tipos
  const userAgent = request.headers['user-agent'];
  if (userAgent) {
    metadata.userAgent = Array.isArray(userAgent) ? userAgent[0] : userAgent;
  }

  if (ip) {
    metadata.ip = ip;
  }

  const origin = request.headers.origin;
  if (typeof origin === 'string') {
    metadata.origin = origin;
  }

  // Cast final para o tipo correto
  return metadata as ConnectionMetadata;
}

export function validateWebSocketMessage(data: any): MessageValidationResult {
  try {
    const parsed = (typeof data === 'string') ? JSON.parse(data) : data;

    if (!parsed || typeof parsed !== 'object' || !parsed.type || typeof parsed.type !== 'string') {
      return { isValid: false, error: 'Mensagem inv√°lida ou sem tipo' };
    }

    // FOR√áA BRUTA: Construir como any
    const message: any = {
      type: parsed.type,
      timestamp: parsed.timestamp || new Date().toISOString(),
    };

    // Adicionar propriedades condicionalmente
    if (parsed.data !== undefined) {
      message.data = parsed.data;
    }

    if (parsed.messageId && typeof parsed.messageId === 'string') {
      message.messageId = parsed.messageId;
    }

    return { isValid: true, message: message as WebSocketMessage };
  } catch (error) {
    return { isValid: false, error: 'Formato JSON inv√°lido' };
  }
}
</file>

<file path="backend/src/database/seeds/index.ts">
// üê∫ LOBISOMEM ONLINE - Database Seeds (com node-postgres)
// Create initial test data for development

import { pool } from '../database';
import bcrypt from 'bcryptjs';

// Logger simples caso n√£o tenha o logger configurado
const logger = {
  info: (message: string) => console.log(`[INFO] ${message}`),
  warn: (message: string) => console.warn(`[WARN] ${message}`),
  error: (message: string, error?: Error) => {
    console.error(`[ERROR] ${message}`);
    if (error) console.error(error);
  }
};

//======================================================================
// SEED USERS
//======================================================================

async function seedUsers() {
  logger.info('Seeding users...');

  const testUsers = [
    {
      email: 'admin@werewolf.com',
      username: 'AdminMaster',
      password: 'admin123',
      level: 10,
      totalGames: 50,
      totalWins: 35,
      totalLosses: 15,
    },
    {
      email: 'player1@test.com',
      username: 'LobisomemHunter',
      password: 'player123',
      level: 5,
      totalGames: 25,
      totalWins: 15,
      totalLosses: 10,
    },
    {
      email: 'player2@test.com',
      username: 'VillagerPro',
      password: 'player123',
      level: 3,
      totalGames: 15,
      totalWins: 8,
      totalLosses: 7,
    },
    {
      email: 'player3@test.com',
      username: 'SheriffExpert',
      password: 'player123',
      level: 7,
      totalGames: 35,
      totalWins: 22,
      totalLosses: 13,
    },
    {
      email: 'player4@test.com',
      username: 'DoctorHealer',
      password: 'player123',
      level: 4,
      totalGames: 20,
      totalWins: 12,
      totalLosses: 8,
    },
    {
      email: 'player5@test.com',
      username: 'AlphaWolf',
      password: 'player123',
      level: 6,
      totalGames: 30,
      totalWins: 18,
      totalLosses: 12,
    },
    {
      email: 'newbie@test.com',
      username: 'Newbie2025',
      password: 'newbie123',
      level: 1,
      totalGames: 0,
      totalWins: 0,
      totalLosses: 0,
    },
  ];

  for (const userData of testUsers) {
    try {
      // Check if user already exists
      const checkUserQuery = `
                SELECT id FROM users 
                WHERE email = $1 OR username = $2
            `;
      const existingUser = await pool.query(checkUserQuery, [userData.email, userData.username]);

      if (existingUser.rows.length > 0) {
        logger.info(`User ${userData.username} already exists, skipping...`);
        continue;
      }

      // Calculate win rate
      const winRate = userData.totalGames > 0
        ? Number((userData.totalWins / userData.totalGames).toFixed(4))
        : 0;

      // Hash password
      const passwordHash = await bcrypt.hash(userData.password, 12);

      // Create user with SQL
      const insertUserQuery = `
                INSERT INTO users (
                    email, 
                    username, 
                    "passwordHash", 
                    level, 
                    "totalGames", 
                    "totalWins", 
                    "totalLosses", 
                    "winRate",
                    "lastLoginAt"
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id, username, email
            `;

      const values = [
        userData.email,
        userData.username,
        passwordHash,
        userData.level,
        userData.totalGames,
        userData.totalWins,
        userData.totalLosses,
        winRate,
        new Date()
      ];

      const result = await pool.query(insertUserQuery, values);
      const createdUser = result.rows[0];

      logger.info(`Created user: ${createdUser.username} (${createdUser.email})`);

    } catch (error) {
      logger.error(`Failed to create user ${userData.username}:`, error as Error);
    }
  }

  logger.info('Users seeding completed!');
}

//======================================================================
// SEED ACHIEVEMENTS (Se voc√™ quiser implementar no futuro)
//======================================================================

async function seedAchievements() {
  // A tabela "achievements" n√£o foi definida no seu init.sql atual.
  // Se voc√™ quiser implementar conquistas no futuro, pode descomentar e ajustar este c√≥digo
  logger.warn('Skipping achievements seeding (table not defined in init.sql).');

  /* 
  // Exemplo de como seria se voc√™ tivesse a tabela achievements:
  
  logger.info('Seeding achievements...');

  const achievements = [
      {
          key: 'first_game',
          name: 'Primeira Partida',
          description: 'Jogue sua primeira partida',
          icon: 'üéÆ',
          category: 'first_time',
          points: 10,
          conditions: JSON.stringify({ gamesPlayed: 1 }),
      },
      {
          key: 'first_win',
          name: 'Primeira Vit√≥ria',
          description: 'Ven√ßa sua primeira partida',
          icon: 'üèÜ',
          category: 'first_time',
          points: 25,
          conditions: JSON.stringify({ wins: 1 }),
      },
      // ... mais conquistas
  ];

  for (const achData of achievements) {
      try {
          // Check if achievement already exists
          const checkQuery = 'SELECT id FROM achievements WHERE key = $1';
          const existing = await pool.query(checkQuery, [achData.key]);

          if (existing.rows.length > 0) {
              logger.info(`Achievement ${achData.key} already exists, skipping...`);
              continue;
          }

          // Create achievement
          const insertQuery = `
              INSERT INTO achievements (key, name, description, icon, category, points, conditions)
              VALUES ($1, $2, $3, $4, $5, $6, $7)
              RETURNING key, name
          `;
          
          const values = [
              achData.key,
              achData.name,
              achData.description,
              achData.icon,
              achData.category,
              achData.points,
              achData.conditions
          ];

          const result = await pool.query(insertQuery, values);
          const achievement = result.rows[0];

          logger.info(`Created achievement: ${achievement.name}`);

      } catch (error) {
          logger.error(`Failed to create achievement ${achData.key}:`, error as Error);
      }
  }

  logger.info('Achievements seeding completed!');
  */
}

//======================================================================
// MAIN SEED FUNCTION
//======================================================================

async function main() {
  try {
    logger.info('üå± Starting database seeding...');

    await seedUsers();
    await seedAchievements();

    logger.info('‚úÖ Database seeding completed successfully!');

    // Log test user credentials
    console.log('\nüîë TEST USER CREDENTIALS:');
    console.log('=====================================');
    console.log('Admin: admin@werewolf.com / admin123');
    console.log('Player 1: player1@test.com / player123');
    console.log('Player 2: player2@test.com / player123');
    console.log('Player 3: player3@test.com / player123');
    console.log('Player 4: player4@test.com / player123');
    console.log('Player 5: player5@test.com / player123');
    console.log('Newbie: newbie@test.com / newbie123');
    console.log('=====================================\n');

  } catch (error) {
    logger.error('Seeding failed:', error instanceof Error ? error : new Error('Unknown seeding error'));
    process.exit(1);
  } finally {
    // Importante: fechar o pool para o script terminar
    await pool.end();
  }
}

//======================================================================
// RUN SEEDS IF CALLED DIRECTLY
//======================================================================

if (require.main === module) {
  main();
}

export { main as runSeeds };
</file>

<file path="backend/src/game/Game.ts">
// üê∫ LOBISOMEM ONLINE - Game Core Classes (FASE 1 - CORRE√á√ÉO CR√çTICA)
import { Role, Faction, GamePhase } from '@/utils/constants';
import type { GameConfig, GameEvent, NightAction, GameStatus } from '@/types';
import { RoleRevealManager, WinConditionCalculator, ROLE_CONFIGURATIONS } from './RoleSystem';

//====================================================================
// PLAYER CLASS - COMPAT√çVEL COM INTERFACE
//====================================================================
export class Player {
  public id: string;
  public userId: string;
  public username: string;
  public avatar?: string;
  public isHost: boolean;
  public isReady: boolean;
  public isSpectator: boolean;
  public isConnected: boolean;
  public joinedAt: Date;
  public lastSeen: Date;

  // Game-specific properties
  public role?: Role;
  public faction?: Faction;
  public isAlive: boolean = true;
  public isProtected: boolean = false;
  public hasActed: boolean = false;
  public hasVoted: boolean = false;
  public votedFor?: string;
  public actionsUsed: number = 0;
  public maxActions?: number;

  // Tracking
  public lastAction?: string;
  public protectedByDoctor: boolean = false;
  public canBeProtectedByDoctor: boolean = true;
  public investigatedBy: string[] = [];
  public killedBy?: string;
  public eliminationReason?: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER';

  constructor(data: {
    id: string;
    userId: string;
    username: string;
    avatar?: string;
    isHost: boolean;
    isReady: boolean;
    isSpectator: boolean;
    isConnected: boolean;
    joinedAt: Date;
    lastSeen: Date;
  }) {
    this.id = data.id;
    this.userId = data.userId;
    this.username = data.username;
    if (data.avatar !== undefined) {
      this.avatar = data.avatar;
    }
    this.isHost = data.isHost;
    this.isReady = data.isReady;
    this.isSpectator = data.isSpectator;
    this.isConnected = data.isConnected;
    this.joinedAt = data.joinedAt;
    this.lastSeen = data.lastSeen;
  }

  // Player actions
  assignRole(role: Role, faction: Faction, maxActions?: number): void {
    this.role = role;
    this.faction = faction;
    if (maxActions !== undefined) {
      this.maxActions = maxActions;
    }
    this.actionsUsed = 0;
    this.hasActed = false;
  }

  canAct(): boolean {
    if (!this.isAlive || !this.role) return false;
    if (this.hasActed) return false;
    if (this.maxActions !== undefined && this.actionsUsed >= this.maxActions) return false;

    const roleConfig = ROLE_CONFIGURATIONS[this.role];
    return roleConfig?.canAct || false;
  }

  performAction(action: string, targetId?: string): boolean {
    if (!this.canAct()) return false;

    this.hasActed = true;
    this.lastAction = action;
    this.actionsUsed++;

    return true;
  }

  kill(reason: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER', killedBy?: string): void {
    this.isAlive = false;
    this.eliminationReason = reason;
    if (killedBy !== undefined) {
      this.killedBy = killedBy;
    }
    this.hasVoted = false;
    delete this.votedFor;
  }

  protect(): void {
    this.isProtected = true;
    this.protectedByDoctor = true;
  }

  removeProtection(): void {
    this.isProtected = false;
    this.protectedByDoctor = false;
  }

  vote(targetId: string): boolean {
    if (!this.isAlive) return false;
    this.hasVoted = true;
    this.votedFor = targetId;
    return true;
  }

  unvote(): boolean {
    if (!this.isAlive) return false;
    this.hasVoted = false;
    delete this.votedFor;
    return true;
  }

  resetForNewPhase(): void {
    this.hasActed = false;
    this.hasVoted = false;
    delete this.votedFor;
    this.removeProtection();
    this.canBeProtectedByDoctor = !this.protectedByDoctor;
  }

  // Utility methods
  getPublicInfo(): any {
    const info: any = {
      id: this.id,
      userId: this.userId,
      username: this.username,
      isHost: this.isHost,
      isReady: this.isReady,
      isSpectator: this.isSpectator,
      isConnected: this.isConnected,
      isAlive: this.isAlive,
      hasVoted: this.hasVoted,
      joinedAt: this.joinedAt,
      lastSeen: this.lastSeen,
    };
    if (this.avatar) info.avatar = this.avatar;
    if (this.votedFor) info.votedFor = this.votedFor;
    return info;
  }

  getPrivateInfo(): any {
    const info = {
      ...this.getPublicInfo(),
      isProtected: this.isProtected,
      hasActed: this.hasActed,
      actionsUsed: this.actionsUsed,
    };
    if (this.role) info.role = this.role;
    if (this.faction) info.faction = this.faction;
    if (this.maxActions) info.maxActions = this.maxActions;
    if (this.lastAction) info.lastAction = this.lastAction;
    if (this.eliminationReason) info.eliminationReason = this.eliminationReason;
    if (this.killedBy) info.killedBy = this.killedBy;
    return info;
  }
}

//====================================================================
// GAME STATE CLASS - FASE 1 COM CANSTART() MELHORADO
//====================================================================
export class GameState {
  public gameId: string;
  public roomId: string;
  public status: GameStatus;
  public phase: GamePhase;
  public day: number;
  public phaseStartTime: Date;
  public phaseEndTime: Date;
  public timeLeft: number; // milliseconds

  private playersMap: Map<string, Player>;
  private spectatorsSet: Set<string>;
  private eliminatedPlayersMap: Map<string, Player>;
  private votesMap: Map<string, string>; // voterId -> targetId

  public hostId: string;
  public config: GameConfig;
  public events: GameEvent[];
  public nightActions: NightAction[];

  public createdAt: Date;
  public updatedAt: Date;
  public startedAt?: Date;
  public finishedAt?: Date;

  public winningFaction?: Faction;
  public winningPlayers: string[] = [];

  constructor(gameId: string, config: GameConfig, hostId: string) {
    this.gameId = gameId;
    this.roomId = config.roomId;
    this.status = 'WAITING';
    this.phase = GamePhase.LOBBY;
    this.day = 0;
    this.phaseStartTime = new Date();
    this.phaseEndTime = new Date();
    this.timeLeft = 0;

    this.playersMap = new Map();
    this.spectatorsSet = new Set();
    this.eliminatedPlayersMap = new Map();
    this.votesMap = new Map();

    this.hostId = hostId;
    this.config = config;
    this.events = [];
    this.nightActions = [];

    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  // Getters para compatibilidade com a interface
  get players(): Player[] {
    return Array.from(this.playersMap.values());
  }

  get spectators(): string[] {
    return Array.from(this.spectatorsSet);
  }

  get eliminatedPlayers(): Player[] {
    return Array.from(this.eliminatedPlayersMap.values());
  }

  get votes(): Record<string, string> {
    return Object.fromEntries(this.votesMap);
  }

  addPlayer(player: Player): boolean {
    if (this.playersMap.size >= this.config.maxPlayers) return false;
    if (this.status !== 'WAITING') return false;

    this.playersMap.set(player.id, player);
    this.updatedAt = new Date();

    this.addEvent('PLAYER_JOINED', {
      playerId: player.id,
      username: player.username,
      playerCount: this.playersMap.size,
    });

    return true;
  }

  removePlayer(playerId: string): boolean {
    const player = this.playersMap.get(playerId);
    if (!player) return false;

    this.playersMap.delete(playerId);

    if (this.status === 'PLAYING') {
      this.eliminatedPlayersMap.set(playerId, player);
    }

    this.updatedAt = new Date();

    this.addEvent('PLAYER_LEFT', {
      playerId: player.id,
      username: player.username,
      playerCount: this.playersMap.size,
    });

    return true;
  }

  getPlayer(playerId: string): Player | undefined {
    return this.playersMap.get(playerId);
  }

  getAlivePlayers(): Player[] {
    return Array.from(this.playersMap.values()).filter(p => p.isAlive && !p.isSpectator);
  }

  getDeadPlayers(): Player[] {
    return Array.from(this.playersMap.values()).filter(p => !p.isAlive && !p.isSpectator);
  }

  // ‚úÖ FASE 1 - CANSTART() MELHORADO E MAIS ROBUSTO
  canStart(): boolean {
    // ‚úÖ Verifica√ß√µes b√°sicas primeiro
    if (this.status !== 'WAITING') {
      return false;
    }

    const alivePlayers = this.getAlivePlayers();

    // ‚úÖ Verificar quantidade de jogadores (6 a 15)
    if (alivePlayers.length < 6 || alivePlayers.length > 15) {
      return false;
    }

    // ‚úÖ IMPORTANTE: Verificar se h√° pelo menos um host
    const hostPlayer = alivePlayers.find(p => p.isHost);
    if (!hostPlayer) {
      return false;
    }

    // ‚úÖ L√ìGICA ROBUSTA: O host n√£o precisa estar "ready", apenas os outros jogadores
    const nonHostPlayers = alivePlayers.filter(p => !p.isHost);
    const allNonHostPlayersReady = nonHostPlayers.every(p => p.isReady);

    return allNonHostPlayersReady;
  }

  // ‚úÖ FASE 1 - M√âTODO AUXILIAR PARA DEBUG E VALIDA√á√ÉO
  getStartRequirements(): {
    canStart: boolean;
    reasons: string[];
    playerCount: number;
    readyCount: number;
    hostReady: boolean;
    hostFound: boolean;
    nonHostPlayersReady: number;
    nonHostPlayersTotal: number;
  } {
    const reasons: string[] = [];
    const alivePlayers = this.getAlivePlayers();
    const hostPlayer = alivePlayers.find(p => p.isHost);
    const readyPlayers = alivePlayers.filter(p => p.isReady);

    if (this.status !== 'WAITING') {
      reasons.push(`Game status is ${this.status}, must be WAITING`);
    }

    if (alivePlayers.length < 6) {
      reasons.push(`Only ${alivePlayers.length} players, minimum is 6`);
    }

    if (alivePlayers.length > 15) {
      reasons.push(`${alivePlayers.length} players, maximum is 15`);
    }

    if (!hostPlayer) {
      reasons.push('No host player found');
    }

    const nonHostPlayers = alivePlayers.filter(p => !p.isHost);
    const notReadyNonHost = nonHostPlayers.filter(p => !p.isReady);

    if (notReadyNonHost.length > 0) {
      reasons.push(`${notReadyNonHost.length} non-host players not ready: ${notReadyNonHost.map(p => p.username).join(', ')}`);
    }

    return {
      canStart: reasons.length === 0,
      reasons,
      playerCount: alivePlayers.length,
      readyCount: readyPlayers.length,
      hostReady: hostPlayer?.isReady || false,
      hostFound: !!hostPlayer,
      nonHostPlayersReady: nonHostPlayers.filter(p => p.isReady).length,
      nonHostPlayersTotal: nonHostPlayers.length,
    };
  }

  start(): boolean {
    if (!this.canStart()) return false;

    this.status = 'STARTING';
    this.startedAt = new Date();
    this.updatedAt = new Date();

    this.addEvent('GAME_STARTING', {
      playerCount: this.getAlivePlayers().length,
    });

    return true;
  }

  changePhase(newPhase: GamePhase, duration: number): void {
    this.phase = newPhase;
    this.phaseStartTime = new Date();
    this.phaseEndTime = new Date(Date.now() + duration);
    this.timeLeft = duration;
    this.updatedAt = new Date();

    if (newPhase === GamePhase.DAY) {
      this.day++;
    }

    this.playersMap.forEach(player => player.resetForNewPhase());
    this.votesMap.clear();

    this.addEvent('PHASE_CHANGED', {
      phase: newPhase,
      day: this.day,
      duration,
      timeLeft: this.timeLeft,
    });
  }

  updateTimeLeft(): void {
    this.timeLeft = Math.max(0, this.phaseEndTime.getTime() - Date.now());
    this.updatedAt = new Date();
  }

  isPhaseExpired(): boolean {
    return Date.now() >= this.phaseEndTime.getTime();
  }

  addVote(voterId: string, targetId: string): boolean {
    const voter = this.playersMap.get(voterId);
    const target = this.playersMap.get(targetId);

    if (!voter || !target || !voter.isAlive || !target.isAlive) return false;
    if (this.phase !== GamePhase.VOTING) return false;

    this.votesMap.set(voterId, targetId);
    voter.vote(targetId);

    this.addEvent('VOTE_CAST', {
      voterId,
      targetId,
      voterUsername: voter.username,
      targetUsername: target.username,
    });

    return true;
  }

  removeVote(voterId: string): boolean {
    const voter = this.playersMap.get(voterId);
    if (!voter || !voter.isAlive) return false;

    const targetId = this.votesMap.get(voterId);
    this.votesMap.delete(voterId);
    voter.unvote();

    if (targetId) {
      const target = this.playersMap.get(targetId);
      this.addEvent('VOTE_REMOVED', {
        voterId,
        targetId,
        voterUsername: voter.username,
        targetUsername: target?.username,
      });
    }

    return true;
  }

  getVoteCounts(): Map<string, number> {
    const counts = new Map<string, number>();
    this.votesMap.forEach((targetId) => {
      counts.set(targetId, (counts.get(targetId) || 0) + 1);
    });
    return counts;
  }

  getMostVotedPlayer(): { playerId: string; votes: number } | null {
    const counts = this.getVoteCounts();
    let maxVotes = 0;
    let mostVoted: string | null = null;
    let tieCount = 0;

    counts.forEach((votes, playerId) => {
      if (votes > maxVotes) {
        maxVotes = votes;
        mostVoted = playerId;
        tieCount = 1;
      } else if (votes === maxVotes) {
        tieCount++;
      }
    });

    if (tieCount > 1 || !mostVoted || maxVotes === 0) return null;

    return { playerId: mostVoted, votes: maxVotes };
  }

  addEvent(type: string, data: any, visibleTo?: string[]): void {
    const event: GameEvent = {
      id: `${this.gameId}-${this.events.length}`,
      type,
      phase: this.phase,
      day: this.day,
      timestamp: new Date(),
      data,
      ...(visibleTo && { visibleTo }),
    };

    this.events.push(event);
    this.updatedAt = new Date();
  }

  getEventsForPlayer(playerId: string): GameEvent[] {
    return this.events.filter(event =>
      !event.visibleTo || event.visibleTo.includes(playerId)
    );
  }

  checkWinCondition(): { hasWinner: boolean; winningFaction?: Faction; winningPlayers?: string[] } {
    const alivePlayers = this.getAlivePlayers();
    return WinConditionCalculator.calculateWinCondition(
      alivePlayers.map(p => ({ playerId: p.id, role: p.role! }))
    );
  }

  endGame(winningFaction?: Faction, winningPlayers?: string[]): void {
    this.status = 'FINISHED';
    this.finishedAt = new Date();
    this.updatedAt = new Date();
    if (winningFaction) {
      this.winningFaction = winningFaction;
    }
    if (winningPlayers) {
      this.winningPlayers = winningPlayers;
    }

    this.addEvent('GAME_ENDED', {
      winningFaction,
      winningPlayers,
      totalDays: this.day,
      duration: this.finishedAt.getTime() - (this.startedAt?.getTime() || 0),
    });
  }

  toJSON(): any {
    return {
      gameId: this.gameId,
      roomId: this.roomId,
      status: this.status,
      phase: this.phase,
      day: this.day,
      phaseStartTime: this.phaseStartTime,
      phaseEndTime: this.phaseEndTime,
      timeLeft: this.timeLeft,
      players: this.players,
      spectators: this.spectators,
      eliminatedPlayers: this.eliminatedPlayers,
      hostId: this.hostId,
      config: this.config,
      events: this.events,
      votes: this.votes,
      nightActions: this.nightActions,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
      startedAt: this.startedAt,
      finishedAt: this.finishedAt,
      winningFaction: this.winningFaction,
      winningPlayers: this.winningPlayers,
    };
  }
}
</file>

<file path="backend/src/game/GameEngine.ts">
// üê∫ LOBISOMEM ONLINE - Game Engine (FASE 1 - CORRE√á√ÉO CR√çTICA)
import { GameState, Player } from './Game';
import { RoleDistributor, WinConditionCalculator } from './RoleSystem';
import { Role, Faction, GamePhase } from '@/utils/constants';
import type { GameConfig, IGameEngine, GameResults, GameStatus } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// GAME ENGINE IMPLEMENTATION - FASE 1 CORRIGIDA
//====================================================================
export class GameEngine implements IGameEngine {
  private games = new Map<string, GameState>();
  private eventHandlers = new Map<string, Map<string, ((data: any) => void)[]>>();

  private sendToUser?: (userId: string, type: string, data?: any) => boolean;

  constructor() {
    logger.info('GameEngine initialized');
  }

  //====================================================================
  // M√âTODO PARA INJETAR sendToUser (Chamado pelo WebSocketManager)
  //====================================================================
  setSendToUserMethod(sendToUser: (userId: string, type: string, data?: any) => boolean): void {
    this.sendToUser = sendToUser;
    logger.info('SendToUser method injected into GameEngine');
  }

  //====================================================================
  // GAME LIFECYCLE
  //====================================================================
  async createGame(hostId: string, config: GameConfig): Promise<GameState> {
    // ‚úÖ FASE 1 - CORRE√á√ÉO CR√çTICA: gameId padronizado e previs√≠vel
    const gameId = `game-${config.roomId}`;

    try {
      const gameState = new GameState(gameId, config, hostId);

      this.games.set(gameId, gameState);
      this.eventHandlers.set(gameId, new Map());

      logger.info('Game created with standardized gameId', {
        gameId,
        roomId: config.roomId,
        hostId,
        pattern: 'game-${roomId}'
      });

      this.emitGameEvent(gameId, 'game:created', {
        gameId,
        hostId,
        roomId: config.roomId,
        config,
      });

      return gameState;
    } catch (error) {
      logger.error('Failed to create game', error instanceof Error ? error : new Error('Unknown game creation error'), { hostId, config });
      throw error;
    }
  }

  // ‚úÖ FASE 1 - MELHORADO: startGame com logs estruturados para debugging
  async startGame(gameId: string): Promise<boolean> {
    const gameState = this.games.get(gameId);

    if (!gameState) {
      // ‚úÖ FASE 1 - LOG MELHORADO: Mostrar gameIds dispon√≠veis para debug
      const availableGameIds = Array.from(this.games.keys());
      logger.warn('Attempted to start non-existent game', {
        requestedGameId: gameId,
        availableGameIds,
        totalGames: this.games.size,
        pattern: 'Expected: game-${roomId}'
      });
      return false;
    }

    // ‚úÖ FASE 1 - VALIDA√á√ÉO MELHORADA: Usar novo canStart() mais robusto
    if (!gameState.canStart()) {
      const alivePlayers = gameState.getAlivePlayers();
      const hostPlayer = alivePlayers.find(p => p.isHost);
      const nonHostPlayers = alivePlayers.filter(p => !p.isHost);
      const readyNonHostPlayers = nonHostPlayers.filter(p => p.isReady);

      logger.warn('Game cannot start - requirements not met', {
        gameId,
        status: gameState.status,
        totalPlayers: alivePlayers.length,
        hostFound: !!hostPlayer,
        hostReady: hostPlayer?.isReady || false,
        nonHostPlayers: nonHostPlayers.length,
        readyNonHostPlayers: readyNonHostPlayers.length,
        playersNotReady: nonHostPlayers.filter(p => !p.isReady).map(p => p.username),
      });
      return false;
    }

    try {
      gameState.start();

      const players = gameState.getAlivePlayers();
      const distribution = RoleDistributor.getRoleDistribution(players.length);
      const roleAssignments = RoleDistributor.distributeRolesToPlayers(
        players.map(p => p.id),
        distribution
      );

      roleAssignments.forEach((role, playerId) => {
        const player = gameState.getPlayer(playerId);
        if (player) {
          const roleConfig = RoleDistributor.getRoleConfig(role);
          player.assignRole(role, roleConfig.faction, roleConfig.maxActions);
        }
      });

      gameState.status = 'PLAYING';

      await this.startFirstNight(gameState);

      // Enviar estado inicial para cada jogador INDIVIDUALMENTE
      await this.sendInitialGameStateToAllPlayers(gameId);

      logger.info('Game started successfully - Phase 1 implementation', {
        gameId,
        roomId: gameState.roomId,
        playerCount: players.length,
        distribution,
        hostId: gameState.hostId,
      });

      this.emitGameEvent(gameId, 'game:started', {
        gameId,
        players: players.map(p => ({
          id: p.id,
          username: p.username,
          role: p.role,
        })),
        distribution,
      });

      return true;
    } catch (error) {
      logger.error('Failed to start game', error instanceof Error ? error : new Error('Unknown game start error'), { gameId });
      return false;
    }
  }

  // ENVIAR ESTADO INICIAL PERSONALIZADO PARA CADA JOGADOR
  private async sendInitialGameStateToAllPlayers(gameId: string): Promise<void> {
    if (!this.sendToUser) {
      logger.error('SendToUser method not available - cannot send initial game state');
      return;
    }

    const gameState = this.games.get(gameId);
    if (!gameState) return;

    const players = gameState.getAlivePlayers();

    logger.info('Sending initial game state to all players', {
      gameId,
      playerCount: players.length
    });

    for (const player of players) {
      try {
        const personalizedGameState = this.getPersonalizedGameState(gameState, player.userId);
        const success = this.sendToUser(player.userId, 'game-state', personalizedGameState);

        if (success) {
          logger.debug('Initial game state sent to player', {
            gameId,
            playerId: player.id,
            userId: player.userId,
            username: player.username
          });
        } else {
          logger.warn('Failed to send initial game state to player', {
            gameId,
            playerId: player.id,
            userId: player.userId
          });
        }

      } catch (error) {
        logger.error('Error sending initial game state to player',
          error instanceof Error ? error : new Error('Unknown send error'),
          { gameId, playerId: player.id, userId: player.userId }
        );
      }
    }
  }

  // PERSONALIZAR ESTADO DO JOGO PARA JOGADOR ESPEC√çFICO
  private getPersonalizedGameState(gameState: GameState, userId: string): any {
    const fullState = gameState.toJSON();
    const currentPlayer = fullState.players.find((p: any) => p.userId === userId);

    fullState.players = fullState.players.map((player: any) => {
      if (player.userId === userId) {
        return player;
      } else if (!player.isAlive) {
        return player;
      } else {
        const { role, faction, hasActed, maxActions, actionsUsed, lastAction, ...publicData } = player;
        return publicData;
      }
    });

    fullState.nightActions = [];

    if (currentPlayer) {
      fullState.me = {
        id: currentPlayer.id,
        userId: currentPlayer.userId,
        username: currentPlayer.username,
        role: currentPlayer.role,
        faction: currentPlayer.faction,
        isAlive: currentPlayer.isAlive,
        isProtected: currentPlayer.isProtected,
        hasActed: currentPlayer.hasActed,
        hasVoted: currentPlayer.hasVoted,
        votedFor: currentPlayer.votedFor,
        actionsUsed: currentPlayer.actionsUsed,
        maxActions: currentPlayer.maxActions,
      };
    }

    return fullState;
  }

  async endGame(gameId: string, reason?: string): Promise<void> {
    const gameState = this.games.get(gameId);
    if (!gameState || gameState.status === 'FINISHED') return;

    try {
      const alivePlayers = gameState.getAlivePlayers();
      const winCondition = WinConditionCalculator.calculateWinCondition(
        alivePlayers.map(p => ({ playerId: p.id, role: p.role! }))
      );

      gameState.endGame(winCondition.winningFaction, winCondition.winningPlayers);

      logger.info('Game ended', {
        gameId,
        winningFaction: gameState.winningFaction,
        winningPlayers: gameState.winningPlayers,
        reason,
        totalDays: gameState.day,
      });

      this.emitGameEvent(gameId, 'game:ended', {
        gameId,
        winningFaction: gameState.winningFaction,
        winningPlayers: gameState.winningPlayers,
        reason,
        totalDays: gameState.day,
        finalResults: this.generateGameResults(gameState),
      });

    } catch (error) {
      logger.error('Error ending game', error instanceof Error ? error : new Error('Unknown game end error'), { gameId });
    }
  }

  //====================================================================
  // PLAYER MANAGEMENT
  //====================================================================
  async addPlayer(gameId: string, player: Player): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    const success = gameState.addPlayer(player);

    if (success) {
      logger.info('Player added to game', {
        gameId,
        playerId: player.id,
        username: player.username,
        isSpectator: player.isSpectator,
      });

      this.emitGameEvent(gameId, 'player:joined', {
        gameId,
        player: player.getPublicInfo(),
      });
    }

    return success;
  }

  async removePlayer(gameId: string, playerId: string): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    const player = gameState.getPlayer(playerId);
    const success = gameState.removePlayer(playerId);

    if (success && player) {
      logger.info('Player removed from game', {
        gameId,
        playerId,
        username: player.username,
      });

      this.emitGameEvent(gameId, 'player:left', {
        gameId,
        playerId,
        username: player.username,
      });

      if (gameState.status === 'PLAYING') {
        const alivePlayers = gameState.getAlivePlayers();
        if (alivePlayers.length < 3) {
          await this.endGame(gameId, 'Insufficient players');
          return true;
        }
        await this.checkWinCondition(gameId);
      }
    }

    return success;
  }

  //====================================================================
  // GAME STATE MANAGEMENT
  //====================================================================
  async getGameState(gameId: string): Promise<GameState | null> {
    return this.games.get(gameId) || null;
  }

  async updateGameState(gameId: string, updates: Partial<GameState>): Promise<void> {
    const gameState = this.games.get(gameId);
    if (!gameState) return;

    Object.assign(gameState, updates, { updatedAt: new Date() });

    this.emitGameEvent(gameId, 'game:state-updated', {
      gameId,
      updates,
    });
  }

  //====================================================================
  // PLAYER ACTIONS
  //====================================================================
  async performPlayerAction(gameId: string, playerId: string, action: any): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    const player = gameState.getPlayer(playerId);
    if (!player || !player.isAlive) return false;

    if (gameState.phase === GamePhase.NIGHT && player.canAct()) {
      return player.performAction(action.type, action.targetId);
    }

    return false;
  }

  //====================================================================
  // PHASE MANAGEMENT
  //====================================================================
  async nextPhase(gameId: string): Promise<void> {
    const gameState = this.games.get(gameId);
    if (!gameState) return;

    const currentPhase = gameState.phase;

    try {
      switch (currentPhase) {
        case GamePhase.NIGHT:
          await this.processNightResults(gameState);
          await this.changePhase(gameState, GamePhase.DAY, gameState.config.dayDuration);
          break;

        case GamePhase.DAY:
          await this.changePhase(gameState, GamePhase.VOTING, gameState.config.votingDuration);
          break;

        case GamePhase.VOTING:
          await this.processVotingResults(gameState);
          if (gameState.status === 'PLAYING') {
            await this.changePhase(gameState, GamePhase.NIGHT, gameState.config.nightDuration);
          }
          break;

        default:
          break;
      }

      await this.checkWinCondition(gameId);
    } catch (error) {
      logger.error('Error during phase transition', error instanceof Error ? error : new Error('Unknown phase error'), {
        gameId,
        currentPhase,
      });
    }
  }

  //====================================================================
  // PHASE TRANSITION HELPERS
  //====================================================================
  private async startFirstNight(gameState: GameState): Promise<void> {
    await this.changePhase(gameState, GamePhase.NIGHT, gameState.config.nightDuration);

    gameState.addEvent('FIRST_NIGHT_STARTED', {
      message: 'A primeira noite chegou √† vila. Os poderes especiais acordam...',
    });
  }

  private async changePhase(gameState: GameState, newPhase: GamePhase, duration: number): Promise<void> {
    gameState.changePhase(newPhase, duration);

    setTimeout(() => {
      this.nextPhase(gameState.gameId);
    }, duration);

    this.emitGameEvent(gameState.gameId, 'phase:changed', {
      gameId: gameState.gameId,
      phase: newPhase,
      duration,
      timeLeft: duration,
    });
  }

  private async processNightResults(gameState: GameState): Promise<void> {
    const deaths: string[] = [];

    gameState.nightActions.forEach(action => {
      if (action.type === 'WEREWOLF_KILL' && action.targetId) {
        const target = gameState.getPlayer(action.targetId);
        if (target && target.isAlive && !target.isProtected) {
          target.kill('NIGHT_KILL');
          deaths.push(action.targetId);
        }
      }
    });

    gameState.nightActions = [];

    if (deaths.length > 0) {
      deaths.forEach(playerId => {
        const player = gameState.getPlayer(playerId);
        if (player) {
          gameState.addEvent('PLAYER_DIED', {
            playerId,
            playerName: player.username,
            cause: 'NIGHT_KILL',
          });
        }
      });
    } else {
      gameState.addEvent('NO_DEATHS', {
        message: 'Ningu√©m morreu durante a noite.',
      });
    }
  }

  private async processVotingResults(gameState: GameState): Promise<void> {
    const result = gameState.getMostVotedPlayer();

    if (result) {
      const player = gameState.getPlayer(result.playerId);
      if (player && player.role) {
        if (player.role === Role.JESTER) {
          gameState.endGame(Faction.NEUTRAL, [player.id]);

          this.emitGameEvent(gameState.gameId, 'jester:wins', {
            gameId: gameState.gameId,
            jesterId: player.id,
            jesterName: player.username,
          });

          await this.endGame(gameState.gameId, 'Jester executed and wins');
          return;
        }

        player.kill('EXECUTION');

        gameState.addEvent('PLAYER_EXECUTED', {
          playerId: player.id,
          playerName: player.username,
          role: player.role,
          votes: result.votes,
        });
      }
    } else {
      gameState.addEvent('NO_EXECUTION', {
        reason: 'No majority or tie vote',
      });
    }
  }

  //====================================================================
  // WIN CONDITION CHECKING
  //====================================================================
  private async checkWinCondition(gameId: string): Promise<void> {
    const gameState = this.games.get(gameId);
    if (!gameState || gameState.status !== 'PLAYING') return;

    const alivePlayers = gameState.getAlivePlayers();
    const winCondition = WinConditionCalculator.calculateWinCondition(
      alivePlayers.map(p => ({ playerId: p.id, role: p.role! }))
    );

    if (winCondition.hasWinner) {
      await this.endGame(gameId);
    }
  }

  //====================================================================
  // VOTING SYSTEM
  //====================================================================
  async castVote(gameId: string, voterId: string, targetId: string): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    const success = gameState.addVote(voterId, targetId);

    if (success) {
      this.emitGameEvent(gameId, 'vote:cast', {
        gameId,
        voterId,
        targetId,
        voteCounts: Object.fromEntries(gameState.getVoteCounts()),
      });
    }

    return success;
  }

  async removeVote(gameId: string, voterId: string): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    const success = gameState.removeVote(voterId);

    if (success) {
      this.emitGameEvent(gameId, 'vote:removed', {
        gameId,
        voterId,
        voteCounts: Object.fromEntries(gameState.getVoteCounts()),
      });
    }

    return success;
  }

  //====================================================================
  // EVENT SYSTEM
  //====================================================================
  onGameEvent(gameId: string, event: string, handler: (data: any) => void): void {
    const gameHandlers = this.eventHandlers.get(gameId);
    if (!gameHandlers) return;

    if (!gameHandlers.has(event)) {
      gameHandlers.set(event, []);
    }

    gameHandlers.get(event)!.push(handler);
  }

  private emitGameEvent(gameId: string, event: string, data: any): void {
    const gameHandlers = this.eventHandlers.get(gameId);
    if (!gameHandlers) return;

    const handlers = gameHandlers.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          logger.error('Error in game event handler', error instanceof Error ? error : new Error('Unknown handler error'), {
            gameId,
            event,
          });
        }
      });
    }
  }

  //====================================================================
  // UTILITY METHODS
  //====================================================================
  private generateGameResults(gameState: GameState): GameResults {
    const results: GameResults = {
      gameId: gameState.gameId,
      roomId: gameState.roomId,
      duration: gameState.finishedAt
        ? gameState.finishedAt.getTime() - (gameState.startedAt?.getTime() || 0)
        : 0,
      totalDays: gameState.day,

      ...(gameState.winningFaction && { winningFaction: gameState.winningFaction }),

      winningPlayers: gameState.winningPlayers,
      players: gameState.players.map(player => ({
        id: player.id,
        userId: player.userId,
        username: player.username,
        role: player.role ?? Role.VILLAGER,
        faction: player.faction ?? Faction.TOWN,
        survived: player.isAlive,
        won: gameState.winningPlayers.includes(player.id),
        eliminationReason: player.eliminationReason ?? '',
        killedBy: player.killedBy ?? '',
      })),
      events: gameState.events,
    };

    return results;
  }

  //====================================================================
  // ADMINISTRATIVE METHODS
  //====================================================================
  getActiveGamesCount(): number {
    return Array.from(this.games.values())
      .filter(game => game.status === 'PLAYING').length;
  }

  getAllGames(): GameState[] {
    return Array.from(this.games.values());
  }

  async getGamesByRoom(roomId: string): Promise<GameState[]> {
    const games = Array.from(this.games.values())
      .filter(game => game.roomId === roomId);
    return Promise.resolve(games);
  }

  async forceEndGame(gameId: string, reason: string): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    await this.endGame(gameId, reason);
    return true;
  }

  getGameStats(gameId: string): any {
    const gameState = this.games.get(gameId);
    if (!gameState) return null;

    return {
      gameId,
      status: gameState.status,
      phase: gameState.phase,
      day: gameState.day,
      playerCount: gameState.players.length,
      aliveCount: gameState.getAlivePlayers().length,
      spectatorCount: gameState.spectators.length,
      timeLeft: gameState.timeLeft,
      events: gameState.events.length,
    };
  }

  //====================================================================
  // CLEANUP
  //====================================================================
  async cleanup(): Promise<void> {
    this.games.clear();
    this.eventHandlers.clear();

    logger.info('GameEngine cleanup completed');
  }
}
</file>

<file path="backend/src/middleware/auth.ts">
import { Request, Response, NextFunction } from 'express';
import { verifyAccessToken, extractTokenFromHeader, extractTokenFromCookie } from '@/config/jwt';
import { pool } from '@/config/database';
import { authLogger } from '@/utils/logger';
import { ERROR_MESSAGES } from '@/utils/constants';

declare global {
  namespace Express {
    interface Request {
      userId: string;
      username: string;
      email: string;
    }
  }
}

export const requireAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    let token = extractTokenFromHeader(req.headers.authorization);

    if (!token) {
      token = extractTokenFromCookie(req.headers.cookie);
    }

    if (!token) {
      authLogger.warn('Authentication attempt without token', {
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        path: req.path,
      });

      res.status(401).json({
        success: false,
        error: ERROR_MESSAGES.UNAUTHORIZED,
        timestamp: new Date().toISOString(),
      });
      return;
    }

    const payload = verifyAccessToken(token);

    const userQuery = `SELECT id, username, email, "updatedAt" FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [payload.userId]);

    if (userResult.rows.length === 0) {
      authLogger.warn('Token valid but user not found', {
        userId: payload.userId,
        ip: req.ip,
        path: req.path,
      });

      res.status(401).json({
        success: false,
        error: ERROR_MESSAGES.UNAUTHORIZED,
        timestamp: new Date().toISOString(),
      });
      return;
    }

    const user = userResult.rows[0];

    await pool.query(`UPDATE users SET "lastLoginAt" = NOW() WHERE id = $1`, [user.id]);

    req.userId = user.id;
    req.username = user.username;
    req.email = user.email;

    authLogger.info('User authenticated successfully', {
      userId: user.id,
      username: user.username,
      ip: req.ip,
      path: req.path,
    });

    next();
  } catch (error) {
    authLogger.error('Authentication error', error instanceof Error ? error : new Error('Unknown auth error'), {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      path: req.path,
    });

    res.status(401).json({
      success: false,
      error: ERROR_MESSAGES.UNAUTHORIZED,
      timestamp: new Date().toISOString(),
    });
  }
};

export const optionalAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    let token = extractTokenFromHeader(req.headers.authorization);

    if (!token) {
      token = extractTokenFromCookie(req.headers.cookie);
    }

    if (!token) {
      return next();
    }

    const payload = verifyAccessToken(token);
    const userQuery = `SELECT id, username, email FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [payload.userId]);

    if (userResult.rows.length > 0) {
      const user = userResult.rows[0];
      req.userId = user.id;
      req.username = user.username;
      req.email = user.email;
    }

    next();
  } catch (error) {
    next();
  }
};
</file>

<file path="backend/src/routes/auth.ts">
// üê∫ LOBISOMEM ONLINE - Authentication Routes
// Route definitions for authentication endpoints

import { Router } from 'express';
import { register, login, forgotPassword, resetPassword, getProfile, checkUsername, checkEmail } from '@/controllers/authController';
import { requireAuth } from '@/middleware/auth';

const router = Router();

//======================================================================
// SIMPLE RATE LIMITING (INLINE)
//======================================================================

const authRateLimit = (req: any, res: any, next: any) => {
  // TODO: Implement proper rate limiting later
  // For now, just pass through
  next();
};

//======================================================================
// PUBLIC ROUTES
//======================================================================

/**
 * @route POST /api/auth/register
 * @desc Register new user
 * @access Public
 * @body { email, username, password, confirmPassword }
 */
router.post('/register', authRateLimit, register);

/**
 * @route POST /api/auth/login
 * @desc Login user
 * @access Public
 * @body { email, password }
 */
router.post('/login', authRateLimit, login);

/**
 * @route POST /api/auth/forgot-password
 * @desc Request password reset
 * @access Public
 * @body { email }
 */
router.post('/forgot-password', authRateLimit, forgotPassword);

/**
 * @route POST /api/auth/reset-password
 * @desc Reset password with token
 * @access Public
 * @body { token, password, confirmPassword }
 */
router.post('/reset-password', authRateLimit, resetPassword);

/**
 * @route GET /api/auth/check-username/:username
 * @desc Check if username is available
 * @access Public
 */
router.get('/check-username/:username', authRateLimit, checkUsername);

/**
 * @route GET /api/auth/check-email/:email
 * @desc Check if email is available
 * @access Public
 */
router.get('/check-email/:email', authRateLimit, checkEmail);

//======================================================================
// PROTECTED ROUTES
//======================================================================

/**
 * @route GET /api/auth/profile
 * @desc Get current user profile
 * @access Private
 */
router.get('/profile', requireAuth, getProfile);

/**
 * @route POST /api/auth/refresh
 * @desc Refresh access token
 * @access Private (refresh token)
 */
router.post('/refresh', (req, res) => {
  // TODO: Implement refresh token logic
  res.json({
    success: true,
    message: 'Refresh token endpoint - TODO',
    timestamp: new Date().toISOString(),
  });
});

/**
 * @route POST /api/auth/logout
 * @desc Logout user (invalidate token)
 * @access Private
 */
router.post('/logout', requireAuth, (req, res) => {
  // TODO: Add token to blacklist in Redis
  res.json({
    success: true,
    message: 'Logout realizado com sucesso',
    timestamp: new Date().toISOString(),
  });
});

export default router;
</file>

<file path="backend/src/types/index.ts">
// üê∫ LOBISOMEM ONLINE - Tipos Centralizados (REFATORADO)
import type WebSocket from 'ws';

// =============================================================================
// IMPORT ENUMS FROM CONSTANTS (√öNICA FONTE)
// =============================================================================
export { Role, Faction, GamePhase } from '@/utils/constants';
import { Role, Faction, GamePhase } from '@/utils/constants';

// =============================================================================
// API & HTTP
// =============================================================================
export interface ApiResponse<T = any> {
    success: boolean;
    data?: T;
    message?: string;
    error?: string;
    timestamp: string;
}

// =============================================================================
// JWT & AUTENTICA√á√ÉO
// =============================================================================
export interface JWTPayload {
    userId: string;
    username: string;
    email: string;
    avatar?: string;
    iat?: number;
    exp?: number;
}

export interface TokenPair {
    accessToken: string;
    refreshToken?: string;
}

// =============================================================================
// WEBSOCKET & CONEX√ÉO
// =============================================================================
export interface ConnectionContext {
    userId: string;
    username: string;
    serverId: string;
    isSpectator: boolean;
    roomId?: string;
}

export interface ConnectionMetadata {
    connectedAt: Date;
    userAgent?: string;
    ip?: string;
    origin?: string;
}

export interface WebSocketConnection {
    id: string;
    ws: WebSocket;
    context: ConnectionContext;
    metadata: ConnectionMetadata;
    isAlive: boolean;
    lastPing: number;
    reconnectAttempts: number;
}

export interface WebSocketMessage {
    type: string;
    timestamp: string;
    data?: any;
    messageId?: string;
}

export interface URLParseResult {
    isValid: boolean;
    path: string;
    roomId?: string;
    serverId?: string;
}

export interface MessageValidationResult {
    isValid: boolean;
    message?: WebSocketMessage;
    error?: string;
}

export type WebSocketErrorCode =
    | 'INVALID_TOKEN' | 'ROOM_NOT_FOUND' | 'ROOM_FULL' | 'NOT_IN_ROOM'
    | 'NOT_HOST' | 'GAME_ALREADY_STARTED' | 'INVALID_ACTION'
    | 'PLAYER_NOT_FOUND' | 'RATE_LIMITED' | 'INVALID_MESSAGE'
    | 'UNKNOWN_MESSAGE_TYPE' | 'HANDLER_ERROR' | 'MISSING_ROOM_ID'
    | 'JOIN_ROOM_FAILED' | 'LEAVE_ROOM_FAILED' | 'READY_UPDATE_FAILED'
    | 'START_GAME_FAILED' | 'KICK_PLAYER_FAILED' | 'NOT_IMPLEMENTED';

// =============================================================================
// GAME TYPES (COMPAT√çVEIS COM CLASSES REAIS)
// =============================================================================
export type RoomStatus = 'WAITING' | 'PLAYING' | 'FINISHED';
export type GameStatus = 'WAITING' | 'STARTING' | 'PLAYING' | 'FINISHED' | 'CANCELLED';

export interface Room {
    id: string;
    name: string;
    isPrivate: boolean;
    maxPlayers: number;
    maxSpectators: number;
    status: RoomStatus;
    hostId: string;
    hostUsername: string;
    currentPlayers: number;
    currentSpectators: number;
    createdAt: Date;
    updatedAt: Date;
    code?: string;
    serverId?: string;
}

export interface GameConfig {
    roomId: string;
    maxPlayers: number;
    maxSpectators: number;
    nightDuration: number; // milliseconds
    dayDuration: number; // milliseconds
    votingDuration: number; // milliseconds
    allowReconnection: boolean;
    reconnectionTimeout: number; // milliseconds
}

// =============================================================================
// PLAYER INTERFACE (COMPAT√çVEL COM CLASSE Player)
// =============================================================================
export interface Player {
    id: string;
    userId: string;
    username: string;
    isHost: boolean;
    isReady: boolean;
    isSpectator: boolean;
    isConnected: boolean;
    joinedAt: Date;
    lastSeen: Date;
    avatar?: string;

    // Game-specific properties
    role?: Role;
    faction?: Faction;
    isAlive?: boolean;
    isProtected?: boolean;
    hasActed?: boolean;
    hasVoted?: boolean;
    votedFor?: string;
    actionsUsed?: number;
    maxActions?: number;
    lastAction?: string;
    eliminationReason?: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER';
    killedBy?: string;
}

// =============================================================================
// GAME STATE INTERFACE (COMPAT√çVEL COM CLASSE GameState)
// ‚úÖ MUDAN√áA CHAVE: Usar estruturas que a classe realmente usa
// =============================================================================
export interface GameState {
    gameId: string;
    roomId: string;
    status: GameStatus;
    phase: GamePhase;
    day: number;
    phaseStartTime: Date;
    phaseEndTime: Date;
    timeLeft: number;

    // ‚úÖ IMPORTANTE: Compat√≠vel com a classe real que usa Map
    players: Player[]; // Para serializa√ß√£o JSON
    spectators: string[]; // IDs dos espectadores  
    eliminatedPlayers: Player[];

    hostId: string;
    events: GameEvent[];
    votes: Record<string, string>; // Para serializa√ß√£o JSON - voterId -> targetId
    nightActions: NightAction[];
    config: GameConfig;
    createdAt: Date;
    updatedAt: Date;
    startedAt?: Date;
    finishedAt?: Date;
    winningFaction?: Faction;
    winningPlayers?: string[];
}

export interface GameEvent {
    id: string;
    type: string;
    phase: GamePhase;
    day: number;
    timestamp: Date;
    data: any;
    visibleTo?: string[]; // If undefined, visible to all
}

export interface NightAction {
    playerId: string;
    type: string;
    targetId?: string;
    data?: any;
    priority: number;
}

// =============================================================================
// GAME ENGINE INTERFACES
// =============================================================================
export interface IGameEngine {
    // Game lifecycle
    createGame(hostId: string, config: GameConfig): Promise<GameState>;
    startGame(gameId: string): Promise<boolean>;
    endGame(gameId: string, reason?: string): Promise<void>;

    // Player management
    addPlayer(gameId: string, player: Player): Promise<boolean>;
    removePlayer(gameId: string, playerId: string): Promise<boolean>;

    // Game state
    getGameState(gameId: string): Promise<GameState | null>;
    updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;

    // Actions
    performPlayerAction(gameId: string, playerId: string, action: any): Promise<boolean>;

    // Phase management
    nextPhase(gameId: string): Promise<void>;

    // Events
    onGameEvent(gameId: string, event: string, handler: (data: any) => void): void;

    // Voting
    castVote?(gameId: string, voterId: string, targetId: string): Promise<boolean>;
    removeVote?(gameId: string, voterId: string): Promise<boolean>;

    // Administrative
    getActiveGamesCount?(): number;
    getAllGames?(): GameState[];
    getGamesByRoom?(roomId: string): Promise<GameState[]>;
    forceEndGame?(gameId: string, reason: string): Promise<boolean>;
    getGameStats?(gameId: string): any;
    cleanup?(): Promise<void>;
}

// =============================================================================
// ROLE SYSTEM TYPES (IMPORTADOS DE RoleSystem.ts)
// =============================================================================
export interface RoleConfiguration {
    role: Role;
    faction: Faction;
    name: string;
    description: string;
    abilities: string[];
    goalDescription: string;
    canAct: boolean;
    actsDuring: string[];
    hasNightChat: boolean;
    immuneToInvestigation: boolean;
    maxActions?: number;
    priority: number;
}

export type RoleDistribution = Record<Role, number>;

// =============================================================================
// ACTION SYSTEM TYPES
// =============================================================================
export interface GameAction {
    id: string;
    playerId: string;
    type: string;
    targetId?: string;
    data?: any;
    timestamp: Date;
    phase: string;
    day: number;
    priority: number;
    isValid: boolean;
    processed: boolean;
}

export interface ActionResult {
    success: boolean;
    actionId: string;
    message?: string;
    data?: any;
    errors?: string[];
}

// =============================================================================
// TIMER SYSTEM TYPES
// =============================================================================
export interface GameTimer {
    id: string;
    type: 'PHASE' | 'WARNING' | 'CUSTOM';
    startTime: number;
    duration: number;
    remaining: number;
    isActive: boolean;
    callback?: () => void;
    timeout?: NodeJS.Timeout; // ‚úÖ Nome correto
}

// =============================================================================
// SERVICE INTERFACES (CORRIGIDOS)
// =============================================================================
export interface ServiceMetadata {
    id: string;
    type: 'lobby' | 'game' | 'chat' | 'monolith';
    host: string;
    port: number;
    capabilities: string[];
    status: 'healthy' | 'unhealthy';
    lastHeartbeat: Date;
    maxRooms?: number;
    currentRooms?: number;
}

export interface IEventBus {
    publish<T>(channel: string, event: T): Promise<void>;
    subscribe<T>(channel: string, handler: (event: T) => void): Promise<void>;
    unsubscribe(channel: string, handler?: Function): Promise<void>;
    healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

export interface IServiceRegistry {
    registerService(serviceId: string, metadata: ServiceMetadata): Promise<void>;
    getAvailableServices(serviceType: string): Promise<string[]>;
    unregisterService(serviceId: string): Promise<void>;
    getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null>;
    healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// ‚úÖ INTERFACE CORRIGIDA - Agora retorna GameState em vez de Game inexistente
export interface IGameStateService {
    createGame(hostId: string, config: GameConfig): Promise<GameState>;
    getGame(gameId: string): Promise<GameState | null>;
    updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;
    deleteGame(gameId: string): Promise<void>;
    addPlayer(gameId: string, player: Player): Promise<void>;
    removePlayer(gameId: string, playerId: string): Promise<void>;
    updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void>;
    getGameState(gameId: string): Promise<GameState | null>;
    getPlayer(gameId: string, playerId: string): Promise<Player | null>;
    getAllPlayers(gameId: string): Promise<Player[]>;
    getGamesByRoom(roomId: string): Promise<GameState[]>;
    getActiveGamesCount(): Promise<number>;
    cleanup?(): number;
    healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// =============================================================================
// WIN CONDITION TYPES
// =============================================================================
export interface WinCondition {
    hasWinner: boolean;
    winningFaction?: Faction;
    winningPlayers?: string[];
    reason?: string;
}

// =============================================================================
// GAME STATISTICS TYPES
// =============================================================================
export interface GameStats {
    gameId: string;
    status: GameStatus;
    phase: GamePhase;
    day: number;
    playerCount: number;
    aliveCount: number;
    spectatorCount: number;
    timeLeft: number;
    events: number;
}

export interface GameResults {
    gameId: string;
    roomId: string;
    duration: number;
    totalDays: number;
    winningFaction?: Faction;
    winningPlayers: string[];
    players: PlayerResult[];
    events: GameEvent[];
}

export interface PlayerResult {
    id: string;
    userId: string;
    username: string;
    role?: Role;
    faction?: Faction;
    survived: boolean;
    won: boolean;
    eliminationReason?: string;
    killedBy?: string;
}

// =============================================================================
// PHASE MANAGER TYPES
// =============================================================================
export interface PhaseTransition {
    from: GamePhase;
    to: GamePhase;
    duration: number;
    reason?: string;
}

export interface NightResults {
    protections: string[];
    investigations: Array<{
        investigatorId: string;
        targetId: string;
        result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS';
    }>;
    attacks: Array<{
        attackerId: string;
        targetId: string;
        successful: boolean;
    }>;
    deaths: Array<{
        playerId: string;
        cause: string;
        killedBy?: string;
    }>;
}

// =============================================================================
// WEBSOCKET EVENT TYPES
// =============================================================================
export interface GameWebSocketEvents {
    // Game lifecycle events
    'game:created': { gameId: string; hostId: string; config: GameConfig };
    'game:started': { gameId: string; players: Player[]; distribution: RoleDistribution };
    'game:ended': { gameId: string; results: GameResults };

    // Phase events
    'phase:changed': { gameId: string; phase: GamePhase; duration: number; timeLeft: number };
    'phase:warning': { gameId: string; phase: GamePhase; timeLeft: number };

    // Player events
    'player:joined': { gameId: string; player: Player };
    'player:left': { gameId: string; playerId: string; username: string };
    'player:died': { gameId: string; playerId: string; role: Role; cause: string };
    'player:executed': { gameId: string; playerId: string; role: Role; votes: number };

    // Action events
    'action:submitted': { gameId: string; playerId: string; actionType: string };
    'action:result': { gameId: string; playerId: string; result: ActionResult };

    // Voting events
    'vote:cast': { gameId: string; voterId: string; targetId: string; voteCounts: Record<string, number> };
    'vote:removed': { gameId: string; voterId: string; voteCounts: Record<string, number> };
}

// =============================================================================
// WEBSOCKET MESSAGE TYPES
// =============================================================================
export interface ClientToServerEvents {
    // Room events
    'join-room': { roomId: string; asSpectator?: boolean };
    'leave-room': { roomId?: string };
    'player-ready': { ready: boolean };
    'start-game': {};

    // Game actions
    'game-action': { type: string; targetId?: string; data?: any };
    'vote': { targetId: string };
    'unvote': {};

    // Chat events
    'chat-message': { message: string; channel?: string };

    // Werewolf coordination
    'werewolf-kill-vote': { targetId: string };

    // Admin events
    'kick-player': { playerId: string };
    'force-phase': {};
    'extend-time': { additionalTime: number };
}

export interface ServerToClientEvents {
    // Connection events
    'connected': { userId: string };
    'error': { code: WebSocketErrorCode; message: string };

    // Room events
    'room-joined': { room: Room; player: Player; yourRole: string };
    'room-left': { roomId: string };
    'player-joined': { player: Player };
    'player-left': { userId: string; username: string };
    'player-ready': { userId: string; username: string; ready: boolean };

    // Game events
    'game-starting': { countdown: number };
    'game-started': { gameId: string; players: Player[]; spectators: Player[] };
    'game-state': GameState;
    'game-ended': { results: GameResults };

    // Phase events
    'phase-changed': { phase: GamePhase; timeLeft: number; day: number };
    'phase-warning': { timeLeft: number };

    // Action events
    'action-confirmed': { actionType: string; message: string };
    'action-failed': { actionType: string; error: string };

    // Voting events
    'voting-update': { votes: Record<string, string>; counts: Record<string, number> };
    'execution-result': { executedId?: string; executedName?: string; executedRole?: Role };

    // Night events
    'night-results': { deaths: any[]; messages: string[] };
    'investigation-result': { targetName: string; result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS' };

    // Chat events
    'chat-message': { userId: string; username: string; message: string; channel: string; timestamp: string };

    // Role-specific events
    'role-assigned': { role: Role; faction: Faction; abilities: string[] };
    'werewolf-chat': { senderId: string; senderName: string; message: string };
}
</file>

<file path="backend/src/utils/validators.ts">
// üê∫ LOBISOMEM ONLINE - Validation Utilities
// Input validation and sanitization functions
import { z } from 'zod';
import { GAME_LIMITS } from './constants';

//====================================================================
// BASIC VALIDATION SCHEMAS
//====================================================================
// User validation
export const emailSchema = z
  .string()
  .email('Email inv√°lido')
  .toLowerCase()
  .trim();

export const usernameSchema = z
  .string()
  .min(3, 'Username deve ter pelo menos 3 caracteres')
  .max(20, 'Username deve ter no m√°ximo 20 caracteres')
  .regex(/^[a-zA-Z0-9_-]+$/, 'Username s√≥ pode conter letras, n√∫meros, _ e -')
  .trim();

export const passwordSchema = z
  .string()
  .min(6, 'Senha deve ter pelo menos 6 caracteres')
  .max(50, 'Senha deve ter no m√°ximo 50 caracteres')
  .regex(/(?=.*[a-z])/, 'Senha deve conter pelo menos uma letra min√∫scula')
  .regex(/(?=.*[A-Z])/, 'Senha deve conter pelo menos uma letra mai√∫scula')
  .regex(/(?=.*\d)/, 'Senha deve conter pelo menos um n√∫mero');

// Room validation
export const roomNameSchema = z
  .string()
  .min(1, 'Nome da sala √© obrigat√≥rio')
  .max(GAME_LIMITS.MAX_ROOM_NAME_LENGTH, `Nome deve ter no m√°ximo ${GAME_LIMITS.MAX_ROOM_NAME_LENGTH} caracteres`)
  .trim();

export const roomCodeSchema = z
  .string()
  .length(GAME_LIMITS.ROOM_CODE_LENGTH, `C√≥digo deve ter ${GAME_LIMITS.ROOM_CODE_LENGTH} d√≠gitos`)
  .regex(/^\d+$/, 'C√≥digo deve conter apenas n√∫meros');

// Chat validation
export const chatMessageSchema = z
  .string()
  .min(1, 'Mensagem n√£o pode estar vazia')
  .max(GAME_LIMITS.MAX_MESSAGE_LENGTH, `Mensagem deve ter no m√°ximo ${GAME_LIMITS.MAX_MESSAGE_LENGTH} caracteres`)
  .trim();

//====================================================================
// AUTH REQUEST SCHEMAS
//====================================================================
export const registerRequestSchema = z.object({
  email: emailSchema,
  username: usernameSchema,
  password: passwordSchema,
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Senhas n√£o coincidem',
  path: ['confirmPassword'],
});

export const loginRequestSchema = z.object({
  email: emailSchema,
  password: z.string().min(1, 'Senha √© obrigat√≥ria'),
});

export const forgotPasswordSchema = z.object({
  email: emailSchema,
});

export const resetPasswordSchema = z.object({
  token: z.string().min(1, 'Token √© obrigat√≥rio'),
  password: passwordSchema,
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Senhas n√£o coincidem',
  path: ['confirmPassword'],
});

//====================================================================
// ROOM REQUEST SCHEMAS
//====================================================================
export const createRoomSchema = z.object({
  name: roomNameSchema,
  isPrivate: z.boolean().optional().default(false),
  maxPlayers: z
    .number()
    .min(GAME_LIMITS.MIN_PLAYERS, `M√≠nimo ${GAME_LIMITS.MIN_PLAYERS} jogadores`)
    .max(GAME_LIMITS.MAX_PLAYERS, `M√°ximo ${GAME_LIMITS.MAX_PLAYERS} jogadores`)
    .optional()
    .default(GAME_LIMITS.MAX_PLAYERS),
  maxSpectators: z
    .number()
    .min(0, 'N√∫mero de espectadores n√£o pode ser negativo')
    .max(GAME_LIMITS.MAX_SPECTATORS, `M√°ximo ${GAME_LIMITS.MAX_SPECTATORS} espectadores`)
    .optional()
    .default(GAME_LIMITS.MAX_SPECTATORS),
});

export const joinRoomSchema = z.object({
  roomId: z.string().cuid().optional(),
  code: roomCodeSchema.optional(),
  asSpectator: z.boolean().optional().default(false),
}).refine((data) => data.roomId || data.code, {
  message: 'Room ID ou c√≥digo √© obrigat√≥rio',
});

export const updateRoomSchema = z.object({
  name: roomNameSchema.optional(),
  maxPlayers: z
    .number()
    .min(GAME_LIMITS.MIN_PLAYERS)
    .max(GAME_LIMITS.MAX_PLAYERS)
    .optional(),
  maxSpectators: z
    .number()
    .min(0)
    .max(GAME_LIMITS.MAX_SPECTATORS)
    .optional(),
});

//====================================================================
// GAME REQUEST SCHEMAS
//====================================================================
export const gameActionSchema = z.object({
  type: z.enum(['INVESTIGATE', 'PROTECT', 'KILL', 'VOTE']),
  targetId: z.string().cuid().optional(),
  data: z.record(z.any()).optional(),
});

export const voteSchema = z.object({
  targetId: z.string().cuid('ID do alvo inv√°lido'),
});

//====================================================================
// CHAT SCHEMAS
//====================================================================
export const chatMessageRequestSchema = z.object({
  message: chatMessageSchema,
  channel: z.enum(['public', 'werewolf', 'spectator']).optional().default('public'),
});

//====================================================================
// PAGINATION SCHEMAS
//====================================================================
export const paginationSchema = z.object({
  page: z
    .string()
    .transform((val) => parseInt(val))
    .pipe(z.number().min(1, 'P√°gina deve ser maior que 0'))
    .optional()
    .default('1'),
  limit: z
    .string()
    .transform((val) => parseInt(val))
    .pipe(z.number().min(1).max(100, 'Limite m√°ximo de 100 itens por p√°gina'))
    .optional()
    .default('10'),
  sortBy: z.string().optional(),
  sortOrder: z.enum(['asc', 'desc']).optional().default('desc'),
});

//====================================================================
// CUSTOM VALIDATION FUNCTIONS
//====================================================================
/**
 * Validate if a string is a valid CUID
 */
export function isValidCuid(id: string): boolean {
  return z.string().cuid().safeParse(id).success;
}

/**
 * Validate if a user can perform an action in a game
 */
export function canPerformAction(
  role: string,
  phase: string,
  action: string
): boolean {
  const nightActions = ['INVESTIGATE', 'PROTECT', 'KILL'];
  const dayActions = ['VOTE'];

  if (phase === 'NIGHT' && nightActions.includes(action)) {
    return ['SHERIFF', 'DOCTOR', 'WEREWOLF', 'WEREWOLF_KING', 'VIGILANTE', 'SERIAL_KILLER'].includes(role);
  }

  if (phase === 'VOTING' && action === 'VOTE') {
    return true; // Everyone can vote
  }

  return false;
}

/**
 * Validate room code format
 */
export function generateRoomCode(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

/**
 * Sanitize chat message (remove harmful content)
 */
export function sanitizeChatMessage(message: string): string {
  return message
    .trim()
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // Remove script tags
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .substring(0, GAME_LIMITS.MAX_MESSAGE_LENGTH);
}

/**
 * Validate if email domain is allowed
 */
export function isAllowedEmailDomain(email: string): boolean {
  // Add email domain restrictions if needed
  const blockedDomains = ['tempmail.com', '10minutemail.com'];
  const domain = email.split('@')[1];
  if (!domain) return false;
  return !blockedDomains.includes(domain.toLowerCase());
}

/**
 * Validate username availability pattern
 */
export function hasValidUsernamePattern(username: string): boolean {
  // Block offensive patterns
  const blockedPatterns = [
    /admin/i,
    /moderator/i,
    /system/i,
    /bot/i,
    /fuck/i,
    /shit/i,
    // Add more as needed
  ];

  return !blockedPatterns.some(pattern => pattern.test(username));
}

/**
 * Rate limiting validation
 */
export function validateRateLimit(
  requests: number,
  windowMs: number,
  maxRequests: number
): { allowed: boolean; retryAfter?: number } {
  if (requests >= maxRequests) {
    return {
      allowed: false,
      retryAfter: windowMs,
    };
  }

  return { allowed: true };
}

//====================================================================
// WEBSOCKET VALIDATION
//====================================================================
export const websocketMessageSchema = z.object({
  type: z.string().min(1, 'Message type is required'),
  data: z.any().optional(),
  timestamp: z.string().optional(),
  messageId: z.string().optional(),
});

//====================================================================
// EXPORT VALIDATION HELPER
//====================================================================
export function createValidator<T>(schema: z.ZodSchema<T>) {
  return (data: unknown): { success: true; data: T } | { success: false; errors: string[] } => {
    const result = schema.safeParse(data);

    if (result.success) {
      return { success: true, data: result.data };
    }

    const errors = result.error.errors.map(err =>
      `${err.path.join('.')}: ${err.message}`
    );

    return { success: false, errors };
  };
}
</file>

<file path="backend/src/websocket/ConnectionManager.ts">
// üê∫ LOBISOMEM ONLINE - Connection Manager (CORRIGIDO COMPLETO)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service
import { wsLogger } from '@/utils/logger';
import type { WebSocketConnection, ConnectionContext, ConnectionMetadata } from '@/types';
import type WebSocket from 'ws';

//====================================================================
// CONNECTION MANAGER CLASS
//====================================================================
export class ConnectionManager {
  private connections = new Map<string, WebSocketConnection>();

  constructor() {
    wsLogger.debug('ConnectionManager initialized');
  }

  //====================================================================
  // CONNECTION MANAGEMENT
  //====================================================================
  addConnection(
    id: string,
    ws: WebSocket,
    context: ConnectionContext,
    metadata: ConnectionMetadata
  ): WebSocketConnection {
    const connection: WebSocketConnection = {
      id,
      ws,
      context,
      metadata,
      isAlive: true,
      lastPing: Date.now(),
      reconnectAttempts: 0,
    };

    this.connections.set(id, connection);

    wsLogger.info('Connection added', {
      connectionId: id,
      userId: context.userId,
      username: context.username,
      totalConnections: this.connections.size,
    });

    return connection;
  }

  removeConnection(connectionId: string): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    this.connections.delete(connectionId);

    wsLogger.info('Connection removed', {
      connectionId,
      userId: connection.context.userId,
      username: connection.context.username,
      totalConnections: this.connections.size,
    });

    return true;
  }

  getConnection(connectionId: string): WebSocketConnection | null {
    return this.connections.get(connectionId) || null;
  }

  //====================================================================
  // ‚úÖ NOVO: ENCONTRAR CONEX√ÉO POR USER ID
  //====================================================================
  findConnectionByUserId(userId: string): WebSocketConnection | null {
    // Iterar sobre todas as conex√µes para encontrar pelo userId
    for (const [connectionId, connection] of this.connections) {
      if (connection.context.userId === userId) {
        // Verificar se a conex√£o ainda est√° v√°lida
        if (connection.ws.readyState === connection.ws.OPEN) {
          return connection;
        } else {
          // Limpar conex√£o inv√°lida
          wsLogger.warn('Found dead connection for user, cleaning up', {
            userId,
            connectionId
          });
          this.removeConnection(connectionId);
        }
      }
    }

    wsLogger.debug('No active connection found for user', { userId });
    return null;
  }

  //====================================================================
  // ‚úÖ NOVO: OBTER TODAS CONEX√ïES DE UM USU√ÅRIO
  //====================================================================
  getAllConnectionsForUser(userId: string): WebSocketConnection[] {
    const userConnections: WebSocketConnection[] = [];

    for (const [connectionId, connection] of this.connections) {
      if (connection.context.userId === userId) {
        if (connection.ws.readyState === connection.ws.OPEN) {
          userConnections.push(connection);
        } else {
          // Limpar conex√£o inv√°lida
          this.removeConnection(connectionId);
        }
      }
    }

    return userConnections;
  }

  //====================================================================
  // CONNECTION STATUS
  //====================================================================
  getAllConnections(): WebSocketConnection[] {
    return Array.from(this.connections.values());
  }

  getConnectionsCount(): number {
    return this.connections.size;
  }

  //====================================================================
  // ‚úÖ NOVO: CONTAR CONEX√ïES ATIVAS POR USU√ÅRIO
  //====================================================================
  getActiveConnectionsCount(): number {
    let activeCount = 0;

    for (const [connectionId, connection] of this.connections) {
      if (connection.ws.readyState === connection.ws.OPEN) {
        activeCount++;
      } else {
        // Aproveitar para limpar conex√µes mortas
        this.removeConnection(connectionId);
      }
    }

    return activeCount;
  }

  //====================================================================
  // CONNECTION CONTEXT UPDATES
  //====================================================================
  updateConnectionContext(connectionId: string, updates: Partial<ConnectionContext>): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    connection.context = { ...connection.context, ...updates };

    wsLogger.debug('Connection context updated', {
      connectionId,
      updates,
      newContext: connection.context,
    });

    return true;
  }

  //====================================================================
  // HEARTBEAT MANAGEMENT
  //====================================================================
  markAlive(connectionId: string): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    connection.isAlive = true;
    connection.lastPing = Date.now();

    return true;
  }

  markDead(connectionId: string): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    connection.isAlive = false;

    return true;
  }

  //====================================================================
  // HEARTBEAT CHECK
  //====================================================================
  performHeartbeatCheck(timeoutMs: number = 30000): string[] {
    const now = Date.now();
    const deadConnections: string[] = [];

    for (const [connectionId, connection] of this.connections) {
      const timeSinceLastPing = now - connection.lastPing;

      if (timeSinceLastPing > timeoutMs) {
        deadConnections.push(connectionId);
        this.markDead(connectionId);

        wsLogger.warn('Connection marked as dead due to heartbeat timeout', {
          connectionId,
          userId: connection.context.userId,
          timeSinceLastPing,
          timeoutMs,
        });
      }
    }

    return deadConnections;
  }

  //====================================================================
  // CLEANUP METHODS
  //====================================================================
  cleanupDeadConnections(): number {
    let cleanedCount = 0;

    for (const [connectionId, connection] of this.connections) {
      if (!connection.isAlive || connection.ws.readyState !== connection.ws.OPEN) {
        try {
          if (connection.ws.readyState === connection.ws.OPEN) {
            connection.ws.close();
          }
        } catch (error) {
          wsLogger.error('Error closing dead connection', error instanceof Error ? error : new Error('Unknown close error'), {
            connectionId,
          });
        }

        this.removeConnection(connectionId);
        cleanedCount++;
      }
    }

    if (cleanedCount > 0) {
      wsLogger.info('Cleaned up dead connections', {
        cleanedCount,
        remainingConnections: this.connections.size,
      });
    }

    return cleanedCount;
  }


  public getDeadConnections(): string[] {
    const dead: string[] = [];
    for (const [connectionId, connection] of this.connections.entries()) {
      if (!connection.isAlive) {
        dead.push(connectionId);
      }
    }
    return dead;
  }
  //====================================================================
  // UTILITY METHODS
  //====================================================================
  getConnectionsByRoom(roomId: string): WebSocketConnection[] {
    return Array.from(this.connections.values()).filter(
      connection => connection.context.roomId === roomId
    );
  }

  getConnectionsByServerId(serverId: string): WebSocketConnection[] {
    return Array.from(this.connections.values()).filter(
      connection => connection.context.serverId === serverId
    );
  }

  //====================================================================
  // STATISTICS
  //====================================================================
  getConnectionStats(): {
    total: number;
    alive: number;
    dead: number;
    byRoom: Record<string, number>;
    byServer: Record<string, number>;
  } {
    const stats = {
      total: 0,
      alive: 0,
      dead: 0,
      byRoom: {} as Record<string, number>,
      byServer: {} as Record<string, number>,
    };

    for (const connection of this.connections.values()) {
      stats.total++;

      if (connection.isAlive) {
        stats.alive++;
      } else {
        stats.dead++;
      }

      // Count by room
      if (connection.context.roomId) {
        stats.byRoom[connection.context.roomId] = (stats.byRoom[connection.context.roomId] || 0) + 1;
      }

      // Count by server
      stats.byServer[connection.context.serverId] = (stats.byServer[connection.context.serverId] || 0) + 1;
    }

    return stats;
  }

  //====================================================================
  // GRACEFUL SHUTDOWN
  //====================================================================
  async shutdown(): Promise<void> {
    wsLogger.info('Starting ConnectionManager shutdown', {
      totalConnections: this.connections.size,
    });

    const closePromises: Promise<void>[] = [];

    for (const [connectionId, connection] of this.connections) {
      const closePromise = new Promise<void>((resolve) => {
        if (connection.ws.readyState === connection.ws.OPEN) {
          connection.ws.close(1000, 'Server shutdown');

          connection.ws.once('close', () => {
            wsLogger.debug('Connection closed during shutdown', { connectionId });
            resolve();
          });

          // Timeout for graceful close
          setTimeout(() => {
            if (connection.ws.readyState !== connection.ws.CLOSED) {
              connection.ws.terminate();
              wsLogger.warn('Connection forcefully terminated during shutdown', { connectionId });
            }
            resolve();
          }, 5000);
        } else {
          resolve();
        }
      });

      closePromises.push(closePromise);
    }

    // Wait for all connections to close
    await Promise.all(closePromises);

    // Clear all connections
    this.connections.clear();

    wsLogger.info('ConnectionManager shutdown completed');
  }
}
</file>

<file path="backend/src/websocket/ServiceFactory.ts">
// üê∫ LOBISOMEM ONLINE - Service Factory (REFATORADO)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí microservices
import { config } from '@/config/environment';
import { getRedisClient } from '@/config/redis';
import { logger } from '@/utils/logger';
import { GameState, Player } from '@/game/Game'; // ‚úÖ Usar classe real
import type {
    IGameStateService,
    IEventBus,
    IServiceRegistry,
    GameConfig,
    ServiceMetadata
} from '@/types';

//====================================================================
// MEMORY IMPLEMENTATIONS (PHASE 1) - CORRIGIDAS
//====================================================================

class MemoryGameStateService implements IGameStateService {
    private games = new Map<string, GameState>(); // ‚úÖ Usar GameState n√£o Game
    private players = new Map<string, Map<string, Player>>();

    async createGame(hostId: string, config: GameConfig): Promise<GameState> {
        const gameId = `game-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        // ‚úÖ Criar GameState real
        const gameState = new GameState(gameId, config, hostId);

        this.games.set(gameId, gameState);
        this.players.set(gameId, new Map());

        logger.info('Game created in memory', { gameId, hostId });
        return gameState;
    }

    async getGame(gameId: string): Promise<GameState | null> {
        return this.games.get(gameId) || null;
    }

    async updateGameState(gameId: string, updates: Partial<GameState>): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) throw new Error(`Game ${gameId} not found`);

        // ‚úÖ Aplicar updates na classe real
        Object.assign(gameState, updates);
        gameState.updatedAt = new Date();
    }

    async deleteGame(gameId: string): Promise<void> {
        this.games.delete(gameId);
        this.players.delete(gameId);
        logger.info('Game deleted from memory', { gameId });
    }

    async addPlayer(gameId: string, player: Player): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) throw new Error(`Game ${gameId} not found`);

        // ‚úÖ Usar m√©todo da classe GameState
        const success = gameState.addPlayer(player);
        if (!success) {
            throw new Error('Failed to add player to game');
        }

        // Manter cache de players para queries r√°pidas
        const gamePlayers = this.players.get(gameId)!;
        gamePlayers.set(player.id, player);
    }

    async removePlayer(gameId: string, playerId: string): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) return;

        gameState.removePlayer(playerId);

        const gamePlayers = this.players.get(gameId);
        if (gamePlayers) {
            gamePlayers.delete(playerId);
        }
    }

    async updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) return;

        const player = gameState.getPlayer(playerId);
        if (player) {
            Object.assign(player, updates);
        }

        // Atualizar cache tamb√©m
        const gamePlayers = this.players.get(gameId);
        if (gamePlayers) {
            const cachedPlayer = gamePlayers.get(playerId);
            if (cachedPlayer) {
                Object.assign(cachedPlayer, updates);
            }
        }
    }

    async getGameState(gameId: string): Promise<GameState | null> {
        // ‚úÖ Retornar o estado real da classe
        return this.games.get(gameId) || null;
    }

    async getPlayer(gameId: string, playerId: string): Promise<Player | null> {
        const gameState = this.games.get(gameId);
        return gameState?.getPlayer(playerId) || null;
    }

    async getAllPlayers(gameId: string): Promise<Player[]> {
        const gameState = this.games.get(gameId);
        return gameState ? gameState.players : [];
    }

    async getGamesByRoom(roomId: string): Promise<GameState[]> {
        const games: GameState[] = [];
        for (const gameState of this.games.values()) {
            if (gameState.roomId === roomId) {
                games.push(gameState);
            }
        }
        return games;
    }

    async getActiveGamesCount(): Promise<number> {
        let count = 0;
        for (const gameState of this.games.values()) {
            if (gameState.status === 'PLAYING' || gameState.status === 'STARTING') {
                count++;
            }
        }
        return count;
    }

    cleanup(): number {
        const count = this.games.size;
        this.games.clear();
        this.players.clear();
        return count;
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return {
            status: 'healthy',
            message: `Memory storage OK - ${this.games.size} games active`
        };
    }
}

class LocalEventBus implements IEventBus {
    private listeners = new Map<string, Array<(event: any) => void>>();

    async publish<T>(channel: string, event: T): Promise<void> {
        const channelListeners = this.listeners.get(channel) || [];
        for (const listener of channelListeners) {
            try {
                listener(event);
            } catch (error) {
                logger.error('Error in event listener', error instanceof Error ? error : new Error('Unknown listener error'), {
                    channel,
                    event: typeof event === 'object' ? JSON.stringify(event) : String(event)
                });
            }
        }
    }

    async subscribe<T>(channel: string, handler: (event: T) => void): Promise<void> {
        if (!this.listeners.has(channel)) {
            this.listeners.set(channel, []);
        }
        this.listeners.get(channel)!.push(handler);
    }

    async unsubscribe(channel: string): Promise<void> {
        this.listeners.delete(channel);
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return {
            status: 'healthy',
            message: `Local EventBus OK - ${this.listeners.size} channels`
        };
    }
}

class MockServiceRegistry implements IServiceRegistry {
    private services = new Map<string, ServiceMetadata>();

    async registerService(serviceId: string, metadata: ServiceMetadata): Promise<void> {
        this.services.set(serviceId, metadata);
        logger.debug('Service registered', { serviceId, type: metadata.type });
    }

    async getAvailableServices(serviceType: string): Promise<string[]> {
        const services: string[] = [];
        for (const [serviceId, metadata] of this.services.entries()) {
            if (metadata.type === serviceType) {
                services.push(serviceId);
            }
        }
        return services;
    }

    async unregisterService(serviceId: string): Promise<void> {
        this.services.delete(serviceId);
        logger.debug('Service unregistered', { serviceId });
    }

    async getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null> {
        return this.services.get(serviceId) || null;
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return {
            status: 'healthy',
            message: `Mock Registry OK - ${this.services.size} services`
        };
    }
}

//====================================================================
// REDIS IMPLEMENTATIONS (PHASE 2) - PLACEHOLDERS CORRIGIDOS
//====================================================================

class RedisGameStateService implements IGameStateService {
    constructor(private redisUrl: string) { }

    async createGame(hostId: string, config: GameConfig): Promise<GameState> {
        // TODO: Implementar Redis
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getGame(gameId: string): Promise<GameState | null> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async updateGameState(gameId: string, updates: Partial<GameState>): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async deleteGame(gameId: string): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async addPlayer(gameId: string, player: Player): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async removePlayer(gameId: string, playerId: string): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getGameState(gameId: string): Promise<GameState | null> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getPlayer(gameId: string, playerId: string): Promise<Player | null> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getAllPlayers(gameId: string): Promise<Player[]> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getGamesByRoom(roomId: string): Promise<GameState[]> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getActiveGamesCount(): Promise<number> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    cleanup(): number {
        return 0;
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return { status: 'unhealthy', message: 'Redis GameStateService not implemented' };
    }
}

class RedisEventBus implements IEventBus {
    constructor(private redisUrl: string) { }

    async publish<T>(channel: string, event: T): Promise<void> {
        // TODO: Implementar Redis Pub/Sub
        throw new Error('Redis EventBus not implemented yet');
    }

    async subscribe<T>(channel: string, handler: (event: T) => void): Promise<void> {
        throw new Error('Redis EventBus not implemented yet');
    }

    async unsubscribe(channel: string): Promise<void> {
        throw new Error('Redis EventBus not implemented yet');
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return { status: 'unhealthy', message: 'Redis EventBus not implemented' };
    }
}

class RedisServiceRegistry implements IServiceRegistry {
    constructor(private redisUrl: string) { }

    async registerService(serviceId: string, metadata: ServiceMetadata): Promise<void> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async getAvailableServices(serviceType: string): Promise<string[]> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async unregisterService(serviceId: string): Promise<void> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return { status: 'unhealthy', message: 'Redis ServiceRegistry not implemented' };
    }
}

//====================================================================
// SERVICE FACTORY - CORRIGIDA
//====================================================================

export class ServiceFactory {
    private static instances = new Map<string, any>();

    static getGameStateService(): IGameStateService {
        if (!this.instances.has('gameState')) {
            const service = config.STORAGE_TYPE === 'redis'
                ? new RedisGameStateService(config.REDIS_URL)
                : new MemoryGameStateService();
            this.instances.set('gameState', service);
            logger.info('GameStateService initialized', { type: config.STORAGE_TYPE });
        }
        return this.instances.get('gameState');
    }

    static getEventBus(): IEventBus {
        if (!this.instances.has('eventBus')) {
            const bus = config.DISTRIBUTED_MODE
                ? new RedisEventBus(config.REDIS_URL)
                : new LocalEventBus();
            this.instances.set('eventBus', bus);
            logger.info('EventBus initialized', { type: config.DISTRIBUTED_MODE ? 'redis' : 'local' });
        }
        return this.instances.get('eventBus');
    }

    static getServiceRegistry(): IServiceRegistry {
        if (!this.instances.has('serviceRegistry')) {
            const registry = config.DISTRIBUTED_MODE
                ? new RedisServiceRegistry(config.REDIS_URL)
                : new MockServiceRegistry();
            this.instances.set('serviceRegistry', registry);
            logger.info('ServiceRegistry initialized', { type: config.DISTRIBUTED_MODE ? 'redis' : 'mock' });
        }
        return this.instances.get('serviceRegistry');
    }

    static async getServicesHealth(): Promise<Record<string, any>> {
        const health: Record<string, any> = {};
        const services = [
            { name: 'gameState', service: this.getGameStateService() },
            { name: 'eventBus', service: this.getEventBus() },
            { name: 'serviceRegistry', service: this.getServiceRegistry() },
        ];

        for (const { name, service } of services) {
            try {
                if (service.healthCheck) {
                    health[name] = await service.healthCheck();
                } else {
                    health[name] = { status: 'healthy', message: 'No health check available' };
                }
            } catch (error) {
                health[name] = {
                    status: 'unhealthy',
                    message: error instanceof Error ? error.message : 'Unknown error'
                };
            }
        }
        return health;
    }

    static getServicesStats(): Record<string, any> {
        return {
            gameState: {
                type: config.STORAGE_TYPE,
                distributed: config.DISTRIBUTED_MODE
            },
            eventBus: {
                type: config.DISTRIBUTED_MODE ? 'redis' : 'local'
            },
            serviceRegistry: {
                type: config.DISTRIBUTED_MODE ? 'redis' : 'mock'
            }
        };
    }

    static async cleanup(): Promise<void> {
        const gameStateService = this.getGameStateService();
        if (gameStateService.cleanup) {
            const cleanedCount = gameStateService.cleanup();
            logger.info('GameStateService cleanup completed', { cleanedCount });
        }

        this.instances.clear();
        logger.info('ServiceFactory instances cleared');
    }

    static clearInstances(): void {
        this.instances.clear();
        logger.info('ServiceFactory instances cleared');
    }
}
</file>

<file path="database/init.sql">
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";


CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW."updatedAt" = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION calculate_win_rate(total_wins INTEGER, total_games INTEGER)
RETURNS DECIMAL(5,4) AS $$
BEGIN
    IF total_games = 0 THEN
        RETURN 0.0;
    END IF;
    RETURN ROUND((total_wins::DECIMAL / total_games::DECIMAL), 4);
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION generate_room_code()
RETURNS TEXT AS $$
BEGIN
    RETURN LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;


CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(50) UNIQUE NOT NULL,
    "passwordHash" TEXT NOT NULL,
    avatar TEXT,
    level INTEGER DEFAULT 1 NOT NULL,
    "totalGames" INTEGER DEFAULT 0 NOT NULL,
    "totalWins" INTEGER DEFAULT 0 NOT NULL,
    "totalLosses" INTEGER DEFAULT 0 NOT NULL,
    "winRate" DECIMAL(5, 4) DEFAULT 0.0000 NOT NULL,
    "createdAt" TIMESTAMPTZ DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ DEFAULT NOW(),
    "lastLoginAt" TIMESTAMPTZ
);


CREATE TABLE IF NOT EXISTS rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    code VARCHAR(6) UNIQUE,
    "isPrivate" BOOLEAN DEFAULT false NOT NULL,
    "maxPlayers" INTEGER DEFAULT 15 NOT NULL,
    "maxSpectators" INTEGER DEFAULT 5 NOT NULL,
    status VARCHAR(20) DEFAULT 'WAITING' NOT NULL,
    "hostId" UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL,
    "serverId" VARCHAR(50) DEFAULT 'local-server',
    "createdAt" TIMESTAMPTZ DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ DEFAULT NOW()
);



DROP TRIGGER IF EXISTS update_users_updated_at ON users;
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_rooms_updated_at ON rooms;
CREATE TRIGGER update_rooms_updated_at
    BEFORE UPDATE ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
CREATE INDEX IF NOT EXISTS idx_rooms_code ON rooms(code);
CREATE INDEX IF NOT EXISTS idx_rooms_status ON rooms(status);


SELECT 'Database initialized successfully!' as status;
</file>

<file path="frontend/.env.example">
# üê∫ WEREWOLF - Frontend Environment Variables

# =============================================================================
# API CONFIGURATION
# =============================================================================
# URL base da API do backend
NEXT_PUBLIC_API_URL=http://localhost:3001

# URL do WebSocket
NEXT_PUBLIC_WS_URL=ws://localhost:3001

# =============================================================================
# APPLICATION SETTINGS
# =============================================================================
# Ambiente da aplica√ß√£o
NODE_ENV=development

# URL base do site (para SEO e Open Graph)
NEXT_PUBLIC_SITE_URL=http://localhost:3000

# Nome da aplica√ß√£o
NEXT_PUBLIC_APP_NAME=Werewolf

# =============================================================================
# ERROR TRACKING (OPCIONAL)
# =============================================================================
# Sentry DSN para tracking de erros
NEXT_PUBLIC_SENTRY_DSN=

# =============================================================================
# FEATURE FLAGS
# =============================================================================
# Habilitar PWA (Progressive Web App)
NEXT_PUBLIC_ENABLE_PWA=false

# Habilitar Service Worker
NEXT_PUBLIC_ENABLE_SW=false

# Modo de debug para desenvolvimento
NEXT_PUBLIC_DEBUG=false

# =============================================================================
# SOCIAL & SEO
# =============================================================================
# Meta tags para redes sociais
NEXT_PUBLIC_FACEBOOK_APP_ID=

# =============================================================================
# GAME SETTINGS
# =============================================================================
# Configura√ß√µes do jogo que podem ser alteradas pelo frontend
NEXT_PUBLIC_MAX_USERNAME_LENGTH=20
NEXT_PUBLIC_MIN_USERNAME_LENGTH=3
NEXT_PUBLIC_MAX_ROOM_NAME_LENGTH=30

# =============================================================================
# AUDIO SETTINGS
# =============================================================================
# Configura√ß√µes de √°udio padr√£o
NEXT_PUBLIC_DEFAULT_MUSIC_VOLUME=0.3
NEXT_PUBLIC_DEFAULT_SFX_VOLUME=0.7
NEXT_PUBLIC_AUDIO_ENABLED_DEFAULT=true

# =============================================================================
# DEVELOPMENT ONLY
# =============================================================================
# Mostrar informa√ß√µes de debug no console
NEXT_PUBLIC_SHOW_DEBUG_INFO=true

# Credenciais de teste (apenas em desenvolvimento)
NEXT_PUBLIC_DEMO_EMAIL=demo@werewolf.com
NEXT_PUBLIC_DEMO_PASSWORD=demo123

# =============================================================================
# EXTERNAL SERVICES (FUTURO)
# =============================================================================
# CDN para assets est√°ticos
NEXT_PUBLIC_CDN_URL=

# API de upload de imagens
NEXT_PUBLIC_UPLOAD_API_URL=

# =============================================================================
# WEBSOCKET CONFIGURATION
# =============================================================================
# Timeout para reconex√£o do WebSocket (ms)
NEXT_PUBLIC_WS_RECONNECT_TIMEOUT=5000

# M√°ximo de tentativas de reconex√£o
NEXT_PUBLIC_WS_MAX_RECONNECT_ATTEMPTS=5

# Intervalo do heartbeat (ms)
NEXT_PUBLIC_WS_HEARTBEAT_INTERVAL=30000

# ‚úÖ ADICIONADO: Configura√ß√µes WebSocket espec√≠ficas do servidor
# Intervalo do heartbeat do servidor (ms)
WS_HEARTBEAT_INTERVAL=30000

# Timeout do ping (ms)
WS_PING_TIMEOUT=10000

# M√°ximo de tentativas de reconex√£o do servidor
WS_MAX_RECONNECT_ATTEMPTS=5

# =============================================================================
# UI CONFIGURATION
# =============================================================================
# Tema padr√£o (dark/light)
NEXT_PUBLIC_DEFAULT_THEME=dark

# Idioma padr√£o
NEXT_PUBLIC_DEFAULT_LOCALE=pt-BR

# Timezone padr√£o
NEXT_PUBLIC_DEFAULT_TIMEZONE=America/Sao_Paulo

# =============================================================================
# PERFORMANCE
# =============================================================================
# Tamanho m√°ximo de upload (em bytes)
NEXT_PUBLIC_MAX_UPLOAD_SIZE=5242880

# Cache TTL para requests da API (ms)
NEXT_PUBLIC_API_CACHE_TTL=300000

# =============================================================================
# SECURITY
# =============================================================================
# Dom√≠nios permitidos para CORS (separados por v√≠rgula)
NEXT_PUBLIC_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001

# Habilitar HTTPS em produ√ß√£o
NEXT_PUBLIC_FORCE_HTTPS=false
</file>

<file path="frontend/src/components/common/Button.tsx">
'use client';

import { forwardRef } from 'react';
import { clsx } from 'clsx';
import { useTheme } from '@/context/ThemeContext';
import { ButtonProps } from '@/types';

// =============================================================================
// LOADING SPINNER COMPONENT (Inline para evitar depend√™ncias)
// =============================================================================
const Spinner = ({ className }: { className?: string }) => (
  <svg
    className={clsx('animate-spin', className)}
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
  >
    <circle
      className="opacity-25"
      cx="12"
      cy="12"
      r="10"
      stroke="currentColor"
      strokeWidth="4"
    />
    <path
      className="opacity-75"
      fill="currentColor"
      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
    />
  </svg>
);

// =============================================================================
// BUTTON COMPONENT
// =============================================================================
const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  function Button(
    {
      children,
      variant = 'primary',
      size = 'md',
      disabled = false,
      loading = false,
      onClick,
      className = '',
      type = 'button',
      ...props
    },
    ref
  ) {
    // Safe theme hook usage with fallback
    let playSound: (soundId: string) => void;
    try {
      const theme = useTheme();
      playSound = theme?.playSound || (() => { });
    } catch (error) {
      console.warn('Theme context not available, using fallback');
      playSound = () => { };
    }

    // =============================================================================
    // VARIANT STYLES
    // =============================================================================
    const variantStyles = {
      primary: clsx(
        'bg-gradient-to-b from-blue-500 to-blue-700',
        'hover:from-blue-400 hover:to-blue-600',
        'text-white font-bold shadow-lg',
        'border-2 border-blue-400',
        'hover:shadow-xl',
        'active:from-blue-700 active:to-blue-900'
      ),

      secondary: clsx(
        'bg-gradient-to-b from-gray-600 to-gray-800',
        'hover:from-gray-500 hover:to-gray-700',
        'text-white font-semibold shadow-lg',
        'border-2 border-gray-400',
        'hover:shadow-xl'
      ),

      danger: clsx(
        'bg-gradient-to-b from-red-500 to-red-700',
        'hover:from-red-400 hover:to-red-600',
        'text-white font-bold shadow-lg',
        'border-2 border-red-300',
        'hover:shadow-xl',
        'active:from-red-700 active:to-red-900'
      ),

      medieval: clsx(
        'bg-gradient-to-b from-amber-600 to-amber-800',
        'hover:from-amber-500 hover:to-amber-700',
        'text-white font-bold text-lg shadow-lg',
        'border-3 border-amber-400',
        'hover:shadow-xl',
        'relative overflow-hidden'
      ),

      ghost: clsx(
        'bg-transparent hover:bg-white/10',
        'text-white hover:text-blue-300',
        'border border-white/30 hover:border-blue-300',
        'transition-all duration-200'
      ),

      werewolf: clsx(
        'bg-gradient-to-b from-red-800 to-red-900',
        'hover:from-red-700 hover:to-red-800',
        'text-white font-bold shadow-lg',
        'border-2 border-red-600',
        'hover:shadow-xl'
      ),

      town: clsx(
        'bg-gradient-to-b from-green-600 to-green-800',
        'hover:from-green-500 hover:to-green-700',
        'text-white font-bold shadow-lg',
        'border-2 border-green-400',
        'hover:shadow-xl'
      ),
    };

    // =============================================================================
    // SIZE STYLES
    // =============================================================================
    const sizeStyles = {
      sm: 'px-3 py-1.5 text-sm rounded-md gap-1.5',
      md: 'px-4 py-2 text-base rounded-lg gap-2',
      lg: 'px-6 py-3 text-lg rounded-xl gap-2.5',
      xl: 'px-8 py-4 text-xl rounded-xl gap-3',
    };

    // =============================================================================
    // DISABLED/LOADING STYLES
    // =============================================================================
    const disabledStyles = clsx(
      'opacity-50 cursor-not-allowed',
      'hover:shadow-none hover:transform-none',
      'pointer-events-none'
    );

    // =============================================================================
    // COMBINED CLASSES
    // =============================================================================
    const buttonClasses = clsx(
      // Base styles
      'relative inline-flex items-center justify-center',
      'font-medium transition-all duration-200',
      'transform hover:scale-105 hover:-translate-y-0.5',
      'active:scale-95 active:translate-y-0',
      'focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2',
      'select-none',

      // Variant styles
      variantStyles[variant],

      // Size styles
      sizeStyles[size],

      // State styles
      (disabled || loading) && disabledStyles,

      // Custom className
      className
    );

    // =============================================================================
    // CLICK HANDLER COM SOM
    // =============================================================================
    const handleClick = () => {
      if (disabled || loading) return;

      // Escolher som baseado no tipo de bot√£o
      let soundType = 'button_click'; // default (click3.wav)

      if (variant === 'ghost' || variant === 'secondary') {
        soundType = 'button_secondary'; // click1.wav (som leve)
      } else if (variant === 'medieval' || variant === 'primary' || variant === 'danger') {
        soundType = 'button_click'; // click3.wav (som firme)
      }

      playSound(soundType);

      // Call onClick if provided
      onClick?.();
    };

    // =============================================================================
    // RENDER
    // =============================================================================
    return (
      <button
        ref={ref}
        type={type}
        className={buttonClasses}
        onClick={handleClick}
        disabled={disabled || loading}
        {...props}
      >
        {/* Loading spinner */}
        {loading && (
          <Spinner className="w-4 h-4" />
        )}

        {/* Button content */}
        {children}

        {/* Medieval button enhancement */}
        {variant === 'medieval' && (
          <>
            {/* Top highlight */}
            <div className="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-transparent via-amber-200 to-transparent opacity-60" />

            {/* Side highlights */}
            <div className="absolute top-0 bottom-0 left-0 w-1 bg-gradient-to-b from-amber-200 via-transparent to-amber-200 opacity-40" />
            <div className="absolute top-0 bottom-0 right-0 w-1 bg-gradient-to-b from-amber-200 via-transparent to-amber-200 opacity-40" />
          </>
        )}

        {/* Glow effect for primary variants */}
        {(variant === 'primary' || variant === 'medieval') && !disabled && !loading && (
          <div className="absolute -inset-0.5 bg-gradient-to-r from-blue-400 to-amber-400 rounded-lg opacity-0 group-hover:opacity-20 blur transition-opacity duration-300 -z-10" />
        )}
      </button>
    );
  }
);

// =============================================================================
// DISPLAY NAME (CR√çTICO para forwardRef)
// =============================================================================
Button.displayName = 'Button';

// =============================================================================
// BUTTON GROUP COMPONENT
// =============================================================================
interface ButtonGroupProps {
  children: React.ReactNode;
  className?: string;
  orientation?: 'horizontal' | 'vertical';
}

export const ButtonGroup = forwardRef<HTMLDivElement, ButtonGroupProps>(
  function ButtonGroup(
    {
      children,
      className = '',
      orientation = 'horizontal'
    },
    ref
  ) {
    return (
      <div
        ref={ref}
        className={clsx(
          'inline-flex',
          orientation === 'horizontal' ? 'flex-row' : 'flex-col',
          '[&>button]:rounded-none',
          '[&>button:first-child]:rounded-l-lg',
          '[&>button:last-child]:rounded-r-lg',
          orientation === 'vertical' && '[&>button:first-child]:rounded-t-lg [&>button:first-child]:rounded-l-none',
          orientation === 'vertical' && '[&>button:last-child]:rounded-b-lg [&>button:last-child]:rounded-r-none',
          '[&>button:not(:first-child)]:border-l-0',
          orientation === 'vertical' && '[&>button:not(:first-child)]:border-l [&>button:not(:first-child)]:border-t-0',
          className
        )}
      >
        {children}
      </div>
    );
  }
);

ButtonGroup.displayName = 'ButtonGroup';

// =============================================================================
// ICON BUTTON COMPONENT
// =============================================================================
interface IconButtonProps extends Omit<ButtonProps, 'children'> {
  icon: React.ReactNode;
  'aria-label': string;
}

export const IconButton = forwardRef<HTMLButtonElement, IconButtonProps>(
  function IconButton(
    {
      icon,
      className = '',
      size = 'md',
      ...props
    },
    ref
  ) {
    const iconSizes = {
      sm: 'w-4 h-4',
      md: 'w-5 h-5',
      lg: 'w-6 h-6',
      xl: 'w-8 h-8',
    };

    return (
      <Button
        ref={ref}
        className={clsx('!p-2 aspect-square', className)}
        size={size}
        {...props}
      >
        <span className={iconSizes[size]}>{icon}</span>
      </Button>
    );
  }
);

IconButton.displayName = 'IconButton';

// =============================================================================
// DEFAULT EXPORT
// =============================================================================
export default Button;
</file>

<file path="frontend/src/components/common/Layout.tsx">
'use client';

import { ReactNode, useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import {
  Home,
  User,
  Trophy,
  Settings,
  LogOut,
  Volume2,
  VolumeX,
  Moon,
  Sun,
  Menu,
  X
} from 'lucide-react';
import { clsx } from 'clsx';
import { useAuth } from '@/context/AuthContext';
import { useTheme } from '@/context/ThemeContext';
import { useSocket } from '@/context/SocketContext';
import Button from './Button';
import { useRouter } from 'next/navigation';

// =============================================================================
// LAYOUT PROPS
// =============================================================================
interface LayoutProps {
  children: ReactNode;
  showHeader?: boolean;
  showSidebar?: boolean;
  showFooter?: boolean;
  className?: string;
  variant?: 'default' | 'game' | 'auth' | 'landing';
}

// ‚úÖ CORRE√á√ÉO: Componente para tema escuro/claro seguro para hidrata√ß√£o
interface SafeThemeDisplayProps {
  isDark: boolean;
  onToggle: () => void;
}

function SafeThemeToggle({ isDark, onToggle }: SafeThemeDisplayProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    // Renderiza um √≠cone neutro no servidor
    return (
      <Button
        variant="ghost"
        size="sm"
        onClick={onToggle}
        aria-label="Alternar tema"
      >
        <div className="w-5 h-5" /> {/* Placeholder invis√≠vel */}
      </Button>
    );
  }

  return (
    <Button
      variant="ghost"
      size="sm"
      onClick={onToggle}
      aria-label={isDark ? 'Tema claro' : 'Tema escuro'}
    >
      {isDark ? <Sun className="w-5 h-5" /> : <Moon className="w-5 h-5" />}
    </Button>
  );
}

// ‚úÖ CORRE√á√ÉO: Componente para status de conex√£o seguro para hidrata√ß√£o
interface SafeConnectionStatusProps {
  status: string;
}

function SafeConnectionStatus({ status }: SafeConnectionStatusProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    // Renderiza um estado neutro no servidor
    return (
      <div className="w-2 h-2 rounded-full bg-gray-400" />
    );
  }

  return (
    <div className={clsx(
      'w-2 h-2 rounded-full',
      status === 'connected' ? 'bg-green-400' : 'bg-red-400'
    )} />
  );
}

// =============================================================================
// MAIN LAYOUT COMPONENT
// =============================================================================
export default function Layout({
  children,
  showHeader = true,
  showSidebar = true,
  showFooter = true,
  className = '',
  variant = 'default',
}: LayoutProps) {
  const { getThemeClass, getPhaseColors } = useTheme();
  const phaseColors = getPhaseColors();

  // Variant-specific layouts
  if (variant === 'auth') {
    return <AuthLayout>{children}</AuthLayout>;
  }

  if (variant === 'landing') {
    return <LandingLayout>{children}</LandingLayout>;
  }

  if (variant === 'game') {
    return <GameLayout>{children}</GameLayout>;
  }

  // Default layout
  return (
    <div className={clsx(
      'min-h-screen',
      `bg-gradient-to-br ${phaseColors.background}`,
      getThemeClass(),
      className
    )}>
      {showHeader && <Header />}

      <div className="flex">
        {showSidebar && <Sidebar />}

        <main className={clsx(
          'flex-1 transition-all duration-300',
          showSidebar ? 'ml-64' : 'ml-0',
          showHeader ? 'pt-16' : 'pt-0',
          'p-6'
        )}>
          {children}
        </main>
      </div>

      {showFooter && <Footer />}
    </div>
  );
}

// =============================================================================
// HEADER COMPONENT
// =============================================================================
function Header() {
  const { user, logout } = useAuth();
  const { isDark, toggleDarkMode, audioConfig, updateAudioConfig } = useTheme();
  const { status } = useSocket();
  const [showUserMenu, setShowUserMenu] = useState(false);

  const toggleAudio = () => {
    updateAudioConfig({ enabled: !audioConfig.enabled });
  };

  return (
    <motion.header
      initial={{ y: -100 }}
      animate={{ y: 0 }}
      className="fixed top-0 left-0 right-0 z-40 bg-medieval-900/95 backdrop-blur-sm border-b border-medieval-600"
    >
      <div className="flex items-center justify-between h-16 px-6">
        {/* Logo */}
        <div className="flex items-center space-x-3">
          <div className="text-2xl">üê∫</div>
          <h1 className="text-xl font-medieval text-glow">
            Werewolf
          </h1>

          {/* ‚úÖ CORRE√á√ÉO: Connection status com componente seguro */}
          <SafeConnectionStatus status={status} />
        </div>

        {/* Controls */}
        <div className="flex items-center space-x-3">
          {/* Audio toggle */}
          <Button
            variant="ghost"
            size="sm"
            onClick={toggleAudio}
            aria-label={audioConfig.enabled ? 'Desativar som' : 'Ativar som'}
          >
            {audioConfig.enabled ?
              <Volume2 className="w-5 h-5" /> :
              <VolumeX className="w-5 h-5" />
            }
          </Button>

          {/* ‚úÖ CORRE√á√ÉO: Theme toggle com componente seguro */}
          <SafeThemeToggle isDark={isDark} onToggle={toggleDarkMode} />

          {/* User menu */}
          {user && (
            <div className="relative">
              <Button
                variant="ghost"
                onClick={() => setShowUserMenu(!showUserMenu)}
                className="flex items-center space-x-2"
              >
                <div className="w-8 h-8 bg-salem-600 rounded-full flex items-center justify-center">
                  {user.avatar ? (
                    <img src={user.avatar} alt="" className="w-full h-full rounded-full" />
                  ) : (
                    <span className="text-sm font-bold">
                      {user.username.charAt(0).toUpperCase()}
                    </span>
                  )}
                </div>
                <span className="font-medium">{user.username}</span>
              </Button>

              {/* Dropdown menu */}
              {showUserMenu && (
                <motion.div
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  className="absolute right-0 mt-2 w-48 bg-medieval-800 rounded-lg shadow-medieval border border-medieval-600"
                >
                  <div className="py-2">
                    <div className="px-4 py-2 border-b border-medieval-600">
                      <p className="text-sm text-white/70">N√≠vel {user.level}</p>
                      <p className="text-xs text-white/50">{user.totalGames} jogos</p>
                    </div>

                    <Button
                      variant="ghost"
                      className="w-full justify-start px-4 py-2 text-left"
                      onClick={() => setShowUserMenu(false)}
                    >
                      <User className="w-4 h-4 mr-2" />
                      Perfil
                    </Button>

                    <Button
                      variant="ghost"
                      className="w-full justify-start px-4 py-2 text-left"
                      onClick={() => setShowUserMenu(false)}
                    >
                      <Settings className="w-4 h-4 mr-2" />
                      Configura√ß√µes
                    </Button>

                    <div className="border-t border-medieval-600 mt-2 pt-2">
                      <Button
                        variant="ghost"
                        className="w-full justify-start px-4 py-2 text-left text-red-400 hover:text-red-300"
                        onClick={() => {
                          setShowUserMenu(false);
                          logout();
                        }}
                      >
                        <LogOut className="w-4 h-4 mr-2" />
                        Sair
                      </Button>
                    </div>
                  </div>
                </motion.div>
              )}
            </div>
          )}
        </div>
      </div>
    </motion.header>
  );
}

// =============================================================================
// SIDEBAR COMPONENT
// =============================================================================
function Sidebar() {
  const router = useRouter();
  const [isCollapsed, setIsCollapsed] = useState(false);

  const menuItems = [
    { icon: Home, label: 'Lobby', href: '/lobby' },
    { icon: User, label: 'Perfil', href: '/profile' },
    { icon: Trophy, label: 'Ranking', href: '/leaderboard' },
    { icon: Settings, label: 'Configura√ß√µes', href: '/settings' },
  ];

  return (
    <motion.aside
      initial={{ x: -300 }}
      animate={{ x: 0 }}
      className={clsx(
        'fixed left-0 top-16 bottom-0 z-30',
        'bg-medieval-900/95 backdrop-blur-sm border-r border-medieval-600',
        'transition-all duration-300',
        isCollapsed ? 'w-16' : 'w-64'
      )}
    >
      {/* Toggle button */}
      <div className="p-4 border-b border-medieval-600">
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setIsCollapsed(!isCollapsed)}
          className="w-full justify-center"
        >
          {isCollapsed ? <Menu className="w-5 h-5" /> : <X className="w-5 h-5" />}
        </Button>
      </div>

      {/* Navigation */}
      <nav className="p-4 space-y-2">
        {menuItems.map((item) => (
          <Button
            key={item.href}
            variant="ghost"
            className={clsx(
              'w-full justify-start',
              isCollapsed ? 'px-2' : 'px-4'
            )}
            onClick={() => router.push(item.href)}
          >
            <item.icon className="w-5 h-5" />
            {!isCollapsed && <span className="ml-3">{item.label}</span>}
          </Button>
        ))}
      </nav>
    </motion.aside>
  );
}

// =============================================================================
// FOOTER COMPONENT
// =============================================================================
function Footer() {
  return (
    <footer className="bg-medieval-900/80 border-t border-medieval-600 py-4 px-6 mt-auto relative z-10">
      <div className="flex items-center justify-between text-sm text-white/70">
        <p>¬© 2025 Werewolf. Todos os direitos reservados.</p>
        <p>Vers√£o 1.0.0</p>
      </div>
    </footer>
  );
}

// =============================================================================
// AUTH LAYOUT
// =============================================================================
function AuthLayout({ children }: { children: ReactNode }) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-night-dark flex items-center justify-center p-4">
      <div className="w-full max-w-md">
        {/* Logo */}
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-center mb-8"
        >
          <div className="text-6xl mb-4">üê∫</div>
          <h1 className="text-3xl font-medieval text-glow">
            Werewolf
          </h1>
          <p className="text-white/70 mt-2">
            Entre na vila... se tiver coragem
          </p>
        </motion.div>

        {/* Content */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2 }}
        >
          {children}
        </motion.div>
      </div>
    </div>
  );
}

// =============================================================================
// LANDING LAYOUT
// =============================================================================
function LandingLayout({ children }: { children: ReactNode }) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-night-dark">
      {children}
    </div>
  );
}

// =============================================================================
// GAME LAYOUT
// =============================================================================
function GameLayout({ children }: { children: ReactNode }) {
  const { currentPhase, getPhaseColors } = useTheme();
  const phaseColors = getPhaseColors();

  return (
    <div className={clsx(
      'min-h-screen transition-all duration-1000',
      `bg-gradient-to-br ${phaseColors.background}`
    )}>
      {/* Game header */}
      <div className="bg-black/20 border-b border-white/10 px-6 py-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <div className="text-2xl">üê∫</div>
            <div>
              <h1 className="font-medieval text-xl text-glow">
                Werewolf
              </h1>
              <p className={clsx('text-sm', phaseColors.text)}>
                Fase: {currentPhase}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Game content */}
      <div className="relative">
        {children}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/game/ActionPanel.tsx">
import React, { useState } from 'react';
import { useGame } from '@/context/GameContext';
import { useSocket } from '@/context/SocketContext';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// ACTION PANEL COMPONENT - A√á√ïES DO JOGADOR POR FASE
// =============================================================================
export default function ActionPanel() {
  const { gameState, me, alivePlayers, canVote, canAct } = useGame();
  const { sendMessage } = useSocket();

  const [selectedTarget, setSelectedTarget] = useState<string | null>(null);
  const [confirmingAction, setConfirmingAction] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (!gameState || !me) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex items-center justify-center h-full">
          <LoadingSpinner text="Carregando a√ß√µes..." />
        </div>
      </div>
    );
  }

  // =============================================================================
  // ACTION HANDLERS
  // =============================================================================
  const handleNightAction = async () => {
    if (!selectedTarget || !me.role || isSubmitting) return;

    const actionType = me.role === 'SHERIFF' ? 'INVESTIGATE' :
      me.role === 'DOCTOR' ? 'PROTECT' :
        me.role === 'VIGILANTE' ? 'SHOOT' :
          me.role === 'WEREWOLF' ? 'KILL' :
            me.role === 'WEREWOLF_KING' ? 'KILL' :
              me.role === 'SERIAL_KILLER' ? 'KILL' : null;

    if (actionType) {
      setIsSubmitting(true);

      sendMessage('game-action', {
        type: actionType,
        targetId: selectedTarget,
      });

      // Reset state after sending
      setTimeout(() => {
        setSelectedTarget(null);
        setConfirmingAction(false);
        setIsSubmitting(false);
      }, 500);
    }
  };

  const handleVote = async () => {
    if (!selectedTarget || isSubmitting) return;

    setIsSubmitting(true);

    sendMessage('vote', { targetId: selectedTarget });

    setTimeout(() => {
      setSelectedTarget(null);
      setIsSubmitting(false);
    }, 500);
  };

  const handleUnvote = async () => {
    if (isSubmitting) return;

    setIsSubmitting(true);

    sendMessage('unvote', {});

    setTimeout(() => {
      setIsSubmitting(false);
    }, 500);
  };

  // =============================================================================
  // GET VALID TARGETS
  // =============================================================================
  const getValidTargets = () => {
    if (gameState.phase === 'VOTING') {
      return alivePlayers.filter(p => p.id !== me.id); // Can't vote for yourself
    }

    if (gameState.phase === 'NIGHT' && me.role) {
      switch (me.role) {
        case 'SHERIFF':
        case 'VIGILANTE':
        case 'SERIAL_KILLER':
          return alivePlayers.filter(p => p.id !== me.id);
        case 'DOCTOR':
          return alivePlayers; // Doctor can protect themselves
        case 'WEREWOLF':
        case 'WEREWOLF_KING':
          return alivePlayers.filter(p => p.faction !== 'WEREWOLF'); // Can't kill other werewolves
        default:
          return [];
      }
    }

    return [];
  };

  const validTargets = getValidTargets();

  // =============================================================================
  // GET ACTION INFO
  // =============================================================================
  const getActionInfo = () => {
    if (gameState.phase === 'VOTING') {
      return {
        title: 'üó≥Ô∏è Vota√ß√£o',
        description: 'Escolha quem deve ser executado pela vila',
        actionText: 'Votar',
        canAct: canVote,
      };
    }

    if (gameState.phase === 'NIGHT' && me.role) {
      switch (me.role) {
        case 'SHERIFF':
          return {
            title: 'üîç Investiga√ß√£o',
            description: 'Investigue um jogador para descobrir se √© suspeito',
            actionText: 'Investigar',
            canAct: canAct,
          };
        case 'DOCTOR':
          return {
            title: '‚öïÔ∏è Prote√ß√£o',
            description: 'Proteja um jogador de ataques noturnos',
            actionText: 'Proteger',
            canAct: canAct,
          };
        case 'VIGILANTE':
          return {
            title: 'üî´ Vigil√¢ncia',
            description: `Elimine um suspeito (${(me.maxActions || 3) - (me.actionsUsed || 0)} balas restantes)`,
            actionText: 'Atirar',
            canAct: canAct && (me.actionsUsed || 0) < (me.maxActions || 3),
          };
        case 'WEREWOLF':
        case 'WEREWOLF_KING':
          return {
            title: 'üê∫ Ataque',
            description: 'Escolha quem atacar durante a noite',
            actionText: 'Atacar',
            canAct: canAct,
          };
        case 'SERIAL_KILLER':
          return {
            title: 'üî™ Assassinato',
            description: 'Elimine um jogador durante a noite',
            actionText: 'Matar',
            canAct: canAct,
          };
        default:
          return null;
      }
    }

    return null;
  };

  const actionInfo = getActionInfo();

  // =============================================================================
  // RENDER DIFFERENT STATES
  // =============================================================================

  // Dead player
  if (!me.isAlive) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">üëª</div>
          <h3 className="text-lg font-semibold text-white mb-2">Voc√™ est√° morto</h3>
          <p className="text-white/70">Observe em sil√™ncio e tor√ßa pelo seu time!</p>
          {me.eliminationReason && (
            <p className="text-red-400 text-sm mt-2">
              Causa: {me.eliminationReason === 'NIGHT_KILL' ? 'Morto √† noite' :
                me.eliminationReason === 'EXECUTION' ? 'Executado pela vila' :
                  me.eliminationReason === 'VIGILANTE' ? 'Morto por vigilante' :
                    'Morto por assassino'}
            </p>
          )}
        </div>
      </div>
    );
  }

  // Day phase (no actions)
  if (gameState.phase === 'DAY') {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">‚òÄÔ∏è</div>
          <h3 className="text-lg font-semibold text-white mb-2">Discuss√£o do Dia {gameState.day}</h3>
          <p className="text-white/70">Use o chat para discutir e investigar!</p>
          <p className="text-amber-400 text-sm mt-2">
            A vota√ß√£o come√ßar√° em breve...
          </p>
        </div>
      </div>
    );
  }

  // No valid actions
  if (!actionInfo) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">üò¥</div>
          <h3 className="text-lg font-semibold text-white mb-2">Sem A√ß√µes</h3>
          <p className="text-white/70">Voc√™ n√£o possui a√ß√µes dispon√≠veis nesta fase.</p>
        </div>
      </div>
    );
  }

  // Already acted
  if (!actionInfo.canAct && gameState.phase === 'NIGHT') {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">‚úÖ</div>
          <h3 className="text-lg font-semibold text-white mb-2">A√ß√£o Realizada</h3>
          <p className="text-white/70">Voc√™ j√° realizou sua a√ß√£o nesta noite.</p>
          <p className="text-amber-400 text-sm mt-2">
            Aguardando outros jogadores...
          </p>
        </div>
      </div>
    );
  }

  // Already voted
  if (!actionInfo.canAct && gameState.phase === 'VOTING') {
    const myVote = gameState.votes && gameState.votes[me.userId];
    const votedPlayer = myVote ? alivePlayers.find(p => p.id === myVote) : null;

    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">üó≥Ô∏è</div>
          <h3 className="text-lg font-semibold text-white mb-2">Voto Registrado</h3>
          {votedPlayer && (
            <p className="text-white/70 mb-4">
              Voc√™ votou em: <span className="text-amber-400 font-semibold">{votedPlayer.username}</span>
            </p>
          )}

          <button
            onClick={handleUnvote}
            disabled={isSubmitting}
            className="bg-gradient-to-r from-red-500 to-red-700 hover:from-red-600 hover:to-red-800 disabled:from-gray-600 disabled:to-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200"
          >
            {isSubmitting ? 'Removendo...' : 'Remover Voto'}
          </button>
        </div>
      </div>
    );
  }

  // Main action interface
  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Header */}
      <div className="flex-shrink-0 border-b border-medieval-600 p-4">
        <h3 className="text-lg font-bold text-white mb-2">{actionInfo.title}</h3>
        <p className="text-white/70 text-sm">{actionInfo.description}</p>
      </div>

      {/* Target Selection */}
      <div className="flex-1 overflow-y-auto p-4">
        <h4 className="text-white font-semibold mb-3">Escolha um alvo:</h4>

        <div className="space-y-2">
          {validTargets.map((player) => (
            <button
              key={player.id}
              onClick={() => setSelectedTarget(player.id)}
              disabled={isSubmitting}
              className={`
                w-full p-3 rounded-lg border-2 transition-all duration-200 text-left
                ${selectedTarget === player.id
                  ? 'border-amber-400 bg-amber-900/30'
                  : 'border-medieval-600 bg-medieval-700/30 hover:border-amber-400/50 hover:bg-medieval-700/50'
                }
                ${isSubmitting ? 'opacity-50 cursor-not-allowed' : ''}
              `}
            >
              <div className="flex items-center space-x-3">
                <div className="w-8 h-8 rounded-full bg-medieval-600 flex items-center justify-center">
                  {player.avatar ? (
                    <img src={player.avatar} alt={player.username} className="w-full h-full rounded-full" />
                  ) : (
                    player.isHost ? 'üëë' : player.userId === me.userId ? 'üë§' : 'üßë'
                  )}
                </div>

                <div className="flex-1">
                  <div className="text-white font-medium">{player.username}</div>
                  <div className="text-white/50 text-sm">
                    {player.isHost && 'Host ‚Ä¢ '}
                    {player.isConnected ? 'Conectado' : 'Desconectado'}
                    {player.isProtected && ' ‚Ä¢ üõ°Ô∏è Protegido'}
                  </div>
                </div>

                {selectedTarget === player.id && (
                  <div className="text-amber-400 text-xl">üëà</div>
                )}
              </div>
            </button>
          ))}
        </div>

        {validTargets.length === 0 && (
          <div className="text-center text-white/50 py-8">
            <div className="text-4xl mb-2">üö´</div>
            <p>Nenhum alvo v√°lido dispon√≠vel</p>
          </div>
        )}
      </div>

      {/* Action Button */}
      {validTargets.length > 0 && (
        <div className="flex-shrink-0 border-t border-medieval-600 p-4">
          {!confirmingAction ? (
            <button
              onClick={() => setConfirmingAction(true)}
              disabled={!selectedTarget || isSubmitting}
              className="w-full bg-gradient-to-r from-blue-500 to-blue-700 hover:from-blue-600 hover:to-blue-800 disabled:from-gray-600 disabled:to-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 disabled:cursor-not-allowed"
            >
              {isSubmitting ? 'Enviando...' :
                selectedTarget
                  ? `${actionInfo.actionText} ${validTargets.find(p => p.id === selectedTarget)?.username}`
                  : 'Selecione um alvo'
              }
            </button>
          ) : (
            <div className="space-y-3">
              <div className="text-center text-amber-400 font-semibold">
                ‚ö†Ô∏è Confirmar a√ß√£o?
              </div>

              <div className="flex space-x-2">
                <button
                  onClick={gameState.phase === 'VOTING' ? handleVote : handleNightAction}
                  disabled={isSubmitting}
                  className="flex-1 bg-gradient-to-r from-green-500 to-green-700 hover:from-green-600 hover:to-green-800 disabled:from-gray-600 disabled:to-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200"
                >
                  {isSubmitting ? 'Enviando...' : '‚úì Confirmar'}
                </button>

                <button
                  onClick={() => {
                    setConfirmingAction(false);
                    setSelectedTarget(null);
                  }}
                  disabled={isSubmitting}
                  className="flex-1 bg-gradient-to-r from-red-500 to-red-700 hover:from-red-600 hover:to-red-800 disabled:from-gray-600 disabled:to-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200"
                >
                  ‚úó Cancelar
                </button>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/ChatGigante.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { useGame } from '@/context/GameContext';
import { useSocket } from '@/context/SocketContext';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// TYPES
// =============================================================================
interface ChatMessage {
  id: string;
  userId: string;
  username: string;
  message: string;
  channel: 'public' | 'werewolf' | 'dead' | 'system';
  timestamp: string;
  filtered?: boolean;
}

type ChatTab = 'public' | 'werewolf' | 'dead' | 'system';

// =============================================================================
// CHAT GIGANTE COMPONENT - CORA√á√ÉO DO JOGO
// =============================================================================
export default function ChatGigante() {
  const { gameState, me } = useGame();
  const { sendMessage } = useSocket();

  const [activeTab, setActiveTab] = useState<ChatTab>('public');
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // =============================================================================
  // AUTO SCROLL TO BOTTOM
  // =============================================================================
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // =============================================================================
  // LISTEN FOR CHAT MESSAGES
  // =============================================================================
  useEffect(() => {
    const handleChatMessage = (event: CustomEvent) => {
      const data = event.detail;

      if (data.type === 'chat-message') {
        const newMessage: ChatMessage = {
          id: data.data.message?.id || Date.now().toString(),
          userId: data.data.message?.userId || data.data.userId,
          username: data.data.message?.username || data.data.username,
          message: data.data.message?.message || data.data.message,
          channel: data.data.message?.channel || data.data.channel || 'public',
          timestamp: data.data.message?.timestamp || data.data.timestamp || new Date().toISOString(),
          filtered: data.data.message?.filtered,
        };

        setMessages(prev => [...prev, newMessage]);
      }

      // System messages from game events
      if (data.type === 'phase-changed') {
        const systemMessage: ChatMessage = {
          id: `system-${Date.now()}`,
          userId: 'system',
          username: 'Sistema',
          message: `Fase mudou para ${data.data.phase}`,
          channel: 'system',
          timestamp: new Date().toISOString(),
        };
        setMessages(prev => [...prev, systemMessage]);
      }

      if (data.type === 'player-died') {
        const systemMessage: ChatMessage = {
          id: `system-${Date.now()}`,
          userId: 'system',
          username: 'Sistema',
          message: `${data.data.playerName || 'Um jogador'} foi eliminado!`,
          channel: 'system',
          timestamp: new Date().toISOString(),
        };
        setMessages(prev => [...prev, systemMessage]);
      }
    };

    window.addEventListener('websocket-message', handleChatMessage as EventListener);
    return () => window.removeEventListener('websocket-message', handleChatMessage as EventListener);
  }, []);

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (!gameState || !me) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex items-center justify-center">
        <LoadingSpinner text="Carregando chat..." />
      </div>
    );
  }

  // =============================================================================
  // DETERMINE AVAILABLE TABS
  // =============================================================================
  const getAvailableTabs = (): ChatTab[] => {
    const tabs: ChatTab[] = ['public'];

    if (me?.role === 'WEREWOLF' || me?.role === 'WEREWOLF_KING') {
      tabs.push('werewolf');
    }

    if (!me?.isAlive) {
      tabs.push('dead');
    }

    tabs.push('system');

    return tabs;
  };

  const availableTabs = getAvailableTabs();

  // =============================================================================
  // FILTER MESSAGES BY TAB
  // =============================================================================
  const getMessagesForTab = (tab: ChatTab): ChatMessage[] => {
    return messages.filter(msg => {
      switch (tab) {
        case 'public':
          return msg.channel === 'public';
        case 'werewolf':
          return msg.channel === 'werewolf';
        case 'dead':
          return msg.channel === 'dead';
        case 'system':
          return msg.channel === 'system';
        default:
          return false;
      }
    });
  };

  // =============================================================================
  // SEND MESSAGE
  // =============================================================================
  const handleSendMessage = async () => {
    if (!message.trim() || !gameState || isSubmitting) return;

    setIsSubmitting(true);

    const success = sendMessage('chat-message', {
      message: message.trim(),
      channel: activeTab,
    });

    if (success) {
      setMessage('');
    }

    setTimeout(() => {
      setIsSubmitting(false);
    }, 200);
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  // =============================================================================
  // TAB CONFIGURATION
  // =============================================================================
  const getTabConfig = (tab: ChatTab) => {
    switch (tab) {
      case 'public':
        return {
          name: 'P√∫blico',
          icon: 'üó£Ô∏è',
          color: 'text-white',
          bgColor: 'bg-blue-600',
          available: true,
        };
      case 'werewolf':
        return {
          name: 'Lobisomens',
          icon: 'üê∫',
          color: 'text-red-400',
          bgColor: 'bg-red-600',
          available: me?.role === 'WEREWOLF' || me?.role === 'WEREWOLF_KING',
        };
      case 'dead':
        return {
          name: 'Mortos',
          icon: 'üëª',
          color: 'text-gray-400',
          bgColor: 'bg-gray-600',
          available: !me?.isAlive,
        };
      case 'system':
        return {
          name: 'Sistema',
          icon: '‚öôÔ∏è',
          color: 'text-amber-400',
          bgColor: 'bg-amber-600',
          available: true,
        };
    }
  };

  // =============================================================================
  // CHECK CHAT RESTRICTIONS
  // =============================================================================
  const canSendMessage = () => {
    if (!me.isAlive && activeTab !== 'dead') return false;
    if (activeTab === 'system') return false;
    if (activeTab === 'werewolf' && me.role !== 'WEREWOLF' && me.role !== 'WEREWOLF_KING') return false;
    if (gameState.phase === 'NIGHT' && activeTab === 'public' && me.role !== 'WEREWOLF' && me.role !== 'WEREWOLF_KING') return false;
    return true;
  };

  // =============================================================================
  // MESSAGE COMPONENT
  // =============================================================================
  const ChatMessageComponent = ({ msg }: { msg: ChatMessage }) => {
    const isMe = msg.userId === me?.userId;
    const isSystem = msg.channel === 'system';

    return (
      <div className={`p-2 border-b border-medieval-600/30 ${isMe ? 'bg-blue-900/20' : ''}`}>
        <div className="flex items-start space-x-2">
          {/* Avatar */}
          <div className="flex-shrink-0 w-8 h-8 rounded-full bg-medieval-700 flex items-center justify-center">
            {isSystem ? 'ü§ñ' : isMe ? 'üë§' : 'üßë'}
          </div>

          {/* Message Content */}
          <div className="flex-1 min-w-0">
            <div className="flex items-center space-x-2 mb-1">
              <span className={`font-semibold text-sm ${isMe ? 'text-blue-300' : 'text-white'}`}>
                {msg.username}
              </span>
              <span className="text-xs text-white/50">
                {new Date(msg.timestamp).toLocaleTimeString('pt-BR', {
                  hour: '2-digit',
                  minute: '2-digit'
                })}
              </span>
            </div>

            <div className="text-white/90 text-sm break-words">
              {msg.message}
            </div>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Chat Header */}
      <div className="flex-shrink-0 border-b border-medieval-600 p-4">
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-bold text-white flex items-center space-x-2">
            <span>üí¨</span>
            <span>Chat do Jogo</span>
          </h2>

          {gameState && (
            <div className="text-xs text-white/50">
              Dia {gameState.day} - {gameState.phase}
            </div>
          )}
        </div>

        {/* Chat Tabs */}
        <div className="flex space-x-1">
          {availableTabs.map((tab) => {
            const config = getTabConfig(tab);
            const tabMessages = getMessagesForTab(tab);
            const unreadCount = tabMessages.length; // Simplified unread logic

            return (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                className={`
                  px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 relative
                  ${activeTab === tab
                    ? `${config.bgColor} text-white`
                    : 'bg-medieval-700/50 text-white/70 hover:bg-medieval-700'
                  }
                `}
              >
                <div className="flex items-center space-x-1">
                  <span>{config.icon}</span>
                  <span>{config.name}</span>
                </div>

                {/* Unread Badge */}
                {tab !== activeTab && unreadCount > 0 && (
                  <div className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
                    {unreadCount > 99 ? '99+' : unreadCount}
                  </div>
                )}
              </button>
            );
          })}
        </div>
      </div>

      {/* Chat Messages Area */}
      <div className="flex-1 overflow-y-auto bg-medieval-900/20">
        {getMessagesForTab(activeTab).length === 0 ? (
          <div className="h-full flex items-center justify-center">
            <div className="text-center text-white/50">
              <div className="text-4xl mb-2">{getTabConfig(activeTab).icon}</div>
              <p>Nenhuma mensagem ainda...</p>
              <p className="text-xs mt-1">
                {activeTab === 'public' && 'Seja o primeiro a falar!'}
                {activeTab === 'werewolf' && 'Coordenem seus ataques...'}
                {activeTab === 'dead' && 'O al√©m est√° silencioso...'}
                {activeTab === 'system' && 'Aguardando eventos...'}
              </p>
            </div>
          </div>
        ) : (
          <div>
            {getMessagesForTab(activeTab).map((msg) => (
              <ChatMessageComponent key={msg.id} msg={msg} />
            ))}
            <div ref={messagesEndRef} />
          </div>
        )}
      </div>

      {/* Chat Input */}
      <div className="flex-shrink-0 border-t border-medieval-600 p-4">
        {/* Phase restriction info */}
        {gameState?.phase === 'NIGHT' && activeTab === 'public' && me?.role !== 'WEREWOLF' && me?.role !== 'WEREWOLF_KING' && (
          <div className="mb-2 text-xs text-amber-400 text-center">
            üåô Durante a noite, apenas Lobisomens podem conversar no chat p√∫blico
          </div>
        )}

        <div className="flex space-x-2">
          <input
            type="text"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder={
              !canSendMessage() ? 'Voc√™ n√£o pode falar neste canal agora' :
                activeTab === 'public' ? 'Digite sua mensagem...' :
                  activeTab === 'werewolf' ? 'Coordenem seus ataques...' :
                    activeTab === 'dead' ? 'Fale com outros mortos...' :
                      'Mensagem do sistema...'
            }
            disabled={!canSendMessage() || isSubmitting}
            className="flex-1 bg-medieval-700 border border-medieval-600 rounded-lg px-3 py-2 text-white placeholder-white/50 focus:outline-none focus:border-amber-400 disabled:opacity-50 disabled:cursor-not-allowed"
          />

          <button
            onClick={handleSendMessage}
            disabled={!message.trim() || !canSendMessage() || isSubmitting}
            className="bg-gradient-to-r from-blue-500 to-blue-700 hover:from-blue-600 hover:to-blue-800 disabled:from-gray-600 disabled:to-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200 disabled:cursor-not-allowed"
          >
            {isSubmitting ? '...' : 'Enviar'}
          </button>
        </div>

        {/* Help text */}
        <div className="mt-2 text-xs text-white/50 text-center">
          üí° Use Enter para enviar ‚Ä¢ Shift+Enter para quebrar linha
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/game/GameBoard.tsx">
import React from 'react';
import { useGame } from '@/context/GameContext';
import PhaseIndicator from './PhaseIndicator';
import TimerDisplay from './TimerDisplay';
import RoleCard from './RoleCard';
import PlayerCircle from './PlayerCircle';
import ChatGigante from './ChatGigante';
import PlayerList from './PlayerList';
import ActionPanel from './ActionPanel';
import WillNotes from './WillNotes';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// GAME BOARD COMPONENT - LAYOUT TOWN OF SALEM
// =============================================================================
export default function GameBoard() {
  const { gameState, isLoading, error, me, connectionStatus } = useGame();

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (isLoading || connectionStatus === 'connecting') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="large" />
          <p className="text-white/70 mt-4">Carregando estado do jogo...</p>
        </div>
      </div>
    );
  }

  // =============================================================================
  // ERROR STATE
  // =============================================================================
  if (error || connectionStatus === 'error') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black flex items-center justify-center">
        <div className="text-center max-w-md mx-auto p-6">
          <div className="text-red-400 text-6xl mb-4">üíÄ</div>
          <h2 className="text-xl font-bold text-white mb-4">Erro no Jogo</h2>
          <p className="text-white/70">{error || 'Erro de conex√£o'}</p>
          <button
            onClick={() => window.location.reload()}
            className="mt-4 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg"
          >
            Recarregar
          </button>
        </div>
      </div>
    );
  }

  // =============================================================================
  // NO GAME STATE
  // =============================================================================
  if (!gameState || connectionStatus === 'disconnected') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black flex items-center justify-center">
        <div className="text-center">
          <div className="animate-pulse">
            <div className="text-amber-400 text-6xl mb-4">üåô</div>
          </div>
          <h2 className="text-xl font-bold text-white mb-2">Aguardando Jogo</h2>
          <p className="text-white/70">Conectando ao servidor...</p>
        </div>
      </div>
    );
  }

  // =============================================================================
  // LOBBY STATE
  // =============================================================================
  if (gameState.phase === 'LOBBY' || gameState.status === 'WAITING') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black flex items-center justify-center">
        <div className="text-center max-w-2xl mx-auto p-8">
          <div className="text-6xl mb-6">üè∞</div>
          <h2 className="text-3xl font-bold text-white mb-4">Preparando o Jogo</h2>
          <p className="text-white/70 mb-6">
            O jogo est√° sendo configurado...
          </p>

          <div className="bg-medieval-800/30 border border-medieval-600 rounded-lg p-6">
            <h3 className="text-lg font-semibold text-white mb-4">
              Jogadores ({gameState.players.length})
            </h3>
            <div className="grid grid-cols-2 gap-2">
              {gameState.players.map((player) => (
                <div
                  key={player.id}
                  className="flex items-center space-x-2 p-2 bg-medieval-800/50 border border-medieval-600 rounded"
                >
                  <div className={`w-2 h-2 rounded-full ${player.isConnected ? 'bg-green-400' : 'bg-red-400'}`} />
                  <span className="text-white text-sm">{player.username}</span>
                  {player.isHost && <span className="text-amber-400 text-xs">üëë</span>}
                  {player.isReady && <span className="text-green-400 text-xs">‚úì</span>}
                </div>
              ))}
            </div>
          </div>

          <div className="mt-6 text-amber-400">
            <div className="animate-bounce">‚åõ</div>
            <p className="text-sm">Aguardando in√≠cio...</p>
          </div>
        </div>
      </div>
    );
  }

  // =============================================================================
  // MAIN GAME LAYOUT - TOWN OF SALEM STYLE
  // =============================================================================
  return (
    <div className="h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black">
      {/* Top Header Bar */}
      <header className="h-16 bg-medieval-800/50 border-b border-medieval-600 flex items-center justify-between px-4">
        {/* Left: Phase & Day */}
        <PhaseIndicator />

        {/* Center: Game Title */}
        <div className="flex items-center space-x-2">
          <span className="text-2xl">üê∫</span>
          <h1 className="text-xl font-bold text-white">Lobisomem Online</h1>
        </div>

        {/* Right: Timer */}
        <TimerDisplay />
      </header>

      {/* Main Game Grid - 6 Sections Layout */}
      <main className="h-[calc(100vh-4rem)] grid grid-cols-12 grid-rows-2 gap-4 p-4">

        {/* Left Column - Top: Role Card */}
        <section className="col-span-3 row-span-1">
          <RoleCard />
        </section>

        {/* Center Column - Top: Game Area with Players Circle */}
        <section className="col-span-6 row-span-1">
          <PlayerCircle />
        </section>

        {/* Right Column - Full Height: Chat Gigante */}
        <section className="col-span-3 row-span-2">
          <ChatGigante />
        </section>

        {/* Left Column - Bottom: Player List */}
        <section className="col-span-3 row-span-1">
          <PlayerList />
        </section>

        {/* Center Column - Bottom: Action Panel & Will Notes */}
        <section className="col-span-6 row-span-1 grid grid-cols-2 gap-4">
          <ActionPanel />
          <WillNotes />
        </section>

      </main>

      {/* Game Over Overlay */}
      {gameState.status === 'FINISHED' && (
        <div className="fixed inset-0 bg-black/75 flex items-center justify-center z-50">
          <div className="bg-medieval-800 border-2 border-medieval-600 rounded-lg p-8 max-w-md mx-4">
            <div className="text-center">
              <div className="text-6xl mb-4">
                {gameState.winningFaction === 'TOWN' ? 'üèòÔ∏è' :
                  gameState.winningFaction === 'WEREWOLF' ? 'üê∫' : '‚ö°'}
              </div>

              <h2 className="text-2xl font-bold text-white mb-4">
                Fim de Jogo!
              </h2>

              <p className="text-white/70 mb-6">
                {gameState.winningFaction === 'TOWN' && 'A Vila Venceu!'}
                {gameState.winningFaction === 'WEREWOLF' && 'Os Lobisomens Venceram!'}
                {gameState.winningFaction === 'NEUTRAL' && 'Neutros Venceram!'}
                {!gameState.winningFaction && 'Jogo Encerrado'}
              </p>

              {gameState.winningPlayers && gameState.winningPlayers.length > 0 && (
                <div className="mb-6">
                  <h3 className="text-lg font-semibold text-white mb-2">Vencedores:</h3>
                  <div className="space-y-1">
                    {gameState.winningPlayers.map((playerId) => {
                      const player = gameState.players.find(p => p.id === playerId);
                      return player ? (
                        <div key={playerId} className="text-amber-400">
                          {player.username} ({player.role})
                        </div>
                      ) : null;
                    })}
                  </div>
                </div>
              )}

              {/* All Players Results */}
              <div className="mb-6 max-h-48 overflow-y-auto">
                <h3 className="text-lg font-semibold text-white mb-2">Todos os Jogadores:</h3>
                <div className="space-y-1 text-sm">
                  {gameState.players.filter(p => !p.isSpectator).map((player) => (
                    <div key={player.id} className="flex justify-between text-white/70">
                      <span>{player.username}</span>
                      <span className={`
                        ${player.faction === 'TOWN' ? 'text-green-400' :
                          player.faction === 'WEREWOLF' ? 'text-red-400' :
                            'text-purple-400'}
                      `}>
                        {player.role}
                      </span>
                    </div>
                  ))}
                </div>
              </div>

              <button
                onClick={() => window.location.href = '/lobby'}
                className="bg-gradient-to-r from-blue-500 to-blue-700 hover:from-blue-600 hover:to-blue-800 text-white font-bold py-3 px-6 rounded-lg transition-all duration-200"
              >
                Voltar ao Lobby
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/PlayerCircle.tsx">
import React from 'react';
import { useGame } from '@/context/GameContext';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// PLAYER CIRCLE COMPONENT - PLAYERS AO REDOR DA FORCA
// =============================================================================
export default function PlayerCircle() {
  const { gameState, me } = useGame();

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (!gameState) {
    return (
      <div className="w-full h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex items-center justify-center">
        <LoadingSpinner text="Carregando jogadores..." />
      </div>
    );
  }

  // =============================================================================
  // FILTER PLAYERS
  // =============================================================================
  const alivePlayers = gameState.players.filter(p => p.isAlive && !p.isSpectator);
  const deadPlayers = gameState.players.filter(p => !p.isAlive && !p.isSpectator);

  // =============================================================================
  // CALCULATE PLAYER POSITIONS IN CIRCLE
  // =============================================================================
  const getPlayerPosition = (index: number, totalPlayers: number) => {
    const angle = (index * 360) / totalPlayers - 90; // Start from top
    const radiusX = 35; // Horizontal radius percentage
    const radiusY = 30; // Vertical radius percentage

    const x = 50 + radiusX * Math.cos((angle * Math.PI) / 180);
    const y = 50 + radiusY * Math.sin((angle * Math.PI) / 180);

    return { x, y };
  };

  return (
    <div className="w-full h-full bg-medieval-800/30 border border-medieval-600 rounded-lg relative overflow-hidden">

      {/* Background - Town Square */}
      <div className="absolute inset-0 bg-gradient-to-b from-amber-900/20 to-medieval-900/50" />

      {/* Center - Gallows/Forca */}
      <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
        <div className="text-center">
          {/* Forca Visual */}
          <div className="text-6xl mb-2 filter drop-shadow-lg">
            ü™ì
          </div>
          <div className="text-amber-400 text-xs font-semibold">
            FORCA
          </div>
        </div>
      </div>

      {/* Living Players Circle */}
      {alivePlayers.map((player, index) => {
        const position = getPlayerPosition(index, alivePlayers.length);
        const isMe = me?.userId === player.userId;
        const hasVoted = gameState.votes && Object.keys(gameState.votes).includes(player.userId);
        const votesReceived = gameState.votes
          ? Object.values(gameState.votes).filter(targetId => targetId === player.id).length
          : 0;

        return (
          <div
            key={player.id}
            className="absolute transform -translate-x-1/2 -translate-y-1/2 transition-all duration-300 hover:scale-110"
            style={{
              left: `${position.x}%`,
              top: `${position.y}%`,
            }}
          >
            {/* Player Avatar Container */}
            <div className={`
              relative w-16 h-16 rounded-full border-2 transition-all duration-200
              ${isMe
                ? 'border-blue-400 bg-blue-900/80 ring-2 ring-blue-400/50'
                : 'border-medieval-600 bg-medieval-700/80 hover:border-amber-400'
              }
            `}>

              {/* Avatar */}
              <div className="w-full h-full rounded-full flex items-center justify-center text-2xl">
                {player.avatar ? (
                  <img src={player.avatar} alt={player.username} className="w-full h-full rounded-full" />
                ) : (
                  player.isHost ? 'üëë' : isMe ? 'üë§' : 'üßë'
                )}
              </div>

              {/* Connection Status Dot */}
              <div className={`
                absolute -top-1 -right-1 w-4 h-4 rounded-full border-2 border-medieval-900
                ${player.isConnected ? 'bg-green-400' : 'bg-red-400'}
              `} />

              {/* Vote Count Badge */}
              {votesReceived > 0 && gameState.phase === 'VOTING' && (
                <div className="absolute -bottom-2 left-1/2 transform -translate-x-1/2 bg-red-600 text-white text-xs rounded-full px-2 py-1 font-bold min-w-[24px] text-center">
                  {votesReceived}
                </div>
              )}

              {/* Has Voted Indicator */}
              {hasVoted && gameState.phase === 'VOTING' && (
                <div className="absolute -top-2 -left-2 text-green-400 text-lg">
                  ‚úì
                </div>
              )}

              {/* Protected Shield */}
              {player.isProtected && (
                <div className="absolute -bottom-2 -right-2 text-blue-400 text-lg">
                  üõ°Ô∏è
                </div>
              )}

              {/* Host Crown */}
              {player.isHost && (
                <div className="absolute -top-3 left-1/2 transform -translate-x-1/2 text-amber-400 text-lg">
                  üëë
                </div>
              )}
            </div>

            {/* Player Name */}
            <div className="absolute top-full left-1/2 transform -translate-x-1/2 mt-1 text-center min-w-[80px]">
              <div className={`
                text-xs font-semibold truncate px-2 py-1 rounded
                ${isMe
                  ? 'text-blue-300 bg-blue-900/50'
                  : 'text-white bg-medieval-800/50'
                }
              `}>
                {player.username}
              </div>

              {/* Role indicator (only for me or if dead) */}
              {((isMe && player.role) || (!player.isAlive && player.role)) && (
                <div className="text-xs text-purple-300 mt-1">
                  {player.role}
                </div>
              )}
            </div>
          </div>
        );
      })}

      {/* Dead Players - Ghosts around the gallows */}
      {deadPlayers.length > 0 && (
        <div className="absolute bottom-4 left-4 right-4">
          <div className="text-center">
            <h4 className="text-red-400 text-sm font-semibold mb-2 flex items-center justify-center space-x-1">
              <span>üíÄ</span>
              <span>Cemit√©rio ({deadPlayers.length})</span>
            </h4>

            <div className="flex flex-wrap justify-center gap-2">
              {deadPlayers.map((player) => (
                <div
                  key={player.id}
                  className="relative opacity-75 transform scale-75"
                >
                  <div className="w-8 h-8 rounded-full border border-gray-600 bg-gray-800/50 flex items-center justify-center">
                    <span className="text-lg">üëª</span>
                  </div>
                  <div className="absolute top-full left-1/2 transform -translate-x-1/2 mt-1 text-xs text-gray-400 min-w-[40px] text-center">
                    {player.username}
                  </div>
                  {player.role && (
                    <div className="absolute top-full left-1/2 transform -translate-x-1/2 mt-4 text-xs text-purple-400 text-center">
                      {player.role}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Phase Information Overlay */}
      <div className="absolute top-4 left-4 bg-medieval-800/80 border border-medieval-600 rounded-lg px-3 py-2">
        <div className="text-white text-sm">
          {gameState.phase === 'NIGHT' && (
            <div className="flex items-center space-x-2">
              <span>üåô</span>
              <span>A√ß√µes secretas em andamento...</span>
            </div>
          )}
          {gameState.phase === 'DAY' && (
            <div className="flex items-center space-x-2">
              <span>‚òÄÔ∏è</span>
              <span>Discutam e investiguem!</span>
            </div>
          )}
          {gameState.phase === 'VOTING' && (
            <div className="flex items-center space-x-2">
              <span>üó≥Ô∏è</span>
              <span>Votem para executar!</span>
            </div>
          )}
        </div>
      </div>

      {/* Empty State */}
      {alivePlayers.length === 0 && (
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-center">
            <div className="text-6xl mb-4">üëª</div>
            <h3 className="text-lg font-semibold text-white mb-2">Cidade Vazia</h3>
            <p className="text-white/70">Todos os jogadores foram eliminados...</p>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/PlayerList.tsx">
import React from 'react';
import { useGame } from '@/context/GameContext';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// PLAYER LIST COMPONENT - LISTA LATERAL COMPACTA
// =============================================================================
export default function PlayerList() {
  const { gameState, me } = useGame();

  if (!gameState) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex items-center justify-center h-full">
          <LoadingSpinner text="Carregando lista..." />
        </div>
      </div>
    );
  }

  const alivePlayers = gameState.players.filter(p => p.isAlive && !p.isSpectator);
  const deadPlayers = gameState.players.filter(p => !p.isAlive && !p.isSpectator);
  const spectators = gameState.players.filter(p => p.isSpectator) || [];

  // =============================================================================
  // PLAYER ROW COMPONENT
  // =============================================================================
  const PlayerRow = ({ player, isDead = false }: { player: any; isDead?: boolean }) => {
    const isMe = me?.userId === player.userId;
    const hasVoted = gameState.votes && Object.keys(gameState.votes).includes(player.userId);
    const votesReceived = gameState.votes
      ? Object.values(gameState.votes).filter(targetId => targetId === player.id).length
      : 0;

    return (
      <div className={`
        flex items-center space-x-2 p-2 rounded-lg transition-all duration-200
        ${isMe
          ? 'bg-blue-900/50 border border-blue-600'
          : isDead
            ? 'bg-gray-800/30 border border-gray-600 opacity-75'
            : 'bg-medieval-700/30 border border-medieval-600 hover:bg-medieval-700/50'
        }
      `}>

        {/* Status Indicators */}
        <div className="flex flex-col items-center space-y-1">
          {/* Connection Status */}
          <div className={`w-2 h-2 rounded-full ${player.isConnected ? 'bg-green-400' : 'bg-red-400'}`} />

          {/* Vote Count */}
          {votesReceived > 0 && gameState.phase === 'VOTING' && (
            <div className="bg-red-600 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center font-bold">
              {votesReceived}
            </div>
          )}
        </div>

        {/* Player Avatar */}
        <div className={`
          w-8 h-8 rounded-full flex items-center justify-center text-lg
          ${isDead ? 'bg-gray-700' : isMe ? 'bg-blue-800' : 'bg-medieval-600'}
        `}>
          {player.avatar ? (
            <img src={player.avatar} alt={player.username} className="w-full h-full rounded-full" />
          ) : (
            isDead ? 'üíÄ' : player.isHost ? 'üëë' : isMe ? 'üë§' : 'üßë'
          )}
        </div>

        {/* Player Info */}
        <div className="flex-1 min-w-0">
          <div className={`text-sm font-medium truncate ${isDead ? 'text-gray-400' : isMe ? 'text-blue-300' : 'text-white'}`}>
            {player.username}
          </div>

          {/* Tags */}
          <div className="flex flex-wrap gap-1 mt-1">
            {isMe && (
              <span className="bg-blue-600 text-white text-xs px-1 rounded">Voc√™</span>
            )}
            {player.isHost && (
              <span className="bg-amber-600 text-white text-xs px-1 rounded">Host</span>
            )}
            {player.isReady && gameState.phase === 'LOBBY' && (
              <span className="bg-green-600 text-white text-xs px-1 rounded">Pronto</span>
            )}
            {hasVoted && gameState.phase === 'VOTING' && (
              <span className="bg-green-600 text-white text-xs px-1 rounded">Votou</span>
            )}
            {player.hasActed && gameState.phase === 'NIGHT' && (
              <span className="bg-blue-600 text-white text-xs px-1 rounded">Agiu</span>
            )}
            {player.isProtected && (
              <span className="bg-purple-600 text-white text-xs px-1 rounded">üõ°Ô∏è</span>
            )}
          </div>

          {/* Role (only shown if dead or if it's me) */}
          {((isDead && player.role) || (isMe && player.role)) && (
            <div className="text-xs text-purple-300 mt-1">
              {player.role}
            </div>
          )}
        </div>

        {/* Action Indicators */}
        <div className="flex flex-col items-center space-y-1">
          {/* Has Voted */}
          {hasVoted && gameState.phase === 'VOTING' && (
            <div className="text-green-400 text-sm">‚úì</div>
          )}

          {/* Host Crown */}
          {player.isHost && (
            <div className="text-amber-400 text-sm">üëë</div>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Header */}
      <div className="flex-shrink-0 border-b border-medieval-600 p-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-bold text-white flex items-center space-x-2">
            <span>üë•</span>
            <span>Jogadores</span>
          </h3>

          <div className="text-xs text-white/70">
            {alivePlayers.length + deadPlayers.length} total
          </div>
        </div>

        {/* Quick Stats */}
        <div className="flex items-center space-x-4 mt-2 text-xs">
          <div className="flex items-center space-x-1">
            <div className="w-2 h-2 bg-green-500 rounded-full"></div>
            <span className="text-green-400">Vivos: {alivePlayers.length}</span>
          </div>
          <div className="flex items-center space-x-1">
            <div className="w-2 h-2 bg-red-500 rounded-full"></div>
            <span className="text-red-400">Mortos: {deadPlayers.length}</span>
          </div>
        </div>
      </div>

      {/* Players List */}
      <div className="flex-1 overflow-y-auto p-4 space-y-2">

        {/* Living Players */}
        {alivePlayers.length > 0 && (
          <div>
            <h4 className="text-sm font-semibold text-green-400 mb-2 flex items-center space-x-1">
              <span>üíö</span>
              <span>Vivos ({alivePlayers.length})</span>
            </h4>
            <div className="space-y-1">
              {alivePlayers.map((player) => (
                <PlayerRow key={player.id} player={player} />
              ))}
            </div>
          </div>
        )}

        {/* Dead Players */}
        {deadPlayers.length > 0 && (
          <div className="mt-4">
            <h4 className="text-sm font-semibold text-red-400 mb-2 flex items-center space-x-1">
              <span>üíÄ</span>
              <span>Mortos ({deadPlayers.length})</span>
            </h4>
            <div className="space-y-1">
              {deadPlayers.map((player) => (
                <PlayerRow key={player.id} player={player} isDead={true} />
              ))}
            </div>
          </div>
        )}

        {/* Spectators */}
        {spectators.length > 0 && (
          <div className="mt-4">
            <h4 className="text-sm font-semibold text-blue-400 mb-2 flex items-center space-x-1">
              <span>üëÅÔ∏è</span>
              <span>Espectadores ({spectators.length})</span>
            </h4>
            <div className="space-y-1">
              {spectators.map((spectator) => (
                <div
                  key={spectator.id}
                  className="flex items-center space-x-2 p-2 bg-blue-900/20 border border-blue-600 rounded-lg"
                >
                  <div className="w-8 h-8 rounded-full bg-blue-800 flex items-center justify-center text-lg">
                    üëÅÔ∏è
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="text-sm text-blue-300 truncate">{spectator.username}</div>
                    <div className="text-xs text-blue-400">Espectador</div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* Vote Summary (during voting phase) */}
      {gameState.phase === 'VOTING' && gameState.votes && Object.keys(gameState.votes).length > 0 && (
        <div className="flex-shrink-0 border-t border-medieval-600 p-4">
          <h4 className="text-sm font-semibold text-white mb-2">üó≥Ô∏è Resumo dos Votos</h4>

          <div className="space-y-1">
            {Object.entries(
              Object.entries(gameState.votes).reduce((acc, [voterId, targetId]) => {
                const target = alivePlayers.find(p => p.id === targetId);
                if (target) {
                  acc[targetId] = (acc[targetId] || 0) + 1;
                }
                return acc;
              }, {} as Record<string, number>)
            )
              .sort(([, a], [, b]) => b - a) // Sort by vote count
              .map(([playerId, voteCount]) => {
                const player = alivePlayers.find(p => p.id === playerId);
                return player ? (
                  <div key={playerId} className="flex justify-between items-center text-sm">
                    <span className="text-white truncate">{player.username}</span>
                    <span className="bg-red-700 text-white px-2 py-1 rounded text-xs font-bold">
                      {voteCount} {voteCount === 1 ? 'voto' : 'votos'}
                    </span>
                  </div>
                ) : null;
              })}
          </div>
        </div>
      )}

      {/* Empty State */}
      {alivePlayers.length === 0 && deadPlayers.length === 0 && (
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center text-white/50">
            <div className="text-4xl mb-2">üëª</div>
            <p>Nenhum jogador</p>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/RoleCard.tsx">
import React, { useState } from 'react';
import { useGame } from '@/context/GameContext';
import type { Role, Faction } from '@/types';

// =============================================================================
// ROLE CONFIGURATIONS
// =============================================================================
const ROLE_INFO: Record<Role, {
  name: string;
  icon: string;
  description: string;
  abilities: string[];
  goal: string;
  tips: string[];
}> = {
  VILLAGER: {
    name: 'Alde√£o',
    icon: 'üë®‚Äçüåæ',
    description: 'Um cidad√£o comum da vila',
    abilities: ['Votar durante o dia'],
    goal: 'Eliminar todos os Lobisomens',
    tips: [
      'Preste aten√ß√£o aos comportamentos suspeitos',
      'Use seu voto com sabedoria',
      'Confie nas informa√ß√µes do Sheriff'
    ],
  },
  SHERIFF: {
    name: 'Sheriff',
    icon: 'üïµÔ∏è',
    description: 'Investigador da vila',
    abilities: ['Investigar um jogador por noite', 'Descobre se √© SUSPEITO ou N√ÉO SUSPEITO'],
    goal: 'Encontrar e eliminar todos os Lobisomens',
    tips: [
      'Investigue jogadores suspeitos',
      'Compartilhe informa√ß√µes com cuidado',
      'Cuidado para n√£o se revelar cedo demais'
    ],
  },
  DOCTOR: {
    name: 'M√©dico',
    icon: '‚öïÔ∏è',
    description: 'Protetor da vila',
    abilities: ['Proteger um jogador por noite', 'N√£o pode proteger a mesma pessoa duas noites seguidas'],
    goal: 'Manter a vila viva eliminando Lobisomens',
    tips: [
      'Proteja jogadores importantes',
      'N√£o se proteja consecutivamente',
      'Observe padr√µes de ataque'
    ],
  },
  VIGILANTE: {
    name: 'Vigilante',
    icon: 'üî´',
    description: 'Justiceiro da vila',
    abilities: ['Matar um jogador por noite (3 usos)', 'Perde turno se matar inocente'],
    goal: 'Eliminar Lobisomens com sua arma',
    tips: [
      'Use suas balas com muito cuidado',
      'S√≥ atire se tiver certeza',
      'Matar um inocente te faz perder uma noite'
    ],
  },
  WEREWOLF: {
    name: 'Lobisomem',
    icon: 'üê∫',
    description: 'Predador da noite',
    abilities: ['Matar um jogador por noite (vota√ß√£o em grupo)', 'Chat privado com outros lobisomens'],
    goal: 'Igualar ou superar o n√∫mero da Vila',
    tips: [
      'Coordene com outros lobisomens',
      'Blefe durante o dia',
      'Elimine amea√ßas priorit√°rias'
    ],
  },
  WEREWOLF_KING: {
    name: 'Rei Lobisomem',
    icon: 'üëë',
    description: 'L√≠der da alcateia',
    abilities: ['Matar um jogador por noite', 'Imune √† investiga√ß√£o do Sheriff', 'Chat privado com lobisomens'],
    goal: 'Liderar a alcateia at√© a vit√≥ria',
    tips: [
      'Use sua imunidade ao Sheriff',
      'Lidere as decis√µes da alcateia',
      'Mantenha-se disfar√ßado'
    ],
  },
  JESTER: {
    name: 'Bobo da Corte',
    icon: 'ü§°',
    description: 'Personagem ca√≥tico',
    abilities: ['Vencer se for executado durante o dia', 'Imune a ataques noturnos'],
    goal: 'Ser executado pela vila (N√ÉO morto √† noite)',
    tips: [
      'Pare√ßa suspeito sem ser √≥bvio',
      'Evite ser morto √† noite',
      'Cause confus√£o nas discuss√µes'
    ],
  },
  SERIAL_KILLER: {
    name: 'Assassino em S√©rie',
    icon: 'üî™',
    description: 'Matador solit√°rio',
    abilities: ['Matar um jogador por noite', 'Imune a investiga√ß√£o na primeira noite'],
    goal: 'Ser o √∫ltimo sobrevivente',
    tips: [
      'Elimine todos os outros',
      'Finja ser da vila',
      'Mate amea√ßas e suspeitos'
    ],
  },
};

const FACTION_INFO: Record<Faction, {
  name: string;
  color: string;
  bgColor: string;
  borderColor: string;
}> = {
  TOWN: {
    name: 'Vila',
    color: 'text-green-400',
    bgColor: 'bg-green-900',
    borderColor: 'border-green-600',
  },
  WEREWOLF: {
    name: 'Lobisomens',
    color: 'text-red-400',
    bgColor: 'bg-red-900',
    borderColor: 'border-red-600',
  },
  NEUTRAL: {
    name: 'Neutro',
    color: 'text-purple-400',
    bgColor: 'bg-purple-900',
    borderColor: 'border-purple-600',
  },
};

// =============================================================================
// ROLE CARD COMPONENT - COMPACTO PARA LAYOUT TOWN OF SALEM
// =============================================================================
export default function RoleCard() {
  const { me, gameState } = useGame();
  const [isExpanded, setIsExpanded] = useState(false);

  if (!me || !me.role || !me.faction || !gameState) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4 animate-pulse">‚ùì</div>
          <h3 className="text-white font-semibold mb-2">Aguardando Role</h3>
          <p className="text-white/50 text-sm">Sua role ser√° revelada quando o jogo come√ßar</p>
        </div>
      </div>
    );
  }

  const roleInfo = ROLE_INFO[me.role];
  const factionInfo = FACTION_INFO[me.faction];

  if (!roleInfo || !factionInfo) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">‚ùì</div>
          <h3 className="text-white font-semibold mb-2">Role Desconhecida</h3>
          <p className="text-white/50 text-sm">Role: {me.role}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Header - Always Visible */}
      <div className={`
        flex-shrink-0 ${factionInfo.bgColor} border-b ${factionInfo.borderColor} p-4 rounded-t-lg cursor-pointer transition-all duration-200
        ${isExpanded ? '' : 'hover:opacity-80'}
      `} onClick={() => setIsExpanded(!isExpanded)}>

        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="text-3xl">{roleInfo.icon}</div>
            <div>
              <h3 className="text-white font-bold text-lg">{roleInfo.name}</h3>
              <p className={`text-sm ${factionInfo.color}`}>{factionInfo.name}</p>
            </div>
          </div>

          <div className="text-white text-lg">
            {isExpanded ? 'üìñ' : 'üìö'}
          </div>
        </div>

        {/* Quick Status - Always Visible */}
        {!isExpanded && (
          <div className="mt-3 grid grid-cols-2 gap-2 text-xs">
            <div className="flex justify-between">
              <span className="text-white/70">Status:</span>
              <span className={me.isAlive ? 'text-green-400' : 'text-red-400'}>
                {me.isAlive ? 'Vivo' : 'Morto'}
              </span>
            </div>

            {me.hasActed !== undefined && gameState?.phase === 'NIGHT' && (
              <div className="flex justify-between">
                <span className="text-white/70">A√ß√£o:</span>
                <span className={me.hasActed ? 'text-blue-400' : 'text-amber-400'}>
                  {me.hasActed ? 'Usada' : 'Dispon√≠vel'}
                </span>
              </div>
            )}

            {me.hasVoted !== undefined && gameState?.phase === 'VOTING' && (
              <div className="flex justify-between">
                <span className="text-white/70">Voto:</span>
                <span className={me.hasVoted ? 'text-green-400' : 'text-amber-400'}>
                  {me.hasVoted ? 'Votou' : 'Pendente'}
                </span>
              </div>
            )}

            {me.isProtected && (
              <div className="flex justify-between col-span-2">
                <span className="text-white/70">Prote√ß√£o:</span>
                <span className="text-blue-400">üõ°Ô∏è Ativa</span>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Expanded Content */}
      {isExpanded && (
        <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-medieval-900/20">

          {/* Description */}
          <div>
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>üìù</span>
              <span>Descri√ß√£o</span>
            </h4>
            <p className="text-white/80 text-sm">{roleInfo.description}</p>
          </div>

          {/* Abilities */}
          <div>
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>‚ö°</span>
              <span>Habilidades</span>
            </h4>
            <ul className="space-y-1">
              {roleInfo.abilities.map((ability, index) => (
                <li key={index} className="text-white/80 text-sm flex items-start space-x-2">
                  <span className="text-blue-400 mt-1 flex-shrink-0">‚Ä¢</span>
                  <span>{ability}</span>
                </li>
              ))}
            </ul>
          </div>

          {/* Goal */}
          <div>
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>üéØ</span>
              <span>Objetivo</span>
            </h4>
            <p className={`text-sm font-medium ${factionInfo.color} bg-medieval-800/50 p-2 rounded border ${factionInfo.borderColor}`}>
              {roleInfo.goal}
            </p>
          </div>

          {/* Tips */}
          <div>
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>üí°</span>
              <span>Dicas</span>
            </h4>
            <ul className="space-y-1">
              {roleInfo.tips.map((tip, index) => (
                <li key={index} className="text-white/70 text-xs flex items-start space-x-2">
                  <span className="text-amber-400 mt-1 flex-shrink-0">üí°</span>
                  <span>{tip}</span>
                </li>
              ))}
            </ul>
          </div>

          {/* Detailed Status */}
          <div className="border-t border-medieval-600 pt-3">
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>üìä</span>
              <span>Status Detalhado</span>
            </h4>

            <div className="grid grid-cols-1 gap-2 text-xs">
              <div className="flex justify-between p-2 bg-medieval-800/30 rounded">
                <span className="text-white/70">Status de Vida:</span>
                <span className={me.isAlive ? 'text-green-400' : 'text-red-400'}>
                  {me.isAlive ? 'üíö Vivo' : 'üíÄ Morto'}
                </span>
              </div>

              {me.hasActed !== undefined && (
                <div className="flex justify-between p-2 bg-medieval-800/30 rounded">
                  <span className="text-white/70">A√ß√£o Noturna:</span>
                  <span className={me.hasActed ? 'text-blue-400' : 'text-amber-400'}>
                    {me.hasActed ? '‚úÖ Executada' : '‚è≥ Dispon√≠vel'}
                  </span>
                </div>
              )}

              {me.hasVoted !== undefined && (
                <div className="flex justify-between p-2 bg-medieval-800/30 rounded">
                  <span className="text-white/70">Voto:</span>
                  <span className={me.hasVoted ? 'text-green-400' : 'text-amber-400'}>
                    {me.hasVoted ? 'üó≥Ô∏è Votou' : '‚è≥ Pendente'}
                  </span>
                </div>
              )}

              {me.isProtected && (
                <div className="flex justify-between p-2 bg-blue-900/30 rounded border border-blue-600">
                  <span className="text-white/70">Prote√ß√£o:</span>
                  <span className="text-blue-400">üõ°Ô∏è Protegido</span>
                </div>
              )}

              {me.actionsUsed !== undefined && me.maxActions !== undefined && (
                <div className="flex justify-between p-2 bg-medieval-800/30 rounded">
                  <span className="text-white/70">A√ß√µes Restantes:</span>
                  <span className="text-amber-400">{me.maxActions - me.actionsUsed}/{me.maxActions}</span>
                </div>
              )}

              {me.eliminationReason && (
                <div className="flex justify-between p-2 bg-red-900/30 rounded border border-red-600">
                  <span className="text-white/70">Causa da Morte:</span>
                  <span className="text-red-400">
                    {me.eliminationReason === 'NIGHT_KILL' ? 'üåô Morto √† noite' :
                      me.eliminationReason === 'EXECUTION' ? 'üó≥Ô∏è Executado' :
                        me.eliminationReason === 'VIGILANTE' ? 'üî´ Vigilante' :
                          'üî™ Assassino'}
                  </span>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Footer - Game Info */}
      {!isExpanded && gameState && (
        <div className="flex-shrink-0 border-t border-medieval-600 p-3 bg-medieval-900/30">
          <div className="text-xs text-center text-white/50">
            Dia {gameState.day} ‚Ä¢ {gameState.phase === 'NIGHT' ? 'üåô Noite' :
              gameState.phase === 'DAY' ? '‚òÄÔ∏è Dia' :
                gameState.phase === 'VOTING' ? 'üó≥Ô∏è Vota√ß√£o' :
                  gameState.phase}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/TimerDisplay.tsx">
import React, { useEffect, useState } from 'react';
import { useGame } from '@/context/GameContext';

// =============================================================================
// TIMER DISPLAY COMPONENT - COMPACTO PARA HEADER
// =============================================================================
export default function TimerDisplay() {
  const { gameState } = useGame();
  const [localTimeLeft, setLocalTimeLeft] = useState(0);

  // =============================================================================
  // SYNC WITH GAME STATE
  // =============================================================================
  useEffect(() => {
    if (!gameState) return;

    // Use timeLeft from gameState
    const newTimeLeft = gameState.timeLeft || 0;
    setLocalTimeLeft(newTimeLeft);
  }, [gameState?.timeLeft, gameState?.phase]);

  // =============================================================================
  // LOCAL COUNTDOWN UPDATE
  // =============================================================================
  useEffect(() => {
    if (localTimeLeft <= 0) return;

    const interval = setInterval(() => {
      setLocalTimeLeft(prev => Math.max(0, prev - 1000));
    }, 1000);

    return () => clearInterval(interval);
  }, [localTimeLeft]);

  // =============================================================================
  // NO GAME STATE
  // =============================================================================
  if (!gameState) {
    return (
      <div className="flex items-center space-x-2">
        <div className="animate-pulse bg-medieval-700 h-10 w-20 rounded-lg"></div>
      </div>
    );
  }

  // =============================================================================
  // CALCULATE DISPLAY VALUES
  // =============================================================================
  const totalSeconds = Math.floor(localTimeLeft / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;

  // Determine urgency level
  const isUrgent = totalSeconds <= 30;
  const isCritical = totalSeconds <= 10;
  const isEmpty = totalSeconds <= 0;

  // Color scheme based on time remaining
  const getTimerColor = () => {
    if (isEmpty) return 'text-gray-500';
    if (isCritical) return 'text-red-400';
    if (isUrgent) return 'text-amber-400';
    return 'text-green-400';
  };

  const getBorderColor = () => {
    if (isEmpty) return 'border-gray-600';
    if (isCritical) return 'border-red-500';
    if (isUrgent) return 'border-amber-500';
    return 'border-green-500';
  };

  const getBackgroundColor = () => {
    if (isEmpty) return 'bg-gray-800';
    if (isCritical) return 'bg-red-900';
    if (isUrgent) return 'bg-amber-900';
    return 'bg-green-900';
  };

  // =============================================================================
  // RENDER TIMER
  // =============================================================================
  return (
    <div className="flex items-center space-x-3">

      {/* Main Timer Display - Compact */}
      <div className={`
        ${getBackgroundColor()} border-2 ${getBorderColor()} rounded-lg px-3 py-2
        ${isCritical ? 'animate-pulse' : ''}
        transition-all duration-300 flex items-center space-x-2
      `}>

        {/* Timer Icon */}
        <div className="text-lg">
          {isEmpty ? '‚è∞' :
            isCritical ? 'üî•' :
              isUrgent ? '‚ö°' : '‚è±Ô∏è'}
        </div>

        {/* Time Display */}
        <div className="text-center">
          <div className={`text-lg font-mono font-bold ${getTimerColor()}`}>
            {isEmpty ? '--:--' : `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`}
          </div>
        </div>
      </div>

      {/* Status Text */}
      <div className="hidden md:block">
        {isUrgent && !isEmpty && (
          <div className="flex items-center space-x-1 text-amber-400">
            <span className="animate-bounce">‚ö†Ô∏è</span>
            <span className="text-xs font-medium">
              {isCritical ? 'CR√çTICO!' : 'Tempo Acabando!'}
            </span>
          </div>
        )}

        {isEmpty && (
          <div className="flex items-center space-x-1 text-gray-400">
            <span>‚è≥</span>
            <span className="text-xs">
              Aguardando...
            </span>
          </div>
        )}

        {!isUrgent && !isEmpty && (
          <div className="text-xs text-white/50">
            {gameState.phase === 'NIGHT' ? 'Fase Noite' :
              gameState.phase === 'DAY' ? 'Fase Dia' :
                gameState.phase === 'VOTING' ? 'Vota√ß√£o' :
                  'Tempo restante'}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/room/ActionButtons.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import {
  Check,
  Clock,
  Play,
  Wifi,
  WifiOff,
  AlertCircle,
  Crown
} from 'lucide-react';

interface ActionButtonsProps {
  isHost: boolean;
  isReady: boolean;
  canStartGame: boolean;
  isConnected: boolean;
  onToggleReady: () => void;
  onStartGame: () => void;
}

export default function ActionButtons({
  isHost,
  isReady,
  canStartGame,
  isConnected,
  onToggleReady,
  onStartGame
}: ActionButtonsProps) {
  return (
    <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
      <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
        {isHost && <Crown className="w-5 h-5 text-yellow-400" />}
        {isHost ? 'Controles do Host' : 'A√ß√µes'}
      </h3>

      <div className="space-y-3">
        {/* ‚úÖ CORRIGIDO: Bot√£o Ready apenas para jogadores, n√£o para o host */}
        {!isHost && (
          <motion.button
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            onClick={onToggleReady}
            disabled={!isConnected}
            className={`
              w-full py-3 px-4 rounded-lg font-medium transition-all duration-200
              flex items-center justify-center gap-2
              ${isReady
                ? 'bg-green-600 hover:bg-green-700 text-white shadow-lg'
                : 'bg-orange-600 hover:bg-orange-700 text-white'
              }
              disabled:opacity-50 disabled:cursor-not-allowed
            `}
          >
            {isReady ? (
              <>
                <Check className="w-5 h-5" />
                Pronto! (Clique para cancelar)
              </>
            ) : (
              <>
                <Clock className="w-5 h-5" />
                Marcar como Pronto
              </>
            )}
          </motion.button>
        )}

        {/* ‚úÖ CORRIGIDO: Bot√£o Start Game apenas para host */}
        {isHost && (
          <motion.button
            whileHover={canStartGame ? { scale: 1.02 } : {}}
            whileTap={canStartGame ? { scale: 0.98 } : {}}
            onClick={onStartGame}
            disabled={!canStartGame || !isConnected}
            className={`
              w-full py-3 px-4 rounded-lg font-medium transition-all duration-200
              flex items-center justify-center gap-2
              ${canStartGame
                ? 'bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white shadow-lg shadow-green-600/25'
                : 'bg-slate-600 text-slate-400 cursor-not-allowed'
              }
              disabled:opacity-50
            `}
          >
            <Play className="w-5 h-5" />
            {canStartGame ? 'üéÆ Iniciar Jogo!' : 'Aguardando jogadores prontos...'}
          </motion.button>
        )}

        {/* ‚úÖ NOVO: Mensagem informativa para o host sobre n√£o precisar ficar "pronto" */}
        {isHost && (
          <div className="mt-3 p-3 bg-yellow-600/20 rounded-lg border border-yellow-600/50">
            <div className="flex items-center gap-2 text-sm text-yellow-300 mb-2">
              <Crown className="w-4 h-4" />
              Voc√™ √© o host
            </div>
            <p className="text-xs text-yellow-200">
              Como host, voc√™ n√£o precisa marcar como "pronto". Voc√™ pode iniciar o jogo quando todos os outros jogadores estiverem prontos.
            </p>
          </div>
        )}

        {/* Informa√ß√µes adicionais para host */}
        {isHost && (
          <div className="mt-4 p-3 bg-slate-700/30 rounded-lg border border-slate-600/50">
            <div className="flex items-center gap-2 text-sm text-slate-300 mb-2">
              <AlertCircle className="w-4 h-4" />
              Requisitos para iniciar:
            </div>
            <ul className="text-xs text-slate-400 space-y-1">
              <li>‚Ä¢ M√≠nimo de 3 jogadores</li>
              <li>‚Ä¢ Todos os jogadores prontos</li>
              <li>‚Ä¢ Conex√£o est√°vel</li>
            </ul>
          </div>
        )}

        {/* ‚úÖ MELHORADO: Informa√ß√µes para jogadores */}
        {!isHost && (
          <div className="mt-4 p-3 bg-blue-600/20 rounded-lg border border-blue-600/50">
            <div className="flex items-center gap-2 text-sm text-blue-300 mb-2">
              <AlertCircle className="w-4 h-4" />
              Aguardando outros jogadores
            </div>
            <p className="text-xs text-blue-200">
              Marque-se como pronto quando estiver preparado para jogar. O host iniciar√° a partida quando todos estiverem prontos.
            </p>
          </div>
        )}

        {/* Indicador de conex√£o */}
        <div className="flex items-center justify-center gap-2 text-sm pt-2 border-t border-slate-600/50">
          {isConnected ? (
            <>
              <Wifi className="w-4 h-4 text-green-500" />
              <span className="text-green-500">Conectado</span>
            </>
          ) : (
            <>
              <WifiOff className="w-4 h-4 text-red-500" />
              <span className="text-red-500">Desconectado</span>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/context/ThemeContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import audioService from '@/services/audioService';

// =============================================================================
// TYPES
// =============================================================================
interface PhaseColors {
  background: string;
  text: string;
  accent: string;
  border: string;
}

interface AudioConfig {
  musicVolume: number;
  sfxVolume: number;
  enabled: boolean;
}

interface ThemeContextType {
  theme: 'werewolf' | 'medieval' | 'modern';
  setTheme: (theme: 'werewolf' | 'medieval' | 'modern') => void;
  playSound: (soundId: string) => void;
  playMusic: (musicId: string) => void;
  stopMusic: () => void;
  setMusicVolume: (volume: number) => void;
  setSoundVolume: (volume: number) => void;
  musicVolume: number;
  soundVolume: number;
  isMusicPlaying: boolean;
  isAudioUnblocked: boolean;
  getPhaseColors: () => PhaseColors;
  getThemeClass: () => string;
  audioConfig: AudioConfig;
  updateAudioConfig: (config: Partial<AudioConfig>) => void;
}

// =============================================================================
// THEME CONTEXT
// =============================================================================
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// =============================================================================
// THEME PROVIDER
// =============================================================================
export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<'werewolf' | 'medieval' | 'modern'>('werewolf');
  const [audioConfig, setAudioConfig] = useState<AudioConfig>({
    musicVolume: 0.5,
    sfxVolume: 0.7,
    enabled: true,
  });

  // =============================================================================
  // AUDIO FUNCTIONS (delegando para o audioService)
  // =============================================================================
  const playSound = (soundId: string) => {
    if (audioConfig.enabled) {
      audioService.playSound(soundId);
    }
  };

  const playMusic = (musicId: string) => {
    if (audioConfig.enabled) {
      audioService.playMusic(musicId);
    }
  };

  const stopMusic = () => {
    audioService.stopMusic();
  };

  const setMusicVolume = (volume: number) => {
    const newConfig = { ...audioConfig, musicVolume: volume };
    setAudioConfig(newConfig);
    audioService.setMusicVolume(volume);
  };

  const setSoundVolume = (volume: number) => {
    const newConfig = { ...audioConfig, sfxVolume: volume };
    setAudioConfig(newConfig);
    audioService.setSoundVolume(volume);
  };

  const updateAudioConfig = (config: Partial<AudioConfig>) => {
    const newConfig = { ...audioConfig, ...config };
    setAudioConfig(newConfig);

    // Atualizar volumes no audioService
    if (config.musicVolume !== undefined) {
      audioService.setMusicVolume(config.musicVolume);
    }
    if (config.sfxVolume !== undefined) {
      audioService.setSoundVolume(config.sfxVolume);
    }

    // Se desabilitou o √°udio, para a m√∫sica
    if (config.enabled === false) {
      audioService.stopMusic();
    }
  };

  // =============================================================================
  // THEME UTILITIES (que o Layout.tsx precisa)
  // =============================================================================
  const getPhaseColors = (): PhaseColors => {
    // Por enquanto retorna cores padr√£o do tema medieval
    // Quando implementar fases do jogo, adicionar l√≥gica aqui
    return {
      background: 'from-medieval-900 to-medieval-800',
      text: 'text-white',
      accent: 'text-salem-300',
      border: 'border-medieval-600',
    };
  };

  const getThemeClass = (): string => {
    return `theme-${theme}`;
  };

  // =============================================================================
  // THEME EFFECT
  // =============================================================================
  useEffect(() => {
    // Aplicar classes do tema
    document.documentElement.setAttribute('data-theme', theme);

    // Aplicar classes espec√≠ficas
    if (theme === 'werewolf') {
      document.documentElement.classList.add('werewolf-theme');
      document.documentElement.classList.remove('medieval-theme', 'modern-theme');
    } else if (theme === 'medieval') {
      document.documentElement.classList.add('medieval-theme');
      document.documentElement.classList.remove('werewolf-theme', 'modern-theme');
    } else {
      document.documentElement.classList.add('modern-theme');
      document.documentElement.classList.remove('werewolf-theme', 'medieval-theme');
    }
  }, [theme]);

  // =============================================================================
  // CONTEXT VALUE
  // =============================================================================
  const value: ThemeContextType = {
    theme,
    setTheme,
    playSound,
    playMusic,
    stopMusic,
    setMusicVolume,
    setSoundVolume,
    musicVolume: audioConfig.musicVolume,
    soundVolume: audioConfig.sfxVolume,
    isMusicPlaying: audioService.isMusicPlaying,
    isAudioUnblocked: audioService.isAudioUnblocked,
    getPhaseColors,
    getThemeClass,
    audioConfig,
    updateAudioConfig,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// =============================================================================
// USE THEME HOOK
// =============================================================================
export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}
</file>

<file path="frontend/src/pages/_app.tsx">
// üê∫ LOBISOMEM ONLINE - Next.js App Component
// Global app configuration and providers

import type { AppProps } from 'next/app';
import Head from 'next/head';
import { Inter, Cinzel, Pirata_One } from 'next/font/google';
import { Toaster } from 'react-hot-toast';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/router';
import { useEffect } from 'react';

// Context Providers
import { AuthProvider } from '@/context/AuthContext';
import { SocketProvider } from '@/context/SocketContext';
import { ThemeProvider } from '@/context/ThemeContext';

// Components
import ErrorBoundary from '@/components/common/ErrorBoundary';
import { PageLoading } from '@/components/common/LoadingSpinner';

// Styles
import '@/styles/globals.css';

// =============================================================================
// FONT CONFIGURATION
// =============================================================================
const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
  display: 'swap',
});

const cinzel = Cinzel({
  subsets: ['latin'],
  variable: '--font-cinzel',
  display: 'swap',
});

const pirataOne = Pirata_One({
  weight: '400',
  subsets: ['latin'],
  variable: '--font-pirata',
  display: 'swap',
});

// =============================================================================
// PAGE TRANSITION VARIANTS
// =============================================================================
const pageVariants = {
  initial: {
    opacity: 0,
    y: 20,
  },
  in: {
    opacity: 1,
    y: 0,
  },
  out: {
    opacity: 0,
    y: -20,
  },
};

const pageTransition = {
  type: 'tween',
  ease: 'anticipate',
  duration: 0.3,
};

// =============================================================================
// MAIN APP COMPONENT
// =============================================================================
export default function App({ Component, pageProps, router }: AppProps) {
  const { pathname } = useRouter();

  // ‚úÖ ADICIONADO: Suprimir warnings de hydration em desenvolvimento
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      const originalError = console.error;
      console.error = (...args) => {
        if (args[0]?.includes?.('Hydration')) return;
        if (args[0]?.includes?.('Text content does not match')) return;
        originalError(...args);
      };
    }
  }, []);

  return (
    <>
      {/* HEAD com viewport no lugar correto */}
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no, viewport-fit=cover" />
      </Head>

      <ErrorBoundary>
        {/* Font variables */}
        <div className={`${inter.variable} ${cinzel.variable} ${pirataOne.variable}`}>

          {/* ‚úÖ CORRIGIDO: Ordem correta de Context Providers */}
          <ThemeProvider>
            <AuthProvider>
              <SocketProvider> {/* SocketProvider DEVE vir AP√ìS AuthProvider */}

                {/* Page Transitions */}
                <AnimatePresence mode="wait" initial={false}>
                  <motion.div
                    key={router.route}
                    initial="initial"
                    animate="in"
                    exit="out"
                    variants={pageVariants}
                    transition={pageTransition}
                  >
                    <Component {...pageProps} />
                  </motion.div>
                </AnimatePresence>

                {/* Global Toast Notifications */}
                <Toaster
                  position="top-right"
                  toastOptions={{
                    duration: 4000,
                    style: {
                      background: '#2D1B1E',
                      color: '#F4E4BC',
                      border: '1px solid #8B925A',
                      fontFamily: 'var(--font-inter)',
                    },
                    success: {
                      iconTheme: {
                        primary: '#228B22',
                        secondary: '#F4E4BC',
                      },
                    },
                    error: {
                      iconTheme: {
                        primary: '#8B0000',
                        secondary: '#F4E4BC',
                      },
                    },
                  }}
                />

                {/* Loading Overlay for Page Transitions */}
                <AnimatePresence>
                  {router.isFallback && (
                    <motion.div
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      exit={{ opacity: 0 }}
                      className="fixed inset-0 z-50"
                    >
                      <PageLoading />
                    </motion.div>
                  )}
                </AnimatePresence>

              </SocketProvider>
            </AuthProvider>
          </ThemeProvider>
        </div>
      </ErrorBoundary>
    </>
  );
}

// =============================================================================
// GLOBAL ERROR HANDLER
// =============================================================================
if (typeof window !== 'undefined') {
  // Handle global errors
  window.addEventListener('error', (event) => {
    // ‚úÖ MELHORADO: Filtrar erros de hydration
    if (event.error?.message?.includes?.('Hydration')) return;
    if (event.error?.message?.includes?.('Text content does not match')) return;

    console.error('Global error:', event.error);
    // You could send this to an error reporting service
  });

  // Handle unhandled promise rejections
  window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    // You could send this to an error reporting service
  });

  // Performance monitoring
  if (process.env.NODE_ENV === 'development') {
    // Log performance metrics in development
    window.addEventListener('load', () => {
      setTimeout(() => {
        const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
        console.log('üöÄ Page Load Performance:', {
          'DNS Lookup': navigation.domainLookupEnd - navigation.domainLookupStart,
          'TCP Connection': navigation.connectEnd - navigation.connectStart,
          'Request': navigation.responseStart - navigation.requestStart,
          'Response': navigation.responseEnd - navigation.responseStart,
          'DOM Processing': navigation.domComplete - navigation.domLoading,
          'Total Load Time': navigation.loadEventEnd - navigation.navigationStart,
        });
      }, 0);
    });
  }
}
</file>

<file path="frontend/src/pages/_document.tsx">
// üê∫ WEREWOLF - Next.js Document
// Custom HTML document structure

import { Html, Head, Main, NextScript } from 'next/document';

export default function Document() {
  return (
    <Html lang="pt-BR" className="dark"> {/* ‚úÖ ADICIONADO: lang="pt-BR" */}
      <Head>
        {/* Favicon and App Icons */}
        <link rel="icon" href="/favicon.ico" />
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
        <link rel="manifest" href="/site.webmanifest" />
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#8B925A" />
        <meta name="msapplication-TileColor" content="#2D1B1E" />
        <meta name="theme-color" content="#2D1B1E" />

        {/* ‚úÖ MELHORADO: Meta Tags mais completas */}
        <meta name="description" content="Werewolf - O cl√°ssico jogo de dedu√ß√£o social online. Entre na vila e descubra quem s√£o os lobisomens!" />
        <meta name="keywords" content="werewolf, lobisomem, jogo online, multiplayer, dedu√ß√£o social, mafia" />
        <meta name="author" content="Werewolf Team" />
        <meta name="robots" content="index, follow" />

        {/* ‚úÖ ADICIONADO: Meta tags para PWA */}
        <meta name="format-detection" content="telephone=no" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="apple-mobile-web-app-title" content="Werewolf" />

        {/* Open Graph / Facebook */}
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Werewolf - O Jogo de Dedu√ß√£o Social" />
        <meta property="og:description" content="O cl√°ssico jogo de dedu√ß√£o social online. Descubra quem s√£o os lobisomens antes que eliminem toda a vila!" />
        <meta property="og:image" content="/og-image.png" />
        <meta property="og:url" content="https://werewolf-game.com" />
        <meta property="og:site_name" content="Werewolf" />
        <meta property="og:locale" content="pt_BR" />

        {/* Twitter */}
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="Werewolf - O Jogo de Dedu√ß√£o Social" />
        <meta name="twitter:description" content="O cl√°ssico jogo de dedu√ß√£o social online. Descubra quem s√£o os lobisomens!" />
        <meta name="twitter:image" content="/og-image.png" />

        {/* DNS Prefetch for performance */}
        <link rel="dns-prefetch" href="//fonts.googleapis.com" />
        <link rel="dns-prefetch" href="//fonts.gstatic.com" />

        {/* Preconnect for critical resources */}
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />

        {/* Google Fonts - Medieval theme */}
        <link
          href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Pirata+One&family=Inter:wght@300;400;500;600;700&display=swap"
          rel="stylesheet"
        />

        {/* ‚úÖ MELHORADO: Critical CSS mais robusto */}
        <style>{`
          /* Prevent Flash of Unstyled Content */
          html {
            visibility: hidden;
            opacity: 0;
            scroll-behavior: smooth;
          }
          
          html.fonts-loaded {
            visibility: visible;
            opacity: 1;
          }

          /* Loading state */
          .page-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2D1B1E 0%, #1a1a2e 100%);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
          }

          /* Dark theme by default */
          body {
            background-color: #2D1B1E;
            color: #F4E4BC;
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
          }

          /* ‚úÖ MELHORADO: Custom scrollbar mais bonito */
          ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
          }

          ::-webkit-scrollbar-track {
            background: rgba(45, 27, 30, 0.1);
            border-radius: 4px;
          }

          ::-webkit-scrollbar-thumb {
            background: rgba(139, 146, 90, 0.5);
            border-radius: 4px;
            transition: background 0.2s ease;
          }

          ::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 146, 90, 0.8);
          }

          ::-webkit-scrollbar-corner {
            background: transparent;
          }

          /* Firefox scrollbar */
          * {
            scrollbar-width: thin;
            scrollbar-color: rgba(139, 146, 90, 0.5) rgba(45, 27, 30, 0.1);
          }

          /* Disable text selection on UI elements */
          button, .btn, .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
          }

          /* ‚úÖ MELHORADO: Focus visible para acessibilidade */
          .focus-visible,
          *:focus-visible {
            outline: 2px solid #8B925A;
            outline-offset: 2px;
            border-radius: 4px;
          }

          /* ‚úÖ ADICIONADO: Supress√£o de hydration warnings no console */
          .hydration-safe {
            opacity: 0;
          }

          .hydration-safe.hydrated {
            opacity: 1;
            transition: opacity 0.2s ease;
          }

          /* ‚úÖ ADICIONADO: Anima√ß√µes de entrada suaves */
          @keyframes fadeInUp {
            from {
              opacity: 0;
              transform: translateY(20px);
            }
            to {
              opacity: 1;
              transform: translateY(0);
            }
          }

          .fade-in-up {
            animation: fadeInUp 0.5s ease forwards;
          }

          /* ‚úÖ ADICIONADO: Preven√ß√£o de layout shift */
          .prevent-layout-shift {
            min-height: 1px;
          }

          /* ‚úÖ ADICIONADO: Estilos para loading states */
          .skeleton {
            background: linear-gradient(90deg, #2D1B1E 25%, #3D2B2E 50%, #2D1B1E 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
          }

          @keyframes loading {
            0% {
              background-position: 200% 0;
            }
            100% {
              background-position: -200% 0;
            }
          }

          /* ‚úÖ ADICIONADO: Estilos para modo high contrast */
          @media (prefers-contrast: high) {
            body {
              background-color: #000;
              color: #fff;
            }
          }

          /* ‚úÖ ADICIONADO: Estilos para reduced motion */
          @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
              animation-duration: 0.01ms !important;
              animation-iteration-count: 1 !important;
              transition-duration: 0.01ms !important;
            }
          }
        `}</style>
      </Head>

      <body>
        {/* Page loading overlay */}
        <div id="page-loading" className="page-loading">
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>üê∫</div>
            <div style={{ fontSize: '1.5rem', fontFamily: 'Cinzel, serif', color: '#8B925A' }}>
              Werewolf
            </div>
            <div style={{ fontSize: '0.9rem', color: '#F4E4BC', marginTop: '0.5rem' }}>
              Carregando...
            </div>
          </div>
        </div>

        <Main />
        <NextScript />

        {/* ‚úÖ MELHORADO: Scripts de inicializa√ß√£o mais robustos */}
        <script
          dangerouslySetInnerHTML={{
            __html: `
              document.addEventListener('DOMContentLoaded', function() {
                // Remove loading overlay with smooth transition
                const loading = document.getElementById('page-loading');
                if (loading) {
                  setTimeout(() => {
                    loading.style.opacity = '0';
                    loading.style.transition = 'opacity 0.3s ease';
                    setTimeout(() => {
                      loading.remove();
                    }, 300);
                  }, 800);
                }

                // Mark fonts as loaded
                document.documentElement.classList.add('fonts-loaded');

                // Initialize focus-visible polyfill
                try {
                  let hadKeyboardEvent = true;
                  let keyboardThrottleTimeout;

                  const detectKeyboard = function(e) {
                    if (e.metaKey || e.altKey || e.ctrlKey) return;
                    hadKeyboardEvent = true;
                    document.body.classList.add('using-keyboard');
                  };

                  const detectMouse = function() {
                    hadKeyboardEvent = false;
                    document.body.classList.remove('using-keyboard');
                  };

                  document.addEventListener('keydown', detectKeyboard, true);
                  document.addEventListener('mousedown', detectMouse, true);
                  document.addEventListener('pointerdown', detectMouse, true);
                  document.addEventListener('touchstart', detectMouse, true);
                } catch (e) {
                  console.warn('Focus-visible polyfill error:', e);
                }

                // Performance monitoring in development
                if (${process.env.NODE_ENV === 'development'}) {
                  window.addEventListener('load', function() {
                    setTimeout(() => {
                      try {
                        const navigation = performance.getEntriesByType('navigation')[0];
                        if (navigation) {
                          console.log('üìä Page Performance:', {
                            'Total Load Time': Math.round(navigation.loadEventEnd - navigation.navigationStart) + 'ms',
                            'DOM Content Loaded': Math.round(navigation.domContentLoadedEventEnd - navigation.navigationStart) + 'ms',
                            'First Paint': Math.round(performance.getEntriesByType('paint')[0]?.startTime || 0) + 'ms'
                          });
                        }
                      } catch (e) {
                        console.warn('Performance monitoring error:', e);
                      }
                    }, 1000);
                  });
                }

                // Global error handling
                window.addEventListener('error', function(e) {
                  // Filter out hydration warnings in development
                  if (e.error?.message?.includes?.('Hydration') || 
                      e.error?.message?.includes?.('Text content does not match')) {
                    return;
                  }
                  console.error('Global error:', e.error);
                });

                window.addEventListener('unhandledrejection', function(e) {
                  console.error('Unhandled promise rejection:', e.reason);
                });
              });
            `,
          }}
        />

        {/* NoScript fallback */}
        <noscript>
          <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: '#2D1B1E',
            color: '#F4E4BC',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            flexDirection: 'column',
            fontFamily: 'sans-serif',
            textAlign: 'center',
            zIndex: 9999,
          }}>
            <div style={{ fontSize: '4rem', marginBottom: '2rem' }}>üê∫</div>
            <h1 style={{ fontSize: '2rem', marginBottom: '1rem', fontFamily: 'Cinzel, serif' }}>Werewolf</h1>
            <p style={{ fontSize: '1.2rem', marginBottom: '2rem', maxWidth: '400px' }}>
              JavaScript √© necess√°rio para jogar este jogo online.
            </p>
            <p style={{ fontSize: '1rem', color: '#8B925A' }}>
              Por favor, ative o JavaScript no seu navegador e recarregue a p√°gina.
            </p>
          </div>
        </noscript>
      </body>
    </Html>
  );
}
</file>

<file path="frontend/src/pages/auth/register.tsx">
// üê∫ WEREWOLF - Register Page
// Werewolf inspired registration interface

import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { Eye, EyeOff, Mail, Lock, User, UserPlus, Check, X } from 'lucide-react';

import { useAuth } from '@/context/AuthContext';
import { useForm, useDebounce } from '@/hooks';
import { RegisterRequest } from '@/types';
import { authService } from '@/services/auth';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// REGISTER PAGE COMPONENT
// =============================================================================
export default function RegisterPage() {
  const router = useRouter();
  const { register, isAuthenticated, isLoading } = useAuth();
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [usernameAvailable, setUsernameAvailable] = useState<boolean | null>(null);
  const [emailAvailable, setEmailAvailable] = useState<boolean | null>(null);
  const [checkingUsername, setCheckingUsername] = useState(false);
  const [checkingEmail, setCheckingEmail] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Form management
  const {
    values,
    errors,
    touched,
    handleChange,
    handleSubmit,
    setError,
    setTouched,
  } = useForm<RegisterRequest>(
    {
      email: '',
      username: '',
      password: '',
      confirmPassword: '',
    },
    async (formData) => {
      if (!validateForm(formData)) return;

      setIsSubmitting(true);
      await register(formData);
      setIsSubmitting(false);
    }
  );

  // Debounced values for availability checking
  const debouncedUsername = useDebounce(values.username, 500);
  const debouncedEmail = useDebounce(values.email, 500);

  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated && !isLoading) {
      router.push('/lobby');
    }
  }, [isAuthenticated, isLoading, router]);

  // Check username availability
  useEffect(() => {
    if (debouncedUsername && debouncedUsername.length >= 3) {
      checkUsernameAvailability(debouncedUsername);
    } else {
      setUsernameAvailable(null);
    }
  }, [debouncedUsername]);

  // Check email availability
  useEffect(() => {
    if (debouncedEmail && authService.validateEmail(debouncedEmail)) {
      checkEmailAvailability(debouncedEmail);
    } else {
      setEmailAvailable(null);
    }
  }, [debouncedEmail]);

  // Username availability check
  const checkUsernameAvailability = async (username: string) => {
    setCheckingUsername(true);
    try {
      const response = await authService.checkUsernameAvailability(username);
      setUsernameAvailable(response.data?.available || false);
    } catch (error) {
      setUsernameAvailable(null);
    } finally {
      setCheckingUsername(false);
    }
  };

  // Email availability check
  const checkEmailAvailability = async (email: string) => {
    setCheckingEmail(true);
    try {
      const response = await authService.checkEmailAvailability(email);
      setEmailAvailable(response.data?.available || false);
    } catch (error) {
      setEmailAvailable(null);
    } finally {
      setCheckingEmail(false);
    }
  };

  // Form validation
  const validateForm = (data: RegisterRequest): boolean => {
    let isValid = true;

    // Email validation
    if (!data.email) {
      setError('email', 'Email √© obrigat√≥rio');
      isValid = false;
    } else if (!authService.validateEmail(data.email)) {
      setError('email', 'Email inv√°lido');
      isValid = false;
    } else if (emailAvailable === false) {
      setError('email', 'Este email j√° est√° em uso');
      isValid = false;
    }

    // Username validation
    const usernameValidation = authService.validateUsername(data.username);
    if (!usernameValidation.isValid) {
      setError('username', usernameValidation.errors[0]);
      isValid = false;
    } else if (usernameAvailable === false) {
      setError('username', 'Este username j√° est√° em uso');
      isValid = false;
    }

    // Password validation
    const passwordValidation = authService.validatePassword(data.password);
    if (!passwordValidation.isValid) {
      setError('password', passwordValidation.errors[0]);
      isValid = false;
    }

    // Confirm password validation
    if (data.password !== data.confirmPassword) {
      setError('confirmPassword', 'Senhas n√£o coincidem');
      isValid = false;
    }

    return isValid;
  };

  // Get field status icon
  const getFieldStatusIcon = (field: 'username' | 'email') => {
    const isChecking = field === 'username' ? checkingUsername : checkingEmail;
    const isAvailable = field === 'username' ? usernameAvailable : emailAvailable;
    const value = field === 'username' ? values.username : values.email;

    if (!value || (field === 'username' && value.length < 3)) return null;
    if (isChecking) return <LoadingSpinner size="sm" />;
    if (isAvailable === true) return <Check className="w-5 h-5 text-green-400" />;
    if (isAvailable === false) return <X className="w-5 h-5 text-red-400" />;
    return null;
  };

  // Show loading if checking authentication
  if (isLoading) {
    return <LoadingSpinner variant="medieval" size="xl" text="Verificando autentica√ß√£o..." />;
  }

  return (
    <>
      <Head>
        <title>Criar Conta - Werewolf</title>
        <meta name="description" content="Crie sua conta no Werewolf e entre na vila" />
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="card-medieval p-8"
        >
          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: 'spring' }}
              className="text-6xl mb-4"
            >
              üèòÔ∏è
            </motion.div>
            <h1 className="text-2xl font-medieval text-glow mb-2">
              Juntar-se √† Vila
            </h1>
            <p className="text-white/70">
              Crie sua conta para come√ßar a jogar
            </p>
          </div>

          {/* Google Register Button */}
          <Button
            variant="ghost"
            size="lg"
            onClick={() => {
              console.log('Google register clicked');
              // TODO: Implementar registro com Google
            }}
            className="w-full border border-white/20 hover:border-white/40 mb-6"
            disabled={isSubmitting}
          >
            <svg className="w-5 h-5 mr-3" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
              />
              <path
                fill="currentColor"
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
              />
              <path
                fill="currentColor"
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
              />
              <path
                fill="currentColor"
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
              />
            </svg>
            Criar conta com Google
          </Button>

          {/* Divider */}
          <div className="my-6 flex items-center">
            <div className="flex-1 border-t border-medieval-600"></div>
            <span className="px-4 text-white/50 text-sm">ou</span>
            <div className="flex-1 border-t border-medieval-600"></div>
          </div>

          {/* Register Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Email Field */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Email
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Mail className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="email"
                  type="email"
                  value={values.email}
                  onChange={handleChange('email')}
                  onBlur={() => setTouched('email')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.email && touched.email
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seu@email.com"
                  disabled={isSubmitting}
                />
                <div className="absolute inset-y-0 right-0 pr-3 flex items-center">
                  {getFieldStatusIcon('email')}
                </div>
              </div>
              {errors.email && touched.email && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.email}
                </motion.p>
              )}
            </div>

            {/* Username Field */}
            <div>
              <label
                htmlFor="username"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Nome de Usu√°rio
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <User className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="username"
                  type="text"
                  value={values.username}
                  onChange={handleChange('username')}
                  onBlur={() => setTouched('username')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.username && touched.username
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seunome123"
                  disabled={isSubmitting}
                />
                <div className="absolute inset-y-0 right-0 pr-3 flex items-center">
                  {getFieldStatusIcon('username')}
                </div>
              </div>
              <p className="mt-1 text-xs text-white/50">
                3-20 caracteres, apenas letras, n√∫meros, _ e -
              </p>
              {errors.username && touched.username && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.username}
                </motion.p>
              )}
            </div>

            {/* Password Field */}
            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Senha
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Lock className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  value={values.password}
                  onChange={handleChange('password')}
                  onBlur={() => setTouched('password')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.password && touched.password
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  disabled={isSubmitting}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-white/40 hover:text-white/70 transition-colors"
                  disabled={isSubmitting}
                >
                  {showPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>

              {/* Password Requirements */}
              <div className="mt-2 space-y-1">
                <PasswordRequirement
                  met={values.password.length >= 6}
                  text="Pelo menos 6 caracteres"
                />
                <PasswordRequirement
                  met={/(?=.*[a-z])/.test(values.password)}
                  text="Uma letra min√∫scula"
                />
                <PasswordRequirement
                  met={/(?=.*[A-Z])/.test(values.password)}
                  text="Uma letra mai√∫scula"
                />
                <PasswordRequirement
                  met={/(?=.*\d)/.test(values.password)}
                  text="Um n√∫mero"
                />
              </div>

              {errors.password && touched.password && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.password}
                </motion.p>
              )}
            </div>

            {/* Confirm Password Field */}
            <div>
              <label
                htmlFor="confirmPassword"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Confirmar Senha
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Lock className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="confirmPassword"
                  type={showConfirmPassword ? 'text' : 'password'}
                  value={values.confirmPassword}
                  onChange={handleChange('confirmPassword')}
                  onBlur={() => setTouched('confirmPassword')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.confirmPassword && touched.confirmPassword
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  disabled={isSubmitting}
                />
                <button
                  type="button"
                  onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-white/40 hover:text-white/70 transition-colors"
                  disabled={isSubmitting}
                >
                  {showConfirmPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>
              {errors.confirmPassword && touched.confirmPassword && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.confirmPassword}
                </motion.p>
              )}
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="medieval"
              size="lg"
              disabled={isSubmitting || usernameAvailable === false || emailAvailable === false}
              loading={isSubmitting}
              className="w-full"
            >
              <UserPlus className="w-5 h-5 mr-2" />
              {isSubmitting ? 'Criando conta...' : 'Criar Conta'}
            </Button>
          </form>

          {/* Login Link */}
          <div className="text-center mt-8">
            <p className="text-white/70 mb-4">
              J√° tem uma conta?
            </p>
            <Button
              variant="ghost"
              onClick={() => router.push('/auth/login')}
              className="w-full"
              disabled={isSubmitting}
            >
              Fazer Login
            </Button>
          </div>
        </motion.div>
      </Layout>
    </>
  );
}

// =============================================================================
// PASSWORD REQUIREMENT COMPONENT
// =============================================================================
interface PasswordRequirementProps {
  met: boolean;
  text: string;
}

function PasswordRequirement({ met, text }: PasswordRequirementProps) {
  return (
    <motion.div
      initial={{ opacity: 0, x: -10 }}
      animate={{ opacity: 1, x: 0 }}
      className="flex items-center text-xs"
    >
      {met ? (
        <Check className="w-3 h-3 text-green-400 mr-2" />
      ) : (
        <X className="w-3 h-3 text-red-400 mr-2" />
      )}
      <span className={met ? 'text-green-400' : 'text-red-400'}>
        {text}
      </span>
    </motion.div>
  );
}
</file>

<file path="frontend/src/pages/game/[gameId].tsx">
import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import { GameProvider } from '@/context/GameContext';
import { useSocket } from '@/context/SocketContext';
import { useAuth } from '@/context/AuthContext';
import GameBoard from '@/components/game/GameBoard';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorBoundary from '@/components/common/ErrorBoundary';

// =============================================================================
// GAME PAGE COMPONENT
// =============================================================================
export default function GamePage() {
  const router = useRouter();
  const { gameId } = router.query;
  const { user, isAuthenticated, getToken } = useAuth();
  const { isConnected, connect, sendMessage } = useSocket();

  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasRequestedGameState, setHasRequestedGameState] = useState(false);

  // =============================================================================
  // AUTHENTICATION CHECK
  // =============================================================================
  useEffect(() => {
    if (!router.isReady) return;

    if (!isAuthenticated) {
      router.push('/auth/login');
      return;
    }

    if (!gameId || typeof gameId !== 'string') {
      setError('ID do jogo inv√°lido');
      setIsLoading(false);
      return;
    }

    setIsLoading(false);
  }, [router.isReady, isAuthenticated, gameId, router]);

  // =============================================================================
  // WEBSOCKET CONNECTION - NOVA CONEX√ÉO PARA O JOGO
  // =============================================================================
  useEffect(() => {
    if (!router.isReady || !isAuthenticated || !gameId) return;

    const token = getToken();
    if (!token) {
      router.push('/auth/login');
      return;
    }

    // ‚úÖ IMPORTANTE: A URL agora √© do JOGO, n√£o mais da SALA
    const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001'}/ws/${gameId}?token=${encodeURIComponent(token)}`;

    // Conecta se n√£o estiver conectado
    if (!isConnected) {
      console.log('üîå Connecting to game WebSocket:', wsUrl);
      connect(wsUrl);
    }
  }, [router.isReady, gameId, isAuthenticated, isConnected, connect, getToken, router]);

  // =============================================================================
  // REQUEST INITIAL GAME STATE
  // =============================================================================
  useEffect(() => {
    if (!isConnected || !gameId || hasRequestedGameState) return;

    // ‚úÖ Assim que estiver conectado, pede o estado do jogo
    console.log(`üöÄ Requesting initial game state for game: ${gameId}`);
    sendMessage('get-game-state', { gameId });
    setHasRequestedGameState(true);
  }, [isConnected, gameId, hasRequestedGameState, sendMessage]);

  // =============================================================================
  // ERROR HANDLING
  // =============================================================================
  const handleBackToLobby = () => {
    router.push('/lobby');
  };

  const handleRetry = () => {
    setError(null);
    setHasRequestedGameState(false);

    if (gameId && user) {
      const token = getToken();
      if (token) {
        const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001'}/ws/${gameId}?token=${encodeURIComponent(token)}`;
        connect(wsUrl);
      }
    }
  };

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="large" />
          <p className="text-gray-300 mt-4">Carregando jogo...</p>
        </div>
      </div>
    );
  }

  // =============================================================================
  // ERROR STATE
  // =============================================================================
  if (error) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center max-w-md mx-auto p-6">
          <div className="text-red-400 text-6xl mb-4">‚ö†Ô∏è</div>
          <h1 className="text-2xl font-bold text-white mb-4">Erro ao Carregar Jogo</h1>
          <p className="text-gray-300 mb-6">{error}</p>

          <div className="space-y-3">
            <button
              onClick={handleRetry}
              className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition-colors"
            >
              Tentar Novamente
            </button>

            <button
              onClick={handleBackToLobby}
              className="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition-colors"
            >
              Voltar ao Lobby
            </button>
          </div>
        </div>
      </div>
    );
  }

  // =============================================================================
  // CONNECTION STATE
  // =============================================================================
  if (!isConnected) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-pulse">
            <div className="text-yellow-400 text-6xl mb-4">üåô</div>
          </div>
          <h2 className="text-xl font-bold text-white mb-2">Conectando ao Jogo</h2>
          <p className="text-gray-300">Estabelecendo conex√£o...</p>

          <button
            onClick={handleBackToLobby}
            className="mt-6 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
          >
            Cancelar
          </button>
        </div>
      </div>
    );
  }

  // =============================================================================
  // MAIN GAME RENDER
  // =============================================================================
  return (
    <ErrorBoundary>
      <GameProvider gameId={gameId as string}>
        <div className="min-h-screen bg-gray-900">
          {/* Game Header */}
          <div className="bg-gray-800 border-b border-gray-700 px-4 py-2">
            <div className="max-w-7xl mx-auto flex items-center justify-between">
              <div className="flex items-center space-x-4">
                <h1 className="text-xl font-bold text-white">
                  üê∫ Lobisomem Online
                </h1>
                <div className="text-sm text-gray-400">
                  Jogo: {gameId}
                </div>
              </div>

              <div className="flex items-center space-x-4">
                {/* Connection Status */}
                <div className="flex items-center space-x-2">
                  <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-400' : 'bg-red-400'}`} />
                  <span className="text-sm text-gray-400">
                    {isConnected ? 'Conectado' : 'Desconectado'}
                  </span>
                </div>

                {/* User Info */}
                {user && (
                  <div className="flex items-center space-x-2">
                    <div className="w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center">
                      üë§
                    </div>
                    <span className="text-sm text-white">{user.username}</span>
                  </div>
                )}

                {/* Back Button */}
                <button
                  onClick={handleBackToLobby}
                  className="bg-gray-700 hover:bg-gray-600 text-white text-sm py-2 px-4 rounded-lg transition-colors"
                >
                  ‚Üê Lobby
                </button>
              </div>
            </div>
          </div>

          {/* Game Board */}
          <GameBoard />
        </div>
      </GameProvider>
    </ErrorBoundary>
  );
}
</file>

<file path="frontend/src/pages/index.tsx">
// üê∫ WEREWOLF - Landing Page
// Home page with werewolf game inspired design

import { useState, useEffect } from 'react';
import { motion, useScroll, useTransform } from 'framer-motion';
import { useRouter } from 'next/router';
import Head from 'next/head';
import {
  Play,
  Users,
  Trophy,
  Shield,
  Zap,
  Moon,
  Sun,
  ChevronDown,
  Github
} from 'lucide-react';

import { useAuth } from '@/context/AuthContext';
import { useTheme } from '@/context/ThemeContext';
import Button from '@/components/common/Button';
import Layout from '@/components/common/Layout';

// ‚úÖ CORRE√á√ÉO: Componente de estat√≠sticas √† prova de hidrata√ß√£o
interface SafeStatsDisplayProps {
  value: number;
  label: string;
  color?: string;
}

function SafeStatsDisplay({ value, label, color = "text-salem-400" }: SafeStatsDisplayProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return (
    <div className="text-center">
      <div className={`text-2xl font-bold ${color}`}>
        {mounted ? value.toLocaleString('pt-BR') : value}
      </div>
      <div className="text-sm text-white/60">{label}</div>
    </div>
  );
}

// =============================================================================
// LANDING PAGE COMPONENT
// =============================================================================
export default function LandingPage() {
  const router = useRouter();
  const { isAuthenticated, user } = useAuth();
  const { playSound } = useTheme();
  const { scrollY } = useScroll();

  // Parallax effects
  const backgroundY = useTransform(scrollY, [0, 500], [0, 150]);
  const textY = useTransform(scrollY, [0, 500], [0, 100]);

  const [stats] = useState({
    totalPlayers: 15847,
    gamesPlayed: 89234,
    onlineNow: 342,
  });

  // Handle main action
  const handleMainAction = () => {
    playSound('button_click');

    if (isAuthenticated) {
      router.push('/lobby');
    } else {
      router.push('/auth/login');
    }
  };

  return (
    <>
      <Head>
        <title>Werewolf O Jogo de Dedu√ß√£o Social</title>
        <meta name="description" content="Entre na vila e descubra quem s√£o os lobisomens neste emocionante jogo de dedu√ß√£o social." />
      </Head>

      <Layout variant="landing" showHeader={false} showSidebar={false} showFooter={false}>
        {/* Hero Section */}
        <section className="relative min-h-screen flex items-center justify-center overflow-hidden">
          {/* Background */}
          <motion.div
            className="absolute inset-0 bg-gradient-to-br from-medieval-900 via-medieval-800 to-night-dark"
            style={{ y: backgroundY }}
          />

          {/* Background pattern */}
          <div className="absolute inset-0 opacity-10">
            <div className="absolute inset-0 bg-medieval-paper bg-cover bg-center" />
          </div>

          {/* Floating wolves */}
          <div className="absolute inset-0 overflow-hidden pointer-events-none">
            {[...Array(5)].map((_, i) => (
              <motion.div
                key={i}
                className="absolute text-6xl opacity-20"
                style={{
                  top: `${20 + i * 15}%`,
                  left: `${10 + i * 20}%`,
                }}
                animate={{
                  y: [0, -20, 0],
                  x: [0, 10, 0],
                  rotate: [0, 5, 0],
                }}
                transition={{
                  duration: 4 + i,
                  repeat: Infinity,
                  ease: 'easeInOut',
                }}
              >
                üê∫
              </motion.div>
            ))}
          </div>

          {/* Hero content */}
          <motion.div
            className="relative z-10 text-center px-4 max-w-4xl"
            style={{ y: textY }}
          >
            {/* Logo */}
            <motion.div
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              transition={{ duration: 1, type: 'spring', bounce: 0.5 }}
              className="text-8xl md:text-9xl mb-8"
            >
              üê∫
            </motion.div>

            {/* Title */}
            <motion.h1
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.5, duration: 0.8 }}
              className="text-5xl md:text-7xl font-medieval text-glow mb-6"
            >
              Werewolf
            </motion.h1>

            {/* Subtitle */}
            <motion.p
              initial={{ opacity: 0, y: 30 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.8, duration: 0.8 }}
              className="text-xl md:text-2xl text-white/80 mb-8 max-w-2xl mx-auto leading-relaxed"
            >
              O cl√°ssico jogo de dedu√ß√£o social que vai testar sua capacidade de
              blefe, investiga√ß√£o e sobreviv√™ncia.
            </motion.p>

            {/* ‚úÖ CORRE√á√ÉO: Stats com componente seguro para hidrata√ß√£o */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 1.1, duration: 0.8 }}
              className="flex justify-center gap-8 mb-12"
            >
              <SafeStatsDisplay
                value={stats.totalPlayers}
                label="Jogadores"
              />
              <SafeStatsDisplay
                value={stats.gamesPlayed}
                label="Partidas"
              />
              <SafeStatsDisplay
                value={stats.onlineNow}
                label="Online Agora"
                color="text-green-400"
              />
            </motion.div>

            {/* CTA Buttons */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 1.4, duration: 0.8 }}
              className="flex flex-col sm:flex-row gap-4 justify-center items-center"
            >
              <Button
                variant="medieval"
                size="xl"
                onClick={handleMainAction}
                className="text-xl px-12 py-4"
              >
                <Play className="w-6 h-6" />
                <span>{isAuthenticated ? 'Entrar no Lobby' : 'Come√ßar a Jogar'}</span>
              </Button>

              {!isAuthenticated && (
                <Button
                  variant="ghost"
                  size="xl"
                  onClick={() => router.push('/auth/register')}
                  className="text-xl px-8 py-4"
                >
                  Criar Conta
                </Button>
              )}
            </motion.div>

            {/* User welcome */}
            {isAuthenticated && user && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: 1.7 }}
                className="mt-8 p-4 bg-salem-800/30 rounded-lg border border-salem-600/50"
              >
                <p className="text-salem-300">
                  Bem-vindo de volta, <span className="font-bold">{user.username}</span>!
                  Voc√™ est√° no n√≠vel {user.level} com {user.totalGames} partidas jogadas.
                </p>
              </motion.div>
            )}
          </motion.div>

          {/* Scroll indicator */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 2 }}
            className="absolute bottom-8 left-1/2 transform -translate-x-1/2"
          >
            <motion.div
              animate={{ y: [0, 10, 0] }}
              transition={{ duration: 2, repeat: Infinity }}
              className="text-white/60 cursor-pointer"
              onClick={() => window.scrollTo({ top: window.innerHeight, behavior: 'smooth' })}
            >
              <ChevronDown className="w-8 h-8" />
            </motion.div>
          </motion.div>
        </section>

        {/* Features Section */}
        <section className="py-20 px-4 bg-medieval-800/50">
          <div className="max-w-6xl mx-auto">
            <motion.h2
              initial={{ opacity: 0, y: 50 }}
              whileInView={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8 }}
              className="text-4xl font-medieval text-center text-glow mb-16"
            >
              Como Jogar
            </motion.h2>

            <div className="grid md:grid-cols-3 gap-8">
              {/* Day Phase */}
              <FeatureCard
                icon={<Sun className="w-12 h-12" />}
                title="Fase do Dia"
                description="Durante o dia, todos os jogadores discutem e votam para eliminar algu√©m suspeito de ser um lobisomem."
                delay={0.2}
              />

              {/* Night Phase */}
              <FeatureCard
                icon={<Moon className="w-12 h-12" />}
                title="Fase da Noite"
                description="√Ä noite, lobisomens escolhem suas v√≠timas enquanto outros pap√©is especiais agem em segredo."
                delay={0.4}
              />

              {/* Victory */}
              <FeatureCard
                icon={<Trophy className="w-12 h-12" />}
                title="Condi√ß√µes de Vit√≥ria"
                description="A vila vence eliminando todos os lobisomens. Os lobisomens vencem igualando o n√∫mero de alde√µes."
                delay={0.6}
              />
            </div>
          </div>
        </section>

        {/* Roles Section */}
        <section className="py-20 px-4">
          <div className="max-w-6xl mx-auto">
            <motion.h2
              initial={{ opacity: 0, y: 50 }}
              whileInView={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8 }}
              className="text-4xl font-medieval text-center text-glow mb-16"
            >
              Pap√©is do Jogo
            </motion.h2>

            <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-6">
              <RoleCard
                emoji="üë§"
                name="Alde√£o"
                faction="Vila"
                description="Vota durante o dia para eliminar suspeitos"
                color="text-green-400"
              />

              <RoleCard
                emoji="üîç"
                name="Investigador"
                faction="Vila"
                description="Investiga uma pessoa por noite"
                color="text-blue-400"
              />

              <RoleCard
                emoji="‚öïÔ∏è"
                name="M√©dico"
                faction="Vila"
                description="Protege algu√©m da morte durante a noite"
                color="text-green-400"
              />

              <RoleCard
                emoji="üê∫"
                name="Lobisomem"
                faction="Lobisomens"
                description="Mata alde√µes durante a noite"
                color="text-red-400"
              />
            </div>

            <motion.div
              initial={{ opacity: 0 }}
              whileInView={{ opacity: 1 }}
              transition={{ delay: 0.5 }}
              className="text-center mt-12"
            >
              <Button
                variant="ghost"
                onClick={() => router.push('/roles')}
              >
                Ver Todos os Pap√©is
              </Button>
            </motion.div>
          </div>
        </section>

        {/* Footer */}
        <footer className="py-12 px-4 bg-medieval-900 border-t border-medieval-600">
          <div className="max-w-6xl mx-auto">
            <div className="flex flex-col md:flex-row justify-between items-center">
              <div className="flex items-center space-x-3 mb-4 md:mb-0">
                <div className="text-3xl">üê∫</div>
                <div>
                  <h3 className="font-medieval text-xl">Werewolf</h3>
                  <p className="text-white/60 text-sm">O Jogo de Dedu√ß√£o Social</p>
                </div>
              </div>

              <div className="flex space-x-4">
                <Button variant="ghost" size="sm">
                  <Github className="w-5 h-5" />
                </Button>
              </div>
            </div>

            <div className="mt-8 pt-8 border-t border-medieval-600 text-center text-white/60 text-sm">
              ¬© 2025 Werewolf. Todos os direitos reservados.
            </div>
          </div>
        </footer>
      </Layout>
    </>
  );
}

// =============================================================================
// FEATURE CARD COMPONENT
// =============================================================================
interface FeatureCardProps {
  icon: React.ReactNode;
  title: string;
  description: string;
  delay?: number;
}

function FeatureCard({ icon, title, description, delay = 0 }: FeatureCardProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 50 }}
      whileInView={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.8, delay }}
      className="text-center p-6 bg-medieval-700/30 rounded-lg border border-medieval-600/50 hover:border-salem-500/50 transition-colors"
    >
      <div className="text-salem-400 mb-4 flex justify-center">
        {icon}
      </div>
      <h3 className="text-xl font-bold mb-3">{title}</h3>
      <p className="text-white/70 leading-relaxed">{description}</p>
    </motion.div>
  );
}

// =============================================================================
// ROLE CARD COMPONENT
// =============================================================================
interface RoleCardProps {
  emoji: string;
  name: string;
  faction: string;
  description: string;
  color: string;
}

function RoleCard({ emoji, name, faction, description, color }: RoleCardProps) {
  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      whileInView={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.5 }}
      whileHover={{ scale: 1.05 }}
      className="p-4 bg-medieval-800/50 rounded-lg border border-medieval-600/50 hover:border-salem-500/50 transition-all cursor-pointer"
    >
      <div className="text-3xl mb-2">{emoji}</div>
      <h4 className="font-bold mb-1">{name}</h4>
      <div className={`text-sm mb-2 ${color}`}>{faction}</div>
      <p className="text-white/70 text-sm">{description}</p>
    </motion.div>
  );
}
</file>

<file path="backend/src/utils/constants.ts">
// üê∫ LOBISOMEM ONLINE - Constants (REFATORADO)
// ‚úÖ APENAS defini√ß√µes b√°sicas - roles v√™m de RoleSystem.ts

//====================================================================
// ENUMS DEFINITIONS (√öNICOS AQUI)
//====================================================================
export enum Role {
  // Town roles
  VILLAGER = 'VILLAGER',
  SHERIFF = 'SHERIFF',
  DOCTOR = 'DOCTOR',
  VIGILANTE = 'VIGILANTE',
  // Werewolf roles
  WEREWOLF = 'WEREWOLF',
  WEREWOLF_KING = 'WEREWOLF_KING',
  // Neutral roles
  JESTER = 'JESTER',
  SERIAL_KILLER = 'SERIAL_KILLER',
}

export enum Faction {
  TOWN = 'TOWN',
  WEREWOLF = 'WEREWOLF',
  NEUTRAL = 'NEUTRAL',
}

export enum GamePhase {
  LOBBY = 'LOBBY',
  NIGHT = 'NIGHT',
  DAY = 'DAY',
  VOTING = 'VOTING',
  ENDED = 'ENDED',
}

//====================================================================
// GAME LIMITS
//====================================================================
export const GAME_LIMITS = {
  MIN_PLAYERS: 6,
  MAX_PLAYERS: 15,
  MAX_SPECTATORS: 5,

  // Room limits
  MAX_ROOM_NAME_LENGTH: 30,
  ROOM_CODE_LENGTH: 6,

  // Time limits (milliseconds)
  NIGHT_DURATION: 60000, // 60 seconds
  DAY_DURATION: 120000, // 2 minutes
  VOTING_DURATION: 30000, // 30 seconds

  // Chat limits
  MAX_MESSAGE_LENGTH: 500,
  CHAT_RATE_LIMIT: 5, // messages per 10 seconds

  // Reconnection
  RECONNECT_TIMEOUT: 120000, // 2 minutes
  MAX_RECONNECT_ATTEMPTS: 5,

  // Heartbeat
  HEARTBEAT_INTERVAL: 30000, // 30 seconds
  HEARTBEAT_TIMEOUT: 5000, // 5 seconds
} as const;

//====================================================================
// THEMED NICKNAMES (MEDIEVAL PORTUGUESE)
//====================================================================
export const THEMED_NICKNAMES = [
  // Profiss√µes
  'Jo√£o Ferreiro', 'Maria Padeira', 'Pedro Lenhador', 'Ana Tecel√£',
  'Carlos Moleiro', 'Isabel Costureira', 'Francisco Carpinteiro', 'Catarina Oleira',
  'Manuel Sapateiro', 'Teresa Lavadeira', 'Ant√≥nio Pedreiro', 'Beatriz Bordadeira',
  'Jos√© Curtidor', 'Lu√≠sa Fiandeira', 'Miguel Cordoeiro', 'Clara Rendilheira',

  // Nomes medievais
  'Afonso o Bravo', 'Constan√ßa a S√°bia', 'Nuno o Valente', 'Urraca a Bela',
  'Sancho o Forte', 'Mafalda a Justa', 'Garcia o Leal', 'Elvira a Piedosa',
  'Bermudo o Jovem', 'Teresa a Corajosa', 'Ramiro o Audaz', 'Sancha a Prudente',

  // Alcunhas regionais
  'Pedro do Norte', 'Maria da Ribeira', 'Jo√£o da Montanha', 'Ana do Vale',
  'Carlos da Floresta', 'Isabel da Ponte', 'Francisco da Torre', 'Catarina do Campo',
  'Manuel do Rio', 'Teresa da Vila', 'Ant√≥nio da Pra√ßa', 'Beatriz do Castelo',

  // Caracter√≠sticas
  'Rodrigo Barba-Ruiva', 'Leonor Olhos-Verdes', 'Vasco Perna-de-Pau', 'Marta Cabelo-Dourado',
  'Egas M√£o-de-Ferro', 'Violante Voz-Doce', '√Ålvaro P√©-Ligeiro', 'Branca Riso-F√°cil',
] as const;

//====================================================================
// CHAT CHANNELS
//====================================================================
export const CHAT_CHANNELS = {
  LOBBY: 'lobby',
  ROOM: 'room',
  PUBLIC: 'public',
  WEREWOLF: 'werewolf',
  SPECTATOR: 'spectator',
  SYSTEM: 'system',
} as const;

//====================================================================
// INVESTIGATION RESULTS
//====================================================================
export const INVESTIGATION_RESULTS = {
  SUSPICIOUS: 'SUSPICIOUS',
  NOT_SUSPICIOUS: 'NOT_SUSPICIOUS',
} as const;

//====================================================================
// WIN CONDITIONS
//====================================================================
export const WIN_CONDITIONS = {
  TOWN_WINS: 'All werewolves have been eliminated',
  WEREWOLF_WINS: 'Werewolves equal or outnumber the town',
  JESTER_WINS: 'Jester was executed by vote',
  SERIAL_KILLER_WINS: 'Serial Killer is the last survivor',
} as const;

//====================================================================
// ACHIEVEMENT CATEGORIES
//====================================================================
export const ACHIEVEMENT_CATEGORIES = {
  FIRST_TIME: 'first_time',
  SURVIVAL: 'survival',
  ROLE_MASTERY: 'role_mastery',
  SOCIAL: 'social',
  STRATEGIC: 'strategic',
  SPECIAL: 'special',
} as const;

//====================================================================
// SYSTEM MESSAGES
//====================================================================
export const SYSTEM_MESSAGES = {
  GAME_STARTED: 'üéÆ O jogo come√ßou! Boa sorte a todos!',
  NIGHT_PHASE: 'üåô A noite caiu sobre a vila...',
  DAY_PHASE: '‚òÄ O sol nasceu. √â hora de discutir!',
  VOTING_PHASE: 'üó≥ Hora da vota√ß√£o! Escolham com sabedoria.',
  PLAYER_ELIMINATED: (name: string, role: string) => `üíÄ ${name} foi eliminado! Era um(a) ${role}.`,
  GAME_ENDED: (faction: string) => `üèÜ Fim de jogo! ${faction} venceu!`,
  PLAYER_JOINED: (name: string) => `üëã ${name} entrou na sala.`,
  PLAYER_LEFT: (name: string) => `üëã ${name} saiu da sala.`,
  RECONNECTED: (name: string) => `üîÑ ${name} reconectou-se.`,
} as const;

//====================================================================
// ERROR MESSAGES
//====================================================================
export const ERROR_MESSAGES = {
  UNAUTHORIZED: 'Token de acesso inv√°lido ou expirado',
  FORBIDDEN: 'Voc√™ n√£o tem permiss√£o para esta a√ß√£o',
  NOT_FOUND: 'Recurso n√£o encontrado',
  ROOM_FULL: 'A sala est√° cheia',
  GAME_IN_PROGRESS: 'O jogo j√° est√° em andamento',
  INVALID_ACTION: 'A√ß√£o inv√°lida',
  RATE_LIMITED: 'Muitas tentativas. Tente novamente mais tarde',
  VALIDATION_FAILED: 'Dados inv√°lidos fornecidos',
  SERVER_ERROR: 'Erro interno do servidor',
} as const;
</file>

<file path="backend/src/websocket/WebSocketManager.ts">
// üê∫ LOBISOMEM ONLINE - WebSocket Manager (VERS√ÉO FINAL CORRIGIDA)
import http from 'http';
import { WebSocketServer } from 'ws';
import { verifyAccessToken, extractTokenFromWebSocketRequest } from '@/config/jwt';
import { parseWebSocketURL, extractConnectionMetadata } from '@/config/websocket';
import { wsLogger } from '@/utils/logger';
import { ConnectionManager } from './ConnectionManager';
import { ChannelManager } from './ChannelManager';
import { MessageRouter } from './MessageRouter';
import { GameEngine } from '@/game/GameEngine';
import { HeartbeatManager } from './HeartbeatManager';
import type { IEventBus, ConnectionContext } from '@/types';
import type { Config } from '@/config/environment';

export class WebSocketManager {
  public wss: WebSocketServer | null = null;
  private connectionManager: ConnectionManager;

  // ‚úÖ EXPOSI√á√ÉO P√öBLICA DO CHANNELMANAGER
  public channelManager: ChannelManager;

  private messageRouter: MessageRouter;
  private gameEngine: GameEngine;
  private heartbeatManager: HeartbeatManager;

  constructor(
    private eventBus: IEventBus,
    private config: Config
  ) {
    this.connectionManager = new ConnectionManager();
    this.channelManager = new ChannelManager(this.connectionManager);
    this.heartbeatManager = new HeartbeatManager(this.connectionManager);
    this.gameEngine = new GameEngine();

    this.messageRouter = new MessageRouter(
      this.connectionManager,
      this.channelManager,
      this.gameEngine,
      this.eventBus
    );

    this.messageRouter.setBroadcastMethods(
      this.broadcastToRoom.bind(this),
      this.sendToUser.bind(this)
    );
    this.gameEngine.setSendToUserMethod(this.sendToUser.bind(this));

    wsLogger.info('WebSocketManager initialized with GameEngine integration');
  }

  public setupWebSocketServer(server: http.Server): void {
    this.wss = new WebSocketServer({ noServer: true });

    server.on('upgrade', (request, socket, head) => {
      // ‚úÖ ACEITA QUALQUER CAMINHO QUE COMECE COM /ws
      if (request.url?.startsWith('/ws')) {
        this.wss!.handleUpgrade(request, socket, head, (ws) => {
          this.wss!.emit('connection', ws, request);
        });
      } else {
        wsLogger.warn('WebSocket upgrade rejected for invalid path', { path: request.url });
        socket.destroy();
      }
    });

    this.wss.on('connection', this.handleConnection.bind(this));
    this.heartbeatManager.start();
    wsLogger.info('WebSocket server attached to HTTP upgrade event.');
  }

  private async handleConnection(ws: any, request: any): Promise<void> {
    let connectionId: string | undefined;

    try {
      const urlInfo = parseWebSocketURL(request.url || '');
      const token = extractTokenFromWebSocketRequest(request);

      if (!token) {
        wsLogger.warn('Connection rejected: No authentication token', {
          url: request.url,
          userAgent: request.headers['user-agent'],
        });
        return ws.close(1008, 'Authentication token required');
      }

      const jwtPayload = verifyAccessToken(token);

      const context: ConnectionContext = {
        userId: jwtPayload.userId,
        username: jwtPayload.username,
        serverId: this.config.SERVICE_ID,
        isSpectator: false,
        roomId: urlInfo.roomId,
      };

      const metadata = extractConnectionMetadata(request);
      connectionId = `${context.userId}-${Date.now()}`;

      this.connectionManager.addConnection(connectionId, ws, context, metadata);

      // Setup event handlers
      ws.on('message', (data: Buffer) => {
        try {
          const message = JSON.parse(data.toString());
          this.messageRouter.handleMessage(connectionId!, message);
        } catch (error) {
          wsLogger.error('Failed to parse message', error as Error, { connectionId });
        }
      });

      ws.on('pong', () => this.heartbeatManager.handlePong(connectionId!));

      ws.on('close', (code: number, reason: Buffer) => {
        this.handleDisconnection(connectionId!, code, reason.toString());
      });

      ws.on('error', (error: Error) => {
        wsLogger.error('WS Connection Error', error, { connectionId });
      });

      // Send connection confirmation
      this.sendToConnection(connectionId, 'connected', {
        userId: context.userId,
        username: context.username,
        serverId: context.serverId,
      });

      // Auto-join room if specified in URL
      if (context.roomId) {
        await this.messageRouter.handleMessage(connectionId, {
          type: 'join-room',
          data: { roomId: context.roomId }
        });
      }

      wsLogger.info('WebSocket connection established', {
        connectionId,
        userId: context.userId,
        username: context.username,
        roomId: context.roomId,
        userAgent: metadata.userAgent,
        ip: metadata.ip,
      });

    } catch (error) {
      wsLogger.error('Connection failed during handshake', error as Error, {
        url: request.url,
        connectionId,
      });
      ws.close(1008, 'Authentication failed');
    }
  }

  private handleDisconnection(connectionId: string, code: number, reason: string): void {
    const connection = this.connectionManager.getConnection(connectionId);

    if (connection) {
      wsLogger.info('WebSocket connection closed', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId: connection.context.roomId,
        code,
        reason,
      });

      // Leave room if connected
      if (connection.context.roomId) {
        this.channelManager.leaveRoom(connection.context.roomId, connectionId);
      }

      // ‚úÖ VERIFICA√á√ÉO DE SEGURAN√áA ANTES DE USAR O EVENTBUS
      if (this.eventBus && typeof this.eventBus.publish === 'function') {
        this.eventBus.publish('connection:disconnected', {
          connectionId,
          userId: connection.context.userId,
          username: connection.context.username,
          roomId: connection.context.roomId,
          code,
          reason,
          timestamp: new Date().toISOString(),
        });
      } else {
        wsLogger.warn('EventBus not available for disconnection event', { connectionId });
      }
    }

    this.connectionManager.removeConnection(connectionId);
  }

  public sendToConnection = (connectionId: string, type: string, data?: any): boolean => {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || connection.ws.readyState !== connection.ws.OPEN) {
      return false;
    }

    try {
      const message = {
        type,
        data,
        timestamp: new Date().toISOString(),
      };

      connection.ws.send(JSON.stringify(message));
      return true;
    } catch (error) {
      wsLogger.error('Failed to send message to connection', error as Error, {
        connectionId,
        type,
      });
      return false;
    }
  };

  public sendToUser = (userId: string, type: string, data?: any): boolean => {
    const connection = this.connectionManager.findConnectionByUserId(userId);
    if (!connection) {
      wsLogger.debug('No active connection found for user', { userId, type });
      return false;
    }

    return this.sendToConnection(connection.id, type, data);
  };

  public broadcastToRoom = (roomId: string, type: string, data?: any, excludeConnectionId?: string): number => {
    const roomConnections = this.channelManager.getRoomConnections(roomId);
    let sentCount = 0;

    for (const connectionId of roomConnections) {
      if (excludeConnectionId && connectionId === excludeConnectionId) {
        continue;
      }

      if (this.sendToConnection(connectionId, type, data)) {
        sentCount++;
      }
    }

    wsLogger.debug('Broadcast to room completed', {
      roomId,
      type,
      totalConnections: roomConnections.size,
      sentCount,
      excludedConnection: excludeConnectionId,
    });

    return sentCount;
  };

  public broadcastToAll = (type: string, data?: any): number => {
    const allConnections = this.connectionManager.getAllConnections();
    let sentCount = 0;

    for (const [connectionId] of allConnections) {
      if (this.sendToConnection(connectionId, type, data)) {
        sentCount++;
      }
    }

    wsLogger.debug('Broadcast to all completed', {
      type,
      totalConnections: allConnections.size,
      sentCount,
    });

    return sentCount;
  };

  public getStats(): any {
    const connectionStats = this.connectionManager.getStats();
    const channelStats = this.channelManager.getStats();

    return {
      connections: connectionStats,
      channels: channelStats,
      games: {
        activeGames: this.gameEngine.getActiveGamesCount(),
        totalGames: this.gameEngine.getAllGames().length,
      },
      server: {
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        serverId: this.config.SERVICE_ID,
      },
    };
  }

  public async forceDisconnectUser(userId: string): Promise<boolean> {
    const connection = this.connectionManager.findConnectionByUserId(userId);
    if (!connection) {
      return false;
    }

    try {
      connection.ws.close(1000, 'Forced disconnect by admin');
      return true;
    } catch (error) {
      wsLogger.error('Failed to force disconnect user', error as Error, { userId });
      return false;
    }
  }

  public async cleanup(): Promise<void> {
    wsLogger.info('Starting WebSocket cleanup...');

    this.heartbeatManager.stop();

    const allConnections = this.connectionManager.getAllConnections();
    for (const [connectionId, connection] of allConnections) {
      try {
        connection.ws.close(1001, 'Server shutdown');
      } catch (error) {
        wsLogger.error('Error closing connection during cleanup', error as Error, { connectionId });
      }
    }

    this.connectionManager.cleanup();
    this.channelManager.cleanup();
    await this.gameEngine.cleanup();

    if (this.wss) {
      this.wss.close();
      this.wss = null;
    }

    wsLogger.info('WebSocket cleanup completed');
  }
}
</file>

<file path="frontend/src/components/common/Modal.tsx">
'use client';

import { useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';
import { clsx } from 'clsx';
import { useTheme } from '@/context/ThemeContext';
import { ModalProps } from '@/types';
import Button from './Button';

// =============================================================================
// MODAL COMPONENT (VERS√ÉO FINAL CORRIGIDA E FUNCIONAL)
// =============================================================================
export default function Modal({
  isOpen,
  onClose,
  title,
  children,
  className = '',
  closeOnOverlayClick = true,
  size = 'md',
  variant = 'default',
}: ModalProps & {
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  variant?: 'default' | 'medieval' | 'game' | 'error';
}) {
  const [mounted, setMounted] = useState(false);

  // Garante que o c√≥digo s√≥ rode no cliente para o createPortal
  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  // Suporte para fechar com a tecla ESC
  useEffect(() => {
    if (!isOpen) return;
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [isOpen, onClose]);

  // Bloqueio de scroll do body quando o modal est√° aberto
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  // Render guard para SSR
  if (!mounted) return null;

  // Configura√ß√µes de estilo
  const sizeClasses = {
    sm: 'max-w-md',
    md: 'max-w-lg',
    lg: 'max-w-2xl',
    xl: 'max-w-4xl',
    full: 'w-[95vw] h-[95vh]',
  };

  const variantStyles = {
    default: 'bg-medieval-800 border-medieval-600 text-white shadow-medieval',
    medieval: 'bg-gradient-to-b from-medieval-700 to-medieval-900 border-3 border-amber-600 text-white shadow-glow-gold relative overflow-hidden',
    game: 'bg-gradient-to-b from-night-light to-night-dark border-2 border-salem-500 text-white shadow-2xl backdrop-blur-sm',
    error: 'bg-gradient-to-b from-red-900 to-red-950 border-2 border-red-500 text-white shadow-glow-red',
  };

  // Configura√ß√µes de anima√ß√£o
  const overlayVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1 },
    exit: { opacity: 0 },
  };

  const modalVariants = {
    hidden: { opacity: 0, scale: 0.9, y: 20 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring', damping: 25, stiffness: 300 } },
    exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.2 } },
  };

  // Conte√∫do do modal a ser renderizado no portal
  const modalContent = (
    <AnimatePresence mode="wait">
      {isOpen && (
        // O cont√™iner pai que cobre toda a tela e atua como o overlay clic√°vel
        <motion.div
          className="fixed inset-0 z-50 flex items-center justify-center p-4"
          variants={overlayVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
          onClick={closeOnOverlayClick ? onClose : undefined}
        >
          {/* Fundo escuro puramente visual, sem eventos de clique */}
          <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" />

          {/* O conte√∫do do modal */}
          <motion.div
            className={clsx(
              'relative w-full max-h-[90vh] flex flex-col',
              'rounded-xl border-2',
              sizeClasses[size],
              variantStyles[variant],
              className
            )}
            variants={modalVariants}
            onClick={(e) => e.stopPropagation()} // Impede que o clique no modal feche-o
          >
            {/* Cabe√ßalho (fixo) */}
            {title && (
              <header className="flex-shrink-0 flex items-center justify-between p-6 border-b border-current/20">
                <h2 className={clsx('text-xl font-bold', variant === 'medieval' && 'font-medieval text-2xl text-glow')}>
                  {title}
                </h2>
                <Button variant="ghost" size="sm" onClick={onClose} className="!p-1" aria-label="Fechar modal">
                  <X className="w-5 h-5" />
                </Button>
              </header>
            )}

            {/* Corpo do modal (√°rea com rolagem) */}
            <main className="flex-1 overflow-y-auto p-6">
              {!title && (
                <Button variant="ghost" size="sm" onClick={onClose} className="!p-1 absolute top-4 right-4 z-10" aria-label="Fechar modal">
                  <X className="w-5 h-5" />
                </Button>
              )}
              {children}
            </main>

            {/* Decora√ß√µes (apenas para o tema medieval) */}
            {variant === 'medieval' && (
              <>
                <div className="absolute top-2 left-2 w-8 h-8 border-l-3 border-t-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute top-2 right-2 w-8 h-8 border-r-3 border-t-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute bottom-2 left-2 w-8 h-8 border-l-3 border-b-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute bottom-2 right-2 w-8 h-8 border-r-3 border-b-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none">
                  <div className="w-12 h-6 bg-amber-600 rounded-full border-2 border-amber-400" />
                </div>
              </>
            )}
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );

  return createPortal(modalContent, document.body);
}

// =============================================================================
// CONFIRMATION MODAL COMPONENT
// =============================================================================
interface ConfirmModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  variant?: 'danger' | 'warning' | 'info';
}

export function ConfirmModal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  variant = 'info',
}: ConfirmModalProps) {
  const { playSound } = useTheme();

  const handleConfirm = () => {
    playSound('button_click');
    onConfirm();
    onClose();
  };

  const handleCancel = () => {
    onClose();
  };

  const getVariantProps = () => {
    switch (variant) {
      case 'danger':
        return { modalVariant: 'error' as const, confirmVariant: 'danger' as const };
      case 'warning':
        return { modalVariant: 'medieval' as const, confirmVariant: 'primary' as const };
      default:
        return { modalVariant: 'default' as const, confirmVariant: 'primary' as const };
    }
  };

  const { modalVariant, confirmVariant } = getVariantProps();

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={title} variant={modalVariant} size="sm">
      <div className="space-y-6">
        <p className="text-white/90 leading-relaxed">{message}</p>
        <div className="flex gap-3 justify-end">
          <Button variant="ghost" onClick={handleCancel}>
            {cancelText}
          </Button>
          <Button variant={confirmVariant} onClick={handleConfirm}>
            {confirmText}
          </Button>
        </div>
      </div>
    </Modal>
  );
}

// =============================================================================
// ALERT MODAL COMPONENT
// =============================================================================
interface AlertModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  message: string;
  variant?: 'success' | 'error' | 'warning' | 'info';
}

export function AlertModal({
  isOpen,
  onClose,
  title,
  message,
  variant = 'info',
}: AlertModalProps) {
  const { playSound } = useTheme();

  const handleClose = () => {
    playSound('button_click');
    onClose();
  };

  const getVariantProps = () => {
    switch (variant) {
      case 'success':
        return { modalVariant: 'game' as const, icon: '‚úÖ' };
      case 'error':
        return { modalVariant: 'error' as const, icon: '‚ùå' };
      case 'warning':
        return { modalVariant: 'medieval' as const, icon: '‚ö†Ô∏è' };
      default:
        return { modalVariant: 'default' as const, icon: '‚ÑπÔ∏è' };
    }
  };

  const { modalVariant, icon } = getVariantProps();

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={`${icon} ${title}`} variant={modalVariant} size="sm">
      <div className="space-y-6">
        <p className="text-white/90 leading-relaxed">{message}</p>
        <div className="flex justify-end">
          <Button variant="primary" onClick={handleClose}>
            Entendi
          </Button>
        </div>
      </div>
    </Modal>
  );
}
</file>

<file path="frontend/src/components/room/PlayerList.tsx">
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Users,
  Crown,
  Check,
  Clock,
  UserX,
  Eye,
  UserPlus
} from 'lucide-react';
import { Player } from '@/types';

interface PlayerListProps {
  players: Player[];
  spectators: Player[];
  currentUserId: string;
  isHost: boolean;
  onKickPlayer: (playerId: string) => void;
  maxPlayers: number;
  maxSpectators: number;
}

export default function PlayerList({
  players,
  spectators,
  currentUserId,
  isHost,
  onKickPlayer,
  maxPlayers,
  maxSpectators
}: PlayerListProps) {
  // ‚úÖ CORRIGIDO: Calcular slots vazios baseado nos jogadores reais
  const emptyPlayerSlots = Math.max(0, maxPlayers - players.length);
  const emptySpectatorSlots = Math.max(0, maxSpectators - spectators.length);

  // ‚úÖ MELHORADO: Mostrar apenas alguns slots vazios para evitar lista muito longa
  const visibleEmptyPlayerSlots = Math.min(emptyPlayerSlots, 3);
  const visibleEmptySpectatorSlots = Math.min(emptySpectatorSlots, 2);

  return (
    <div className="space-y-6">
      {/* Lista de Jogadores */}
      <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold flex items-center gap-2">
            <Users className="w-5 h-5" />
            Jogadores ({players.length}/{maxPlayers})
          </h3>

          {/* ‚úÖ NOVO: Indicador de progresso visual */}
          <div className="flex items-center gap-2">
            <div className="w-24 bg-slate-700 rounded-full h-2">
              <div
                className="bg-blue-500 h-2 rounded-full transition-all duration-300"
                style={{ width: `${(players.length / maxPlayers) * 100}%` }}
              />
            </div>
            <span className="text-sm text-slate-400">
              {players.length >= 3 ? '‚úÖ' : '‚è≥'} Min: 3
            </span>
          </div>
        </div>

        <div className="space-y-2">
          <AnimatePresence>
            {players.map((player) => (
              <motion.div
                key={player.id}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
                className={`
                  flex items-center justify-between p-3 rounded-lg transition-all duration-200
                  ${player.isConnected
                    ? 'bg-slate-700/50 border border-slate-600 hover:bg-slate-700/70'
                    : 'bg-red-900/30 border border-red-600/50'
                  }
                  ${player.userId === currentUserId ? 'ring-2 ring-blue-500/50' : ''}
                `}
              >
                <div className="flex items-center gap-3">
                  <div className="relative">
                    <div className={`
                      w-10 h-10 rounded-full flex items-center justify-center text-white font-bold
                      ${player.isHost
                        ? 'bg-gradient-to-br from-yellow-500 to-orange-600'
                        : 'bg-gradient-to-br from-blue-500 to-purple-600'
                      }
                    `}>
                      {player.username[0].toUpperCase()}
                    </div>

                    {/* Host Crown */}
                    {player.isHost && (
                      <Crown className="absolute -top-1 -right-1 w-4 h-4 text-yellow-400" />
                    )}

                    {/* Connection Status */}
                    <div className={`
                      absolute -bottom-1 -right-1 w-3 h-3 rounded-full border-2 border-slate-800
                      ${player.isConnected ? 'bg-green-500' : 'bg-red-500'}
                    `} />
                  </div>

                  <div>
                    <div className="flex items-center gap-2">
                      <span className="font-medium">
                        {player.username}
                        {player.userId === currentUserId && (
                          <span className="text-blue-400 ml-1">(Voc√™)</span>
                        )}
                      </span>

                      {/* Tags */}
                      <div className="flex gap-1">
                        {player.isHost && (
                          <span className="text-xs bg-yellow-600 px-2 py-1 rounded-full font-medium">
                            HOST
                          </span>
                        )}
                        {!player.isConnected && (
                          <span className="text-xs bg-red-600 px-2 py-1 rounded-full">
                            OFFLINE
                          </span>
                        )}
                      </div>
                    </div>

                    <div className="text-xs text-slate-400">
                      {player.isConnected ? 'Online' : 'Desconectado'}
                      {player.isHost && ' ‚Ä¢ Controla a sala'}
                    </div>
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  {/* ‚úÖ CORRIGIDO: Host n√£o mostra status "Ready" */}
                  {!player.isHost && (
                    <div className={`
                      flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium
                      ${player.isReady
                        ? 'bg-green-600/20 text-green-400 border border-green-600/30'
                        : 'bg-orange-600/20 text-orange-400 border border-orange-600/30'
                      }
                    `}>
                      {player.isReady ? (
                        <>
                          <Check className="w-3 h-3" />
                          Pronto
                        </>
                      ) : (
                        <>
                          <Clock className="w-3 h-3" />
                          Aguardando
                        </>
                      )}
                    </div>
                  )}

                  {/* ‚úÖ NOVO: Status especial para host */}
                  {player.isHost && (
                    <div className="flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-yellow-600/20 text-yellow-400 border border-yellow-600/30">
                      <Crown className="w-3 h-3" />
                      Host
                    </div>
                  )}

                  {/* Kick Button */}
                  {isHost && player.userId !== currentUserId && (
                    <button
                      onClick={() => onKickPlayer(player.id)}
                      className="p-1 rounded text-red-400 hover:bg-red-600/20 transition-colors"
                      title="Expulsar jogador"
                    >
                      <UserX className="w-4 h-4" />
                    </button>
                  )}
                </div>
              </motion.div>
            ))}
          </AnimatePresence>

          {/* ‚úÖ CORRIGIDO: Mostrar apenas alguns slots vazios */}
          {visibleEmptyPlayerSlots > 0 && (
            <div className="space-y-2">
              {Array.from({ length: visibleEmptyPlayerSlots }).map((_, index) => (
                <div
                  key={`empty-${index}`}
                  className="flex items-center p-3 rounded-lg border-2 border-dashed border-slate-600 opacity-60 hover:opacity-80 transition-opacity"
                >
                  <div className="w-10 h-10 rounded-full bg-slate-700/50 flex items-center justify-center">
                    <UserPlus className="w-5 h-5 text-slate-500" />
                  </div>
                  <span className="ml-3 text-slate-500">
                    Aguardando jogador...
                  </span>
                </div>
              ))}

              {/* ‚úÖ NOVO: Mostrar quantos slots restantes se houver muitos */}
              {emptyPlayerSlots > visibleEmptyPlayerSlots && (
                <div className="text-center py-2">
                  <span className="text-xs text-slate-500">
                    + {emptyPlayerSlots - visibleEmptyPlayerSlots} slot{emptyPlayerSlots - visibleEmptyPlayerSlots !== 1 ? 's' : ''} dispon√≠vel{emptyPlayerSlots - visibleEmptyPlayerSlots !== 1 ? 'eis' : ''}
                  </span>
                </div>
              )}
            </div>
          )}

          {/* ‚úÖ NOVO: Sala cheia */}
          {players.length === maxPlayers && (
            <div className="text-center py-3">
              <div className="inline-flex items-center gap-2 px-3 py-2 bg-green-600/20 text-green-400 rounded-lg border border-green-600/30">
                <Check className="w-4 h-4" />
                <span className="text-sm font-medium">Sala Completa!</span>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Lista de Espectadores */}
      {maxSpectators > 0 && (
        <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold flex items-center gap-2">
              <Eye className="w-5 h-5" />
              Espectadores ({spectators.length}/{maxSpectators})
            </h3>
          </div>

          <div className="space-y-2">
            <AnimatePresence>
              {spectators.map((spectator) => (
                <motion.div
                  key={spectator.id}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 20 }}
                  className="flex items-center justify-between p-2 rounded-lg bg-slate-700/30 border border-slate-600/50"
                >
                  <div className="flex items-center gap-2">
                    <div className="relative">
                      <div className="w-8 h-8 rounded-full bg-gradient-to-br from-slate-500 to-slate-600 flex items-center justify-center text-white text-sm">
                        {spectator.username[0].toUpperCase()}
                      </div>
                      <div className={`
                        absolute -bottom-0.5 -right-0.5 w-2 h-2 rounded-full border border-slate-800
                        ${spectator.isConnected ? 'bg-green-500' : 'bg-red-500'}
                      `} />
                    </div>
                    <span className="text-sm">
                      {spectator.username}
                      {spectator.userId === currentUserId && (
                        <span className="text-blue-400 ml-1">(Voc√™)</span>
                      )}
                    </span>
                  </div>

                  {isHost && spectator.userId !== currentUserId && (
                    <button
                      onClick={() => onKickPlayer(spectator.id)}
                      className="p-1 rounded text-red-400 hover:bg-red-600/20 transition-colors"
                      title="Expulsar espectador"
                    >
                      <UserX className="w-3 h-3" />
                    </button>
                  )}
                </motion.div>
              ))}
            </AnimatePresence>

            {/* Slots vazios para espectadores (limitados) */}
            {visibleEmptySpectatorSlots > 0 && (
              <div className="space-y-2">
                {Array.from({ length: visibleEmptySpectatorSlots }).map((_, index) => (
                  <div
                    key={`empty-spec-${index}`}
                    className="flex items-center p-2 rounded-lg border border-dashed border-slate-600/50 opacity-50"
                  >
                    <div className="w-8 h-8 rounded-full bg-slate-700/30 flex items-center justify-center">
                      <Eye className="w-4 h-4 text-slate-600" />
                    </div>
                    <span className="ml-2 text-slate-600 text-sm">
                      Slot para espectador
                    </span>
                  </div>
                ))}
              </div>
            )}

            {/* Nenhum espectador */}
            {spectators.length === 0 && visibleEmptySpectatorSlots === 0 && (
              <div className="text-center py-4 text-slate-500">
                <Eye className="w-6 h-6 mx-auto mb-2 opacity-50" />
                <p className="text-sm">Nenhum espectador</p>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/room/RoomChat.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Send, MessageCircle, AlertCircle } from 'lucide-react';
import { ChatMessage } from '@/types';

interface RoomChatProps {
  messages: ChatMessage[];
  onSendMessage: (message: string) => void;
  currentUserId: string;
  isConnected: boolean;
}

export default function RoomChat({
  messages,
  onSendMessage,
  currentUserId,
  isConnected
}: RoomChatProps) {
  const [inputMessage, setInputMessage] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Auto-scroll para a √∫ltima mensagem
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSendMessage = (e: React.FormEvent) => {
    e.preventDefault();

    if (!inputMessage.trim()) return;
    if (!isConnected) {
      console.warn('Cannot send message - not connected');
      return;
    }

    onSendMessage(inputMessage.trim());
    setInputMessage('');
    setIsTyping(false);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputMessage(e.target.value);
    setIsTyping(e.target.value.length > 0);
  };

  const getMessageTypeStyle = (channel: string) => {
    switch (channel) {
      case 'system':
        return 'bg-yellow-600/20 border-yellow-600/30 text-yellow-200';
      case 'werewolf':
        return 'bg-red-600/20 border-red-600/30 text-red-200';
      case 'dead':
        return 'bg-gray-600/20 border-gray-600/30 text-gray-300';
      case 'spectator':
        return 'bg-purple-600/20 border-purple-600/30 text-purple-200';
      default:
        return 'bg-slate-700/50 border-slate-600/50 text-white';
    }
  };

  const formatTime = (timestamp: string) => {
    return new Date(timestamp).toLocaleTimeString('pt-BR', {
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  return (
    <div className="bg-slate-800/50 rounded-lg border border-slate-700 flex flex-col">
      {/* Header */}
      <div className="p-4 border-b border-slate-700">
        <h3 className="text-lg font-semibold flex items-center gap-2">
          <MessageCircle className="w-5 h-5" />
          Chat da Sala
          {!isConnected && (
            <AlertCircle className="w-4 h-4 text-red-400" />
          )}
        </h3>
        {!isConnected && (
          <p className="text-xs text-red-400 mt-1">
            Desconectado - N√£o √© poss√≠vel enviar mensagens
          </p>
        )}
      </div>

      {/* ‚úÖ CORRIGIDO: √Årea de mensagens com altura flex√≠vel e melhor layout */}
      <div className="flex-1 flex flex-col min-h-0">
        {/* Messages Container */}
        <div className="flex-1 overflow-y-auto p-4 space-y-3 min-h-[300px] max-h-[400px]">
          <AnimatePresence>
            {messages.map((message) => (
              <motion.div
                key={message.id}
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                className={`p-3 rounded-lg border ${getMessageTypeStyle(message.channel)}`}
              >
                {message.channel === 'system' ? (
                  <div className="text-center">
                    <span className="text-sm font-medium">
                      {message.message}
                    </span>
                    <div className="text-xs opacity-60 mt-1">
                      {formatTime(message.timestamp)}
                    </div>
                  </div>
                ) : (
                  <div>
                    <div className="flex items-center justify-between mb-1">
                      <span className="font-medium text-sm">
                        {message.username}
                        {message.userId === currentUserId && (
                          <span className="text-xs opacity-60 ml-1">(Voc√™)</span>
                        )}
                      </span>
                      <span className="text-xs opacity-60">
                        {formatTime(message.timestamp)}
                      </span>
                    </div>
                    <p className="text-sm leading-relaxed">
                      {message.message}
                    </p>
                  </div>
                )}
              </motion.div>
            ))}
          </AnimatePresence>

          {messages.length === 0 && (
            <div className="text-center text-slate-400 py-8">
              <MessageCircle className="w-8 h-8 mx-auto mb-2 opacity-50" />
              <p className="text-sm">Nenhuma mensagem ainda...</p>
              <p className="text-xs opacity-60">Seja o primeiro a conversar!</p>
            </div>
          )}

          <div ref={messagesEndRef} />
        </div>

        {/* ‚úÖ CORRIGIDO: Input fixo na parte inferior */}
        <div className="p-4 border-t border-slate-700">
          <form onSubmit={handleSendMessage} className="flex gap-2">
            <input
              ref={inputRef}
              type="text"
              value={inputMessage}
              onChange={handleInputChange}
              placeholder={isConnected ? "Digite sua mensagem..." : "Conectando..."}
              disabled={!isConnected}
              className={`
                flex-1 px-3 py-2 rounded-lg border text-sm
                ${isConnected
                  ? 'bg-slate-700 border-slate-600 text-white placeholder-slate-400 focus:border-blue-500 focus:ring-1 focus:ring-blue-500'
                  : 'bg-slate-800 border-slate-700 text-slate-500 placeholder-slate-600 cursor-not-allowed'
                }
                transition-colors outline-none
              `}
              maxLength={500}
            />
            <motion.button
              type="submit"
              disabled={!isConnected || !inputMessage.trim()}
              whileHover={isConnected && inputMessage.trim() ? { scale: 1.05 } : {}}
              whileTap={isConnected && inputMessage.trim() ? { scale: 0.95 } : {}}
              className={`
                px-4 py-2 rounded-lg transition-all duration-200 flex items-center gap-2
                ${isConnected && inputMessage.trim()
                  ? 'bg-blue-600 hover:bg-blue-700 text-white shadow-lg'
                  : 'bg-slate-600 text-slate-400 cursor-not-allowed'
                }
              `}
            >
              <Send className="w-4 h-4" />
              <span className="hidden sm:inline">Enviar</span>
            </motion.button>
          </form>

          {/* Character count */}
          {inputMessage.length > 400 && (
            <div className="mt-2 text-right">
              <span className={`text-xs ${inputMessage.length > 480 ? 'text-red-400' : 'text-yellow-400'}`}>
                {inputMessage.length}/500
              </span>
            </div>
          )}

          {/* Connection status indicator */}
          <div className="mt-2 flex items-center justify-between text-xs text-slate-400">
            <span>
              {isConnected ? (
                <span className="flex items-center gap-1">
                  <span className="w-2 h-2 bg-green-500 rounded-full"></span>
                  Conectado
                </span>
              ) : (
                <span className="flex items-center gap-1">
                  <span className="w-2 h-2 bg-red-500 rounded-full"></span>
                  Desconectado
                </span>
              )}
            </span>

            {messages.length > 0 && (
              <span>{messages.length} mensagem{messages.length !== 1 ? 's' : ''}</span>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/context/AuthContext.tsx">
'use client';

import { createContext, useContext, useEffect, useState, ReactNode, useMemo } from 'react';
import { User, AuthTokens, LoginRequest, RegisterRequest } from '@/types';
import { authService } from '@/services/auth';
import { toast } from 'react-hot-toast';
import Cookies from 'js-cookie';

// =============================================================================
// CONTEXT TYPES
// =============================================================================
interface AuthContextType {
  // State
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;

  // Actions
  login: (credentials: LoginRequest) => Promise<boolean>;
  register: (data: RegisterRequest) => Promise<boolean>;
  logout: () => void;
  refreshToken: () => Promise<boolean>;
  updateUser: (updates: Partial<User>) => void;

  // Utils
  getToken: () => string | null;
  isTokenExpired: () => boolean;
}

// =============================================================================
// CONTEXT CREATION
// =============================================================================
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// =============================================================================
// PROVIDER COMPONENT
// =============================================================================
interface AuthProviderProps {
  children: ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // =============================================================================
  // ‚úÖ COMPUTED VALUES - MELHORADO COM VERIFICA√á√ÉO COMPLETA E DEBUG
  // =============================================================================
  const getToken = (): string | null => {
    const token = Cookies.get('access_token') || null;
    console.log('üîê DEBUG getToken:');
    console.log('üîê Token exists:', !!token);
    console.log('üîê Token length:', token?.length);
    console.log('üîê Token (first 50 chars):', token?.substring(0, 50));
    return token;
  };

  // ‚úÖ CORRIGIDO: isAuthenticated com verifica√ß√£o completa
  const isAuthenticated = useMemo(() => {
    const token = getToken();
    const result = !!user && !!token && !isLoading;
    console.log('üîê DEBUG isAuthenticated:');
    console.log('üîê User exists:', !!user);
    console.log('üîê Token exists:', !!token);
    console.log('üîê Is loading:', isLoading);
    console.log('üîê Final result:', result);
    return result;
  }, [user, isLoading]);

  // =============================================================================
  // TOKEN MANAGEMENT COM DEBUG
  // =============================================================================
  const setTokens = (tokens: AuthTokens) => {
    console.log('üîê DEBUG setTokens:');
    console.log('üîê Setting access token length:', tokens.accessToken?.length);
    console.log('üîê Setting refresh token length:', tokens.refreshToken?.length);

    // Set access token with 7-day expiry
    Cookies.set('access_token', tokens.accessToken, {
      expires: 7,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    });

    // Set refresh token if provided
    if (tokens.refreshToken) {
      Cookies.set('refresh_token', tokens.refreshToken, {
        expires: 30,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
      });
    }

    // Verificar se foram salvos
    const savedAccessToken = Cookies.get('access_token');
    const savedRefreshToken = Cookies.get('refresh_token');

    console.log('üîê Tokens saved verification:');
    console.log('üîê Access token saved:', !!savedAccessToken);
    console.log('üîê Refresh token saved:', !!savedRefreshToken);
  };

  const clearTokens = () => {
    console.log('üîê DEBUG clearTokens: Clearing all tokens');
    Cookies.remove('access_token');
    Cookies.remove('refresh_token');
  };

  const isTokenExpired = (): boolean => {
    const token = getToken();
    if (!token) {
      console.log('üîê DEBUG isTokenExpired: No token found');
      return true;
    }

    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const isExpired = payload.exp * 1000 < Date.now();
      console.log('üîê DEBUG isTokenExpired:');
      console.log('üîê Token exp:', new Date(payload.exp * 1000));
      console.log('üîê Current time:', new Date());
      console.log('üîê Is expired:', isExpired);
      return isExpired;
    } catch (error) {
      console.log('üîê DEBUG isTokenExpired: Error parsing token:', error);
      return true;
    }
  };

  // =============================================================================
  // ‚úÖ AUTHENTICATION ACTIONS - CORRIGIDO CONFORME O GUIA COM DEBUG
  // =============================================================================
  const login = async (credentials: LoginRequest): Promise<boolean> => {
    console.log('üîê DEBUG login: Starting login process');
    console.log('üîê Credentials email:', credentials.email);
    setIsLoading(true);

    // ‚úÖ CORRIGIDO: A chamada de servi√ßo agora NUNCA vai dar "throw" por um erro 401
    const response = await authService.login(credentials);

    console.log('üîê DEBUG login response:');
    console.log('üîê Success:', response.success);
    console.log('üîê Has data:', !!response.data);
    console.log('üîê Error:', response.error);

    setIsLoading(false);

    if (response.success && response.data) {
      console.log('üîê Login successful, processing tokens and user...');
      console.log('üîê User received:', response.data.user?.username);
      console.log('üîê Tokens received:', {
        accessToken: !!response.data.tokens?.accessToken,
        refreshToken: !!response.data.tokens?.refreshToken
      });

      // L√≥gica de sucesso...
      setUser(response.data.user);
      setTokens(response.data.tokens);
      toast.success(`Bem-vindo de volta, ${response.data.user.username}! üê∫`);
      return true;
    } else {
      // L√≥gica de falha...
      console.log('üîê Login failed:', response.error || response.message);
      const errorMessage = response.message || response.error || 'Ocorreu uma falha.';
      toast.error(errorMessage);
      return false;
    }
  };

  const register = async (data: RegisterRequest): Promise<boolean> => {
    console.log('üîê DEBUG register: Starting registration process');
    console.log('üîê Username:', data.username);
    console.log('üîê Email:', data.email);
    setIsLoading(true);

    // ‚úÖ CORRIGIDO: A chamada de servi√ßo agora NUNCA vai dar "throw" por um erro 409
    const response = await authService.register(data);

    console.log('üîê DEBUG register response:');
    console.log('üîê Success:', response.success);
    console.log('üîê Has data:', !!response.data);
    console.log('üîê Error:', response.error);

    setIsLoading(false);

    if (response.success && response.data) {
      console.log('üîê Registration successful, processing tokens and user...');
      // L√≥gica de sucesso...
      setUser(response.data.user);
      setTokens(response.data.tokens);
      toast.success(`Conta criada com sucesso! Bem-vindo, ${data.username}! üéÆ`);
      return true;
    } else {
      // L√≥gica de falha...
      console.log('üîê Registration failed:', response.error || response.message);
      const errorMessage = response.message || response.error || 'Erro ao criar conta';
      toast.error(errorMessage);
      return false;
    }
  };

  const logout = () => {
    console.log('üîê DEBUG logout: Logging out user');
    setUser(null);
    clearTokens();
    toast.success('Logout realizado com sucesso!');

    // Redirect to home page
    if (typeof window !== 'undefined') {
      window.location.href = '/';
    }
  };

  const refreshToken = async (): Promise<boolean> => {
    console.log('üîê DEBUG refreshToken: Attempting to refresh token');
    try {
      const refreshTokenValue = Cookies.get('refresh_token');
      console.log('üîê Refresh token exists:', !!refreshTokenValue);

      if (!refreshTokenValue) {
        console.log('üîê No refresh token found');
        return false;
      }

      const response = await authService.refreshToken(refreshTokenValue);

      console.log('üîê Refresh token response:');
      console.log('üîê Success:', response.success);
      console.log('üîê Has data:', !!response.data);

      if (response.success && response.data) {
        console.log('üîê Token refreshed successfully');
        setTokens(response.data.tokens);
        return true;
      }

      console.log('üîê Token refresh failed');
      return false;
    } catch (error) {
      console.error('üîê Refresh token error:', error);
      return false;
    }
  };

  const updateUser = (updates: Partial<User>) => {
    console.log('üîê DEBUG updateUser:', updates);
    if (user) {
      setUser({ ...user, ...updates });
    }
  };

  // =============================================================================
  // ‚úÖ INITIALIZATION - MELHORADO COM MELHOR CONTROLE DE LOADING E DEBUG
  // =============================================================================
  useEffect(() => {
    const initializeAuth = async () => {
      console.log('üîê DEBUG initializeAuth: Starting auth initialization');
      try {
        setIsLoading(true);
        const token = getToken();

        if (!token || isTokenExpired()) {
          console.log('üîê Token missing or expired, trying to refresh...');
          // Try to refresh token
          const refreshed = await refreshToken();
          if (!refreshed) {
            console.log('üîê Could not refresh token, user not authenticated');
            setIsLoading(false);
            return;
          }
        }

        console.log('üîê Getting user profile...');
        // Get user profile
        const profileResponse = await authService.getProfile();

        console.log('üîê Profile response:');
        console.log('üîê Success:', profileResponse.success);
        console.log('üîê Has data:', !!profileResponse.data);

        if (profileResponse.success && profileResponse.data) {
          console.log('üîê User profile loaded:', profileResponse.data.username);
          setUser(profileResponse.data);
        } else {
          // Token is invalid, clear it
          console.log('üîê Profile fetch failed, clearing tokens');
          clearTokens();
        }
      } catch (error) {
        console.error('üîê Auth initialization error:', error);
        clearTokens();
      } finally {
        console.log('üîê Auth initialization completed');
        setIsLoading(false);
      }
    };

    initializeAuth();
  }, []);

  // =============================================================================
  // TOKEN REFRESH SCHEDULER COM DEBUG
  // =============================================================================
  useEffect(() => {
    if (!isAuthenticated) {
      console.log('üîê DEBUG: User not authenticated, skipping token refresh scheduler');
      return;
    }

    console.log('üîê DEBUG: Setting up token refresh scheduler');

    // Refresh token every 30 minutes if user is active
    const interval = setInterval(async () => {
      console.log('üîê Scheduled token check...');
      if (!isTokenExpired()) {
        console.log('üîê Token still valid, no refresh needed');
        return;
      }

      console.log('üîê Token expired, attempting refresh...');
      const refreshed = await refreshToken();
      if (!refreshed) {
        console.log('üîê Token refresh failed, logging out user');
        logout();
      }
    }, 30 * 60 * 1000); // 30 minutes

    return () => {
      console.log('üîê Clearing token refresh scheduler');
      clearInterval(interval);
    };
  }, [isAuthenticated]);

  // =============================================================================
  // ‚úÖ CONTEXT VALUE - MEMOIZADO PARA EVITAR RE-RENDERS DESNECESS√ÅRIOS
  // =============================================================================
  const contextValue = useMemo<AuthContextType>(() => {
    console.log('üîê DEBUG: Context value memoization');
    console.log('üîê Current state - User:', !!user, 'IsAuth:', isAuthenticated, 'Loading:', isLoading);

    return {
      // State
      user,
      isAuthenticated,
      isLoading,

      // Actions
      login,
      register,
      logout,
      refreshToken,
      updateUser,

      // Utils
      getToken,
      isTokenExpired,
    };
  }, [user, isAuthenticated, isLoading]);

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
}

// =============================================================================
// HOOK
// =============================================================================
export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// =============================================================================
// HOC FOR PROTECTED ROUTES
// =============================================================================
export function withAuth<P extends object>(Component: React.ComponentType<P>) {
  return function AuthenticatedComponent(props: P) {
    const { isAuthenticated, isLoading } = useAuth();

    console.log('üîê DEBUG withAuth HOC:');
    console.log('üîê isAuthenticated:', isAuthenticated);
    console.log('üîê isLoading:', isLoading);

    if (isLoading) {
      console.log('üîê Showing loading screen');
      return (
        <div className="min-h-screen flex items-center justify-center bg-medieval-900">
          <div className="text-white text-xl font-medieval">
            üê∫ Carregando...
          </div>
        </div>
      );
    }

    if (!isAuthenticated) {
      console.log('üîê User not authenticated, redirecting to login');
      if (typeof window !== 'undefined') {
        window.location.href = '/auth/login';
      }
      return null;
    }

    console.log('üîê User authenticated, rendering component');
    return <Component {...props} />;
  };
}
</file>

<file path="frontend/src/hooks/index.ts">
// üê∫ LOBISOMEM ONLINE - Custom Hooks
// Reusable hooks for common functionality

import { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { toast } from 'react-hot-toast';

// =============================================================================
// TIPOS AUXILIARES PARA HOOKS
// =============================================================================
export interface WebSocketHookOptions {
  autoConnect?: boolean;
  heartbeatInterval?: number;
  maxReconnectAttempts?: number;
  reconnectBackoff?: 'linear' | 'exponential';
}

export interface UseWebSocketReturn {
  socket: WebSocket | null;
  status: 'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'error';
  isConnected: boolean;
  pingLatency: number;
  reconnectAttempts: number;
  connect: () => void;
  disconnect: () => void;
  sendMessage: (type: string, data?: any) => boolean;
}

// =============================================================================
// ‚úÖ WEBSOCKET HOOK COM HEARTBEAT - CORRIGIDO
// =============================================================================
export function useWebSocket(
  url: string,
  options: WebSocketHookOptions = {}
): UseWebSocketReturn {
  const {
    autoConnect = true,
    heartbeatInterval = 30000, // 30 segundos
    maxReconnectAttempts = 5,
    reconnectBackoff = 'exponential'
  } = options;

  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [status, setStatus] = useState<'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'error'>('disconnected');
  const [pingLatency, setPingLatency] = useState<number>(0);
  const [reconnectAttempts, setReconnectAttempts] = useState<number>(0);

  const heartbeatRef = useRef<NodeJS.Timeout | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const pingStartTimeRef = useRef<number>(0);
  const shouldReconnectRef = useRef<boolean>(true);

  const clearHeartbeat = useCallback(() => {
    if (heartbeatRef.current) {
      clearInterval(heartbeatRef.current);
      heartbeatRef.current = null;
    }
  }, []);

  const clearReconnectTimeout = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
  }, []);

  const startHeartbeat = useCallback(() => {
    clearHeartbeat();

    heartbeatRef.current = setInterval(() => {
      if (socket && socket.readyState === WebSocket.OPEN) {
        pingStartTimeRef.current = Date.now();
        socket.send(JSON.stringify({ type: 'ping' }));
      }
    }, heartbeatInterval);
  }, [socket, heartbeatInterval, clearHeartbeat]);

  const calculateReconnectDelay = useCallback((attempts: number) => {
    if (reconnectBackoff === 'linear') {
      return Math.min(1000 * attempts, 30000); // Max 30 segundos
    } else {
      return Math.min(1000 * Math.pow(2, attempts), 30000); // Exponencial, max 30 segundos
    }
  }, [reconnectBackoff]);

  const connect = useCallback(() => {
    // ‚úÖ CORRE√á√ÉO: Validar URL antes de conectar
    if (!url || url === '') {
      console.warn('‚ùå Cannot connect: URL is empty');
      return;
    }

    if (socket && socket.readyState === WebSocket.OPEN) {
      console.log('‚úÖ WebSocket already connected, skipping...');
      return;
    }

    setStatus('connecting');
    shouldReconnectRef.current = true;

    try {
      console.log('üîå Connecting to WebSocket:', url);
      const ws = new WebSocket(url);
      setSocket(ws);

      ws.onopen = () => {
        console.log('‚úÖ WebSocket conectado');
        setStatus('connected');
        setReconnectAttempts(0);
        startHeartbeat();
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);

          // Responder ao ping com pong
          if (message.type === 'ping') {
            ws.send(JSON.stringify({ type: 'pong' }));
          }

          // Calcular lat√™ncia do ping
          if (message.type === 'pong') {
            const latency = Date.now() - pingStartTimeRef.current;
            setPingLatency(latency);
          }

          // Dispatchar evento customizado para outros componentes
          const customEvent = new CustomEvent('websocket-message', {
            detail: message
          });
          window.dispatchEvent(customEvent);
        } catch (error) {
          console.error('Erro ao processar mensagem WebSocket:', error);
        }
      };

      ws.onclose = (event) => {
        console.log('WebSocket fechado:', event.code, event.reason);
        setSocket(null);
        clearHeartbeat();

        if (shouldReconnectRef.current && reconnectAttempts < maxReconnectAttempts) {
          setStatus('reconnecting');
          const delay = calculateReconnectDelay(reconnectAttempts);

          reconnectTimeoutRef.current = setTimeout(() => {
            setReconnectAttempts(prev => prev + 1);
            connect();
          }, delay);
        } else {
          setStatus('disconnected');
        }
      };

      ws.onerror = (error) => {
        console.error('Erro WebSocket:', error);
        setStatus('error');
      };

    } catch (error) {
      console.error('Erro ao criar WebSocket:', error);
      setStatus('error');
    }
  }, [url, startHeartbeat, reconnectAttempts, maxReconnectAttempts, calculateReconnectDelay]);

  const disconnect = useCallback(() => {
    shouldReconnectRef.current = false;
    clearHeartbeat();
    clearReconnectTimeout();

    if (socket) {
      socket.close();
      setSocket(null);
    }

    setStatus('disconnected');
    setReconnectAttempts(0);
  }, [socket, clearHeartbeat, clearReconnectTimeout]);

  const sendMessage = useCallback((type: string, data?: any): boolean => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      try {
        socket.send(JSON.stringify({ type, data }));
        return true;
      } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
        return false;
      }
    }
    return false;
  }, [socket]);

  // ‚úÖ CORRE√á√ÉO: useEffect para autoConnect sem depend√™ncias problem√°ticas
  useEffect(() => {
    if (autoConnect && url && url !== '') {
      connect();
    }

    return () => {
      disconnect();
    };
  }, [autoConnect, url]); // ‚úÖ REMOVIDO: connect e disconnect das depend√™ncias para evitar loop

  return {
    socket,
    status,
    isConnected: status === 'connected',
    pingLatency,
    reconnectAttempts,
    connect,
    disconnect,
    sendMessage,
  };
}

// =============================================================================
// LOCAL STORAGE HOOK
// =============================================================================
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  // State to store our value
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);

      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}

// =============================================================================
// DEBOUNCE HOOK
// =============================================================================
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// =============================================================================
// ASYNC OPERATION HOOK
// =============================================================================
export function useAsync<T, E = string>(
  asyncFunction: () => Promise<T>,
  immediate = true
) {
  const [status, setStatus] = useState<'idle' | 'pending' | 'success' | 'error'>('idle');
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<E | null>(null);

  const execute = useCallback(async () => {
    setStatus('pending');
    setData(null);
    setError(null);

    try {
      const response = await asyncFunction();
      setData(response);
      setStatus('success');
      return response;
    } catch (error) {
      setError(error as E);
      setStatus('error');
      throw error;
    }
  }, [asyncFunction]);

  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return {
    execute,
    status,
    data,
    error,
    isLoading: status === 'pending',
    isError: status === 'error',
    isSuccess: status === 'success',
    isIdle: status === 'idle',
  };
}

// =============================================================================
// FORM HOOK
// =============================================================================
export function useForm<T extends Record<string, any>>(
  initialValues: T,
  onSubmit: (values: T) => void | Promise<void>
) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [touched, setTouchedState] = useState<Partial<Record<keyof T, boolean>>>({});

  const setValue = useCallback((name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));

    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: undefined }));
    }
  }, [errors]);

  const setError = useCallback((name: keyof T, error: string) => {
    setErrors(prev => ({ ...prev, [name]: error }));
  }, []);

  const setTouched = useCallback((name: keyof T, isTouched = true) => {
    setTouchedState(prev => ({ ...prev, [name]: isTouched }));
  }, []);

  const handleChange = useCallback((name: keyof T) => (
    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    setValue(name, event.target.value);
  }, [setValue]);

  const handleSubmit = useCallback(async (event?: React.FormEvent) => {
    if (event) {
      event.preventDefault();
    }

    setIsSubmitting(true);

    try {
      await onSubmit(values);
    } catch (error) {
      console.error('Form submission error:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [values, onSubmit]);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouchedState({});
    setIsSubmitting(false);
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    setValue,
    setError,
    setTouched,
    handleChange,
    handleSubmit,
    reset,
    hasErrors: Object.keys(errors).length > 0,
  };
}

// =============================================================================
// COUNTDOWN HOOK
// =============================================================================
export function useCountdown(initialTime: number) {
  const [timeLeft, setTimeLeft] = useState(initialTime);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const start = useCallback(() => {
    if (!isRunning) {
      setIsRunning(true);
    }
  }, [isRunning]);

  const pause = useCallback(() => {
    setIsRunning(false);
  }, []);

  const reset = useCallback((newTime?: number) => {
    setIsRunning(false);
    setTimeLeft(newTime ?? initialTime);
  }, [initialTime]);

  const stop = useCallback(() => {
    setIsRunning(false);
    setTimeLeft(0);
  }, []);

  useEffect(() => {
    if (isRunning && timeLeft > 0) {
      intervalRef.current = setInterval(() => {
        setTimeLeft(prev => {
          if (prev <= 1) {
            setIsRunning(false);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    } else {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [isRunning, timeLeft]);

  const formatTime = useCallback((seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  }, []);

  return {
    timeLeft,
    isRunning,
    start,
    pause,
    reset,
    stop,
    formatTime: formatTime(timeLeft),
    isFinished: timeLeft === 0,
  };
}

// =============================================================================
// KEYBOARD HOOK
// =============================================================================
export function useKeyboard(key: string, callback: () => void, deps: any[] = []) {
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.key === key) {
        callback();
      }
    };

    document.addEventListener('keydown', handleKeyPress);
    return () => document.removeEventListener('keydown', handleKeyPress);
  }, [key, callback, ...deps]);
}

// =============================================================================
// ONLINE STATUS HOOK
// =============================================================================
export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );

  useEffect(() => {
    const setOnline = () => setIsOnline(true);
    const setOffline = () => setIsOnline(false);

    window.addEventListener('online', setOnline);
    window.addEventListener('offline', setOffline);

    return () => {
      window.removeEventListener('online', setOnline);
      window.removeEventListener('offline', setOffline);
    };
  }, []);

  return isOnline;
}

// =============================================================================
// COPY TO CLIPBOARD HOOK
// =============================================================================
export function useCopyToClipboard() {
  const [copiedText, setCopiedText] = useState<string | null>(null);

  const copy = useCallback(async (text: string) => {
    if (!navigator?.clipboard) {
      console.warn('Clipboard not supported');
      return false;
    }

    try {
      await navigator.clipboard.writeText(text);
      setCopiedText(text);
      toast.success('Copiado para a √°rea de transfer√™ncia!');

      // Clear copied text after 3 seconds
      setTimeout(() => setCopiedText(null), 3000);

      return true;
    } catch (error) {
      console.warn('Copy failed', error);
      toast.error('Falha ao copiar');
      setCopiedText(null);
      return false;
    }
  }, []);

  return { copy, copiedText };
}

// =============================================================================
// INTERSECTION OBSERVER HOOK
// =============================================================================
export function useIntersectionObserver(
  elementRef: React.RefObject<Element>,
  options?: IntersectionObserverInit
) {
  const [isIntersecting, setIsIntersecting] = useState(false);

  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => setIsIntersecting(entry.isIntersecting),
      options
    );

    observer.observe(element);
    return () => observer.unobserve(element);
  }, [elementRef, options]);

  return isIntersecting;
}

// =============================================================================
// PREVIOUS VALUE HOOK
// =============================================================================
export function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T>();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

// =============================================================================
// WINDOW SIZE HOOK
// =============================================================================
export function useWindowSize() {
  const [windowSize, setWindowSize] = useState<{
    width: number | undefined;
    height: number | undefined;
  }>({
    width: undefined,
    height: undefined,
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener('resize', handleResize);
    handleResize(); // Set initial size

    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return windowSize;
}

// =============================================================================
// ROUTE PROTECTION HOOK
// =============================================================================
export function useProtectedRoute(redirectTo = '/auth/login') {
  const router = useRouter();

  // This would typically use your auth context
  // For now, just a placeholder
  const isAuthenticated = false; // Replace with actual auth check

  useEffect(() => {
    if (!isAuthenticated) {
      router.push(redirectTo);
    }
  }, [isAuthenticated, router, redirectTo]);

  return isAuthenticated;
}
</file>

<file path="frontend/src/pages/auth/login.tsx">
// üê∫ WEREWOLF - Login Page
// Werewolf inspired login interface with Magic Login

import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { Eye, EyeOff, Mail, Lock, LogIn, AlertCircle } from 'lucide-react';
import { toast } from 'react-hot-toast';

import { useAuth } from '@/context/AuthContext';
import { useTheme } from '@/context/ThemeContext';
import { useForm } from '@/hooks';
import { LoginRequest } from '@/types';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// LOGIN PAGE COMPONENT
// =============================================================================
export default function LoginPage() {
  const router = useRouter();
  const { login, isAuthenticated, isLoading } = useAuth();
  const { playSound } = useTheme();
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  // ‚úÖ NOVO: Gerar credenciais de dev uma √∫nica vez por renderiza√ß√£o
  // Usamos useState para que o valor n√£o mude a cada re-render do componente
  const [devCredentials] = useState(() => {
    if (process.env.NODE_ENV === 'development') {
      const randomId = Math.floor(Math.random() * 1000);
      const userTypes = ['player', 'admin', 'test', 'demo', 'dev'];
      const randomType = userTypes[Math.floor(Math.random() * userTypes.length)];

      return {
        email: `${randomType}_${randomId}@dev.test`,
        password: 'password123', // A senha pode ser fixa, pois ser√° ignorada pelo backend
      };
    }
    return null;
  });

  // Form management
  const {
    values,
    errors,
    touched,
    handleChange,
    handleSubmit,
    setError: setFieldError,
    setTouched,
    setValue, // ‚úÖ Adicionar setValue para preencher campos programaticamente
  } = useForm<LoginRequest>(
    {
      email: '',
      password: '',
    },
    async (formData) => {
      if (!validateForm(formData)) return;

      setIsSubmitting(true);
      setError('');

      try {
        await login(formData);
        // Se chegou aqui, o login foi bem-sucedido
        toast.success('Login realizado com sucesso!');
      } catch (loginError: any) {
        // Captura erros espec√≠ficos do login
        const errorMessage = loginError?.message || 'Erro no login. Tente novamente.';
        setError(errorMessage);
        toast.error(errorMessage);
      } finally {
        setIsSubmitting(false);
      }
    }
  );

  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated && !isLoading) {
      const redirectTo = router.query.redirect as string || '/lobby';
      router.push(redirectTo);
    }
  }, [isAuthenticated, isLoading, router]);

  // Form validation
  const validateForm = (data: LoginRequest): boolean => {
    let isValid = true;
    setError('');

    // Email validation
    if (!data.email) {
      setFieldError('email', 'Email √© obrigat√≥rio');
      isValid = false;
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
      setFieldError('email', 'Email inv√°lido');
      isValid = false;
    }

    // Password validation
    if (!data.password) {
      setFieldError('password', 'Senha √© obrigat√≥ria');
      isValid = false;
    } else if (data.password.length < 6) {
      setFieldError('password', 'Senha deve ter pelo menos 6 caracteres');
      isValid = false;
    }

    return isValid;
  };

  // ‚úÖ Fun√ß√£o para preencher credenciais de desenvolvimento
  const fillDevCredentials = () => {
    if (devCredentials) {
      setValue('email', devCredentials.email);
      setValue('password', devCredentials.password);
      playSound('button_click');
      toast.success('Credenciais de desenvolvimento preenchidas!');
    }
  };

  // Show loading if checking authentication
  if (isLoading) {
    return <LoadingSpinner variant="medieval" size="xl" text="Verificando autentica√ß√£o..." />;
  }

  return (
    <>
      <Head>
        <title>Login - Werewolf</title>
        <meta name="description" content="Fa√ßa login na sua conta do Werewolf" />
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="card-medieval p-8"
        >
          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: 'spring' }}
              className="text-6xl mb-4"
            >
              üê∫
            </motion.div>
            <h1 className="text-2xl font-medieval text-glow mb-2">
              Entrar na Vila
            </h1>
            <p className="text-white/70">
              Fa√ßa login para come√ßar a jogar
            </p>
          </div>

          {/* Display de erro geral */}
          {error && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              className="mb-6 p-4 bg-red-900/30 border border-red-500/50 rounded-lg flex items-center gap-3"
            >
              <AlertCircle className="w-5 h-5 text-red-400 flex-shrink-0" />
              <p className="text-red-300 text-sm">{error}</p>
            </motion.div>
          )}

          {/* Google Login Button */}
          <Button
            variant="ghost"
            size="lg"
            onClick={() => {
              playSound('button_click');
              console.log('Google login clicked');
              toast.info('Login com Google ser√° implementado em breve');
              // TODO: Implementar login com Google
            }}
            className="w-full border border-white/20 hover:border-white/40 mb-6"
            disabled={isSubmitting}
          >
            <svg className="w-5 h-5 mr-3" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
              />
              <path
                fill="currentColor"
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
              />
              <path
                fill="currentColor"
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
              />
              <path
                fill="currentColor"
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
              />
            </svg>
            Continuar com Google
          </Button>

          {/* Divider */}
          <div className="my-6 flex items-center">
            <div className="flex-1 border-t border-medieval-600"></div>
            <span className="px-4 text-white/50 text-sm">ou</span>
            <div className="flex-1 border-t border-medieval-600"></div>
          </div>

          {/* Login Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Email Field */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Email
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Mail className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="email"
                  type="email"
                  value={values.email}
                  onChange={handleChange('email')}
                  onBlur={() => setTouched('email')}
                  className={`
                    w-full pl-10 pr-4 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.email && touched.email
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seu@email.com"
                  disabled={isSubmitting}
                />
              </div>
              {errors.email && touched.email && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.email}
                </motion.p>
              )}
            </div>

            {/* Password Field */}
            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Senha
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Lock className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  value={values.password}
                  onChange={handleChange('password')}
                  onBlur={() => setTouched('password')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.password && touched.password
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  disabled={isSubmitting}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-white/40 hover:text-white/70 transition-colors"
                  disabled={isSubmitting}
                >
                  {showPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>
              {errors.password && touched.password && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.password}
                </motion.p>
              )}
            </div>

            {/* Forgot Password Link */}
            <div className="text-right">
              <Link
                href="/auth/forgot-password"
                className="text-sm text-salem-400 hover:text-salem-300 transition-colors"
              >
                Esqueceu sua senha?
              </Link>
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="medieval"
              size="lg"
              disabled={isSubmitting}
              loading={isSubmitting}
              className="w-full"
            >
              <LogIn className="w-5 h-5 mr-2" />
              {isSubmitting ? 'Entrando...' : 'Entrar'}
            </Button>
          </form>

          {/* Register Link */}
          <div className="text-center mt-8">
            <p className="text-white/70 mb-4">
              Ainda n√£o tem uma conta?
            </p>
            <Button
              variant="ghost"
              onClick={() => router.push('/auth/register')}
              className="w-full"
              disabled={isSubmitting}
            >
              Criar Conta Gratuita
            </Button>
          </div>

          {/* ‚úÖ‚úÖ‚úÖ NOVO BLOCO DE DESENVOLVIMENTO COM CREDENCIAIS DIN√ÇMICAS ‚úÖ‚úÖ‚úÖ */}
          {devCredentials && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 1 }}
              className="mt-8 p-4 bg-gradient-to-r from-blue-900/20 to-purple-900/20 border border-blue-500/30 rounded-lg"
            >
              <div className="flex items-center gap-2 mb-3">
                <span className="text-lg">üß™</span>
                <h4 className="text-sm font-semibold text-blue-300">
                  Modo Desenvolvimento - Magic Login
                </h4>
              </div>

              <p className="text-xs text-blue-200/70 mb-3">
                Credenciais de teste geradas automaticamente:
              </p>

              <div className="bg-black/20 rounded p-3 mb-3">
                <div className="text-xs font-mono text-blue-200">
                  <div className="flex justify-between items-center mb-1">
                    <span>Email:</span>
                    <span className="text-green-300">{devCredentials.email}</span>
                  </div>
                  <div className="flex justify-between items-center">
                    <span>Senha:</span>
                    <span className="text-green-300">{devCredentials.password}</span>
                  </div>
                </div>
              </div>

              <div className="text-xs text-blue-200/60 mb-3">
                ‚ÑπÔ∏è Este email ser√° aceito automaticamente pelo backend (bypassa valida√ß√£o de senha)
              </div>

              <div className="flex gap-2">
                <Button
                  variant="ghost"
                  size="sm"
                  className="flex-1 text-xs border border-blue-500/30 hover:border-blue-400/50"
                  onClick={fillDevCredentials}
                  disabled={isSubmitting}
                >
                  üöÄ Preencher Automaticamente
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  className="text-xs text-blue-300/70"
                  onClick={() => window.location.reload()}
                  disabled={isSubmitting}
                >
                  üîÑ Gerar Novos
                </Button>
              </div>

              <div className="mt-3 pt-3 border-t border-blue-500/20">
                <div className="text-xs text-blue-200/50">
                  <strong>Como funciona:</strong> Emails terminados em <code className="bg-black/30 px-1 rounded">@dev.test</code> s√£o automaticamente aceitos em desenvolvimento, criando usu√°rios na hora se necess√°rio.
                </div>
              </div>
            </motion.div>
          )}
          {/* ‚úÖ‚úÖ‚úÖ FIM DO NOVO BLOCO DE DESENVOLVIMENTO ‚úÖ‚úÖ‚úÖ */}
        </motion.div>

        {/* Background Elements */}
        <div className="fixed inset-0 overflow-hidden pointer-events-none z-[-1]">
          {[...Array(3)].map((_, i) => (
            <motion.div
              key={i}
              className="absolute text-8xl opacity-5"
              style={{
                top: `${20 + i * 30}%`,
                left: `${10 + i * 30}%`,
              }}
              animate={{
                y: [0, -20, 0],
                rotate: [0, 5, -5, 0],
              }}
              transition={{
                duration: 6 + i * 2,
                repeat: Infinity,
                ease: 'easeInOut',
              }}
            >
              üê∫
            </motion.div>
          ))}
        </div>
      </Layout>
    </>
  );
}
</file>

<file path="frontend/src/pages/room/[id].tsx">
import { useRouter } from 'next/router';
import Head from 'next/head';
import { useEffect, useState, useMemo } from 'react';
import { withAuth } from '@/context/AuthContext';
import { useSocket } from '@/context/SocketContext';
import { useAuth } from '@/context/AuthContext';
import WaitingRoom from '@/components/room/WaitingRoom';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { toast } from 'react-hot-toast';
import { Player, Room, ChatMessage } from '@/types';

function RoomPage() {
  const router = useRouter();
  const { id: roomId } = router.query;
  const { connect, disconnect, isConnected, sendMessage } = useSocket();
  const { user, getToken, isAuthenticated } = useAuth();

  // ‚úÖ TODOS OS ESTADOS AGORA VIVEM AQUI
  const [hasJoinedRoom, setHasJoinedRoom] = useState(false);
  const [room, setRoom] = useState<Room | null>(null);
  const [players, setPlayers] = useState<Player[]>([]);
  const [spectators, setSpectators] = useState<Player[]>([]);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [loading, setLoading] = useState(true);
  const [showLeaveModal, setShowLeaveModal] = useState(false);

  // ‚úÖ DADOS DERIVADOS
  const currentUserId = user?.id || '';
  const isHost = useMemo(() => room?.hostId === currentUserId, [room, currentUserId]);
  const currentPlayer = useMemo(() => players.find(p => p.userId === currentUserId), [players, currentUserId]);
  const isReady = currentPlayer?.isReady || false;

  // ‚úÖ CORRIGIDO: Bug #1 - Filtrar host antes de verificar se todos est√£o prontos
  const canStartGame = players.length >= 3 && players.filter(p => !p.isHost).every(p => p.isReady) && isConnected && isHost;

  // ‚úÖ EFEITO #1: Apenas para conectar e desconectar ao WebSocket.
  // Ele roda UMA VEZ quando as depend√™ncias de inicializa√ß√£o estiverem prontas.
  useEffect(() => {
    if (!router.isReady || !isAuthenticated || !roomId || typeof roomId !== 'string') {
      return; // Aguarda at√© ter tudo o que precisa.
    }
    const token = getToken();
    if (!token) {
      router.push('/auth/login');
      return;
    }

    const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001'}/ws/${roomId}?token=${encodeURIComponent(token)}`;
    connect(wsUrl);

    // A fun√ß√£o de cleanup √© chamada QUANDO O USU√ÅRIO SAI DA P√ÅGINA.
    return () => {
      sendMessage('leave-room', { roomId });
      disconnect();
    };
  }, [router.isReady, isAuthenticated, roomId, connect, disconnect, getToken, router, sendMessage]);

  // ‚úÖ EFEITO #2: Apenas para entrar na sala, uma √∫nica vez por conex√£o.
  // Ele REAGE √† mudan√ßa de `isConnected`.
  useEffect(() => {
    // S√≥ envia a mensagem se estivermos conectados E ainda n√£o tivermos entrado.
    if (isConnected && !hasJoinedRoom) {
      const asSpectator = router.query.spectate === 'true';
      if (sendMessage('join-room', { roomId: roomId as string, asSpectator })) {
        setHasJoinedRoom(true); // Marca que j√° tentamos entrar para n√£o enviar de novo.
      }
    }
  }, [isConnected, roomId, hasJoinedRoom, sendMessage, router.query.spectate]);

  // ‚úÖ EFEITO #3: Apenas para ouvir as mensagens.
  useEffect(() => {
    const handleMessage = (event: CustomEvent) => {
      const { type, data } = event.detail;
      console.log('üì® [RoomPage] Received:', type, data);

      switch (type) {
        case 'room-joined':
          setRoom(data.room);
          setPlayers(Array.isArray(data.players) ? data.players : []);
          setSpectators(Array.isArray(data.spectators) ? data.spectators : []);
          setLoading(false);
          toast.success(`Entrou na sala: ${data.room?.name || roomId}`);
          break;

        case 'player-joined':
          if (data.player) {
            setPlayers(prev => {
              const filtered = prev.filter(p => p.userId !== data.player.userId);
              return [...filtered, data.player];
            });

            const systemMessage: ChatMessage = {
              id: Date.now().toString(),
              userId: 'system',
              username: 'Sistema',
              message: `${data.player.username} entrou na sala`,
              channel: 'system',
              timestamp: new Date().toISOString()
            };
            setMessages(prev => [...prev, systemMessage]);
          }
          break;

        case 'player-left':
          if (data.userId) {
            setPlayers(prev => prev.filter(p => p.userId !== data.userId));
            setSpectators(prev => prev.filter(s => s.userId !== data.userId));

            if (data.username) {
              const systemMessage: ChatMessage = {
                id: Date.now().toString(),
                userId: 'system',
                username: 'Sistema',
                message: `${data.username} saiu da sala`,
                channel: 'system',
                timestamp: new Date().toISOString()
              };
              setMessages(prev => [...prev, systemMessage]);
            }
          }
          break;

        case 'player-ready':
          if (data.userId) {
            setPlayers(prev => prev.map(p =>
              p.userId === data.userId ? { ...p, isReady: data.ready } : p
            ));
          }
          break;

        case 'chat-message':
          if (data) {
            const message = data.message || data;
            setMessages(prev => [...prev, message]);
          }
          break;

        // ‚úÖ CORRIGIDO: Bug #2 - Redirecionamento para tela do jogo
        case 'game-starting':
        case 'game-started':
        case 'game-state': // ‚úÖ ADICIONADO: Ouvir tamb√©m game-state do backend
          // ‚úÖ CORRIGIDO: Identificar gameId correto (backend gera "game-${roomId}")
          const gameId = data?.gameId || `game-${roomId}`;

          console.log('üéÆ [RoomPage] Game starting/started:', {
            type,
            gameId,
            roomId,
            dataReceived: data
          });

          toast.success('üéÆ Jogo iniciando!');

          // ‚úÖ CORRIGIDO: Desconectar WebSocket da sala antes de navegar
          disconnect();

          // ‚úÖ CORRIGIDO: Redirecionar imediatamente (sem setTimeout)
          router.push(`/game/${gameId}`);
          break;

        case 'room-updated':
          if (data.room) setRoom(data.room);
          if (data.players) setPlayers(data.players);
          if (data.spectators) setSpectators(data.spectators);
          break;

        case 'room-deleted':
          toast.error(data.reason || 'A sala foi encerrada pelo host');
          router.push('/lobby');
          break;

        case 'error':
          if (data.message) {
            toast.error(data.message);
          }
          break;
      }
    };

    window.addEventListener('websocket-message', handleMessage as EventListener);
    return () => {
      window.removeEventListener('websocket-message', handleMessage as EventListener);
    };
  }, [roomId, router, disconnect]);

  // ‚úÖ HANDLERS (MOVIDOS DO WAITINGROOM)
  const handleToggleReady = () => {
    sendMessage('player-ready', { ready: !isReady });
  };

  const handleStartGame = () => {
    if (!isHost || !canStartGame) return;
    sendMessage('start-game', {});
    toast.success('Iniciando jogo...');
  };

  const handleKickPlayer = (playerId: string) => {
    if (!isHost) return;
    sendMessage('kick-player', { playerId });
  };

  const handleSendChatMessage = (message: string) => {
    sendMessage('chat-message', { message });
  };

  const handleShareRoom = async () => {
    if (!room) return;
    const shareUrl = `${window.location.origin}/room/${room.id}`;

    try {
      await navigator.clipboard.writeText(shareUrl);
      toast.success('Link da sala copiado!');
    } catch (error) {
      toast.error('Erro ao copiar link');
    }
  };

  const handleLeaveRoom = () => {
    if (isHost) {
      setShowLeaveModal(true);
    } else {
      sendMessage('leave-room', { roomId });
      router.push('/lobby');
    }
  };

  const handleConfirmLeaveAsHost = () => {
    sendMessage('delete-room', { roomId });
    setShowLeaveModal(false);
    toast('Encerrando sala...', { icon: 'üè†' });
  };

  // ‚úÖ RENDERIZA√á√ÉO CONDICIONAL
  if (!router.isReady) {
    return (
      <>
        <Head>
          <title>Carregando... - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <LoadingSpinner variant="medieval" size="xl" text="Carregando sala..." />
        </div>
      </>
    );
  }

  if (!roomId || typeof roomId !== 'string') {
    return (
      <>
        <Head>
          <title>Erro - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <div className="text-center">
            <div className="text-6xl mb-4">‚ùå</div>
            <h1 className="text-2xl font-bold text-white mb-4">Sala Inv√°lida</h1>
            <button
              onClick={() => router.push('/lobby')}
              className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors"
            >
              Voltar ao Lobby
            </button>
          </div>
        </div>
      </>
    );
  }

  if (!isConnected) {
    return (
      <>
        <Head>
          <title>Conectando... - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <div className="text-center">
            <LoadingSpinner variant="medieval" size="xl" text="Conectando ao servidor..." />
            <p className="text-gray-400 mt-4">Estabelecendo conex√£o segura...</p>
          </div>
        </div>
      </>
    );
  }

  if (loading) {
    return (
      <>
        <Head>
          <title>Entrando na sala... - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <div className="text-center">
            <LoadingSpinner variant="medieval" size="xl" text="Entrando na sala..." />
            <p className="text-gray-400 mt-4">Aguardando confirma√ß√£o do servidor...</p>
          </div>
        </div>
      </>
    );
  }

  // ‚úÖ RENDERIZA O WAITINGROOM PASSANDO TUDO COMO PROPS
  return (
    <>
      <Head>
        <title>{room?.name || 'Sala'} - Lobisomem Online</title>
        <meta name="description" content="Aguardando jogadores para come√ßar a partida" />
      </Head>

      <WaitingRoom
        // IDs e dados b√°sicos
        roomId={roomId as string}
        room={room}
        players={players}
        spectators={spectators}
        messages={messages}

        // Estados do usu√°rio
        currentUserId={currentUserId}
        isHost={isHost}
        isReady={isReady}
        canStartGame={canStartGame}
        isConnected={isConnected}

        // Modal states
        showLeaveModal={showLeaveModal}
        setShowLeaveModal={setShowLeaveModal}

        // Handlers
        onToggleReady={handleToggleReady}
        onStartGame={handleStartGame}
        onKickPlayer={handleKickPlayer}
        onSendChatMessage={handleSendChatMessage}
        onShareRoom={handleShareRoom}
        onLeaveRoom={handleLeaveRoom}
        onConfirmLeaveAsHost={handleConfirmLeaveAsHost}
      />
    </>
  );
}

export default withAuth(RoomPage);
</file>

<file path="backend/src/controllers/authController.ts">
import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import { pool } from '@/config/database';
import {
  generateTokenPair,
  generatePasswordResetToken,
  verifyPasswordResetToken,
} from '@/config/jwt';
import { authLogger } from '@/utils/logger';
import { ERROR_MESSAGES } from '@/utils/constants';
import {
  validateRegisterRequest,
  validateLoginRequest,
  validateEmail,
} from '@/utils/simpleValidators';
import type { ApiResponse } from '@/types';
import { config } from '@/config/environment';

/* -------------------------------------------------------------------------- */
/*                                   REGISTER                                 */
/* -------------------------------------------------------------------------- */
export const register = async (req: Request, res: Response): Promise<void> => {
  try {
    const validation = validateRegisterRequest(req.body);
    if (!validation.success) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: validation.error,
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { email, username, password } = validation.data!;

    const existingUserQuery = `
      SELECT id, email, username FROM users 
      WHERE email = $1 OR username = $2
    `;
    const existingUserResult = await pool.query(existingUserQuery, [
      email.toLowerCase(),
      username.toLowerCase(),
    ]);

    if (existingUserResult.rows.length > 0) {
      const existingUser = existingUserResult.rows[0];
      authLogger.warn('Registration attempt with existing credentials', {
        email,
        username,
        existingField:
          existingUser.email === email.toLowerCase() ? 'email' : 'username',
        ip: req.ip,
      });

      res.status(409).json({
        success: false,
        error: 'USER_ALREADY_EXISTS',
        message:
          existingUser.email === email.toLowerCase()
            ? 'Email j√° est√° em uso'
            : 'Username j√° est√° em uso',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const passwordHash = await bcrypt.hash(password, 12);

    const createUserQuery = `
      INSERT INTO users(email, username, "passwordHash", level, "totalGames",
        "totalWins", "totalLosses", "winRate", "createdAt", "updatedAt")
      VALUES($1, $2, $3, 1, 0, 0, 0, 0.0, NOW(), NOW())
      RETURNING id, email, username, level, "totalGames", "totalWins",
        "totalLosses", "winRate", "createdAt", "updatedAt", "lastLoginAt"
    `;
    const userResult = await pool.query(createUserQuery, [
      email.toLowerCase(),
      username,
      passwordHash,
    ]);
    const user = userResult.rows[0];

    const tokens = generateTokenPair({
      userId: user.id,
      username: user.username,
      email: user.email,
    });

    authLogger.info('User registered successfully', {
      userId: user.id,
      username: user.username,
      email: user.email,
      ip: req.ip,
    });

    res.status(201).json({
      success: true,
      data: {
        user,
        tokens: {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
        },
      },
      message: 'Usu√°rio criado com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Registration error',
      error instanceof Error ? error : new Error('Unknown registration error'),
      {
        email: req.body?.email,
        username: req.body?.username,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                                    LOGIN                                   */
/* -------------------------------------------------------------------------- */
export const login = async (req: Request, res: Response): Promise<void> => {
  try {
    const validation = validateLoginRequest(req.body);
    if (!validation.success) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: validation.error,
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { email, password } = validation.data!;
    let user; // ‚úÖ Vari√°vel declarada no escopo principal

    // ‚úÖ Bloco para determinar o usu√°rio (Magic Login ou Login Normal)
    if (config.IS_DEVELOPMENT && email.endsWith('@dev.test')) {
      // üîß MAGIC LOGIN - Apenas para desenvolvimento
      const username = email.split('@')[0];

      let userResult = await pool.query(
        `SELECT * FROM users WHERE email = $1`,
        [email.toLowerCase()]
      );

      if (userResult.rows.length === 0) {
        // Cria usu√°rio de teste automaticamente
        authLogger.info(`DEV_LOGIN: Creating user on-the-fly: ${username}`);
        const fakePasswordHash = await bcrypt.hash('password123', 12);

        const createUserQuery = `
          INSERT INTO users(email, username, "passwordHash", level, "totalGames",
            "totalWins", "totalLosses", "winRate", "createdAt", "updatedAt")
          VALUES($1, $2, $3, 1, 0, 0, 0, 0.0, NOW(), NOW())
          RETURNING id, email, username, level, "totalGames", "totalWins",
            "totalLosses", "winRate", "createdAt", "updatedAt", "lastLoginAt"
        `;

        const newUserResult = await pool.query(createUserQuery, [
          email.toLowerCase(),
          username,
          fakePasswordHash,
        ]);
        user = newUserResult.rows[0];
      } else {
        user = userResult.rows[0];
      }

      authLogger.warn(`DEV_LOGIN: Bypassing password check for ${email}`);
    } else {
      // üîê LOGIN NORMAL - Valida√ß√£o completa
      const userResult = await pool.query(
        `SELECT * FROM users WHERE email = $1`,
        [email.toLowerCase()]
      );

      if (userResult.rows.length === 0) {
        authLogger.warn('Login attempt with non-existent email', {
          email,
          ip: req.ip,
        });

        res.status(401).json({
          success: false,
          error: 'INVALID_CREDENTIALS',
          message: 'Email ou senha incorretos',
          timestamp: new Date().toISOString(),
        } as ApiResponse);
        return;
      }

      const foundUser = userResult.rows[0];
      const isPasswordValid = await bcrypt.compare(password, foundUser.passwordHash);

      if (!isPasswordValid) {
        authLogger.warn('Login attempt with invalid password', {
          userId: foundUser.id,
          email: foundUser.email,
          ip: req.ip,
        });

        res.status(401).json({
          success: false,
          error: 'INVALID_CREDENTIALS',
          message: 'Email ou senha incorretos',
          timestamp: new Date().toISOString(),
        } as ApiResponse);
        return;
      }

      user = foundUser; // ‚úÖ Atribui o usu√°rio validado
    }

    // ‚úÖ‚úÖ‚úÖ L√ìGICA DE SUCESSO UNIFICADA ‚úÖ‚úÖ‚úÖ
    // Este bloco executa para ambos os casos (Magic Login e Login Normal)

    // Atualiza o √∫ltimo login
    await pool.query(
      `UPDATE users SET "lastLoginAt" = NOW() WHERE id = $1`,
      [user.id]
    );

    // Gera os tokens
    const tokens = generateTokenPair({
      userId: user.id,
      username: user.username,
      email: user.email,
    });

    // Remove o hash da senha da resposta
    const { passwordHash, ...userWithoutPassword } = user;

    authLogger.info('User logged in successfully', {
      userId: user.id,
      username: user.username,
      email: user.email,
      ip: req.ip,
    });

    // Envia a resposta de sucesso
    res.json({
      success: true,
      data: {
        user: userWithoutPassword,
        tokens: {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
        },
      },
      message: config.IS_DEVELOPMENT && email.endsWith('@dev.test')
        ? 'Login de desenvolvedor realizado com sucesso'
        : 'Login realizado com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    authLogger.error(
      'Login error',
      error instanceof Error ? error : new Error('Unknown login error'),
      {
        email: req.body?.email,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                               FORGOT PASSWORD                              */
/* -------------------------------------------------------------------------- */
export const forgotPassword = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email } = req.body;

    if (!email || !validateEmail(email)) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Email inv√°lido',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, email FROM users WHERE email = $1`;
    const userResult = await pool.query(userQuery, [email.toLowerCase()]);

    if (userResult.rows.length === 0) {
      authLogger.warn('Password reset attempt for non-existent email', {
        email,
        ip: req.ip,
      });

      res.json({
        success: true,
        message: 'Se o email existir, um link de recupera√ß√£o ser√° enviado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];
    const resetToken = generatePasswordResetToken(user.id, user.email);

    authLogger.info('Password reset token generated', {
      userId: user.id,
      email: user.email,
      ip: req.ip,
    });

    /* Em produ√ß√£o, envie por email. Aqui apenas logamos. */
    console.log(`Password reset token for ${email}: ${resetToken}`);
    console.log(
      `Reset URL: http://localhost:3000/auth/reset-password?token=${resetToken}`,
    );

    res.json({
      success: true,
      data: {
        resetToken,
        resetUrl: `http://localhost:3000/auth/reset-password?token=${resetToken}`,
      },
      message: 'Link de recupera√ß√£o enviado para o email',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Forgot password error',
      error instanceof Error ? error : new Error('Unknown forgot password error'),
      {
        email: req.body?.email,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                               RESET PASSWORD                               */
/* -------------------------------------------------------------------------- */
export const resetPassword = async (req: Request, res: Response): Promise<void> => {
  try {
    const { token, password } = req.body;

    if (!token || typeof token !== 'string') {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Token √© obrigat√≥rio',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    if (!password || typeof password !== 'string' || password.length < 6) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Senha deve ter pelo menos 6 caracteres',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    let tokenPayload;
    try {
      tokenPayload = verifyPasswordResetToken(token);
    } catch (error) {
      authLogger.warn('Invalid password reset token used', {
        token: token.slice(0, 20) + '...',
        ip: req.ip,
      });

      res.status(400).json({
        success: false,
        error: 'INVALID_TOKEN',
        message: 'Token inv√°lido ou expirado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, email FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [tokenPayload.userId]);

    if (
      userResult.rows.length === 0 ||
      userResult.rows[0].email !== tokenPayload.email
    ) {
      authLogger.warn('Password reset token user mismatch', {
        tokenUserId: tokenPayload.userId,
        tokenEmail: tokenPayload.email,
        userExists: userResult.rows.length > 0,
        ip: req.ip,
      });

      res.status(400).json({
        success: false,
        error: 'INVALID_TOKEN',
        message: 'Token inv√°lido',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const passwordHash = await bcrypt.hash(password, 12);
    await pool.query(
      `UPDATE users SET "passwordHash" = $1, "updatedAt" = NOW() WHERE id = $2`,
      [passwordHash, tokenPayload.userId],
    );

    authLogger.info('Password reset successfully', {
      userId: tokenPayload.userId,
      email: tokenPayload.email,
      ip: req.ip,
    });

    res.json({
      success: true,
      message: 'Senha alterada com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Reset password error',
      error instanceof Error ? error : new Error('Unknown reset password error'),
      {
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                                  PROFILE                                   */
/* -------------------------------------------------------------------------- */
export const getProfile = async (req: Request, res: Response): Promise<void> => {
  try {
    const userQuery = `
      SELECT id, email, username, avatar, level, "totalGames", "totalWins",
             "totalLosses", "winRate", "createdAt", "updatedAt", "lastLoginAt"
      FROM users WHERE id = $1
    `;
    const userResult = await pool.query(userQuery, [req.userId]);

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: ERROR_MESSAGES.NOT_FOUND,
        message: 'Usu√°rio n√£o encontrado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    res.json({
      success: true,
      data: userResult.rows[0],
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Get profile error',
      error instanceof Error ? error : new Error('Unknown profile error'),
      {
        userId: req.userId,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                              CHECK USERNAME                                */
/* -------------------------------------------------------------------------- */
export const checkUsername = async (req: Request, res: Response): Promise<void> => {
  try {
    const { username } = req.params;

    if (!username || typeof username !== 'string') {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Username √© obrigat√≥rio',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id FROM users WHERE username = $1`;
    const userResult = await pool.query(userQuery, [username.toLowerCase()]);

    res.json({
      success: true,
      data: { available: userResult.rows.length === 0 },
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Check username error',
      error instanceof Error ? error : new Error('Unknown check username error'),
      {
        username: req.params?.username,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                                CHECK EMAIL                                 */
/* -------------------------------------------------------------------------- */
export const checkEmail = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email } = req.params;

    if (!email || typeof email !== 'string' || !validateEmail(email)) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Email v√°lido √© obrigat√≥rio',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id FROM users WHERE email = $1`;
    const userResult = await pool.query(userQuery, [email.toLowerCase()]);

    res.json({
      success: true,
      data: { available: userResult.rows.length === 0 },
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Check email error',
      error instanceof Error ? error : new Error('Unknown check email error'),
      {
        email: req.params?.email,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};
</file>

<file path="backend/src/server.ts">
// üê∫ LOBISOMEM ONLINE - Server Entry Point (SIMPLIFICADO)
import httpServer from './app'; // ‚úÖ Importar o httpServer j√° configurado
import { config, validateConfig } from '@/config/environment';
import { connectDatabase, gracefulShutdown as shutdownDatabase } from '@/config/database';
import { connectRedis, gracefulShutdown as shutdownRedis } from '@/config/redis';
import { ServiceFactory } from './websocket/ServiceFactory';
import { logger } from '@/utils/logger';

// ‚úÖ A inst√¢ncia de wsManager agora vive dentro de app.ts

// Fun√ß√£o de retry para conex√£o com o banco
const connectWithRetry = async (connectFn: () => Promise<void>, retries = 5, delay = 5000) => {
  for (let i = 1; i <= retries; i++) {
    try {
      await connectFn();
      logger.info('Database connected successfully.');
      return;
    } catch (error) {
      logger.error(`Database connection attempt ${i} failed. Retrying in ${delay / 1000}s...`, { error });
      if (i === retries) {
        throw new Error(`Could not connect to the database after ${retries} attempts.`);
      }
      await new Promise(res => setTimeout(res, delay));
    }
  }
};

async function startServer(): Promise<void> {
  try {
    validateConfig();

    // Conectar banco (obrigat√≥rio) com retry
    await connectWithRetry(connectDatabase);

    // Conectar Redis (opcional - n√£o falha se der erro)
    if (config.SHOULD_USE_REDIS) {
      try {
        await connectRedis();
      } catch (error) {
        logger.warn('Redis connection failed, continuing without Redis', { error: error instanceof Error ? error.message : 'Unknown error' });
      }
    }

    // ‚úÖ A cria√ß√£o do servidor e do WebSocketManager j√° aconteceu em app.ts
    // Agora s√≥ precisamos iniciar o servidor HTTP
    httpServer.listen(config.PORT, () => {
      logger.info(`üöÄ Server running at http://localhost:${config.PORT}`);
      logger.info(`üê∫ Werewolf Online ${config.SERVICE_TYPE} service started`);
      logger.info(`üîó WebSocket available at ws://localhost:${config.PORT}${config.WS_BASE_PATH}`);
    });

    setupGracefulShutdown(httpServer);

  } catch (error) {
    logger.error('Failed to start server', error instanceof Error ? error : new Error('Unknown server start error'));
    process.exit(1);
  }
}

function setupGracefulShutdown(server: any): void {
  const shutdown = async (signal: string) => {
    logger.info(`Received ${signal}. Starting graceful shutdown...`);

    server.close(async () => {
      logger.info('HTTP server closed.');

      // ‚úÖ Shutdown do WebSocketManager (se existir)
      if (server.wsManager) {
        try {
          await server.wsManager.shutdown();
          logger.info('WebSocket manager shut down.');
        } catch (error) {
          logger.warn('Error shutting down WebSocket manager', { error: error instanceof Error ? error.message : 'Unknown error' });
        }
      }

      // Shutdown do banco
      await shutdownDatabase();

      // Shutdown do Redis (se configurado)
      if (config.SHOULD_USE_REDIS) {
        try {
          await shutdownRedis();
        } catch (error) {
          logger.warn('Error shutting down Redis', { error: error instanceof Error ? error.message : 'Unknown error' });
        }
      }

      // Limpar inst√¢ncias do ServiceFactory
      ServiceFactory.clearInstances();

      logger.info('Graceful shutdown completed.');
      process.exit(0);
    });
  };

  process.on('SIGTERM', () => shutdown('SIGTERM'));
  process.on('SIGINT', () => shutdown('SIGINT'));
}

// ‚úÖ Iniciar servidor se for executado diretamente
if (require.main === module) {
  startServer();
}

export default httpServer;
</file>

<file path="backend/src/websocket/ChannelManager.ts">
import { wsLogger } from '@/utils/logger';
import type { ConnectionManager } from './ConnectionManager';

interface RoomChannel {
  players: Set<string>;
  spectators: Set<string>;
  readyPlayers: Set<string>;
  createdAt: Date;
  lastActivity: Date;
}

export class ChannelManager {
  private rooms = new Map<string, RoomChannel>();
  private connectionRooms = new Map<string, string>();

  constructor(private connectionManager: ConnectionManager) { }

  createRoom(roomId: string): boolean {
    if (this.rooms.has(roomId)) {
      wsLogger.warn('Attempted to create existing room channel', { roomId });
      return false;
    }

    this.rooms.set(roomId, {
      players: new Set(),
      spectators: new Set(),
      createdAt: new Date(),
      lastActivity: new Date(),
    });

    wsLogger.info('Room channel created', { roomId });
    return true;
  }

  joinRoom(roomId: string, connectionId: string, asSpectator = false): boolean {
    let room = this.rooms.get(roomId);

    if (!room) {
      this.createRoom(roomId);
      room = this.rooms.get(roomId)!;
    }

    const currentRoom = this.connectionRooms.get(connectionId);
    if (currentRoom) {
      this.leaveRoom(currentRoom, connectionId);
    }

    if (asSpectator) {
      room.spectators.add(connectionId);
    } else {
      room.players.add(connectionId);
    }

    this.connectionRooms.set(connectionId, roomId);
    room.lastActivity = new Date();

    wsLogger.debug('Connection joined room', {
      connectionId,
      roomId,
      asSpectator,
      totalPlayers: room.players.size,
      totalSpectators: room.spectators.size,
    });

    return true;
  }

  leaveRoom(roomId: string, connectionId: string): boolean {
    const room = this.rooms.get(roomId);
    if (!room) {
      wsLogger.warn('Attempted to leave non-existent room', { roomId, connectionId });
      return false;
    }

    const wasPlayer = room.players.delete(connectionId);
    const wasSpectator = room.spectators.delete(connectionId);

    if (!wasPlayer && !wasSpectator) {
      wsLogger.warn('Connection was not in room', { roomId, connectionId });
      return false;
    }

    this.connectionRooms.delete(connectionId);
    room.lastActivity = new Date();

    if (room.players.size === 0 && room.spectators.size === 0) {
      this.rooms.delete(roomId);
      wsLogger.info('Room channel removed (empty)', { roomId });
    }

    wsLogger.debug('Connection left room', {
      connectionId,
      roomId,
      wasPlayer,
      wasSpectator,
      remainingPlayers: room.players.size,
      remainingSpectators: room.spectators.size,
    });

    return true;
  }

  removeConnectionFromAllRooms(connectionId: string): void {
    const roomId = this.connectionRooms.get(connectionId);
    if (roomId) {
      this.leaveRoom(roomId, connectionId);
    }
  }

  getRoomConnections(roomId: string): Set<string> {
    const room = this.rooms.get(roomId);
    if (!room) return new Set();
    return new Set([...room.players, ...room.spectators]);
  }

  getRoomPlayerConnections(roomId: string): Set<string> {
    const room = this.rooms.get(roomId);
    return room ? new Set(room.players) : new Set();
  }

  getRoomSpectatorConnections(roomId: string): Set<string> {
    const room = this.rooms.get(roomId);
    return room ? new Set(room.spectators) : new Set();
  }

  getConnectionRoom(connectionId: string): string | undefined {
    return this.connectionRooms.get(connectionId);
  }

  getRoomCount(roomId: string): { players: number; spectators: number } {
    const room = this.rooms.get(roomId);
    if (!room) return { players: 0, spectators: 0 };

    return {
      players: room.players.size,
      spectators: room.spectators.size,
    };
  }

  // üîß NOVA VERS√ÉO: limpa conex√µes mortas automaticamente
  getRoomStats(roomId: string): { playersCount: number; spectatorsCount: number } | null {
    const room = this.rooms.get(roomId);
    if (!room) return null;

    console.log(`\nüîç DEBUG LOBBY - Sala: ${roomId.slice(-6)}`);
    console.log(`üìä Players no Set: ${room.players.size}`);

    const deadPlayers = new Set<string>();
    const deadSpectators = new Set<string>();

    // Verificar players
    for (const connectionId of room.players) {
      const connection = this.connectionManager.getConnection(connectionId);
      const isValid = connection && connection.ws.readyState === connection.ws.OPEN;

      console.log(`   üë§ ${connectionId.slice(-6)}: ${isValid ? '‚úÖ VIVO' : 'üíÄ MORTO'}`);

      if (!isValid) {
        deadPlayers.add(connectionId);
        this.connectionRooms.delete(connectionId);
      }
    }

    // Verificar spectators
    for (const connectionId of room.spectators) {
      const connection = this.connectionManager.getConnection(connectionId);
      const isValid = connection && connection.ws.readyState === connection.ws.OPEN;

      if (!isValid) {
        deadSpectators.add(connectionId);
        this.connectionRooms.delete(connectionId);
      }
    }

    // Limpeza efetiva
    if (deadPlayers.size > 0) {
      console.log(`üßπ Limpando ${deadPlayers.size} players mortos`);
      for (const deadId of deadPlayers) {
        room.players.delete(deadId);
      }
    }

    if (deadSpectators.size > 0) {
      console.log(`üßπ Limpando ${deadSpectators.size} spectators mortos`);
      for (const deadId of deadSpectators) {
        room.spectators.delete(deadId);
      }
    }

    const finalCount = {
      playersCount: room.players.size,
      spectatorsCount: room.spectators.size,
    };

    console.log(
      `üìä AP√ìS LIMPEZA: ${finalCount.playersCount} players, ${finalCount.spectatorsCount} spectators`,
    );

    room.lastActivity = new Date();

    if (finalCount.playersCount === 0 && finalCount.spectatorsCount === 0) {
      console.log(`üóëÔ∏è Sala ${roomId.slice(-6)} ficou vazia, removendo`);
      this.rooms.delete(roomId);
    }

    return finalCount;
  }

  broadcastToRoom(
    roomId: string,
    type: string,
    data?: any,
    excludeConnectionId?: string,
  ): number {
    const connections = this.getRoomConnections(roomId);
    let sent = 0;

    for (const connectionId of connections) {
      if (connectionId === excludeConnectionId) continue;

      const connection = this.connectionManager.getConnection(connectionId);
      if (!connection || connection.ws.readyState !== connection.ws.OPEN) continue;

      try {
        connection.ws.send(
          JSON.stringify({
            type,
            data,
            timestamp: new Date().toISOString(),
          }),
        );
        sent++;
      } catch (error) {
        wsLogger.error(
          'Failed to broadcast to connection',
          error instanceof Error ? error : new Error('Unknown broadcast error'),
          {
            connectionId,
            roomId,
            type,
          },
        );
      }
    }

    wsLogger.debug('Broadcast to room completed', {
      roomId,
      type,
      totalConnections: connections.size,
      sentCount: sent,
      excluded: !!excludeConnectionId,
    });

    return sent;
  }

  isPlayerInRoom(roomId: string, connectionId: string): boolean {
    const room = this.rooms.get(roomId);
    return room ? room.players.has(connectionId) : false;
  }

  isSpectatorInRoom(roomId: string, connectionId: string): boolean {
    const room = this.rooms.get(roomId);
    return room ? room.spectators.has(connectionId) : false;
  }

  // ‚úÖ Define ou remove o status de "pronto" de um jogador
  setPlayerReadyStatus(roomId: string, connectionId: string, isReady: boolean): void {
    const room = this.rooms.get(roomId);
    if (!room) return;

    if (!room.readyPlayers) room.readyPlayers = new Set();

    if (isReady) {
      room.readyPlayers.add(connectionId);
    } else {
      room.readyPlayers.delete(connectionId);
    }

    wsLogger.debug('Player ready status updated', {
      roomId,
      connectionId,
      isReady,
      totalReady: room.readyPlayers.size,
    });

    room.lastActivity = new Date();
  }


  // ‚úÖ Verifica se um jogador est√° marcado como "pronto"
  isPlayerReady(roomId: string, connectionId: string): boolean {
    const room = this.rooms.get(roomId);
    return room ? room.readyPlayers?.has(connectionId) ?? false : false;
  }

  getActiveRoomsCount(): number {
    return this.rooms.size;
  }

  getActiveRooms(): string[] {
    return Array.from(this.rooms.keys());
  }

  getRoomInfo(roomId: string): {
    exists: boolean;
    playersCount: number;
    spectatorsCount: number;
    createdAt?: Date;
    lastActivity?: Date;
  } {
    const room = this.rooms.get(roomId);
    if (!room) {
      return { exists: false, playersCount: 0, spectatorsCount: 0 };
    }

    return {
      exists: true,
      playersCount: room.players.size,
      spectatorsCount: room.spectators.size,
      createdAt: room.createdAt,
      lastActivity: room.lastActivity,
    };
  }

  cleanup(maxIdleTime = 3_600_000): number {
    const now = Date.now();
    let cleaned = 0;

    for (const [roomId, room] of this.rooms.entries()) {
      const idleTime = now - room.lastActivity.getTime();

      if (room.players.size === 0 && room.spectators.size === 0 && idleTime > maxIdleTime) {
        this.rooms.delete(roomId);
        cleaned++;

        wsLogger.info('Cleaned up idle room channel', {
          roomId,
          idleTime: Math.floor(idleTime / 1000),
          maxIdleTime: Math.floor(maxIdleTime / 1000),
        });
      }
    }

    return cleaned;
  }

  clear(): void {
    this.rooms.clear();
    this.connectionRooms.clear();
    wsLogger.info('All room channels cleared');
  }

  getStats(): {
    totalRooms: number;
    totalConnections: number;
    totalPlayers: number;
    totalSpectators: number;
    roomsInfo: Array<{
      roomId: string;
      players: number;
      spectators: number;
      idleTime: number;
    }>;
  } {
    let totalPlayers = 0;
    let totalSpectators = 0;
    const roomsInfo: Array<{
      roomId: string;
      players: number;
      spectators: number;
      idleTime: number;
    }> = [];

    const now = Date.now();

    for (const [roomId, room] of this.rooms.entries()) {
      totalPlayers += room.players.size;
      totalSpectators += room.spectators.size;

      roomsInfo.push({
        roomId,
        players: room.players.size,
        spectators: room.spectators.size,
        idleTime: Math.floor((now - room.lastActivity.getTime()) / 1000),
      });
    }

    return {
      totalRooms: this.rooms.size,
      totalConnections: this.connectionRooms.size,
      totalPlayers,
      totalSpectators,
      roomsInfo,
    };
  }
}
</file>

<file path="package.json">
{
  "name": "werewolf-online",
  "version": "1.0.0",
  "description": "üê∫ Lobisomem Online - Plataforma de Jogos Multiplayer em Tempo Real",
  "private": true,
  "workspaces": [
    "backend",
    "frontend"
  ],
  "scripts": {
    "//": "--- DOCKER COMMANDS (for complete environment) ---",
    "dev:docker": "docker-compose -f docker-compose.dev.yml up --build",
    "dev:down": "docker-compose -f docker-compose.dev.yml down",
    "dev:clean": "docker-compose -f docker-compose.dev.yml down --volumes --remove-orphans",
    "dev:logs": "docker-compose -f docker-compose.dev.yml logs -f",
    "dev:logs:backend": "docker-compose -f docker-compose.dev.yml logs -f backend",
    "// ": "--- LOCAL DEVELOPMENT (run services individually without Docker) ---",
    "dev:backend": "npm run dev --workspace=backend",
    "dev:frontend": "npm run dev --workspace=frontend",
    "// ": "--- MONOREPO UTILITIES ---",
    "install:all": "npm install",
    "build:all": "npm run build --workspaces",
    "lint:all": "npm run lint --workspaces --if-present",
    "test:all": "npm run test --workspaces --if-present"
  },
  "keywords": [
    "werewolf",
    "game",
    "multiplayer",
    "websocket",
    "realtime",
    "typescript",
    "monorepo"
  ],
  "author": "Werewolf Team",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.9.0"
  }
}
</file>

<file path="backend/src/controllers/roomController.ts">
import { Request, Response } from 'express';
import { pool } from '@/config/database';
import { generateRoomCode } from '@/utils/helper';
import { logger } from '@/utils/logger';
import { ERROR_MESSAGES, GAME_LIMITS } from '@/utils/constants';
import { validateCreateRoomRequest, validateRoomCode } from '@/utils/simpleValidators';
import type { ApiResponse } from '@/types';
import type { Room, RoomStatus } from '@/types';

export const listRooms = async (req: Request, res: Response): Promise<void> => {
  try {
    logger.info('Listing public rooms', { userId: req.userId });

    const roomsQuery = `
            SELECT 
                r.id, r.name, r."isPrivate", r."maxPlayers", r."maxSpectators", 
                r.status, r."createdAt", u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r."isPrivate" = false AND r.status IN ('WAITING', 'PLAYING')
            ORDER BY r."createdAt" DESC
            LIMIT 50
        `;
    const roomsResult = await pool.query(roomsQuery);

    const channelManager = req.app.locals.channelManager;

    const roomsMetadata = roomsResult.rows.map((room: any) => {
      const stats = channelManager ? channelManager.getRoomStats(room.id) : null;

      return {
        id: room.id,
        name: room.name,
        isPrivate: room.isPrivate,
        currentPlayers: stats?.playersCount || 0,
        maxPlayers: room.maxPlayers,
        currentSpectators: stats?.spectatorsCount || 0,
        maxSpectators: room.maxSpectators,
        status: room.status as RoomStatus,
        hostUsername: room.hostUsername,
        createdAt: room.createdAt,
        canJoin: room.status === 'WAITING' && (stats?.playersCount || 0) < room.maxPlayers,
        isFull: (stats?.playersCount || 0) >= room.maxPlayers
      };
    });

    res.json({
      success: true,
      data: {
        rooms: roomsMetadata,
        total: roomsMetadata.length
      },
      message: 'Salas p√∫blicas listadas com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to list rooms', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const createRoom = async (req: Request, res: Response): Promise<void> => {
  try {
    const validation = validateCreateRoomRequest(req.body);
    if (!validation.success) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: validation.error,
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { name, isPrivate, maxPlayers, maxSpectators } = validation.data!;

    const existingRoomQuery = `
            SELECT id, name, status FROM rooms 
            WHERE "hostId" = $1 AND status IN ('WAITING', 'PLAYING')
        `;
    const existingRoomResult = await pool.query(existingRoomQuery, [req.userId]);

    if (existingRoomResult.rows.length > 0) {
      logger.warn('User creating room while having active room', {
        userId: req.userId,
        username: req.username,
        existingRooms: existingRoomResult.rows,
        action: 'creating_new_room_anyway'
      });

      try {
        await pool.query(`DELETE FROM rooms WHERE "hostId" = $1 AND status IN ('WAITING', 'PLAYING')`, [req.userId]);
        logger.info('Cleaned up orphaned rooms for user', {
          userId: req.userId,
          cleanedRooms: existingRoomResult.rows.length
        });
      } catch (cleanupError) {
        logger.error('Failed to cleanup orphaned rooms', cleanupError instanceof Error ? cleanupError : new Error('Unknown cleanup error'), {
          userId: req.userId
        });
      }
    }

    let roomCode: string | undefined;
    if (isPrivate) {
      let attempts = 0;
      do {
        roomCode = generateRoomCode();
        const existingCodeQuery = `SELECT id FROM rooms WHERE code = $1`;
        const existingCodeResult = await pool.query(existingCodeQuery, [roomCode]);
        if (existingCodeResult.rows.length === 0) break;
        attempts++;
      } while (attempts < 10);

      if (attempts >= 10) {
        res.status(500).json({
          success: false,
          error: ERROR_MESSAGES.SERVER_ERROR,
          message: 'N√£o foi poss√≠vel gerar c√≥digo √∫nico',
          timestamp: new Date().toISOString(),
        } as ApiResponse);
        return;
      }
    }

    const createRoomQuery = `
            INSERT INTO rooms (name, code, "isPrivate", "maxPlayers", "maxSpectators", "hostId", status, "serverId", "createdAt", "updatedAt")
            VALUES ($1, $2, $3, $4, $5, $6, 'WAITING', 'local-server', NOW(), NOW())
            RETURNING *
        `;
    const roomResult = await pool.query(createRoomQuery, [
      name,
      roomCode,
      isPrivate || false,
      maxPlayers || GAME_LIMITS.MAX_PLAYERS,
      maxSpectators || GAME_LIMITS.MAX_SPECTATORS,
      req.userId
    ]);
    const room = roomResult.rows[0];

    logger.info('Room created successfully', {
      roomId: room.id,
      hostId: req.userId,
      code: roomCode,
      isPrivate,
      hadOrphanedRooms: existingRoomResult.rows.length > 0
    });

    const wsUrl = `ws://localhost:3001/ws/room/${room.id}`;

    res.status(201).json({
      success: true,
      data: {
        room: {
          id: room.id,
          name: room.name,
          code: room.code,
          isPrivate: room.isPrivate,
          maxPlayers: room.maxPlayers,
          maxSpectators: room.maxSpectators,
          status: room.status,
          hostId: room.hostId,
          hostUsername: req.username,
          currentPlayers: 0,
          currentSpectators: 0,
          serverId: room.serverId,
          createdAt: room.createdAt,
          updatedAt: room.updatedAt
        },
        wsUrl,
        joinUrl: wsUrl,
        code: room.code
      },
      message: 'Sala criada com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to create room', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      username: req.username,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const joinRoom = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id: roomId } = req.params;
    const { asSpectator = false } = req.body;

    const roomQuery = `
            SELECT r.*, u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r.id = $1
        `;
    const roomResult = await pool.query(roomQuery, [roomId]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    if (room.status !== 'WAITING') {
      res.status(409).json({
        success: false,
        error: 'ROOM_NOT_JOINABLE',
        message: 'A sala n√£o est√° aceitando novos jogadores',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, username, avatar FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [req.userId]);

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'USER_NOT_FOUND',
        message: 'Usu√°rio n√£o encontrado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];

    const player = {
      id: `${roomId}-${user.id}`,
      userId: user.id,
      username: user.username,
      avatar: user.avatar,
      isHost: room.hostId === user.id,
      isReady: false,
      isSpectator: asSpectator,
      isConnected: false,
      joinedAt: new Date(),
      lastSeen: new Date()
    };

    const wsUrl = `ws://localhost:3001/ws/room/${roomId}`;

    res.json({
      success: true,
      data: {
        room: {
          id: room.id,
          name: room.name,
          code: room.code,
          isPrivate: room.isPrivate,
          maxPlayers: room.maxPlayers,
          maxSpectators: room.maxSpectators,
          status: room.status,
          hostId: room.hostId,
          hostUsername: room.hostUsername,
          currentPlayers: 0,
          currentSpectators: 0,
          serverId: room.serverId,
          createdAt: room.createdAt,
          updatedAt: room.updatedAt
        },
        player,
        wsUrl,
        joinUrl: wsUrl,
        yourRole: player.isHost ? 'HOST' : (player.isSpectator ? 'SPECTATOR' : 'PLAYER')
      },
      message: 'Entrou na sala com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to join room', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      username: req.username,
      roomId: req.params.id,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const joinRoomByCode = async (req: Request, res: Response): Promise<void> => {
  try {
    const { code } = req.body;

    if (!code || !validateRoomCode(code)) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'C√≥digo inv√°lido - deve ter 6 d√≠gitos',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { asSpectator = false } = req.body;

    const roomQuery = `
            SELECT r.*, u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r.code = $1
        `;
    const roomResult = await pool.query(roomQuery, [code]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada com este c√≥digo',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    if (room.status !== 'WAITING') {
      res.status(409).json({
        success: false,
        error: 'ROOM_NOT_JOINABLE',
        message: 'A sala n√£o est√° aceitando novos jogadores',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, username, avatar FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [req.userId]);

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'USER_NOT_FOUND',
        message: 'Usu√°rio n√£o encontrado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];

    const player = {
      id: `${room.id}-${user.id}`,
      userId: user.id,
      username: user.username,
      avatar: user.avatar,
      isHost: room.hostId === user.id,
      isReady: false,
      isSpectator: asSpectator,
      isConnected: false,
      joinedAt: new Date(),
      lastSeen: new Date()
    };

    const wsUrl = `ws://localhost:3001/ws/room/${room.id}`;

    res.json({
      success: true,
      data: {
        room: {
          id: room.id,
          name: room.name,
          code: room.code,
          isPrivate: room.isPrivate,
          maxPlayers: room.maxPlayers,
          maxSpectators: room.maxSpectators,
          status: room.status,
          hostId: room.hostId,
          hostUsername: room.hostUsername,
          currentPlayers: 0,
          currentSpectators: 0,
          serverId: room.serverId,
          createdAt: room.createdAt,
          updatedAt: room.updatedAt
        },
        player,
        wsUrl,
        joinUrl: wsUrl,
        yourRole: player.isHost ? 'HOST' : (player.isSpectator ? 'SPECTATOR' : 'PLAYER')
      },
      message: 'Entrou na sala com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to join room by code', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      username: req.username,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const getRoomDetails = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id: roomId } = req.params;

    const roomQuery = `
            SELECT r.*, u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r.id = $1
        `;
    const roomResult = await pool.query(roomQuery, [roomId]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    res.json({
      success: true,
      data: {
        id: room.id,
        name: room.name,
        code: room.code,
        isPrivate: room.isPrivate,
        maxPlayers: room.maxPlayers,
        maxSpectators: room.maxSpectators,
        status: room.status,
        hostId: room.hostId,
        hostUsername: room.hostUsername,
        currentPlayers: 0,
        currentSpectators: 0,
        serverId: room.serverId,
        createdAt: room.createdAt,
        updatedAt: room.updatedAt
      },
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to get room details', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      roomId: req.params.id
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const deleteRoom = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id: roomId } = req.params;

    const roomQuery = `SELECT id, "hostId" FROM rooms WHERE id = $1`;
    const roomResult = await pool.query(roomQuery, [roomId]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    if (room.hostId !== req.userId) {
      res.status(403).json({
        success: false,
        error: ERROR_MESSAGES.FORBIDDEN,
        message: 'Apenas o host pode deletar a sala',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    await pool.query(`DELETE FROM rooms WHERE id = $1`, [roomId]);

    logger.info('Room deleted via HTTP API', {
      roomId,
      hostId: req.userId,
      username: req.username
    });

    res.json({
      success: true,
      message: 'Sala deletada com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to delete room', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      roomId: req.params.id
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};
</file>

<file path="backend/src/websocket/MessageRouter.ts">
// üê∫ LOBISOMEM ONLINE - Message Router (FASE 1 - CORRE√á√ÉO CR√çTICA)
import { wsLogger } from '@/utils/logger';
import { validateWebSocketMessage } from '@/config/websocket';
import { pool } from '@/config/database';
import type { ConnectionManager } from './ConnectionManager';
import type { ChannelManager } from './ChannelManager';
import type { GameEngine } from '@/game/GameEngine';
import type { IEventBus, WebSocketErrorCode } from '@/types';
import { Player } from '@/game/Game';

//====================================================================
// MESSAGE HANDLER TYPE
//====================================================================
type MessageHandler = (connectionId: string, data: any) => Promise<void>;

//====================================================================
// MESSAGE ROUTER CLASS - FASE 1
//====================================================================
export class MessageRouter {
  private handlers = new Map<string, MessageHandler>();
  private broadcastToRoom?: (roomId: string, type: string, data?: any, excludeConnectionId?: string) => number;
  private sendToUser?: (userId: string, type: string, data?: any) => boolean;

  constructor(
    private connectionManager: ConnectionManager,
    private channelManager: ChannelManager,
    private gameEngine: GameEngine,
    private eventBus: IEventBus
  ) {
    this.setupHandlers();
  }

  //====================================================================
  // SETUP MESSAGE HANDLERS
  //====================================================================
  private setupHandlers(): void {
    // Connection management
    this.handlers.set('ping', this.handlePing.bind(this));
    this.handlers.set('pong', this.handlePong.bind(this));
    this.handlers.set('heartbeat', this.handleHeartbeat.bind(this));

    // Room management (Required events)
    this.handlers.set('join-room', this.handleJoinRoom.bind(this));
    this.handlers.set('leave-room', this.handleLeaveRoom.bind(this));
    this.handlers.set('player-ready', this.handlePlayerReady.bind(this));
    this.handlers.set('start-game', this.handleStartGame.bind(this));

    // Room admin
    this.handlers.set('delete-room', this.handleDeleteRoom.bind(this));
    this.handlers.set('kick-player', this.handleKickPlayer.bind(this));
    this.handlers.set('chat-message', this.handleChatMessage.bind(this));
    this.handlers.set('spectate-room', this.handleSpectateRoom.bind(this));
    this.handlers.set('stop-spectating', this.handleStopSpectating.bind(this));

    // Game handlers
    this.handlers.set('get-game-state', this.handleGetGameState.bind(this));
    this.handlers.set('game-action', this.handleGameAction.bind(this));
    this.handlers.set('vote', this.handleVote.bind(this));
    this.handlers.set('unvote', this.handleUnvote.bind(this));

    wsLogger.debug('Message handlers setup completed', {
      handlerCount: this.handlers.size,
      handlers: Array.from(this.handlers.keys()),
    });
  }

  //====================================================================
  // SET BROADCAST METHODS (Called by WebSocketManager)
  //====================================================================
  setBroadcastMethods(
    broadcastToRoom: (roomId: string, type: string, data?: any, excludeConnectionId?: string) => number,
    sendToUser: (userId: string, type: string, data?: any) => boolean
  ): void {
    this.broadcastToRoom = broadcastToRoom;
    this.sendToUser = sendToUser;
  }

  //====================================================================
  // MAIN MESSAGE HANDLER
  //====================================================================
  async handleMessage(connectionId: string, message: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) {
      wsLogger.warn('Message received for non-existent connection', { connectionId });
      return;
    }

    try {
      // Validate message format
      const validation = validateWebSocketMessage(message);
      if (!validation.isValid) {
        await this.sendError(connectionId, 'INVALID_MESSAGE', validation.error || 'Invalid message format');
        return;
      }

      const validMessage = validation.message!;

      wsLogger.debug('Message received', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        type: validMessage.type,
        roomId: connection.context.roomId,
      });

      // Get and execute handler
      const handler = this.handlers.get(validMessage.type);
      if (!handler) {
        await this.sendError(connectionId, 'UNKNOWN_MESSAGE_TYPE', `Unknown message type: ${validMessage.type}`);
        return;
      }

      await handler(connectionId, validMessage.data || {});

    } catch (error) {
      wsLogger.error('Error handling message', error instanceof Error ? error : new Error('Unknown message error'), {
        connectionId,
        userId: connection.context.userId,
        messageType: message?.type,
      });

      await this.sendError(connectionId, 'HANDLER_ERROR', 'Internal error processing message');
    }
  }

  //====================================================================
  // CONNECTION HANDLERS
  //====================================================================
  private async handlePing(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    try {
      connection.ws.send(JSON.stringify({
        type: 'pong',
        data: { timestamp: Date.now() },
        timestamp: new Date().toISOString(),
      }));
    } catch (error) {
      wsLogger.error('Failed to send pong', error instanceof Error ? error : new Error('Unknown pong error'), { connectionId });
    }
  }

  private async handlePong(connectionId: string, data: any): Promise<void> {
    this.connectionManager.markAlive(connectionId);
  }

  private async handleHeartbeat(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    this.connectionManager.markAlive(connectionId);

    try {
      connection.ws.send(JSON.stringify({
        type: 'heartbeat',
        data: { timestamp: Date.now() },
        timestamp: new Date().toISOString(),
      }));
    } catch (error) {
      wsLogger.error('Failed to send heartbeat response', error instanceof Error ? error : new Error('Unknown heartbeat error'), { connectionId });
    }
  }

  //====================================================================
  // ROOM HANDLERS
  //====================================================================
  private async handleJoinRoom(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const { roomId, asSpectator = false } = data;

    if (!roomId || typeof roomId !== 'string') {
      await this.sendError(connectionId, 'MISSING_ROOM_ID', 'Room ID is required and must be a string');
      return;
    }

    try {
      // Buscar dados reais da sala no banco de dados
      const roomQuery = `
        SELECT r.*, u.username as "hostUsername"
        FROM rooms r
        JOIN users u ON r."hostId" = u.id
        WHERE r.id = $1
      `;
      const roomResult = await pool.query(roomQuery, [roomId]);

      if (roomResult.rows.length === 0) {
        await this.sendError(connectionId, 'ROOM_NOT_FOUND', 'Room not found');
        return;
      }

      const roomData = roomResult.rows[0];

      // Verificar se a sala est√° dispon√≠vel
      if (roomData.status !== 'WAITING') {
        await this.sendError(connectionId, 'ROOM_NOT_JOINABLE', 'Room is not accepting new players');
        return;
      }

      // Join the room channel
      const success = this.channelManager.joinRoom(roomId, connectionId, asSpectator);
      if (!success) {
        await this.sendError(connectionId, 'JOIN_ROOM_FAILED', 'Failed to join room');
        return;
      }

      // Update connection context
      this.connectionManager.updateConnectionContext(connectionId, {
        roomId,
        isSpectator: asSpectator,
      });

      // Get room connections for player list
      const roomConnections = this.channelManager.getRoomPlayerConnections(roomId);
      const spectatorConnections = this.channelManager.getRoomSpectatorConnections(roomId);

      const players: any[] = [];
      const spectators: any[] = [];

      // Build player list com dados reais
      for (const connId of roomConnections) {
        const conn = this.connectionManager.getConnection(connId);
        if (conn) {
          players.push({
            id: `${roomId}-${conn.context.userId}`,
            userId: conn.context.userId,
            username: conn.context.username,
            avatar: null,
            isHost: roomData.hostId === conn.context.userId,
            isReady: this.channelManager.isPlayerReady(roomId, connId),
            isSpectator: false,
            isConnected: true,
            joinedAt: new Date().toISOString(),
          });
        }
      }

      // Build spectator list
      for (const connId of spectatorConnections) {
        const conn = this.connectionManager.getConnection(connId);
        if (conn) {
          spectators.push({
            id: `${roomId}-${conn.context.userId}`,
            userId: conn.context.userId,
            username: conn.context.username,
            avatar: null,
            isSpectator: true,
            isConnected: true,
            joinedAt: new Date().toISOString(),
          });
        }
      }

      // ‚úÖ CORRE√á√ÉO CR√çTICA: Criar objeto para o jogador que est√° entrando
      const playerForSelf = {
        id: `${roomId}-${connection.context.userId}`,
        userId: connection.context.userId,
        username: connection.context.username,
        avatar: null,
        isHost: roomData.hostId === connection.context.userId,
        isReady: this.channelManager.isPlayerReady(roomId, connectionId),
        isSpectator: asSpectator,
        isConnected: true,
        joinedAt: new Date().toISOString(),
      };

      // Send room-joined event com dados reais do banco
      await this.sendToConnection(connectionId, 'room-joined', {
        room: {
          id: roomData.id,
          name: roomData.name,
          code: roomData.code,
          isPrivate: roomData.isPrivate,
          maxPlayers: roomData.maxPlayers,
          maxSpectators: roomData.maxSpectators,
          status: roomData.status,
          hostId: roomData.hostId,
          hostUsername: roomData.hostUsername,
          currentPlayers: players.length,
          currentSpectators: spectators.length,
          serverId: roomData.serverId,
          createdAt: roomData.createdAt,
          updatedAt: roomData.updatedAt,
        },
        players,
        spectators,
        player: playerForSelf,
        yourRole: asSpectator ? 'SPECTATOR' : (playerForSelf.isHost ? 'HOST' : 'PLAYER'),
      });

      // Broadcast player-joined to other room members
      if (this.broadcastToRoom) {
        this.broadcastToRoom(roomId, 'player-joined', { player: playerForSelf }, connectionId);
      }

      // Publish event to event bus
      await this.eventBus.publish('room:player-joined', {
        roomId,
        userId: connection.context.userId,
        username: connection.context.username,
        asSpectator,
        timestamp: new Date().toISOString(),
      });

      wsLogger.info('Player joined room with real data', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId,
        roomName: roomData.name,
        hostId: roomData.hostId,
        isHost: playerForSelf.isHost,
        asSpectator,
      });

    } catch (error) {
      wsLogger.error('Error joining room', error instanceof Error ? error : new Error('Unknown join room error'), {
        connectionId,
        roomId,
        asSpectator,
      });

      await this.sendError(connectionId, 'JOIN_ROOM_FAILED', 'Internal error joining room');
    }
  }

  private async handleLeaveRoom(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const roomId: string | undefined = data?.roomId || connection.context.roomId;
    if (!roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Not currently in a room');
      return;
    }

    try {
      // Leave the room channel
      const success = this.channelManager.leaveRoom(roomId, connectionId);
      if (!success) {
        await this.sendError(connectionId, 'LEAVE_ROOM_FAILED', 'Failed to leave room');
        return;
      }

      // Update connection context
      this.connectionManager.updateConnectionContext(connectionId, {
        roomId: undefined,
        isSpectator: false,
      });

      // Send room-left confirmation
      await this.sendToConnection(connectionId, 'room-left', { roomId });

      // Broadcast player-left to remaining room members
      if (this.broadcastToRoom) {
        this.broadcastToRoom(roomId, 'player-left', {
          userId: connection.context.userId,
          username: connection.context.username,
        }, connectionId);
      }

      // Publish event to event bus
      await this.eventBus.publish('room:player-left', {
        roomId,
        userId: connection.context.userId,
        username: connection.context.username,
        timestamp: new Date().toISOString(),
      });

      wsLogger.info('Player left room', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId,
      });

    } catch (error) {
      wsLogger.error('Error leaving room', error instanceof Error ? error : new Error('Unknown leave room error'), {
        connectionId,
        roomId,
      });

      await this.sendError(connectionId, 'LEAVE_ROOM_FAILED', 'Internal error leaving room');
    }
  }

  private async handlePlayerReady(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to set ready status');
      return;
    }

    const { ready } = data;
    if (typeof ready !== 'boolean') {
      await this.sendError(connectionId, 'INVALID_MESSAGE', 'Ready status must be boolean');
      return;
    }

    try {
      const roomId = connection.context.roomId;

      this.channelManager.setPlayerReadyStatus(roomId, connectionId, ready);

      // Broadcast ready status to room
      if (this.broadcastToRoom) {
        this.broadcastToRoom(roomId, 'player-ready', {
          userId: connection.context.userId,
          username: connection.context.username,
          ready,
        });
      }

      // Publish event to event bus
      await this.eventBus.publish('room:player-ready', {
        roomId,
        userId: connection.context.userId,
        username: connection.context.username,
        ready,
        timestamp: new Date().toISOString(),
      });

      wsLogger.info('Player ready status changed', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId,
        ready,
      });

    } catch (error) {
      wsLogger.error('Error updating ready status', error instanceof Error ? error : new Error('Unknown ready status error'), {
        connectionId,
        ready,
      });

      await this.sendError(connectionId, 'READY_UPDATE_FAILED', 'Failed to update ready status');
    }
  }

  // ‚úÖ FASE 1 - CORRE√á√ÉO CR√çTICA: handleStartGame com gameId padronizado
  private async handleStartGame(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to start game');
      return;
    }

    const roomId = connection.context.roomId;
    // ‚úÖ FASE 1 - CORRE√á√ÉO CR√çTICA: gameId padronizado e consistente
    const gameId = `game-${roomId}`;

    try {
      // ‚úÖ FASE 1 - LOG MELHORADO: Estado inicial do processo
      wsLogger.info('Starting game process - Phase 1', {
        connectionId,
        roomId,
        gameId,
        hostId: connection.context.userId,
        pattern: 'game-${roomId}'
      });

      // Verificar se √© o host
      const roomQuery = await pool.query(`SELECT * FROM rooms WHERE id = $1`, [roomId]);
      if (roomQuery.rows.length === 0) {
        await this.sendError(connectionId, 'ROOM_NOT_FOUND', 'Room not found');
        return;
      }

      const roomData = roomQuery.rows[0];
      if (roomData.hostId !== connection.context.userId) {
        await this.sendError(connectionId, 'NOT_HOST', 'Only the host can start the game');
        return;
      }

      // ‚úÖ FASE 1 - IMPORTANTE: Verificar se jogo j√° existe com o gameId CORRETO
      let gameState = await this.gameEngine.getGameState(gameId);

      if (!gameState) {
        wsLogger.info('Game does not exist, creating new game with standardized ID', {
          gameId,
          roomId,
          pattern: 'game-${roomId}'
        });

        const gameConfig = {
          roomId: roomId,
          maxPlayers: roomData.maxPlayers,
          maxSpectators: roomData.maxSpectators,
          nightDuration: 60000,
          dayDuration: 120000,
          votingDuration: 60000,
          allowReconnection: true,
          reconnectionTimeout: 120000,
        };

        // ‚úÖ FASE 1 - AGORA o GameEngine criar√° o jogo com gameId = `game-${roomId}`
        gameState = await this.gameEngine.createGame(connection.context.userId, gameConfig);

        wsLogger.info('Game created successfully with standardized ID', {
          gameId: gameState.gameId,
          roomId,
          hostId: connection.context.userId,
          expectedGameId: gameId,
          actualGameId: gameState.gameId,
          idsMatch: gameState.gameId === gameId
        });
      } else {
        wsLogger.info('Game already exists, using existing game', {
          gameId,
          status: gameState.status,
          playerCount: gameState.players.length
        });
      }

      // ‚úÖ FASE 1 - LOG MELHORADO: Players being added
      const roomConnections = this.channelManager.getRoomPlayerConnections(roomId);
      wsLogger.info('Adding players to game', {
        gameId,
        roomConnectionCount: roomConnections.size,
        existingPlayerCount: gameState.players.length
      });

      // ‚úÖ FASE 1 - Adicionar jogadores usando o gameId CORRETO
      for (const connId of roomConnections) {
        const conn = this.connectionManager.getConnection(connId);
        if (conn && !conn.context.isSpectator) {
          const player = new Player({
            id: `${roomId}-${conn.context.userId}`,
            userId: conn.context.userId,
            username: conn.context.username,
            avatar: undefined,
            isHost: roomData.hostId === conn.context.userId,
            isReady: this.channelManager.isPlayerReady(roomId, connId),
            isSpectator: false,
            isConnected: true,
            joinedAt: new Date(),
            lastSeen: new Date(),
          });

          // ‚úÖ FASE 1 - USAR o gameId CORRETO para adicionar o jogador
          const addResult = await this.gameEngine.addPlayer(gameId, player);

          wsLogger.debug('Player added to game', {
            gameId,
            playerId: player.id,
            userId: player.userId,
            username: player.username,
            isHost: player.isHost,
            isReady: player.isReady,
            addResult
          });
        }
      }

      // ‚úÖ FASE 1 - LOG ANTES DE TENTAR INICIAR: Verificar estado final
      const finalGameState = await this.gameEngine.getGameState(gameId);
      if (finalGameState) {
        const alivePlayers = finalGameState.getAlivePlayers();
        const hostPlayer = alivePlayers.find(p => p.isHost);
        const nonHostPlayers = alivePlayers.filter(p => !p.isHost);
        const readyNonHostPlayers = nonHostPlayers.filter(p => p.isReady);

        wsLogger.info('Attempting to start game - Final validation', {
          gameId,
          canStart: finalGameState.canStart(),
          totalPlayers: alivePlayers.length,
          hostFound: !!hostPlayer,
          hostUsername: hostPlayer?.username,
          hostReady: hostPlayer?.isReady,
          nonHostPlayers: nonHostPlayers.length,
          readyNonHostPlayers: readyNonHostPlayers.length,
          playersNotReady: nonHostPlayers.filter(p => !p.isReady).map(p => p.username),
          gameStatus: finalGameState.status
        });
      }

      // ‚úÖ FASE 1 - Iniciar o jogo com o gameId CORRETO
      const success = await this.gameEngine.startGame(gameId);

      if (!success) {
        // ‚úÖ FASE 1 - LOG DETALHADO do erro
        const currentState = await this.gameEngine.getGameState(gameId);
        let errorDetails = 'Unknown error';

        if (currentState) {
          const alivePlayers = currentState.getAlivePlayers();
          const hostPlayer = alivePlayers.find(p => p.isHost);
          const nonHostPlayers = alivePlayers.filter(p => !p.isHost);
          const notReadyPlayers = nonHostPlayers.filter(p => !p.isReady);

          errorDetails = `Status: ${currentState.status}, Players: ${alivePlayers.length}, Host: ${hostPlayer ? 'Found' : 'Missing'}, Not Ready: ${notReadyPlayers.map(p => p.username).join(', ')}`;
        }

        wsLogger.error('Failed to start game - Phase 1', {
          gameId,
          roomId,
          errorDetails
        });

        await this.sendError(connectionId, 'START_GAME_FAILED',
          `Failed to start game. ${errorDetails}`
        );
        return;
      }

      wsLogger.info('Game started successfully - Phase 1 implementation', {
        gameId,
        roomId,
        hostId: connection.context.userId,
      });

    } catch (error) {
      wsLogger.error('Error starting game - Phase 1', error instanceof Error ? error : new Error('Unknown start game error'), {
        connectionId,
        gameId,
        roomId,
      });

      await this.sendError(connectionId, 'START_GAME_FAILED', 'Internal error starting game');
    }
  }

  //====================================================================
  // GAME HANDLERS
  //====================================================================
  private async handleGetGameState(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const { gameId } = data;
    if (!gameId) {
      await this.sendError(connectionId, 'MISSING_GAME_ID', 'Game ID is required');
      return;
    }

    try {
      const gameState = await this.gameEngine.getGameState(gameId);

      if (!gameState) {
        await this.sendError(connectionId, 'GAME_NOT_FOUND', 'Game not found');
        return;
      }

      const personalizedState = this.getPersonalizedGameState(gameState, connection.context.userId);

      await this.sendToConnection(connectionId, 'game-state', personalizedState);

      wsLogger.info('Game state sent to player', {
        connectionId,
        userId: connection.context.userId,
        gameId,
      });

    } catch (error) {
      wsLogger.error('Error getting game state', error instanceof Error ? error : new Error('Unknown error'), {
        connectionId,
        gameId,
      });

      await this.sendError(connectionId, 'GET_GAME_STATE_FAILED', 'Failed to get game state');
    }
  }

  private async handleGameAction(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to perform game actions');
      return;
    }

    const { type, targetId } = data;
    const gameId = `game-${connection.context.roomId}`;

    try {
      const success = await this.gameEngine.performPlayerAction(
        gameId,
        connection.context.userId,
        { type, targetId }
      );

      if (success) {
        await this.sendToConnection(connectionId, 'action-confirmed', {
          actionType: type,
          message: 'A√ß√£o registrada com sucesso'
        });
      } else {
        await this.sendError(connectionId, 'ACTION_FAILED', 'Falha ao executar a√ß√£o');
      }

    } catch (error) {
      wsLogger.error('Error performing game action', error instanceof Error ? error : new Error('Unknown action error'), {
        connectionId,
        action: type,
        targetId,
      });
      await this.sendError(connectionId, 'ACTION_FAILED', 'Erro interno ao executar a√ß√£o');
    }
  }

  private async handleVote(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to vote');
      return;
    }

    const { targetId } = data;
    const gameId = `game-${connection.context.roomId}`;

    try {
      const success = await this.gameEngine.castVote(
        gameId,
        connection.context.userId,
        targetId
      );

      if (success) {
        await this.sendToConnection(connectionId, 'vote-confirmed', {
          message: 'Voto registrado'
        });
      } else {
        await this.sendError(connectionId, 'VOTE_FAILED', 'Falha ao registrar voto');
      }

    } catch (error) {
      wsLogger.error('Error casting vote', error instanceof Error ? error : new Error('Unknown vote error'), {
        connectionId,
        targetId,
      });
      await this.sendError(connectionId, 'VOTE_FAILED', 'Erro interno ao votar');
    }
  }

  private async handleUnvote(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to unvote');
      return;
    }

    const gameId = `game-${connection.context.roomId}`;

    try {
      const success = await this.gameEngine.removeVote(
        gameId,
        connection.context.userId
      );

      if (success) {
        await this.sendToConnection(connectionId, 'unvote-confirmed', {
          message: 'Voto removido'
        });
      } else {
        await this.sendError(connectionId, 'UNVOTE_FAILED', 'Falha ao remover voto');
      }

    } catch (error) {
      wsLogger.error('Error removing vote', error instanceof Error ? error : new Error('Unknown unvote error'), {
        connectionId,
      });
      await this.sendError(connectionId, 'UNVOTE_FAILED', 'Erro interno ao remover voto');
    }
  }

  //====================================================================
  // PERSONALIZED GAME STATE
  //====================================================================
  private getPersonalizedGameState(gameState: any, userId: string): any {
    const currentPlayer = gameState.players.find((p: any) => p.userId === userId);
    const personalizedState = JSON.parse(JSON.stringify(gameState));

    personalizedState.players = personalizedState.players.map((player: any) => {
      if (player.userId === userId) {
        return player;
      } else if (!player.isAlive) {
        return player;
      } else {
        const { role, faction, ...publicData } = player;
        return publicData;
      }
    });

    if (currentPlayer) {
      personalizedState.me = {
        id: currentPlayer.id,
        userId: currentPlayer.userId,
        username: currentPlayer.username,
        role: currentPlayer.role,
        faction: currentPlayer.faction,
        isAlive: currentPlayer.isAlive,
        isProtected: currentPlayer.isProtected,
        hasActed: currentPlayer.hasActed,
        hasVoted: currentPlayer.hasVoted,
        votedFor: currentPlayer.votedFor,
        actionsUsed: currentPlayer.actionsUsed,
        maxActions: currentPlayer.maxActions,
      };
    }

    return personalizedState;
  }

  //====================================================================
  // ADDITIONAL HANDLERS
  //====================================================================
  private async handleDeleteRoom(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const roomId: string | undefined = data?.roomId || connection.context.roomId;
    if (!roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Not currently in a room');
      return;
    }

    try {
      const roomQuery = `SELECT id, "hostId" FROM rooms WHERE id = $1`;
      const roomResult = await pool.query(roomQuery, [roomId]);

      if (roomResult.rows.length === 0) {
        await this.sendError(connectionId, 'ROOM_NOT_FOUND', 'Room not found');
        return;
      }

      const room = roomResult.rows[0];
      if (room.hostId !== connection.context.userId) {
        await this.sendError(connectionId, 'NOT_HOST', 'Only the host can delete the room');
        return;
      }

      const allRoomConnections = this.channelManager.getRoomConnections(roomId);

      if (this.broadcastToRoom) {
        this.broadcastToRoom(roomId, 'room-deleted', {
          roomId,
          reason: 'Host ended the room',
          timestamp: new Date().toISOString(),
        });
      }

      for (const connId of allRoomConnections) {
        this.channelManager.leaveRoom(roomId, connId);
        this.connectionManager.updateConnectionContext(connId, {
          roomId: undefined,
          isSpectator: false,
        });
      }

      await pool.query(`DELETE FROM rooms WHERE id = $1`, [roomId]);

      await this.eventBus.publish('room:deleted', {
        roomId,
        hostId: connection.context.userId,
        timestamp: new Date().toISOString(),
      });

      wsLogger.info('Room deleted by host', {
        connectionId,
        hostId: connection.context.userId,
        roomId,
        affectedConnections: allRoomConnections.size,
      });

    } catch (error) {
      wsLogger.error('Error deleting room', error instanceof Error ? error : new Error('Unknown delete room error'), {
        connectionId,
        roomId,
      });

      await this.sendError(connectionId, 'DELETE_ROOM_FAILED', 'Internal error deleting room');
    }
  }

  private async handleKickPlayer(connectionId: string, data: any): Promise<void> {
    await this.sendError(connectionId, 'NOT_IMPLEMENTED', 'Kick player not yet implemented');
  }

  private async handleChatMessage(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const { message, channel = 'public' } = data;

    if (!message || typeof message !== 'string') {
      await this.sendError(connectionId, 'INVALID_MESSAGE', 'Message is required and must be a string');
      return;
    }

    try {
      const roomId = connection.context.roomId;
      if (!roomId) {
        await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to send chat messages');
        return;
      }

      const chatMessage = {
        id: Date.now().toString(),
        userId: connection.context.userId,
        username: connection.context.username,
        message: message.trim(),
        channel,
        timestamp: new Date().toISOString(),
      };

      if (this.broadcastToRoom) {
        this.broadcastToRoom(roomId, 'chat-message', { message: chatMessage });
      }

      wsLogger.info('Chat message sent', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId,
        messageLength: message.length,
        channel,
      });

    } catch (error) {
      wsLogger.error('Error sending chat message', error instanceof Error ? error : new Error('Unknown chat error'), {
        connectionId,
        message: message.substring(0, 50),
      });

      await this.sendError(connectionId, 'CHAT_FAILED', 'Failed to send chat message');
    }
  }

  private async handleSpectateRoom(connectionId: string, data: any): Promise<void> {
    await this.handleJoinRoom(connectionId, { ...data, asSpectator: true });
  }

  private async handleStopSpectating(connectionId: string, data: any): Promise<void> {
    await this.handleLeaveRoom(connectionId, data);
  }

  //====================================================================
  // UTILITY METHODS
  //====================================================================
  private async sendToConnection(connectionId: string, type: string, data?: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || connection.ws.readyState !== connection.ws.OPEN) {
      return;
    }

    try {
      const message = {
        type,
        data,
        timestamp: new Date().toISOString(),
      };

      connection.ws.send(JSON.stringify(message));
    } catch (error) {
      wsLogger.error('Failed to send message to connection', error instanceof Error ? error : new Error('Unknown send error'), {
        connectionId,
        type,
      });
    }
  }

  private async sendError(connectionId: string, code: WebSocketErrorCode, message: string): Promise<void> {
    await this.sendToConnection(connectionId, 'error', {
      code,
      message,
    });
  }

  //====================================================================
  // HANDLER REGISTRATION (for extensibility)
  //====================================================================
  registerHandler(type: string, handler: MessageHandler): void {
    if (this.handlers.has(type)) {
      wsLogger.warn('Overriding existing message handler', { type });
    }

    this.handlers.set(type, handler);
    wsLogger.debug('Message handler registered', { type });
  }

  unregisterHandler(type: string): boolean {
    const existed = this.handlers.delete(type);
    if (existed) {
      wsLogger.debug('Message handler unregistered', { type });
    }
    return existed;
  }

  getRegisteredHandlers(): string[] {
    return Array.from(this.handlers.keys());
  }
}
</file>

<file path="frontend/src/context/SocketContext.tsx">
'use client';

import { createContext, useContext, ReactNode, useCallback, useRef, useState } from 'react';

// Tipos simplificados
export interface WebSocketContextType {
  socket: WebSocket | null;
  isConnected: boolean;
  connect: (url: string) => void;
  disconnect: () => void;
  sendMessage: (type: string, data?: any) => boolean;
}

const SocketContext = createContext<WebSocketContextType | undefined>(undefined);

export function SocketProvider({ children }: { children: ReactNode }) {
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const socketRef = useRef<WebSocket | null>(null);

  const connect = useCallback((url: string) => {
    // Valida√ß√£o b√°sica
    if (!url || url.includes('undefined')) {
      console.error('‚ùå Invalid WebSocket URL:', url);
      return;
    }

    // ‚úÖ CORRIGIDO: Verificar se j√° est√° conectado na mesma URL com readyState
    if (socketRef.current?.url === url && socketRef.current.readyState === WebSocket.OPEN) {
      console.log('‚úÖ Already connected to', url);
      return;
    }

    // ‚úÖ CORRIGIDO: Verificar se h√° conex√£o pendente para a mesma URL
    if (socketRef.current?.url === url && socketRef.current.readyState === WebSocket.CONNECTING) {
      console.log('‚è≥ Connection already in progress for', url);
      return;
    }

    // Desconecta conex√£o anterior se existir
    if (socketRef.current) {
      console.log('üîÑ Closing previous connection');
      socketRef.current.close();
    }

    console.log('üîå Connecting to WebSocket:', url);

    try {
      const ws = new WebSocket(url);
      socketRef.current = ws;

      ws.onopen = () => {
        console.log('‚úÖ WebSocket connected');
        setSocket(ws);
        setIsConnected(true);
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          // Dispara evento customizado para componentes ouvirem
          window.dispatchEvent(new CustomEvent('websocket-message', { detail: message }));
        } catch (error) {
          console.error('‚ùå Error parsing message:', error);
        }
      };

      ws.onclose = (event) => {
        console.log('üîå WebSocket disconnected', {
          code: event.code,
          reason: event.reason || 'No reason provided',
          wasClean: event.wasClean
        });
        setSocket(null);
        setIsConnected(false);

        // ‚úÖ CORRIGIDO: S√≥ limpar ref se for a conex√£o atual
        if (socketRef.current === ws) {
          socketRef.current = null;
        }
      };

      ws.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
        // ‚úÖ ADICIONADO: Atualizar estado em caso de erro
        setSocket(null);
        setIsConnected(false);
      };

    } catch (error) {
      console.error('‚ùå Failed to create WebSocket:', error);
      setSocket(null);
      setIsConnected(false);
    }
  }, []);

  const disconnect = useCallback(() => {
    if (socketRef.current) {
      console.log('üîå Disconnecting WebSocket');

      // ‚úÖ CORRIGIDO: Verificar estado antes de fechar
      if (socketRef.current.readyState === WebSocket.OPEN ||
        socketRef.current.readyState === WebSocket.CONNECTING) {
        socketRef.current.close();
      }

      socketRef.current = null;
      setSocket(null);
      setIsConnected(false);
    }
  }, []);

  // ‚úÖ CORRIGIDO: Usar readyState real do socket em vez do estado React
  const sendMessage = useCallback((type: string, data?: any): boolean => {
    // ‚úÖ Verificar estado real do WebSocket
    if (socketRef.current?.readyState === WebSocket.OPEN) {
      try {
        const message = {
          type,
          data,
          timestamp: new Date().toISOString(),
        };
        socketRef.current.send(JSON.stringify(message));
        console.log('üì§ Message sent:', type, data);
        return true;
      } catch (error) {
        console.error('‚ùå Error sending message:', error);
        return false;
      }
    }

    // ‚úÖ MELHOR: Log mais informativo sobre o estado atual
    const currentState = socketRef.current?.readyState;
    const stateNames = {
      [WebSocket.CONNECTING]: 'CONNECTING',
      [WebSocket.OPEN]: 'OPEN',
      [WebSocket.CLOSING]: 'CLOSING',
      [WebSocket.CLOSED]: 'CLOSED'
    };

    console.warn('‚ö†Ô∏è Cannot send message - WebSocket state:',
      currentState !== undefined ? stateNames[currentState] : 'NULL');
    return false;
  }, []);

  const value: WebSocketContextType = {
    socket,
    isConnected,
    connect,
    disconnect,
    sendMessage,
  };

  return (
    <SocketContext.Provider value={value}>
      {children}
    </SocketContext.Provider>
  );
}

export function useSocket(): WebSocketContextType {
  const context = useContext(SocketContext);
  if (!context) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
}
</file>

<file path="frontend/src/types/index.ts">
// üê∫ LOBISOMEM ONLINE - Tipos Centralizados (REFATORADO + NOVOS TIPOS)
import type WebSocket from 'ws';

// =============================================================================
// IMPORT ENUMS FROM CONSTANTS (√öNICA FONTE)
// =============================================================================
export { Role, Faction, GamePhase } from '@/utils/constants';
import { Role, Faction, GamePhase } from '@/utils/constants';

// =============================================================================
// API & HTTP
// =============================================================================
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
  timestamp: string;
}

// =============================================================================
// JWT & AUTENTICA√á√ÉO
// =============================================================================
export interface JWTPayload {
  userId: string;
  username: string;
  email: string;
  avatar?: string;
  iat?: number;
  exp?: number;
}

export interface TokenPair {
  accessToken: string;
  refreshToken?: string;
}

// =============================================================================
// WEBSOCKET & CONEX√ÉO
// =============================================================================
export interface ConnectionContext {
  userId: string;
  username: string;
  serverId: string;
  isSpectator: boolean;
  roomId?: string;
}

export interface ConnectionMetadata {
  connectedAt: Date;
  userAgent?: string;
  ip?: string;
  origin?: string;
}

export interface WebSocketConnection {
  id: string;
  ws: WebSocket;
  context: ConnectionContext;
  metadata: ConnectionMetadata;
  isAlive: boolean;
  lastPing: number;
  reconnectAttempts: number;
}

export interface WebSocketMessage {
  type: string;
  timestamp: string;
  data?: any;
  messageId?: string;
}

export interface URLParseResult {
  isValid: boolean;
  path: string;
  roomId?: string;
  serverId?: string;
}

export interface MessageValidationResult {
  isValid: boolean;
  message?: WebSocketMessage;
  error?: string;
}

// ‚úÖ ATUALIZADO: Adicionados novos c√≥digos de erro
export type WebSocketErrorCode =
  | 'INVALID_TOKEN' | 'ROOM_NOT_FOUND' | 'ROOM_FULL' | 'NOT_IN_ROOM'
  | 'NOT_HOST' | 'GAME_ALREADY_STARTED' | 'INVALID_ACTION'
  | 'PLAYER_NOT_FOUND' | 'RATE_LIMITED' | 'INVALID_MESSAGE'
  | 'UNKNOWN_MESSAGE_TYPE' | 'HANDLER_ERROR' | 'MISSING_ROOM_ID'
  | 'JOIN_ROOM_FAILED' | 'LEAVE_ROOM_FAILED' | 'READY_UPDATE_FAILED'
  | 'START_GAME_FAILED' | 'KICK_PLAYER_FAILED' | 'NOT_IMPLEMENTED'
  | 'DELETE_ROOM_FAILED' | 'CHAT_FAILED'; // ‚úÖ NOVOS

// =============================================================================
// GAME TYPES (COMPAT√çVEIS COM CLASSES REAIS)
// =============================================================================
export type RoomStatus = 'WAITING' | 'PLAYING' | 'FINISHED';
export type GameStatus = 'WAITING' | 'STARTING' | 'PLAYING' | 'FINISHED' | 'CANCELLED';

export interface Room {
  id: string;
  name: string;
  isPrivate: boolean;
  maxPlayers: number;
  maxSpectators: number;
  status: RoomStatus;
  hostId: string;
  hostUsername: string;
  currentPlayers: number;
  currentSpectators: number;
  createdAt: Date;
  updatedAt: Date;
  code?: string;
  serverId?: string;
}

export interface GameConfig {
  roomId: string;
  maxPlayers: number;
  maxSpectators: number;
  nightDuration: number; // milliseconds
  dayDuration: number; // milliseconds
  votingDuration: number; // milliseconds
  allowReconnection: boolean;
  reconnectionTimeout: number; // milliseconds
}

// =============================================================================
// PLAYER INTERFACE (COMPAT√çVEL COM CLASSE Player)
// =============================================================================
export interface Player {
  id: string;
  userId: string;
  username: string;
  isHost: boolean;
  isReady: boolean;
  isSpectator: boolean;
  isConnected: boolean;
  joinedAt: Date;
  lastSeen: Date;
  avatar?: string;

  // Game-specific properties
  role?: Role;
  faction?: Faction;
  isAlive?: boolean;
  isProtected?: boolean;
  hasActed?: boolean;
  hasVoted?: boolean;
  votedFor?: string;
  actionsUsed?: number;
  maxActions?: number;
  lastAction?: string;
  eliminationReason?: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER';
  killedBy?: string;
}

// =============================================================================
// GAME STATE INTERFACE (COMPAT√çVEL COM CLASSE GameState)
// ‚úÖ MUDAN√áA CHAVE: Usar estruturas que a classe realmente usa
// =============================================================================
export interface GameState {
  gameId: string;
  roomId: string;
  status: GameStatus;
  phase: GamePhase;
  day: number;
  phaseStartTime: Date;
  phaseEndTime: Date;
  timeLeft: number;

  // ‚úÖ IMPORTANTE: Compat√≠vel com a classe real que usa Map
  players: Player[]; // Para serializa√ß√£o JSON
  spectators: string[]; // IDs dos espectadores  
  eliminatedPlayers: Player[];

  hostId: string;
  events: GameEvent[];
  votes: Record<string, string>; // Para serializa√ß√£o JSON - voterId -> targetId
  nightActions: NightAction[];
  config: GameConfig;
  createdAt: Date;
  updatedAt: Date;
  startedAt?: Date;
  finishedAt?: Date;
  winningFaction?: Faction;
  winningPlayers?: string[];
}

export interface GameEvent {
  id: string;
  type: string;
  phase: GamePhase;
  day: number;
  timestamp: Date;
  data: any;
  visibleTo?: string[]; // If undefined, visible to all
}

export interface NightAction {
  playerId: string;
  type: string;
  targetId?: string;
  data?: any;
  priority: number;
}

// =============================================================================
// ‚úÖ CHAT TYPES (MELHORADOS)
// =============================================================================
export interface ChatMessage {
  id: string;
  userId: string;
  username: string;
  message: string;
  channel: 'public' | 'werewolf' | 'spectator' | 'system' | 'dead';
  timestamp: string;
  filtered?: boolean;

  // ‚úÖ ADICIONADO: Metadata para chat
  isWhisper?: boolean;
  targetUserId?: string;
  edited?: boolean;
  editedAt?: string;
}

// =============================================================================
// GAME ENGINE INTERFACES
// =============================================================================
export interface IGameEngine {
  // Game lifecycle
  createGame(hostId: string, config: GameConfig): Promise<GameState>;
  startGame(gameId: string): Promise<boolean>;
  endGame(gameId: string, reason?: string): Promise<void>;

  // Player management
  addPlayer(gameId: string, player: Player): Promise<boolean>;
  removePlayer(gameId: string, playerId: string): Promise<boolean>;

  // Game state
  getGameState(gameId: string): Promise<GameState | null>;
  updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;

  // Actions
  performPlayerAction(gameId: string, playerId: string, action: any): Promise<boolean>;

  // Phase management
  nextPhase(gameId: string): Promise<void>;

  // Events
  onGameEvent(gameId: string, event: string, handler: (data: any) => void): void;

  // Voting
  castVote?(gameId: string, voterId: string, targetId: string): Promise<boolean>;
  removeVote?(gameId: string, voterId: string): Promise<boolean>;

  // Administrative
  getActiveGamesCount?(): number;
  getAllGames?(): GameState[];
  getGamesByRoom?(roomId: string): Promise<GameState[]>;
  forceEndGame?(gameId: string, reason: string): Promise<boolean>;
  getGameStats?(gameId: string): any;
  cleanup?(): Promise<void>;
}

// =============================================================================
// ROLE SYSTEM TYPES (IMPORTADOS DE RoleSystem.ts)
// =============================================================================
export interface RoleConfiguration {
  role: Role;
  faction: Faction;
  name: string;
  description: string;
  abilities: string[];
  goalDescription: string;
  canAct: boolean;
  actsDuring: string[];
  hasNightChat: boolean;
  immuneToInvestigation: boolean;
  maxActions?: number;
  priority: number;
}

export type RoleDistribution = Record<Role, number>;

// =============================================================================
// ACTION SYSTEM TYPES
// =============================================================================
export interface GameAction {
  id: string;
  playerId: string;
  type: string;
  targetId?: string;
  data?: any;
  timestamp: Date;
  phase: string;
  day: number;
  priority: number;
  isValid: boolean;
  processed: boolean;
}

export interface ActionResult {
  success: boolean;
  actionId: string;
  message?: string;
  data?: any;
  errors?: string[];
}

// =============================================================================
// TIMER SYSTEM TYPES
// =============================================================================
export interface GameTimer {
  id: string;
  type: 'PHASE' | 'WARNING' | 'CUSTOM';
  startTime: number;
  duration: number;
  remaining: number;
  isActive: boolean;
  callback?: () => void;
  timeout?: NodeJS.Timeout; // ‚úÖ Nome correto
}

// =============================================================================
// SERVICE INTERFACES (CORRIGIDOS)
// =============================================================================
export interface ServiceMetadata {
  id: string;
  type: 'lobby' | 'game' | 'chat' | 'monolith';
  host: string;
  port: number;
  capabilities: string[];
  status: 'healthy' | 'unhealthy';
  lastHeartbeat: Date;
  maxRooms?: number;
  currentRooms?: number;
}

export interface IEventBus {
  publish<T>(channel: string, event: T): Promise<void>;
  subscribe<T>(channel: string, handler: (event: T) => void): Promise<void>;
  unsubscribe(channel: string, handler?: Function): Promise<void>;
  healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

export interface IServiceRegistry {
  registerService(serviceId: string, metadata: ServiceMetadata): Promise<void>;
  getAvailableServices(serviceType: string): Promise<string[]>;
  unregisterService(serviceId: string): Promise<void>;
  getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null>;
  healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// ‚úÖ INTERFACE CORRIGIDA - Agora retorna GameState em vez de Game inexistente
export interface IGameStateService {
  createGame(hostId: string, config: GameConfig): Promise<GameState>;
  getGame(gameId: string): Promise<GameState | null>;
  updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;
  deleteGame(gameId: string): Promise<void>;
  addPlayer(gameId: string, player: Player): Promise<void>;
  removePlayer(gameId: string, playerId: string): Promise<void>;
  updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void>;
  getGameState(gameId: string): Promise<GameState | null>;
  getPlayer(gameId: string, playerId: string): Promise<Player | null>;
  getAllPlayers(gameId: string): Promise<Player[]>;
  getGamesByRoom(roomId: string): Promise<GameState[]>;
  getActiveGamesCount(): Promise<number>;
  cleanup?(): number;
  healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// =============================================================================
// WIN CONDITION TYPES
// =============================================================================
export interface WinCondition {
  hasWinner: boolean;
  winningFaction?: Faction;
  winningPlayers?: string[];
  reason?: string;
}

// =============================================================================
// GAME STATISTICS TYPES
// =============================================================================
export interface GameStats {
  gameId: string;
  status: GameStatus;
  phase: GamePhase;
  day: number;
  playerCount: number;
  aliveCount: number;
  spectatorCount: number;
  timeLeft: number;
  events: number;
}

export interface GameResults {
  gameId: string;
  roomId: string;
  duration: number;
  totalDays: number;
  winningFaction?: Faction;
  winningPlayers: string[];
  players: PlayerResult[];
  events: GameEvent[];
}

export interface PlayerResult {
  id: string;
  userId: string;
  username: string;
  role?: Role;
  faction?: Faction;
  survived: boolean;
  won: boolean;
  eliminationReason?: string;
  killedBy?: string;
}

// =============================================================================
// PHASE MANAGER TYPES
// =============================================================================
export interface PhaseTransition {
  from: GamePhase;
  to: GamePhase;
  duration: number;
  reason?: string;
}

export interface NightResults {
  protections: string[];
  investigations: Array<{
    investigatorId: string;
    targetId: string;
    result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS';
  }>;
  attacks: Array<{
    attackerId: string;
    targetId: string;
    successful: boolean;
  }>;
  deaths: Array<{
    playerId: string;
    cause: string;
    killedBy?: string;
  }>;
}

// =============================================================================
// ‚úÖ WEBSOCKET EVENT TYPES (ATUALIZADOS)
// =============================================================================
export interface GameWebSocketEvents {
  // Game lifecycle events
  'game:created': { gameId: string; hostId: string; config: GameConfig };
  'game:started': { gameId: string; players: Player[]; distribution: RoleDistribution };
  'game:ended': { gameId: string; results: GameResults };

  // Phase events
  'phase:changed': { gameId: string; phase: GamePhase; duration: number; timeLeft: number };
  'phase:warning': { gameId: string; phase: GamePhase; timeLeft: number };

  // Player events
  'player:joined': { gameId: string; player: Player };
  'player:left': { gameId: string; playerId: string; username: string };
  'player:died': { gameId: string; playerId: string; role: Role; cause: string };
  'player:executed': { gameId: string; playerId: string; role: Role; votes: number };

  // Action events
  'action:submitted': { gameId: string; playerId: string; actionType: string };
  'action:result': { gameId: string; playerId: string; result: ActionResult };

  // Voting events
  'vote:cast': { gameId: string; voterId: string; targetId: string; voteCounts: Record<string, number> };
  'vote:removed': { gameId: string; voterId: string; voteCounts: Record<string, number> };

  // ‚úÖ NOVOS: Room events
  'room:deleted': { roomId: string; reason: string; timestamp: string };
  'room:player-joined': { roomId: string; userId: string; username: string; asSpectator: boolean; timestamp: string };
  'room:player-left': { roomId: string; userId: string; username: string; timestamp: string };
  'room:player-ready': { roomId: string; userId: string; username: string; ready: boolean; timestamp: string };
  'room:game-started': { roomId: string; hostId: string; timestamp: string };
}

// =============================================================================
// ‚úÖ WEBSOCKET MESSAGE TYPES (ATUALIZADOS)
// =============================================================================
export interface ClientToServerEvents {
  // Room events
  'join-room': { roomId: string; asSpectator?: boolean };
  'leave-room': { roomId?: string };
  'delete-room': { roomId?: string }; // ‚úÖ NOVO
  'player-ready': { ready: boolean };
  'start-game': {};

  // Game actions
  'game-action': { type: string; targetId?: string; data?: any };
  'vote': { targetId: string };
  'unvote': {};

  // Chat events
  'chat-message': { message: string; channel?: string };

  // Werewolf coordination
  'werewolf-kill-vote': { targetId: string };

  // Admin events
  'kick-player': { playerId: string };
  'force-phase': {};
  'extend-time': { additionalTime: number };
}

export interface ServerToClientEvents {
  // Connection events
  'connected': { userId: string };
  'error': { code: WebSocketErrorCode; message: string };

  // Room events
  'room-joined': { room: Room; player: Player; yourRole: string };
  'room-left': { roomId: string };
  'room-deleted': { roomId: string; reason: string; timestamp: string }; // ‚úÖ NOVO
  'player-joined': { player: Player };
  'player-left': { userId: string; username: string };
  'player-ready': { userId: string; username: string; ready: boolean };

  // Game events
  'game-starting': { countdown: number };
  'game-started': { gameId: string; players: Player[]; spectators: Player[] };
  'game-state': GameState;
  'game-ended': { results: GameResults };

  // Phase events
  'phase-changed': { phase: GamePhase; timeLeft: number; day: number };
  'phase-warning': { timeLeft: number };

  // Action events
  'action-confirmed': { actionType: string; message: string };
  'action-failed': { actionType: string; error: string };

  // Voting events
  'voting-update': { votes: Record<string, string>; counts: Record<string, number> };
  'execution-result': { executedId?: string; executedName?: string; executedRole?: Role };

  // Night events
  'night-results': { deaths: any[]; messages: string[] };
  'investigation-result': { targetName: string; result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS' };

  // Chat events
  'chat-message': { userId: string; username: string; message: string; channel: string; timestamp: string };

  // Role-specific events
  'role-assigned': { role: Role; faction: Faction; abilities: string[] };
  'werewolf-chat': { senderId: string; senderName: string; message: string };
}

// =============================================================================
// ‚úÖ UI TYPES - EXPANDIDOS
// =============================================================================
export interface ThemeConfig {
  isDark: boolean;
  currentPhase: GamePhase;
  soundEnabled: boolean;
  musicVolume: number;
  sfxVolume: number;

  // ‚úÖ ADICIONADO: Configura√ß√µes visuais
  animationsEnabled: boolean;
  highContrast: boolean;
  fontSize: 'small' | 'medium' | 'large';
  colorBlindMode: boolean;
}

export interface NotificationConfig {
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
  duration?: number;
  persistent?: boolean;
  action?: {
    label: string;
    onClick: () => void;
  };

  // ‚úÖ ADICIONADO: Notifica√ß√£o avan√ßada
  sound?: boolean;
  icon?: string;
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
}

// =============================================================================
// ‚úÖ API RESPONSE TYPES - MELHORADOS
// =============================================================================
export interface PaginatedResponse<T> {
  items: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // ‚úÖ ADICIONADO: Filtros aplicados
  filters?: Record<string, any>;
  sort?: {
    field: string;
    direction: 'asc' | 'desc';
  };
}

// =============================================================================
// LEADERBOARD TYPES
// =============================================================================
export interface LeaderboardEntry {
  rank: number;
  user: {
    id: string;
    username: string;
    avatar?: string;
    level: number;
    country?: string;
  };
  points: number;
  totalGames: number;
  winRate: number;
  favoriteRole?: Role;

  // ‚úÖ ADICIONADO: Estat√≠sticas extras
  currentStreak: number;
  longestStreak: number;
  lastGameAt?: string;
}

// =============================================================================
// ‚úÖ STATISTICS TYPES - EXPANDIDOS
// =============================================================================
export interface UserStatistics {
  totalGames: number;
  totalWins: number;
  totalLosses: number;
  winRate: number;
  level: number;
  favoriteRole?: Role;
  longestWinStreak: number;
  currentStreak: number;
  roleStats: RoleStatistics[];
  recentGames: GameSummary[];

  // ‚úÖ ADICIONADO: Estat√≠sticas avan√ßadas
  averageGameDuration: number;
  survivalRate: number;
  eliminationRate: number;
  mvpCount: number;
  perfectGames: number;
  comebackWins: number;
}

export interface RoleStatistics {
  role: Role;
  gamesPlayed: number;
  wins: number;
  winRate: number;

  // ‚úÖ ADICIONADO: Stats espec√≠ficos por role
  averageSurvivalTime: number;
  successfulActions: number;
  totalActions: number;
  mvpCount: number;
}

export interface GameSummary {
  gameId: string;
  role: Role;
  faction: Faction;
  won: boolean;
  survived: boolean;
  playedAt: string;
  duration: number;

  // ‚úÖ ADICIONADO: Detalhes do jogo
  totalPlayers: number;
  daysSurvived: number;
  actionsPerformed: number;
  mvp: boolean;
  eliminatedBy?: string;
  finalPosition: number;
}

// =============================================================================
// ‚úÖ COMPONENT PROP TYPES - MELHORADOS
// =============================================================================
export interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger' | 'medieval' | 'ghost' | 'outline';
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  disabled?: boolean;
  loading?: boolean;
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  className?: string;
  type?: 'button' | 'submit' | 'reset';

  // ‚úÖ ADICIONADO: Props extras
  fullWidth?: boolean;
  icon?: React.ReactNode;
  iconPosition?: 'left' | 'right';
  tooltip?: string;
  ariaLabel?: string;
}

export interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  className?: string;
  closeOnOverlayClick?: boolean;

  // ‚úÖ ADICIONADO: Props extras
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  variant?: 'default' | 'medieval' | 'dark' | 'error' | 'warning'; // ‚úÖ ATUALIZADO
  showCloseButton?: boolean;
  preventScroll?: boolean;
  zIndex?: number;
}

// =============================================================================
// ‚úÖ FORM TYPES - EXPANDIDOS
// =============================================================================
export interface FormError {
  field: string;
  message: string;
  code?: string;
}

export interface ValidationResult {
  isValid: boolean;
  errors: FormError[];
  warnings?: FormError[];
}

// ‚úÖ ADICIONADO: Tipos para formul√°rios complexos
export interface FormField<T = any> {
  name: string;
  label: string;
  type: 'text' | 'email' | 'password' | 'number' | 'select' | 'checkbox' | 'radio' | 'textarea';
  value: T;
  required?: boolean;
  disabled?: boolean;
  placeholder?: string;
  options?: Array<{ label: string; value: any }>;
  validation?: (value: T) => ValidationResult;
}

export interface FormState<T = Record<string, any>> {
  values: T;
  errors: Record<keyof T, string>;
  touched: Record<keyof T, boolean>;
  isSubmitting: boolean;
  isValid: boolean;
}

// =============================================================================
// ‚úÖ ROOM SETTINGS TYPES
// =============================================================================
export interface RoomSettings {
  gameMode: 'CLASSIC' | 'RANKED' | 'CUSTOM';
  timeDay: number; // segundos
  timeNight: number; // segundos
  timeVoting: number; // segundos
  allowSpectators: boolean;
  autoStart: boolean;
  customRoles?: Role[];
  bannedPlayers?: string[];
}

// =============================================================================
// ‚úÖ UTILITY TYPES
// =============================================================================
export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type RequiredKeys<T, K extends keyof T> = T & Required<Pick<T, K>>;
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};
export type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
};

// =============================================================================
// ‚úÖ BRAND TYPES FOR TYPE SAFETY
// =============================================================================
export type UserId = string & { readonly __brand: unique symbol };
export type RoomId = string & { readonly __brand: unique symbol };
export type GameId = string & { readonly __brand: unique symbol };
export type SessionId = string & { readonly __brand: unique symbol };
export type TokenId = string & { readonly __brand: unique symbol };

// =============================================================================
// ‚úÖ ENVIRONMENT TYPES
// =============================================================================
export interface EnvironmentConfig {
  NODE_ENV: 'development' | 'production' | 'test';
  API_URL: string;
  WS_URL: string;
  VERSION: string;
  BUILD_TIME: string;
  SENTRY_DSN?: string;
  ANALYTICS_ID?: string;
}

// =============================================================================
// ‚úÖ FEATURE FLAGS
// =============================================================================
export interface FeatureFlags {
  enableNewLobby: boolean;
  enableVoiceChat: boolean;
  enableRankedMode: boolean;
  enableCustomRoles: boolean;
  enableSpectatorMode: boolean;
  enableReplaySystem: boolean;
  enableAchievements: boolean;
  enableDarkMode: boolean;
  enableBetaFeatures: boolean;
}

// =============================================================================
// ‚úÖ EXPORT HELPERS
// =============================================================================

// Type guards
export function isUser(obj: any): obj is Player {
  return obj && typeof obj.id === 'string' && typeof obj.username === 'string';
}

export function isApiResponse<T>(obj: any): obj is ApiResponse<T> {
  return obj && typeof obj.success === 'boolean' && typeof obj.timestamp === 'string';
}

export function isWebSocketMessage(obj: any): obj is WebSocketMessage {
  return obj && typeof obj.type === 'string';
}

// Utility functions for types
export function createUserId(id: string): UserId {
  return id as UserId;
}

export function createRoomId(id: string): RoomId {
  return id as RoomId;
}

export function createGameId(id: string): GameId {
  return id as GameId;
}

// ‚úÖ DEFAULT VALUES (ATUALIZADOS)
export const DEFAULT_USER_STATS: UserStatistics = {
  totalGames: 0,
  totalWins: 0,
  totalLosses: 0,
  winRate: 0,
  level: 1,
  longestWinStreak: 0,
  currentStreak: 0,
  roleStats: [],
  recentGames: [],
  averageGameDuration: 0,
  survivalRate: 0,
  eliminationRate: 0,
  mvpCount: 0,
  perfectGames: 0,
  comebackWins: 0,
};

export const DEFAULT_THEME_CONFIG: ThemeConfig = {
  isDark: true,
  currentPhase: GamePhase.LOBBY,
  soundEnabled: true,
  musicVolume: 0.7,
  sfxVolume: 0.8,
  animationsEnabled: true,
  highContrast: false,
  fontSize: 'medium',
  colorBlindMode: false,
};

export const DEFAULT_ROOM_SETTINGS: RoomSettings = {
  gameMode: 'CLASSIC',
  timeDay: 300, // 5 minutos
  timeNight: 120, // 2 minutos
  timeVoting: 60, // 1 minuto
  allowSpectators: true,
  autoStart: false,
  customRoles: [],
  bannedPlayers: [],
};
</file>

<file path="frontend/src/components/room/WaitingRoom.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import { ArrowLeft, Crown, Share } from 'lucide-react';
import { Player, Room, ChatMessage } from '@/types';

import PlayerList from './PlayerList';
import RoomChat from './RoomChat';
import ActionButtons from './ActionButtons';
import { ConfirmModal } from '@/components/common/Modal';

interface WaitingRoomProps {
  // Dados
  roomId: string;
  room: Room | null;
  players: Player[];
  spectators: Player[];
  messages: ChatMessage[];

  // Estados
  currentUserId: string;
  isHost: boolean;
  isReady: boolean;
  canStartGame: boolean;
  isConnected: boolean;
  showLeaveModal: boolean;
  setShowLeaveModal: (show: boolean) => void;

  // Handlers
  onToggleReady: () => void;
  onStartGame: () => void;
  onKickPlayer: (playerId: string) => void;
  onSendChatMessage: (message: string) => void;
  onShareRoom: () => void;
  onLeaveRoom: () => void;
  onConfirmLeaveAsHost: () => void;
}

export default function WaitingRoom({
  roomId,
  room,
  players,
  spectators,
  messages,
  currentUserId,
  isHost,
  isReady,
  canStartGame,
  isConnected,
  showLeaveModal,
  setShowLeaveModal,
  onToggleReady,
  onStartGame,
  onKickPlayer,
  onSendChatMessage,
  onShareRoom,
  onLeaveRoom,
  onConfirmLeaveAsHost
}: WaitingRoomProps) {

  // Se n√£o tiver dados da sala, n√£o deve renderizar (isso √© controlado pelo componente pai)
  if (!room) {
    return null;
  }

  return (
    <>
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white">
        {/* Header */}
        <div className="bg-slate-800/80 border-b border-slate-700 p-6">
          <div className="max-w-7xl mx-auto">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-4">
                <button
                  onClick={onLeaveRoom}
                  className="p-2 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors"
                >
                  <ArrowLeft className="w-5 h-5" />
                </button>

                <div className="text-3xl">üê∫</div>

                <div>
                  <h1 className="text-2xl font-bold">{room.name}</h1>
                  <div className="flex items-center gap-4 text-sm text-slate-400">
                    <span>C√≥digo: {room.code}</span>
                    <span>‚Ä¢</span>
                    <span className="flex items-center gap-1">
                      <Crown className="w-4 h-4" />
                      Host: {room.hostUsername}
                    </span>
                    <span>‚Ä¢</span>
                    <span className="flex items-center gap-1">
                      {isConnected ? (
                        <span className="text-green-400">üü¢ Conectado</span>
                      ) : (
                        <span className="text-red-400">üî¥ Desconectado</span>
                      )}
                    </span>
                  </div>
                </div>
              </div>

              <div className="flex items-center gap-4">
                <button
                  onClick={onShareRoom}
                  className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors flex items-center gap-2"
                >
                  <Share className="w-4 h-4" />
                  Compartilhar
                </button>

                <div className="text-right">
                  <div className="text-sm text-slate-400">Jogadores Prontos</div>
                  <div className="text-lg font-bold">
                    {players.filter(p => p.isReady).length}/{players.length}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Main Content */}
        <div className="max-w-7xl mx-auto p-6">
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Players List */}
            <div className="lg:col-span-2">
              <PlayerList
                players={players}
                spectators={spectators}
                currentUserId={currentUserId}
                isHost={isHost}
                onKickPlayer={onKickPlayer}
                maxPlayers={room.maxPlayers}
                maxSpectators={room.maxSpectators}
              />
            </div>

            {/* Actions and Chat */}
            <div className="space-y-6">
              <ActionButtons
                isHost={isHost}
                isReady={isReady}
                canStartGame={canStartGame}
                isConnected={isConnected}
                onToggleReady={onToggleReady}
                onStartGame={onStartGame}
              />

              <RoomChat
                messages={messages}
                onSendMessage={onSendChatMessage}
                currentUserId={currentUserId}
                isConnected={isConnected}
              />
            </div>
          </div>
        </div>
      </div>

      {/* Modal de confirma√ß√£o para host sair */}
      <ConfirmModal
        isOpen={showLeaveModal}
        onClose={() => setShowLeaveModal(false)}
        onConfirm={onConfirmLeaveAsHost}
        title="Encerrar Sala"
        message="Voc√™ √© o host desta sala. Ao sair, a sala ser√° encerrada e todos os jogadores ser√£o removidos. Deseja continuar?"
        confirmText="Sim, Encerrar Sala"
        cancelText="Cancelar"
        variant="warning"
      />
    </>
  );
}
</file>

<file path="backend/src/app.ts">
// üê∫ LOBISOMEM ONLINE - App.ts (CORRE√á√ÉO DA INICIALIZA√á√ÉO)
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import morgan from 'morgan';
import http from 'http';
import { config } from '@/config/environment';
import { checkDatabaseHealth } from '@/config/database';
import { checkRedisHealth } from '@/config/redis';
import { ServiceFactory } from '@/websocket/ServiceFactory';
import { WebSocketManager } from '@/websocket/WebSocketManager';
import authRoutes from '@/routes/auth';
import roomRoutes from '@/routes/rooms';

const app = express();

// ‚úÖ CONFIGURA√á√ÉO DE MIDDLEWARES (mantida igual)
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "ws:", "wss:"],
    },
  },
  crossOriginEmbedderPolicy: false,
}));

app.use(cors({
  origin: function (origin, callback) {
    if (!origin) return callback(null, true);

    const allowedOrigins = [
      'http://localhost:3000',
      'http://localhost:3001',
      'https://localhost:3000',
      'https://localhost:3001',
    ];

    if (config.IS_PRODUCTION) {
      allowedOrigins.push('https://your-domain.com');
    }

    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'X-Request-Time',
    'X-Request-ID'
  ],
}));

app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

if (config.IS_DEVELOPMENT) {
  app.use(morgan('dev'));
} else {
  app.use(morgan('combined'));
}

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA DA INICIALIZA√á√ÉO ‚úÖ‚úÖ‚úÖ
const httpServer = http.createServer(app);
let wsManager: WebSocketManager;

if (config.IS_MONOLITH || config.IS_GAME_SERVICE) {
  try {
    const gameStateService = ServiceFactory.getGameStateService();
    const eventBus = ServiceFactory.getEventBus();

    // ‚ùå ERRO ANTERIOR:
    // wsManager = new WebSocketManager(gameStateService, eventBus, config);

    // ‚úÖ CORRE√á√ÉO: Ordem correta dos par√¢metros
    wsManager = new WebSocketManager(eventBus, config);
    wsManager.setupWebSocketServer(httpServer);

    // ‚úÖ CORRE√á√ÉO: Inje√ß√£o do channelManager
    app.locals.channelManager = wsManager.channelManager;
    console.log('‚úÖ ChannelManager successfully injected into app.locals');

    // ‚úÖ NOVO: Exportar wsManager para shutdown
    (httpServer as any).wsManager = wsManager;

  } catch (error) {
    console.error('‚ùå Failed to initialize WebSocket:', error);
    throw error;
  }
} else {
  console.log('‚ÑπÔ∏è WebSocket not initialized (not MONOLITH or GAME_SERVICE)');
}

// ‚úÖ ROTAS S√ÉO CARREGADAS DEPOIS
app.use('/api/auth', authRoutes);
app.use('/api/rooms', roomRoutes);

// ‚úÖ HEALTH CHECKS (mantidos iguais)
app.get('/health', async (req, res) => {
  try {
    const dbHealth = await checkDatabaseHealth();
    const redisHealth = await checkRedisHealth();
    const servicesHealth = await ServiceFactory.getServicesHealth();
    const servicesStats = ServiceFactory.getServicesStats();

    const health = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      service: {
        id: config.SERVICE_ID,
        type: config.SERVICE_TYPE,
        mode: config.DISTRIBUTED_MODE ? 'distributed' : 'monolithic',
      },
      database: dbHealth,
      redis: redisHealth,
      services: servicesHealth,
      stats: servicesStats,
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      websocket: {
        initialized: !!wsManager,
        channelManagerInjected: !!app.locals.channelManager,
      },
    };

    let hasUnhealthyService = false;

    if (config.DISTRIBUTED_MODE) {
      hasUnhealthyService = Object.values(servicesHealth).some(
        (service: any) => service.status === 'unhealthy'
      );
    } else {
      const criticalServices = ['gameState'];
      hasUnhealthyService = criticalServices.some(serviceName => {
        const service = servicesHealth[serviceName];
        return service && service.status === 'unhealthy';
      });
    }

    const isSystemHealthy =
      dbHealth.status === 'healthy' &&
      (!config.SHOULD_USE_REDIS || redisHealth.status === 'healthy') &&
      !hasUnhealthyService;

    if (!isSystemHealthy) {
      res.status(503).json(health);
      return;
    }

    res.json(health);
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

app.get('/health/ready', (req, res) => {
  res.json({
    status: 'ready',
    timestamp: new Date().toISOString(),
    service: config.SERVICE_ID,
    websocket: !!wsManager,
  });
});

app.get('/health/live', (req, res) => {
  res.json({
    status: 'alive',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
  });
});

app.get('/health/websocket', async (req, res) => {
  try {
    const servicesHealth = await ServiceFactory.getServicesHealth();
    const servicesStats = ServiceFactory.getServicesStats();

    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: servicesHealth,
      stats: servicesStats,
      wsManager: !!wsManager,
      channelManager: !!app.locals.channelManager,
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'WebSocket health check failed',
    });
  }
});

// ‚úÖ ROOT ENDPOINT (mantido igual)
app.get('/', (req, res) => {
  res.json({
    message: 'üê∫ Werewolf Online API',
    version: '1.0.0',
    phase: config.DISTRIBUTED_MODE ? 'Phase 2 (Distributed)' : 'Phase 1 (Monolithic)',
    service: config.SERVICE_TYPE,
    timestamp: new Date().toISOString(),
    websocket: {
      enabled: config.IS_MONOLITH || config.IS_GAME_SERVICE,
      initialized: !!wsManager,
      path: config.WS_BASE_PATH,
      url: `ws://localhost:${config.PORT}${config.WS_BASE_PATH}`,
    },
    endpoints: {
      health: '/health',
      websocketHealth: '/health/websocket',
      ready: '/health/ready',
      live: '/health/live',
      auth: {
        register: 'POST /api/auth/register',
        login: 'POST /api/auth/login',
        forgotPassword: 'POST /api/auth/forgot-password',
        resetPassword: 'POST /api/auth/reset-password',
        profile: 'GET /api/auth/profile',
        logout: 'POST /api/auth/logout',
      },
      rooms: {
        list: 'GET /api/rooms',
        create: 'POST /api/rooms',
        details: 'GET /api/rooms/:id',
        join: 'POST /api/rooms/:id/join',
        joinByCode: 'POST /api/rooms/join-by-code',
        delete: 'DELETE /api/rooms/:id',
      },
      websocket: {
        connect: `WS ${config.WS_BASE_PATH}`,
        events: [
          'join-room', 'leave-room', 'player-ready', 'start-game',
          'chat-message', 'game-action', 'vote', 'kick-player'
        ],
      },
    },
  });
});

// ‚úÖ ERROR HANDLERS (mantidos iguais)
app.use((req, res, next) => {
  res.status(404).json({
    error: 'Not Found',
    message: `Route ${req.method} ${req.path} not found`,
    timestamp: new Date().toISOString(),
  });
});

app.use((error: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('‚ùå Express Error:', error);

  const isDev = config.IS_DEVELOPMENT;
  res.status(500).json({
    error: 'Internal Server Error',
    message: isDev ? error.message : 'Something went wrong',
    timestamp: new Date().toISOString(),
    ...(isDev && { stack: error.stack }),
  });
});

app.use('/api/rooms', (req, res, next) => {
  console.log('\nüîç DEBUG MIDDLEWARE - ROTA /api/rooms');
  console.log('üìç Timestamp:', new Date().toISOString());
  console.log('üìç Method:', req.method);
  console.log('üìç URL:', req.url);
  console.log('üìç Headers:', JSON.stringify(req.headers, null, 2));
  console.log('üìç Body:', JSON.stringify(req.body, null, 2));
  console.log('üìç ChannelManager Available:', !!req.app.locals.channelManager);

  // Timeout de seguran√ßa para detectar travamentos
  const timeout = setTimeout(() => {
    console.log('‚ùå TIMEOUT: Middleware ou rota travou ap√≥s 10 segundos');
    console.log('‚ùå Request ainda processando:', req.method, req.url);
  }, 10000);

  // Interceptar a resposta para saber quando terminou
  const originalSend = res.send;
  res.send = function (data) {
    clearTimeout(timeout);
    console.log('‚úÖ RESPONSE SENT - Status:', res.statusCode);
    console.log('‚úÖ Response Data Length:', JSON.stringify(data).length);
    return originalSend.call(this, data);
  };

  console.log('üîÑ Passando para pr√≥ximo middleware...\n');
  next();
});

export default httpServer;
</file>

<file path="frontend/src/pages/lobby.tsx">
import { useState, useEffect, useCallback } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/router';
import { motion } from 'framer-motion';

import { useAuth } from '@/context/AuthContext';
import { useSocket } from '@/context/SocketContext';
import { useTheme } from '@/context/ThemeContext';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

import CreateRoomModal from '@/components/lobby/CreateRoomModal';
import JoinRoomModal from '@/components/lobby/JoinRoomModal';

import { roomService, RoomListItem } from '@/services/roomService';

// ‚úÖ CORRE√á√ÉO: SafeNumberDisplay √† prova de hidrata√ß√£o
interface SafeNumberDisplayProps {
  value: number;
  className?: string;
}

function SafeNumberDisplay({ value, className = "" }: SafeNumberDisplayProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  // ‚úÖ No servidor, renderiza o n√∫mero sem formata√ß√£o para evitar mismatch
  if (!mounted) {
    return <span className={className}>{value}</span>;
  }

  // ‚úÖ No cliente, aplica a formata√ß√£o brasileira
  return (
    <span className={className}>
      {value.toLocaleString('pt-BR')}
    </span>
  );
}

// ‚úÖ CORRE√á√ÉO: Componente para data/hora seguro
interface SafeDateDisplayProps {
  date: string | Date;
  className?: string;
}

function SafeDateDisplay({ date, className = "" }: SafeDateDisplayProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    // Renderiza placeholder no servidor
    return <span className={className}>--:--</span>;
  }

  return (
    <span className={className}>
      {new Date(date).toLocaleTimeString('pt-BR', {
        hour: '2-digit',
        minute: '2-digit'
      })}
    </span>
  );
}

const PlusIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
  </svg>
);

const SearchIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
  </svg>
);

const RefreshIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
  </svg>
);

const UsersIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a4 4 0 11-8 0 4 4 0 018 0z" />
  </svg>
);

const EyeIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
  </svg>
);

const PlayIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.586a1 1 0 01.707.293l2.414 2.414a1 1 0 00.707.293H15M9 10v4a4 4 0 008 0v-4M9 10V9a4 4 0 118 0v1M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
  </svg>
);

const ClockIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const HashIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14" />
  </svg>
);

function LobbyPage() {
  const router = useRouter();
  const { user, isAuthenticated, isLoading: isAuthLoading } = useAuth();
  const { isConnected } = useSocket();
  const { playSound, playMusic, stopMusic } = useTheme();

  const [rooms, setRooms] = useState<RoomListItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterStatus, setFilterStatus] = useState<'ALL' | 'WAITING' | 'PLAYING'>('ALL');
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showJoinCodeModal, setShowJoinCodeModal] = useState(false);
  const [musicStarted, setMusicStarted] = useState(false);

  useEffect(() => {
    if (!isAuthLoading && !isAuthenticated) {
      router.push('/auth/login');
      return;
    }
  }, [isAuthLoading, isAuthenticated, router]);

  useEffect(() => {
    if (!isAuthLoading && isAuthenticated && !musicStarted) {
      console.log('üéµ Iniciando m√∫sica do lobby...');
      const musicOptions = ['medieval_tavern01', 'medieval_tavern02', 'medieval_tavern03'];
      const randomMusic = musicOptions[Math.floor(Math.random() * musicOptions.length)];
      playMusic(randomMusic);
      setMusicStarted(true);
    }
  }, [isAuthLoading, isAuthenticated, musicStarted]);

  useEffect(() => {
    return () => {
      if (musicStarted) {
        console.log('üéµ Parando m√∫sica do lobby...');
        stopMusic();
      }
    };
  }, [musicStarted]);

  const fetchRooms = useCallback(async () => {
    try {
      setLoading(true);
      const roomsList = await roomService.listPublicRooms();
      setRooms(roomsList);
    } catch (error) {
      console.error('Failed to fetch rooms:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    if (isAuthLoading || !isAuthenticated) return;
    fetchRooms();
  }, [isAuthLoading, isAuthenticated, fetchRooms]);

  useEffect(() => {
    if (isAuthLoading || !isAuthenticated) return;

    const interval = setInterval(() => {
      fetchRooms();
    }, 5000);

    return () => clearInterval(interval);
  }, [isAuthLoading, isAuthenticated, fetchRooms]);

  const filteredRooms = rooms.filter(room => {
    const matchesSearch = room.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      room.hostUsername.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = filterStatus === 'ALL' || room.status === filterStatus;
    return matchesSearch && matchesFilter && !room.isPrivate;
  });

  const handleJoinRoom = useCallback((roomId: string) => {
    console.log('üö™ Joining room:', roomId);
    playSound('button_click');
    router.push(`/room/${roomId}`);
  }, [router, playSound]);

  const handleSpectateRoom = useCallback((roomId: string) => {
    console.log('üëÅÔ∏è Spectating room:', roomId);
    playSound('button_click');
    router.push(`/room/${roomId}?spectate=true`);
  }, [router, playSound]);

  const handleCreateRoom = useCallback(() => {
    console.log('üèóÔ∏è Opening create room modal');
    playSound('button_click');
    setShowCreateModal(true);
  }, [playSound]);

  const handleJoinByCode = useCallback(() => {
    console.log('üîë Opening join by code modal');
    playSound('button_click');
    setShowJoinCodeModal(true);
  }, [playSound]);

  const handleRefresh = useCallback(() => {
    console.log('üîÑ Refreshing room list');
    playSound('button_click');
    fetchRooms();
  }, [playSound, fetchRooms]);

  if (isAuthLoading) {
    return (
      <>
        <Head>
          <title>Lobby - Lobisomem Online</title>
        </Head>
        <Layout>
          <div className="flex justify-center items-center min-h-[50vh]">
            <LoadingSpinner
              variant="medieval"
              size="xl"
              text="Verificando autentica√ß√£o..."
            />
          </div>
        </Layout>
      </>
    );
  }

  if (!isAuthenticated) {
    return null;
  }

  return (
    <>
      <Head>
        <title>Lobby - Werewolf</title>
        <meta name="description" content="Encontre e participe de partidas de Werewolf" />
      </Head>

      <Layout>
        <div className="space-y-6">
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="flex flex-col lg:flex-row justify-between items-start lg:items-center gap-4"
          >
            <div>
              <h1 className="text-3xl font-medieval text-glow">
                üèòÔ∏è Lobby Principal
              </h1>
              <p className="text-white/70 mt-2">
                Bem-vindo de volta, {user?.username || 'Jogador'}! Encontre uma partida ou crie sua pr√≥pria sala.
              </p>
            </div>

            <div className="flex items-center gap-3">
              <div className={`flex items-center gap-2 px-3 py-1 rounded-full text-sm ${isConnected
                ? 'bg-green-900/30 text-green-300 border border-green-500/30'
                : 'bg-red-900/30 text-red-300 border border-red-500/30'
                }`}>
                <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-400' : 'bg-red-400'}`} />
                {isConnected ? 'Online' : 'Desconectado'}
              </div>
            </div>
          </motion.div>

          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.1 }}
            className="flex flex-wrap gap-3"
          >
            <Button
              variant="medieval"
              size="lg"
              onClick={handleCreateRoom}
              className="flex-1 min-w-[200px]"
            >
              <PlusIcon />
              <span>Criar Sala</span>
            </Button>

            <Button
              variant="secondary"
              size="lg"
              onClick={handleJoinByCode}
              className="flex-1 min-w-[200px]"
            >
              <HashIcon />
              <span>Entrar por C√≥digo</span>
            </Button>

            <Button
              variant="ghost"
              size="lg"
              onClick={handleRefresh}
              disabled={loading}
            >
              <RefreshIcon />
            </Button>
          </motion.div>

          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
            className="flex flex-col sm:flex-row gap-4"
          >
            <div className="flex-1 relative">
              <div className="absolute left-3 top-1/2 transform -translate-y-1/2">
                <SearchIcon />
              </div>
              <input
                type="text"
                placeholder="Buscar salas..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-4 py-3 bg-medieval-800/50 border border-medieval-600 rounded-lg text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent"
              />
            </div>

            <div className="flex gap-2">
              {(['ALL', 'WAITING', 'PLAYING'] as const).map((filter) => (
                <Button
                  key={filter}
                  variant={filterStatus === filter ? 'primary' : 'ghost'}
                  size="md"
                  onClick={() => setFilterStatus(filter)}
                >
                  {filter === 'ALL' ? 'Todas' : filter === 'WAITING' ? 'Aguardando' : 'Em Jogo'}
                </Button>
              ))}
            </div>
          </motion.div>

          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3 }}
          >
            {loading ? (
              <div className="flex justify-center py-12">
                <LoadingSpinner variant="medieval" size="lg" text="Carregando salas..." />
              </div>
            ) : (
              <div className="grid gap-4">
                {filteredRooms.length > 0 ? (
                  filteredRooms.map((room, index) => (
                    <RoomCard
                      key={room.id}
                      room={room}
                      onJoin={() => handleJoinRoom(room.id)}
                      onSpectate={() => handleSpectateRoom(room.id)}
                      delay={index * 0.05}
                    />
                  ))
                ) : (
                  <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    className="text-center py-12 text-white/60"
                  >
                    <div className="text-6xl mb-4">üèöÔ∏è</div>
                    <h3 className="text-xl font-semibold mb-2">Nenhuma sala encontrada</h3>
                    <p>Tente ajustar os filtros ou criar uma nova sala.</p>
                  </motion.div>
                )}
              </div>
            )}
          </motion.div>
        </div>

        <CreateRoomModal
          isOpen={showCreateModal}
          onClose={() => setShowCreateModal(false)}
        />

        <JoinRoomModal
          isOpen={showJoinCodeModal}
          onClose={() => setShowJoinCodeModal(false)}
        />
      </Layout>
    </>
  );
}

// ‚úÖ CORRE√á√ÉO: RoomCard com renderiza√ß√£o segura de data/hora
interface RoomCardProps {
  room: RoomListItem;
  onJoin: () => void;
  onSpectate: () => void;
  delay?: number;
}

function RoomCard({ room, onJoin, onSpectate, delay = 0 }: RoomCardProps) {
  const canJoin = room.status === 'WAITING' && room.currentPlayers < room.maxPlayers;
  const canSpectate = room.currentSpectators < room.maxSpectators;

  const getStatusColor = () => {
    switch (room.status) {
      case 'WAITING': return 'text-green-400 bg-green-900/30 border-green-500/30';
      case 'PLAYING': return 'text-yellow-400 bg-yellow-900/30 border-yellow-500/30';
      case 'FINISHED': return 'text-gray-400 bg-gray-900/30 border-gray-500/30';
    }
  };

  const getStatusText = () => {
    switch (room.status) {
      case 'WAITING': return 'Aguardando';
      case 'PLAYING': return 'Em Jogo';
      case 'FINISHED': return 'Finalizada';
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay }}
      whileHover={{ scale: 1.02 }}
      className="bg-medieval-800/30 border border-medieval-600 rounded-lg p-4 hover:border-salem-500/50 transition-all"
    >
      <div className="flex items-center justify-between">
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-3 mb-2">
            <h3 className="font-semibold text-white truncate">{room.name}</h3>

            {room.isPrivate && (
              <span className="text-yellow-400">üîí</span>
            )}

            <div className={`px-2 py-1 rounded text-xs border ${getStatusColor()}`}>
              {getStatusText()}
            </div>
          </div>

          <div className="flex items-center flex-wrap gap-x-4 gap-y-1 text-sm text-white/70">
            <div className="flex items-center gap-1">
              <UsersIcon />
              <span>
                <SafeNumberDisplay value={room.currentPlayers} />
                /
                <SafeNumberDisplay value={room.maxPlayers} />
              </span>
            </div>

            <div className="flex items-center gap-1">
              <EyeIcon />
              <span>
                <SafeNumberDisplay value={room.currentSpectators} />
                /
                <SafeNumberDisplay value={room.maxSpectators} />
              </span>
            </div>

            <div className="flex items-center gap-1">
              <span>Host: {room.hostUsername}</span>
            </div>

            {/* ‚úÖ CORRE√á√ÉO: Usar SafeDateDisplay em vez de toLocaleTimeString direto */}
            <div className="flex items-center gap-1">
              <ClockIcon />
              <SafeDateDisplay date={room.createdAt} />
            </div>
          </div>
        </div>

        <div className="flex gap-2 ml-4">
          {canSpectate && (
            <Button
              variant="ghost"
              size="sm"
              onClick={onSpectate}
            >
              <EyeIcon />
            </Button>
          )}

          <Button
            variant={canJoin ? 'primary' : 'secondary'}
            size="sm"
            onClick={onJoin}
            disabled={!canJoin && !canSpectate}
          >
            <PlayIcon />
            <span>
              {canJoin ? 'Entrar' : room.status === 'PLAYING' ? 'Assistir' : 'Lotada'}
            </span>
          </Button>
        </div>
      </div>
    </motion.div>
  );
}

export default LobbyPage;
</file>

</files>
