This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.env.example
backend/src/app.ts
backend/src/config/database.ts
backend/src/config/environment.ts
backend/src/config/jwt.ts
backend/src/config/redis.ts
backend/src/config/websocket.ts
backend/src/controllers/authController.ts
backend/src/controllers/roomController.ts
backend/src/database/init.sql
backend/src/database/seeds/index.ts
backend/src/game/ActionManager.ts
backend/src/game/Game.ts
backend/src/game/GameEngine.ts
backend/src/game/PhaseManager.ts
backend/src/game/RoleSystem.ts
backend/src/game/TimerManager.ts
backend/src/middleware/auth.ts
backend/src/routes/auth.ts
backend/src/routes/rooms.ts
backend/src/server.ts
backend/src/types/index.ts
backend/src/utils/constants.ts
backend/src/utils/helper.ts
backend/src/utils/logger.ts
backend/src/utils/simpleValidators.ts
backend/src/utils/validators.ts
backend/src/websocket/ChannelManager.ts
backend/src/websocket/ConnectionManager.ts
backend/src/websocket/HeartbeatManager.ts
backend/src/websocket/index.ts
backend/src/websocket/MessageRouter.ts
backend/src/websocket/ServiceFactory.ts
backend/src/websocket/WebSocketManager.ts
database/init.sql
frontend/.env.example
frontend/src/components/common/Button.tsx
frontend/src/components/common/ErrorBoundary.tsx
frontend/src/components/common/Layout.tsx
frontend/src/components/common/LoadingSpinner.tsx
frontend/src/components/common/Modal.tsx
frontend/src/components/lobby/CreateRoomModal.tsx
frontend/src/components/lobby/JoinRoomModal.tsx
frontend/src/components/room/ActionButtons.tsx
frontend/src/components/room/PlayerList.tsx
frontend/src/components/room/RoomChat.tsx
frontend/src/components/room/WaitingRoom.tsx
frontend/src/context/AuthContext.tsx
frontend/src/context/SocketContext.tsx
frontend/src/context/ThemeContext.tsx
frontend/src/hooks/index.ts
frontend/src/pages/_app.tsx
frontend/src/pages/_document.tsx
frontend/src/pages/auth/forgot-password.tsx
frontend/src/pages/auth/login.tsx
frontend/src/pages/auth/register.tsx
frontend/src/pages/index.tsx
frontend/src/pages/lobby.tsx
frontend/src/pages/room/[id].tsx
frontend/src/types/index.ts
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/src/components/lobby/CreateRoomModal.tsx">
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { X, Users, Eye, Lock, Globe, Settings } from 'lucide-react';
import { useRouter } from 'next/router';
import { toast } from 'react-hot-toast';

import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';
import { apiService } from '@/services/api';

interface CreateRoomModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface RoomSettings {
  gameMode: 'CLASSIC' | 'RANKED' | 'CUSTOM';
  timeDay: number;
  timeNight: number;
  timeVoting: number;
  allowSpectators: boolean;
  autoStart: boolean;
}

export default function CreateRoomModal({
  isOpen,
  onClose,
}: CreateRoomModalProps) {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  const [formData, setFormData] = useState({
    name: '',
    isPrivate: false,
    maxPlayers: 12,
    maxSpectators: 8,
  });

  const [settings, setSettings] = useState<RoomSettings>({
    gameMode: 'CLASSIC',
    timeDay: 300,
    timeNight: 120,
    timeVoting: 180,
    allowSpectators: true,
    autoStart: false,
  });

  const [showAdvanced, setShowAdvanced] = useState(false);

  /* -------------------------------------------------------------------------- */
  /*                                 Handlers                                   */
  /* -------------------------------------------------------------------------- */
  const handleInputChange = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleSettingsChange = (field: keyof RoomSettings, value: any) => {
    setSettings(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.name.trim()) {
      toast.error('Nome da sala √© obrigat√≥rio');
      return;
    }
    if (formData.name.length < 3) {
      toast.error('Nome da sala deve ter pelo menos 3 caracteres');
      return;
    }

    setLoading(true);

    try {
      /* ------------------------------ Cria a sala ----------------------------- */
      const response = await apiService.post('/api/rooms', {
        ...formData,
        settings,
      });

      toast.success('Sala criada com sucesso!');
      onClose();

      /* ----------------------- Redireciona para a nova sala ----------------------- */
      const roomId =
        response.data?.data?.room?.id ?? response.data?.room?.id ?? null;

      if (roomId) {
        router.push(`/room/${roomId}`);
      } else {
        console.error(
          'ERRO CR√çTICO: N√£o foi poss√≠vel obter o ID da sala.',
          response.data,
        );
        toast.error('N√£o foi poss√≠vel redirecionar para a sala.');
      }
    } catch (error: any) {
      console.error('Erro ao criar sala:', error);
      toast.error(
        error.response?.data?.message || 'Erro inesperado ao criar sala',
      );
    } finally {
      setLoading(false);
    }
  };

  const handleClose = () => {
    if (!loading) {
      setFormData({
        name: '',
        isPrivate: false,
        maxPlayers: 12,
        maxSpectators: 8,
      });
      setSettings({
        gameMode: 'CLASSIC',
        timeDay: 300,
        timeNight: 120,
        timeVoting: 180,
        allowSpectators: true,
        autoStart: false,
      });
      setShowAdvanced(false);
      onClose();
    }
  };

  /* -------------------------------------------------------------------------- */
  /*                                   JSX                                      */
  /* -------------------------------------------------------------------------- */
  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title="üê∫ Criar Nova Sala"
      size="lg"
      variant="medieval"
    >
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Nome da Sala */}
        <div>
          <label className="block text-sm font-medium text-slate-300 mb-2">
            Nome da Sala *
          </label>
          <input
            type="text"
            value={formData.name}
            onChange={e => handleInputChange('name', e.target.value)}
            placeholder="Digite o nome da sua sala."
            maxLength={50}
            className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            disabled={loading}
          />
          <div className="text-xs text-slate-500 mt-1">
            {formData.name.length}/50 caracteres
          </div>
        </div>

        {/* Configura√ß√µes B√°sicas */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* M√°ximo de Jogadores */}
          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
              <Users className="w-4 h-4 inline mr-2" />
              M√°ximo de Jogadores
            </label>
            <select
              value={formData.maxPlayers}
              onChange={e =>
                handleInputChange('maxPlayers', parseInt(e.target.value))
              }
              className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={loading}
            >
              {[6, 8, 10, 12, 14, 16].map(num => (
                <option key={num} value={num}>
                  {num} jogadores
                </option>
              ))}
            </select>
          </div>

          {/* M√°ximo de Espectadores */}
          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
              <Eye className="w-4 h-4 inline mr-2" />
              M√°ximo de Espectadores
            </label>
            <select
              value={formData.maxSpectators}
              onChange={e =>
                handleInputChange('maxSpectators', parseInt(e.target.value))
              }
              className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={loading}
            >
              {[0, 4, 8, 12, 16, 20].map(num => (
                <option key={num} value={num}>
                  {num === 0 ? 'Sem espectadores' : `${num} espectadores`}
                </option>
              ))}
            </select>
          </div>
        </div>

        {/* Tipo de Sala */}
        <div>
          <label className="block text-sm font-medium text-slate-300 mb-3">
            Tipo de Sala
          </label>
          <div className="grid grid-cols-2 gap-3">
            <button
              type="button"
              onClick={() => handleInputChange('isPrivate', false)}
              className={`p-4 rounded-lg border-2 transition-all ${!formData.isPrivate
                ? 'border-green-500 bg-green-500/10 text-green-400'
                : 'border-slate-600 bg-slate-700/50 text-slate-300'
                }`}
              disabled={loading}
            >
              <Globe className="w-6 h-6 mx-auto mb-2" />
              <div className="font-medium">P√∫blica</div>
              <div className="text-xs opacity-75">Vis√≠vel no lobby</div>
            </button>

            <button
              type="button"
              onClick={() => handleInputChange('isPrivate', true)}
              className={`p-4 rounded-lg border-2 transition-all ${formData.isPrivate
                ? 'border-blue-500 bg-blue-500/10 text-blue-400'
                : 'border-slate-600 bg-slate-700/50 text-slate-300'
                }`}
              disabled={loading}
            >
              <Lock className="w-6 h-6 mx-auto mb-2" />
              <div className="font-medium">Privada</div>
              <div className="text-xs opacity-75">Apenas por c√≥digo</div>
            </button>
          </div>
        </div>

        {/* Configura√ß√µes Avan√ßadas (colapse) */}
        <div>
          <button
            type="button"
            onClick={() => setShowAdvanced(!showAdvanced)}
            className="flex items-center gap-2 text-slate-300 hover:text-white transition-colors"
            disabled={loading}
          >
            <Settings className="w-4 h-4" />
            Configura√ß√µes Avan√ßadas
            <motion.div
              animate={{ rotate: showAdvanced ? 180 : 0 }}
              transition={{ duration: 0.2 }}
            >
              <X className="w-4 h-4" />
            </motion.div>
          </button>

          {showAdvanced && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              className="mt-4 p-4 bg-slate-800/50 rounded-lg border border-slate-600 space-y-4"
            >
              {/* Modo de Jogo */}
              <div>
                <label className="block text-sm font-medium text-slate-300 mb-2">
                  Modo de Jogo
                </label>
                <select
                  value={settings.gameMode}
                  onChange={e =>
                    handleSettingsChange(
                      'gameMode',
                      e.target.value as RoomSettings['gameMode'],
                    )
                  }
                  className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded text-white"
                  disabled={loading}
                >
                  <option value="CLASSIC">Cl√°ssico</option>
                  <option value="RANKED">Ranqueado</option>
                  <option value="CUSTOM">Personalizado</option>
                </select>
              </div>

              {/* Tempos */}
              <div className="grid grid-cols-3 gap-3">
                <div>
                  <label className="block text-xs text-slate-400 mb-1">
                    Tempo Dia (seg)
                  </label>
                  <input
                    type="number"
                    min={60}
                    max={600}
                    value={settings.timeDay}
                    onChange={e =>
                      handleSettingsChange(
                        'timeDay',
                        parseInt(e.target.value, 10),
                      )
                    }
                    className="w-full px-2 py-1 bg-slate-700 border border-slate-600 rounded text-white text-sm"
                    disabled={loading}
                  />
                </div>

                <div>
                  <label className="block text-xs text-slate-400 mb-1">
                    Tempo Noite (seg)
                  </label>
                  <input
                    type="number"
                    min={30}
                    max={300}
                    value={settings.timeNight}
                    onChange={e =>
                      handleSettingsChange(
                        'timeNight',
                        parseInt(e.target.value, 10),
                      )
                    }
                    className="w-full px-2 py-1 bg-slate-700 border border-slate-600 rounded text-white text-sm"
                    disabled={loading}
                  />
                </div>

                <div>
                  <label className="block text-xs text-slate-400 mb-1">
                    Tempo Vota√ß√£o (seg)
                  </label>
                  <input
                    type="number"
                    min={60}
                    max={300}
                    value={settings.timeVoting}
                    onChange={e =>
                      handleSettingsChange(
                        'timeVoting',
                        parseInt(e.target.value, 10),
                      )
                    }
                    className="w-full px-2 py-1 bg-slate-700 border border-slate-600 rounded text-white text-sm"
                    disabled={loading}
                  />
                </div>
              </div>

              {/* Op√ß√µes */}
              <div className="space-y-2">
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={settings.allowSpectators}
                    onChange={e =>
                      handleSettingsChange('allowSpectators', e.target.checked)
                    }
                    className="rounded"
                    disabled={loading}
                  />
                  <span className="text-sm text-slate-300">
                    Permitir espectadores
                  </span>
                </label>

                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={settings.autoStart}
                    onChange={e =>
                      handleSettingsChange('autoStart', e.target.checked)
                    }
                    className="rounded"
                    disabled={loading}
                  />
                  <span className="text-sm text-slate-300">
                    In√≠cio autom√°tico quando todos estiverem prontos
                  </span>
                </label>
              </div>
            </motion.div>
          )}
        </div>

        {/* Bot√µes */}
        <div className="flex justify-end gap-3 pt-4 border-t border-slate-700">
          <Button variant="ghost" onClick={handleClose} disabled={loading}>
            Cancelar
          </Button>

          <Button
            type="submit"
            variant="primary"
            loading={loading}
            className="min-w-[120px]"
          >
            {loading ? 'Criando...' : 'Criar Sala'}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
</file>

<file path="frontend/src/components/lobby/JoinRoomModal.tsx">
import React, { useState } from 'react';
import { Eye, X } from 'lucide-react';
import { toast } from 'react-hot-toast';
import { motion } from 'framer-motion';
import { useRouter } from 'next/router';

import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';
import { apiService } from '@/services/api';

interface JoinRoomModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function JoinRoomModal({ isOpen, onClose }: JoinRoomModalProps) {
  const router = useRouter();

  const [roomCode, setRoomCode] = useState('');
  const [asSpectator, setAsSpectator] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!roomCode.trim()) {
      toast.error('Informe o c√≥digo da sala');
      return;
    }

    setLoading(true);

    try {
      const response = await apiService.post('/api/rooms/join-by-code', {
        code: roomCode.toUpperCase(),
        asSpectator,
      });

      toast.success(`${asSpectator ? 'Espectando' : 'Entrou na'} sala com sucesso!`);
      onClose();

      // ‚úÖ CORRE√á√ÉO APLICADA AQUI
      const roomId =
        response.data?.data?.room?.id ?? response.data?.room?.id ?? null;

      if (roomId) {
        router.push(`/room/${roomId}`);
      } else {
        console.error(
          'ERRO CR√çTICO: N√£o foi poss√≠vel obter o ID da sala da resposta da API.',
          response.data
        );
        toast.error('Ocorreu um erro ao redirecionar para a sala.');
      }
    } catch (error: any) {
      console.error('Erro ao entrar na sala:', error);
      toast.error(
        error.response?.data?.message || 'Erro inesperado ao entrar na sala'
      );
    } finally {
      setLoading(false);
    }
  };

  const handleClose = () => {
    if (!loading) {
      setRoomCode('');
      setAsSpectator(false);
      onClose();
    }
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title="üîë Entrar em uma Sala"
      size="md"
      variant="medieval"
    >
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* C√≥digo da Sala */}
        <div>
          <label className="block text-sm font-medium text-slate-300 mb-2">
            C√≥digo da Sala
          </label>
          <input
            type="text"
            value={roomCode}
            onChange={(e) => setRoomCode(e.target.value)}
            placeholder="Ex: ABC123"
            maxLength={10}
            className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 uppercase tracking-widest"
            disabled={loading}
          />
        </div>

        {/* Entrar como Espectador */}
        <div className="flex items-center gap-2">
          <input
            id="spectator"
            type="checkbox"
            checked={asSpectator}
            onChange={(e) => setAsSpectator(e.target.checked)}
            className="rounded"
            disabled={loading}
          />
          <label htmlFor="spectator" className="text-sm text-slate-300 flex items-center gap-2">
            <Eye className="w-4 h-4" />
            Entrar como espectador
          </label>
        </div>

        {/* Bot√µes */}
        <div className="flex justify-end gap-3 pt-4 border-t border-slate-700">
          <Button variant="ghost" onClick={handleClose} disabled={loading}>
            Cancelar
          </Button>

          <Button
            type="submit"
            variant="primary"
            loading={loading}
            className="min-w-[120px]"
          >
            {loading ? 'Entrando...' : 'Entrar'}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
</file>

<file path=".env.example">
# üê∫ LOBISOMEM ONLINE - Environment Variables

# =============================================================================
# CORE SETTINGS
# =============================================================================
NODE_ENV=development
PORT=3001

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
DATABASE_URL=postgresql://werewolf:werewolf123@localhost:5432/werewolf_dev
REDIS_URL=redis://localhost:6379

# =============================================================================
# AUTHENTICATION
# =============================================================================
JWT_SECRET=your-super-secret-jwt-key-change-in-production
JWT_EXPIRES_IN=7d

# =============================================================================
# ARCHITECTURE MODE (CR√çTICO PARA MIGRA√á√ÉO)
# =============================================================================
# Fase 1: false | Fase 2: true
DISTRIBUTED_MODE=false

# memory (Fase 1) | redis (Fase 2)
STORAGE_TYPE=memory

# =============================================================================
# SERVICE DISCOVERY (FASE 2)
# =============================================================================
SERVICE_ID=local-server
SERVICE_TYPE=monolith
# monolith | lobby | game

# =============================================================================
# WEBSOCKET CONFIGURATION
# =============================================================================
WS_BASE_PATH=/ws
WS_PORT=3001

# =============================================================================
# GAME SETTINGS
# =============================================================================
MIN_PLAYERS=6
MAX_PLAYERS=15
MAX_SPECTATORS=5
NIGHT_DURATION=60000
DAY_DURATION=120000
VOTING_DURATION=30000

# =============================================================================
# EMAIL (OPCIONAL)
# =============================================================================
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# =============================================================================
# FRONTEND CONFIGURATION
# =============================================================================
NEXT_PUBLIC_API_URL=http://localhost:3001
NEXT_PUBLIC_WS_URL=ws://localhost:3001
</file>

<file path="backend/src/database/init.sql">
-- Garante que a extens√£o para UUIDs seja criada
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tabela de usu√°rios com UUID como chave prim√°ria
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(50) UNIQUE NOT NULL,
    "passwordHash" TEXT NOT NULL, -- "passwordHash" entre aspas por causa do case
    avatar TEXT,
    level INTEGER DEFAULT 1 NOT NULL,
    "totalGames" INTEGER DEFAULT 0 NOT NULL,
    "totalWins" INTEGER DEFAULT 0 NOT NULL,
    "totalLosses" INTEGER DEFAULT 0 NOT NULL,
    "winRate" DECIMAL(5, 4) DEFAULT 0.0000 NOT NULL, -- Maior precis√£o
    "createdAt" TIMESTAMPTZ DEFAULT NOW(), -- TIMESTAMPTZ √© melhor para fusos hor√°rios
    "updatedAt" TIMESTAMPTZ DEFAULT NOW(),
    "lastLoginAt" TIMESTAMPTZ
);

-- Tabela de salas
CREATE TABLE IF NOT EXISTS rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    code VARCHAR(6) UNIQUE,
    "isPrivate" BOOLEAN DEFAULT false NOT NULL,
    "maxPlayers" INTEGER DEFAULT 15 NOT NULL,
    "maxSpectators" INTEGER DEFAULT 5 NOT NULL,
    status VARCHAR(20) DEFAULT 'WAITING' NOT NULL,
    "hostId" UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL, -- Evitar apagar salas se o host for deletado
    "serverId" VARCHAR(50) DEFAULT 'local-server',
    "createdAt" TIMESTAMPTZ DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ DEFAULT NOW()
);

-- √çndices para melhor performance
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_rooms_code ON rooms(code);
CREATE INDEX IF NOT EXISTS idx_rooms_status ON rooms(status);

-- Fun√ß√£o para atualizar o campo "updatedAt" automaticamente
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW."updatedAt" = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers para usar a fun√ß√£o acima
-- Dropa o trigger se ele j√° existir, para evitar erros ao rodar o script de novo
DROP TRIGGER IF EXISTS update_users_updated_at ON users;
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_rooms_updated_at ON rooms;
CREATE TRIGGER update_rooms_updated_at BEFORE UPDATE ON rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="backend/src/game/ActionManager.ts">
// üê∫ LOBISOMEM ONLINE - Action Manager (CORRIGIDO DEFINITIVAMENTE)
import { GameState, Player } from './Game';
import { ROLE_CONFIGURATIONS } from './RoleSystem';
import type { Role, Faction, GamePhase, GameStatus, GameConfig, IGameEngine } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// ACTION INTERFACES (CORRIGIDAS PARA exactOptionalPropertyTypes)
//====================================================================
export interface GameAction {
    id: string;
    playerId: string;
    type: string;
    targetId?: string; // Opcional, pode n√£o existir
    data?: any;
    timestamp: Date;
    phase: string;
    day: number;
    priority: number;
    isValid: boolean;
    processed: boolean;
}

export interface ActionResult {
    success: boolean;
    actionId: string;
    message?: string;
    data?: any;
    errors?: string[];
}

// CORRE√á√ÉO: Interface para NightAction que aceita targetId opcional
export interface NightAction {
    playerId: string;
    type: string;
    targetId?: string; // CORRE√á√ÉO: Opcional, n√£o undefined expl√≠cito
    data?: any;
    priority: number;
}

//====================================================================
// ACTION MANAGER CLASS - CORRIGIDA PARA exactOptionalPropertyTypes
//====================================================================
export class ActionManager {
    private gameState: GameState;
    private pendingActions = new Map<string, GameAction>();
    private processedActions = new Map<string, GameAction>();

    constructor(gameState: GameState) {
        this.gameState = gameState;
    }

    //====================================================================
    // ACTION SUBMISSION
    //====================================================================
    async performAction(playerId: string, actionData: any): Promise<ActionResult> {
        try {
            // Validate player
            const player = this.gameState.getPlayer(playerId);
            if (!player) {
                return {
                    success: false,
                    actionId: '',
                    message: 'Jogador n√£o encontrado',
                    errors: ['PLAYER_NOT_FOUND'],
                };
            }

            // Validate basic requirements
            const validation = this.validateAction(player, actionData);
            if (!validation.success) {
                return validation;
            }

            // Create action
            const action = this.createAction(player, actionData);

            // Process action based on phase
            if (this.gameState.phase === 'NIGHT') {
                return await this.processNightAction(action);
            } else if (this.gameState.phase === 'VOTING') {
                return await this.processVotingAction(action);
            } else {
                return {
                    success: false,
                    actionId: action.id,
                    message: 'A√ß√µes n√£o permitidas nesta fase',
                    errors: ['INVALID_PHASE'],
                };
            }

        } catch (error) {
            logger.error('Error performing action', error instanceof Error ? error : new Error('Unknown action error'), {
                playerId,
                actionData,
                gameId: this.gameState.gameId,
            });

            return {
                success: false,
                actionId: '',
                message: 'Erro interno ao processar a√ß√£o',
                errors: ['INTERNAL_ERROR'],
            };
        }
    }

    //====================================================================
    // ACTION VALIDATION
    //====================================================================
    private validateAction(player: Player, actionData: any): ActionResult {
        // Check if player is alive
        if (!player.isAlive && actionData.type !== 'SPECTATE') {
            return {
                success: false,
                actionId: '',
                message: 'Jogadores mortos n√£o podem realizar a√ß√µes',
                errors: ['PLAYER_DEAD'],
            };
        }

        // Check if player can act
        if (!player.canAct() && actionData.type !== 'VOTE' && actionData.type !== 'UNVOTE') {
            return {
                success: false,
                actionId: '',
                message: 'Voc√™ n√£o pode realizar a√ß√µes neste momento',
                errors: ['CANNOT_ACT'],
            };
        }

        // Check action type validity
        if (!this.isValidActionType(actionData.type)) {
            return {
                success: false,
                actionId: '',
                message: 'Tipo de a√ß√£o inv√°lido',
                errors: ['INVALID_ACTION_TYPE'],
            };
        }

        // Check phase-specific permissions
        if (!this.canPerformActionInPhase(player.role, actionData.type, this.gameState.phase)) {
            return {
                success: false,
                actionId: '',
                message: 'A√ß√£o n√£o permitida nesta fase',
                errors: ['INVALID_PHASE_FOR_ACTION'],
            };
        }

        // Check if target is valid (if action requires target)
        if (this.requiresTarget(actionData.type)) {
            const targetValidation = this.validateTarget(player, actionData);
            if (!targetValidation.success) {
                return targetValidation;
            }
        }

        return { success: true, actionId: '' };
    }

    private validateTarget(player: Player, actionData: any): ActionResult {
        if (!actionData.targetId) {
            return {
                success: false,
                actionId: '',
                message: 'Alvo √© obrigat√≥rio para esta a√ß√£o',
                errors: ['TARGET_REQUIRED'],
            };
        }

        const target = this.gameState.getPlayer(actionData.targetId);
        if (!target) {
            return {
                success: false,
                actionId: '',
                message: 'Alvo n√£o encontrado',
                errors: ['TARGET_NOT_FOUND'],
            };
        }

        // Check if target is alive (for most actions)
        if (!target.isAlive && !['INVESTIGATE'].includes(actionData.type)) {
            return {
                success: false,
                actionId: '',
                message: 'N√£o √© poss√≠vel ter como alvo um jogador morto',
                errors: ['TARGET_DEAD'],
            };
        }

        // Check self-targeting rules
        if (player.id === target.id && !this.allowsSelfTarget(actionData.type)) {
            return {
                success: false,
                actionId: '',
                message: 'Voc√™ n√£o pode ter a si mesmo como alvo',
                errors: ['CANNOT_SELF_TARGET'],
            };
        }

        // Role-specific target validations
        const roleValidation = this.validateRoleSpecificTarget(player, target, actionData);
        if (!roleValidation.success) {
            return roleValidation;
        }

        return { success: true, actionId: '' };
    }

    private validateRoleSpecificTarget(player: Player, target: Player, actionData: any): ActionResult {
        switch (actionData.type) {
            case 'PROTECT':
                // Doctor can't protect same person twice in a row
                if (!target.canBeProtectedByDoctor) {
                    return {
                        success: false,
                        actionId: '',
                        message: 'N√£o √© poss√≠vel proteger a mesma pessoa duas noites seguidas',
                        errors: ['CANNOT_PROTECT_CONSECUTIVELY'],
                    };
                }
                break;

            case 'WEREWOLF_KILL':
                // Werewolves can't kill other werewolves
                if (target.faction === 'WEREWOLF') {
                    return {
                        success: false,
                        actionId: '',
                        message: 'Lobisomens n√£o podem atacar outros lobisomens',
                        errors: ['CANNOT_KILL_WEREWOLF'],
                    };
                }
                break;

            case 'VOTE':
                // Can't vote for yourself
                if (player.id === target.id) {
                    return {
                        success: false,
                        actionId: '',
                        message: 'Voc√™ n√£o pode votar em si mesmo',
                        errors: ['CANNOT_VOTE_SELF'],
                    };
                }
                break;
        }

        return { success: true, actionId: '' };
    }

    //====================================================================
    // ACTION CREATION
    //====================================================================
    private createAction(player: Player, actionData: any): GameAction {
        const actionId = `${this.gameState.gameId}-${player.id}-${actionData.type}-${Date.now()}`;

        const action: GameAction = {
            id: actionId,
            playerId: player.id,
            type: actionData.type,
            // CORRE√á√ÉO: S√≥ incluir targetId se existir, evitando undefined expl√≠cito
            ...(actionData.targetId && { targetId: actionData.targetId }),
            data: actionData.data || {},
            timestamp: new Date(),
            phase: this.gameState.phase,
            day: this.gameState.day,
            priority: this.getActionPriority(actionData.type),
            isValid: true,
            processed: false,
        };

        return action;
    }

    //====================================================================
    // NIGHT ACTIONS
    //====================================================================
    private async processNightAction(action: GameAction): Promise<ActionResult> {
        const player = this.gameState.getPlayer(action.playerId);
        if (!player) {
            return {
                success: false,
                actionId: action.id,
                message: 'Jogador n√£o encontrado',
                errors: ['PLAYER_NOT_FOUND'],
            };
        }

        // Mark player as having acted
        player.performAction(action.type, action.targetId);

        // Store action for processing at end of night
        this.pendingActions.set(action.id, action);

        // CORRE√á√ÉO: Criar NightAction corretamente, s√≥ incluindo targetId se existir
        const nightAction: NightAction = {
            playerId: action.playerId,
            type: action.type,
            // CORRE√á√ÉO: S√≥ incluir targetId se realmente existir
            ...(action.targetId && { targetId: action.targetId }),
            data: action.data,
            priority: action.priority,
        };

        this.gameState.nightActions.push(nightAction);

        // Log the action
        logger.info('Night action queued', {
            gameId: this.gameState.gameId,
            actionId: action.id,
            playerId: action.playerId,
            type: action.type,
            targetId: action.targetId,
        });

        // Send confirmation to player
        this.gameState.addEvent('ACTION_SUBMITTED', {
            actionId: action.id,
            type: action.type,
            message: this.getActionConfirmationMessage(action.type),
        }, [action.playerId]);

        return {
            success: true,
            actionId: action.id,
            message: this.getActionConfirmationMessage(action.type),
        };
    }

    //====================================================================
    // VOTING ACTIONS
    //====================================================================
    private async processVotingAction(action: GameAction): Promise<ActionResult> {
        if (action.type === 'VOTE') {
            return await this.processVote(action);
        } else if (action.type === 'UNVOTE') {
            return await this.processUnvote(action);
        } else {
            return {
                success: false,
                actionId: action.id,
                message: 'A√ß√£o n√£o permitida durante vota√ß√£o',
                errors: ['INVALID_VOTING_ACTION'],
            };
        }
    }

    private async processVote(action: GameAction): Promise<ActionResult> {
        if (!action.targetId) {
            return {
                success: false,
                actionId: action.id,
                message: 'Alvo √© obrigat√≥rio para vota√ß√£o',
                errors: ['TARGET_REQUIRED'],
            };
        }

        const success = this.gameState.addVote(action.playerId, action.targetId);

        if (success) {
            this.processedActions.set(action.id, action);

            const target = this.gameState.getPlayer(action.targetId);
            logger.info('Vote cast', {
                gameId: this.gameState.gameId,
                voterId: action.playerId,
                targetId: action.targetId,
                targetName: target?.username,
            });

            return {
                success: true,
                actionId: action.id,
                message: `Voto registrado em ${target?.username}`,
                data: {
                    targetName: target?.username,
                    voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
                },
            };
        } else {
            return {
                success: false,
                actionId: action.id,
                message: 'Falha ao registrar voto',
                errors: ['VOTE_FAILED'],
            };
        }
    }

    private async processUnvote(action: GameAction): Promise<ActionResult> {
        const success = this.gameState.removeVote(action.playerId);

        if (success) {
            this.processedActions.set(action.id, action);

            logger.info('Vote removed', {
                gameId: this.gameState.gameId,
                voterId: action.playerId,
            });

            return {
                success: true,
                actionId: action.id,
                message: 'Voto removido',
                data: {
                    voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
                },
            };
        } else {
            return {
                success: false,
                actionId: action.id,
                message: 'Falha ao remover voto',
                errors: ['UNVOTE_FAILED'],
            };
        }
    }

    //====================================================================
    // ACTION VALIDATION HELPERS
    //====================================================================
    private isValidActionType(type: string): boolean {
        const validTypes = [
            'INVESTIGATE', 'PROTECT', 'WEREWOLF_KILL', 'VIGILANTE_KILL',
            'SERIAL_KILL', 'VOTE', 'UNVOTE', 'SPECTATE'
        ];
        return validTypes.includes(type);
    }

    private canPerformActionInPhase(role: Role | undefined, actionType: string, phase: string): boolean {
        if (!role) return false;

        const roleConfig = ROLE_CONFIGURATIONS[role];

        // Special cases for voting
        if (actionType === 'VOTE' || actionType === 'UNVOTE') {
            return phase === 'VOTING';
        }

        // Night actions
        if (phase === 'NIGHT') {
            return roleConfig.actsDuring.includes('NIGHT') && this.isNightAction(actionType);
        }

        return false;
    }

    private isNightAction(actionType: string): boolean {
        const nightActions = ['INVESTIGATE', 'PROTECT', 'WEREWOLF_KILL', 'VIGILANTE_KILL', 'SERIAL_KILL'];
        return nightActions.includes(actionType);
    }

    private requiresTarget(actionType: string): boolean {
        const targetActions = ['INVESTIGATE', 'PROTECT', 'WEREWOLF_KILL', 'VIGILANTE_KILL', 'SERIAL_KILL', 'VOTE'];
        return targetActions.includes(actionType);
    }

    private allowsSelfTarget(actionType: string): boolean {
        const selfTargetActions = ['PROTECT']; // Doctor can protect themselves
        return selfTargetActions.includes(actionType);
    }

    private getActionPriority(actionType: string): number {
        const priorities: Record<string, number> = {
            'PROTECT': 1,        // Protections first
            'INVESTIGATE': 3,    // Investigations
            'WEREWOLF_KILL': 5,  // Werewolf kills
            'VIGILANTE_KILL': 4, // Vigilante kills
            'SERIAL_KILL': 6,    // Serial killer last
            'VOTE': 1,           // Votes are immediate
            'UNVOTE': 1,         // Unvotes are immediate
        };

        return priorities[actionType] || 999;
    }

    private getActionConfirmationMessage(actionType: string): string {
        const messages: Record<string, string> = {
            'INVESTIGATE': 'Investiga√ß√£o programada para esta noite',
            'PROTECT': 'Prote√ß√£o programada para esta noite',
            'WEREWOLF_KILL': 'Ataque programado para esta noite',
            'VIGILANTE_KILL': 'Execu√ß√£o programada para esta noite',
            'SERIAL_KILL': 'Assassinato programado para esta noite',
            'VOTE': 'Voto registrado',
            'UNVOTE': 'Voto removido',
        };

        return messages[actionType] || 'A√ß√£o programada';
    }

    //====================================================================
    // ACTION PROCESSING UTILITIES
    //====================================================================
    getAllPendingActions(): GameAction[] {
        return Array.from(this.pendingActions.values())
            .sort((a, b) => a.priority - b.priority);
    }

    clearPendingActions(): void {
        // Move pending to processed
        this.pendingActions.forEach((action, id) => {
            action.processed = true;
            this.processedActions.set(id, action);
        });

        this.pendingActions.clear();
    }

    getActionHistory(playerId?: string): GameAction[] {
        const allActions = Array.from(this.processedActions.values());

        if (playerId) {
            return allActions.filter(action => action.playerId === playerId);
        }

        return allActions;
    }

    //====================================================================
    // STATISTICS AND MONITORING
    //====================================================================
    getActionStats(): {
        total: number;
        pending: number;
        processed: number;
        byType: Record<string, number>;
        byPhase: Record<string, number>;
    } {
        const allActions = [
            ...Array.from(this.pendingActions.values()),
            ...Array.from(this.processedActions.values())
        ];

        const stats = {
            total: allActions.length,
            pending: this.pendingActions.size,
            processed: this.processedActions.size,
            byType: {} as Record<string, number>,
            byPhase: {} as Record<string, number>,
        };

        allActions.forEach(action => {
            stats.byType[action.type] = (stats.byType[action.type] || 0) + 1;
            stats.byPhase[action.phase] = (stats.byPhase[action.phase] || 0) + 1;
        });

        return stats;
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    cleanup(): void {
        this.pendingActions.clear();
        this.processedActions.clear();
        logger.info('ActionManager cleanup completed');
    }

    
}
</file>

<file path="backend/src/game/Game.ts">
// üê∫ LOBISOMEM ONLINE - Game Core Classes (CORRIGIDO)
// ‚úÖ COMPAT√çVEL com types/index.ts
// CORRE√á√ÉO 1: Importar os enums necess√°rios
import { Role, Faction, GamePhase } from '@/utils/constants';
import type { GameConfig, GameEvent, NightAction, GameStatus } from '@/types';
// CORRE√á√ÉO 2: Importar ROLE_CONFIGURATIONS no topo do arquivo
import { RoleRevealManager, WinConditionCalculator, ROLE_CONFIGURATIONS } from './RoleSystem';

//====================================================================
// PLAYER CLASS - COMPAT√çVEL COM INTERFACE
//====================================================================
export class Player {
    public id: string;
    public userId: string;
    public username: string;
    public avatar?: string;
    public isHost: boolean;
    public isReady: boolean;
    public isSpectator: boolean;
    public isConnected: boolean;
    public joinedAt: Date;
    public lastSeen: Date;

    // Game-specific properties
    public role?: Role;
    public faction?: Faction;
    public isAlive: boolean = true;
    public isProtected: boolean = false;
    public hasActed: boolean = false;
    public hasVoted: boolean = false;
    public votedFor?: string;
    public actionsUsed: number = 0;
    public maxActions?: number;

    // Tracking
    public lastAction?: string;
    public protectedByDoctor: boolean = false;
    public canBeProtectedByDoctor: boolean = true;
    public investigatedBy: string[] = [];
    public killedBy?: string;
    public eliminationReason?: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER';

    constructor(data: {
        id: string;
        userId: string;
        username: string;
        avatar?: string;
        isHost: boolean;
        isReady: boolean;
        isSpectator: boolean;
        isConnected: boolean;
        joinedAt: Date;
        lastSeen: Date;
    }) {
        this.id = data.id;
        this.userId = data.userId;
        this.username = data.username;
        // CORRE√á√ÉO 3: Apenas atribuir a propriedade se o valor n√£o for undefined
        if (data.avatar !== undefined) {
            this.avatar = data.avatar;
        }
        this.isHost = data.isHost;
        this.isReady = data.isReady;
        this.isSpectator = data.isSpectator;
        this.isConnected = data.isConnected;
        this.joinedAt = data.joinedAt;
        this.lastSeen = data.lastSeen;
    }

    // Player actions
    assignRole(role: Role, faction: Faction, maxActions?: number): void {
        this.role = role;
        this.faction = faction;
        // CORRE√á√ÉO 3: Apenas atribuir a propriedade se o valor n√£o for undefined
        if (maxActions !== undefined) {
            this.maxActions = maxActions;
        }
        this.actionsUsed = 0;
        this.hasActed = false;
    }

    canAct(): boolean {
        if (!this.isAlive || !this.role) return false;
        if (this.hasActed) return false;
        if (this.maxActions !== undefined && this.actionsUsed >= this.maxActions) return false;

        // CORRE√á√ÉO 2: Usar a importa√ß√£o do topo do arquivo em vez de 'require'
        const roleConfig = ROLE_CONFIGURATIONS[this.role];
        return roleConfig?.canAct || false;
    }

    performAction(action: string, targetId?: string): boolean {
        if (!this.canAct()) return false;

        this.hasActed = true;
        this.lastAction = action;
        this.actionsUsed++;

        return true;
    }

    kill(reason: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER', killedBy?: string): void {
        this.isAlive = false;
        this.eliminationReason = reason;
        // CORRE√á√ÉO 3: Apenas atribuir a propriedade se o valor n√£o for undefined
        if (killedBy !== undefined) {
            this.killedBy = killedBy;
        }
        this.hasVoted = false;
        // CORRE√á√ÉO 4: Usar 'delete' para remover a propriedade opcional
        delete this.votedFor;
    }

    protect(): void {
        this.isProtected = true;
        this.protectedByDoctor = true;
    }

    removeProtection(): void {
        this.isProtected = false;
        this.protectedByDoctor = false;
    }

    vote(targetId: string): boolean {
        if (!this.isAlive) return false;
        this.hasVoted = true;
        this.votedFor = targetId;
        return true;
    }

    unvote(): boolean {
        if (!this.isAlive) return false;
        this.hasVoted = false;
        // CORRE√á√ÉO 4: Usar 'delete' para remover a propriedade opcional
        delete this.votedFor;
        return true;
    }

    resetForNewPhase(): void {
        this.hasActed = false;
        this.hasVoted = false;
        // CORRE√á√ÉO 4: Usar 'delete' para remover a propriedade opcional
        delete this.votedFor;
        this.removeProtection();
        this.canBeProtectedByDoctor = !this.protectedByDoctor;
    }

    // Utility methods
    getPublicInfo(): any {
        const info: any = {
            id: this.id,
            userId: this.userId,
            username: this.username,
            isHost: this.isHost,
            isReady: this.isReady,
            isSpectator: this.isSpectator,
            isConnected: this.isConnected,
            isAlive: this.isAlive,
            hasVoted: this.hasVoted,
            joinedAt: this.joinedAt,
            lastSeen: this.lastSeen,
        };
        if (this.avatar) info.avatar = this.avatar;
        if (this.votedFor) info.votedFor = this.votedFor;
        return info;
    }

    getPrivateInfo(): any {
        const info = {
            ...this.getPublicInfo(),
            isProtected: this.isProtected,
            hasActed: this.hasActed,
            actionsUsed: this.actionsUsed,
        };
        if (this.role) info.role = this.role;
        if (this.faction) info.faction = this.faction;
        if (this.maxActions) info.maxActions = this.maxActions;
        if (this.lastAction) info.lastAction = this.lastAction;
        if (this.eliminationReason) info.eliminationReason = this.eliminationReason;
        if (this.killedBy) info.killedBy = this.killedBy;
        return info;
    }
}

//====================================================================
// GAME STATE CLASS - REFATORADA PARA COMPATIBILIDADE
//====================================================================
export class GameState {
    public gameId: string;
    public roomId: string;
    public status: GameStatus;
    public phase: GamePhase;
    public day: number;
    public phaseStartTime: Date;
    public phaseEndTime: Date;
    public timeLeft: number; // milliseconds

    private playersMap: Map<string, Player>;
    private spectatorsSet: Set<string>;
    private eliminatedPlayersMap: Map<string, Player>;
    private votesMap: Map<string, string>; // voterId -> targetId

    public hostId: string;
    public config: GameConfig;
    public events: GameEvent[];
    public nightActions: NightAction[];

    public createdAt: Date;
    public updatedAt: Date;
    public startedAt?: Date;
    public finishedAt?: Date;

    public winningFaction?: Faction;
    public winningPlayers: string[] = [];

    constructor(gameId: string, config: GameConfig, hostId: string) {
        this.gameId = gameId;
        this.roomId = config.roomId;
        this.status = 'WAITING';
        // CORRE√á√ÉO 5: Usar o enum GamePhase
        this.phase = GamePhase.LOBBY;
        this.day = 0;
        this.phaseStartTime = new Date();
        this.phaseEndTime = new Date();
        this.timeLeft = 0;

        this.playersMap = new Map();
        this.spectatorsSet = new Set();
        this.eliminatedPlayersMap = new Map();
        this.votesMap = new Map();

        this.hostId = hostId;
        this.config = config;
        this.events = [];
        this.nightActions = [];

        this.createdAt = new Date();
        this.updatedAt = new Date();
    }

    // Getters para compatibilidade com a interface
    get players(): Player[] {
        return Array.from(this.playersMap.values());
    }

    get spectators(): string[] {
        return Array.from(this.spectatorsSet);
    }

    get eliminatedPlayers(): Player[] {
        return Array.from(this.eliminatedPlayersMap.values());
    }

    get votes(): Record<string, string> {
        return Object.fromEntries(this.votesMap);
    }

    addPlayer(player: Player): boolean {
        if (this.playersMap.size >= this.config.maxPlayers) return false;
        if (this.status !== 'WAITING') return false;

        this.playersMap.set(player.id, player);
        this.updatedAt = new Date();

        this.addEvent('PLAYER_JOINED', {
            playerId: player.id,
            username: player.username,
            playerCount: this.playersMap.size,
        });

        return true;
    }

    removePlayer(playerId: string): boolean {
        const player = this.playersMap.get(playerId);
        if (!player) return false;

        this.playersMap.delete(playerId);

        if (this.status === 'PLAYING') {
            this.eliminatedPlayersMap.set(playerId, player);
        }

        this.updatedAt = new Date();

        this.addEvent('PLAYER_LEFT', {
            playerId: player.id,
            username: player.username,
            playerCount: this.playersMap.size,
        });

        return true;
    }

    getPlayer(playerId: string): Player | undefined {
        return this.playersMap.get(playerId);
    }

    getAlivePlayers(): Player[] {
        return Array.from(this.playersMap.values()).filter(p => p.isAlive && !p.isSpectator);
    }

    getDeadPlayers(): Player[] {
        return Array.from(this.playersMap.values()).filter(p => !p.isAlive && !p.isSpectator);
    }

    canStart(): boolean {
        const alivePlayers = this.getAlivePlayers();
        return alivePlayers.length >= 6 && alivePlayers.length <= 15 &&
            alivePlayers.every(p => p.isReady) && this.status === 'WAITING';
    }

    start(): boolean {
        if (!this.canStart()) return false;

        this.status = 'STARTING';
        this.startedAt = new Date();
        this.updatedAt = new Date();

        this.addEvent('GAME_STARTING', {
            playerCount: this.getAlivePlayers().length,
        });

        return true;
    }

    changePhase(newPhase: GamePhase, duration: number): void {
        this.phase = newPhase;
        this.phaseStartTime = new Date();
        this.phaseEndTime = new Date(Date.now() + duration);
        this.timeLeft = duration;
        this.updatedAt = new Date();

        if (newPhase === GamePhase.DAY) {
            this.day++;
        }

        this.playersMap.forEach(player => player.resetForNewPhase());
        this.votesMap.clear();

        this.addEvent('PHASE_CHANGED', {
            phase: newPhase,
            day: this.day,
            duration,
            timeLeft: this.timeLeft,
        });
    }

    updateTimeLeft(): void {
        this.timeLeft = Math.max(0, this.phaseEndTime.getTime() - Date.now());
        this.updatedAt = new Date();
    }

    isPhaseExpired(): boolean {
        return Date.now() >= this.phaseEndTime.getTime();
    }

    addVote(voterId: string, targetId: string): boolean {
        const voter = this.playersMap.get(voterId);
        const target = this.playersMap.get(targetId);

        if (!voter || !target || !voter.isAlive || !target.isAlive) return false;
        if (this.phase !== GamePhase.VOTING) return false;

        this.votesMap.set(voterId, targetId);
        voter.vote(targetId);

        this.addEvent('VOTE_CAST', {
            voterId,
            targetId,
            voterUsername: voter.username,
            targetUsername: target.username,
        });

        return true;
    }

    removeVote(voterId: string): boolean {
        const voter = this.playersMap.get(voterId);
        if (!voter || !voter.isAlive) return false;

        const targetId = this.votesMap.get(voterId);
        this.votesMap.delete(voterId);
        voter.unvote();

        if (targetId) {
            const target = this.playersMap.get(targetId);
            this.addEvent('VOTE_REMOVED', {
                voterId,
                targetId,
                voterUsername: voter.username,
                targetUsername: target?.username,
            });
        }

        return true;
    }

    getVoteCounts(): Map<string, number> {
        const counts = new Map<string, number>();
        this.votesMap.forEach((targetId) => {
            counts.set(targetId, (counts.get(targetId) || 0) + 1);
        });
        return counts;
    }

    getMostVotedPlayer(): { playerId: string; votes: number } | null {
        const counts = this.getVoteCounts();
        let maxVotes = 0;
        let mostVoted: string | null = null;
        let tieCount = 0;

        counts.forEach((votes, playerId) => {
            if (votes > maxVotes) {
                maxVotes = votes;
                mostVoted = playerId;
                tieCount = 1;
            } else if (votes === maxVotes) {
                tieCount++;
            }
        });

        if (tieCount > 1 || !mostVoted || maxVotes === 0) return null;

        return { playerId: mostVoted, votes: maxVotes };
    }

    addEvent(type: string, data: any, visibleTo?: string[]): void {
        // CORRE√á√ÉO 6: Usar spread condicional para a propriedade opcional 'visibleTo'
        const event: GameEvent = {
            id: `${this.gameId}-${this.events.length}`,
            type,
            phase: this.phase,
            day: this.day,
            timestamp: new Date(),
            data,
            ...(visibleTo && { visibleTo }),
        };

        this.events.push(event);
        this.updatedAt = new Date();
    }

    getEventsForPlayer(playerId: string): GameEvent[] {
        return this.events.filter(event =>
            !event.visibleTo || event.visibleTo.includes(playerId)
        );
    }

    checkWinCondition(): { hasWinner: boolean; winningFaction?: Faction; winningPlayers?: string[] } {
        const alivePlayers = this.getAlivePlayers();
        return WinConditionCalculator.calculateWinCondition(
            alivePlayers.map(p => ({ playerId: p.id, role: p.role! }))
        );
    }

    endGame(winningFaction?: Faction, winningPlayers?: string[]): void {
        this.status = 'FINISHED';
        this.finishedAt = new Date();
        this.updatedAt = new Date();
        // Apenas define as propriedades se elas existirem
        if (winningFaction) {
            this.winningFaction = winningFaction;
        }
        if (winningPlayers) {
            this.winningPlayers = winningPlayers;
        }

        this.addEvent('GAME_ENDED', {
            winningFaction,
            winningPlayers,
            totalDays: this.day,
            duration: this.finishedAt.getTime() - (this.startedAt?.getTime() || 0),
        });
    }

    toJSON(): any {
        return {
            gameId: this.gameId,
            roomId: this.roomId,
            status: this.status,
            phase: this.phase,
            day: this.day,
            phaseStartTime: this.phaseStartTime,
            phaseEndTime: this.phaseEndTime,
            timeLeft: this.timeLeft,
            players: this.players,
            spectators: this.spectators,
            eliminatedPlayers: this.eliminatedPlayers,
            hostId: this.hostId,
            config: this.config,
            events: this.events,
            votes: this.votes,
            nightActions: this.nightActions,
            createdAt: this.createdAt,
            updatedAt: this.updatedAt,
            startedAt: this.startedAt,
            finishedAt: this.finishedAt,
            winningFaction: this.winningFaction,
            winningPlayers: this.winningPlayers,
        };
    }
}
</file>

<file path="backend/src/game/GameEngine.ts">
// üê∫ LOBISOMEM ONLINE - Game Engine (CORRIGIDO)
import { GameState, Player } from './Game';
import { RoleDistributor, WinConditionCalculator } from './RoleSystem';
// CORRE√á√ÉO 1: Remover 'GameStatus' da importa√ß√£o de 'constants'
import { Role, Faction, GamePhase } from '@/utils/constants';
// CORRE√á√ÉO 1: Importar os tipos necess√°rios diretamente de 'types'
import type { GameConfig, IGameEngine, GameResults, GameStatus } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// GAME ENGINE IMPLEMENTATION - CORRIGIDA
//====================================================================
export class GameEngine implements IGameEngine {
    private games = new Map<string, GameState>();
    private eventHandlers = new Map<string, Map<string, ((data: any) => void)[]>>();

    constructor() {
        logger.info('GameEngine initialized');
    }

    //====================================================================
    // GAME LIFECYCLE
    //====================================================================
    async createGame(hostId: string, config: GameConfig): Promise<GameState> {
        const gameId = `game-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        try {
            const gameState = new GameState(gameId, config, hostId);

            this.games.set(gameId, gameState);
            this.eventHandlers.set(gameId, new Map());

            logger.info('Game created', { gameId, hostId, roomId: config.roomId });

            this.emitGameEvent(gameId, 'game:created', {
                gameId,
                hostId,
                roomId: config.roomId,
                config,
            });

            return gameState;
        } catch (error) {
            logger.error('Failed to create game', error instanceof Error ? error : new Error('Unknown game creation error'), { hostId, config });
            throw error;
        }
    }

    async startGame(gameId: string): Promise<boolean> {
        const gameState = this.games.get(gameId);
        if (!gameState) {
            logger.warn('Attempted to start non-existent game', { gameId });
            return false;
        }

        if (!gameState.canStart()) {
            logger.warn('Game cannot start - requirements not met', {
                gameId,
                playerCount: gameState.getAlivePlayers().length,
                allReady: gameState.getAlivePlayers().every(p => p.isReady),
                status: gameState.status,
            });
            return false;
        }

        try {
            gameState.start();

            const players = gameState.getAlivePlayers();
            const distribution = RoleDistributor.getRoleDistribution(players.length);
            const roleAssignments = RoleDistributor.distributeRolesToPlayers(
                players.map(p => p.id),
                distribution
            );

            roleAssignments.forEach((role, playerId) => {
                const player = gameState.getPlayer(playerId);
                if (player) {
                    const roleConfig = RoleDistributor.getRoleConfig(role);
                    player.assignRole(role, roleConfig.faction, roleConfig.maxActions);
                }
            });

            // CORRE√á√ÉO 1: Usar a string literal em vez do enum inexistente
            gameState.status = 'PLAYING';

            await this.startFirstNight(gameState);

            logger.info('Game started successfully', {
                gameId,
                playerCount: players.length,
                distribution,
            });

            this.emitGameEvent(gameId, 'game:started', {
                gameId,
                players: players.map(p => ({
                    id: p.id,
                    username: p.username,
                    role: p.role,
                })),
                distribution,
            });

            return true;
        } catch (error) {
            logger.error('Failed to start game', error instanceof Error ? error : new Error('Unknown game start error'), { gameId });
            return false;
        }
    }

    async endGame(gameId: string, reason?: string): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState || gameState.status === 'FINISHED') return; // Se j√° terminou, n√£o faz nada.

        try {
            // Tenta determinar um vencedor no momento em que o jogo termina.
            const alivePlayers = gameState.getAlivePlayers();
            const winCondition = WinConditionCalculator.calculateWinCondition(
                alivePlayers.map(p => ({ playerId: p.id, role: p.role! }))
            );

            // Chama o m√©todo endGame do GameState, passando o vencedor se houver, ou nada se n√£o houver.
            gameState.endGame(winCondition.winningFaction, winCondition.winningPlayers);

            logger.info('Game ended', {
                gameId,
                winningFaction: gameState.winningFaction,
                winningPlayers: gameState.winningPlayers,
                reason,
                totalDays: gameState.day,
            });

            this.emitGameEvent(gameId, 'game:ended', {
                gameId,
                winningFaction: gameState.winningFaction,
                winningPlayers: gameState.winningPlayers,
                reason,
                totalDays: gameState.day,
                finalResults: this.generateGameResults(gameState),
            });

        } catch (error) {
            logger.error('Error ending game', error instanceof Error ? error : new Error('Unknown game end error'), { gameId });
        }
    }

    //====================================================================
    // PLAYER MANAGEMENT
    //====================================================================
    async addPlayer(gameId: string, player: Player): Promise<boolean> {
        const gameState = this.games.get(gameId);
        if (!gameState) return false;

        const success = gameState.addPlayer(player);

        if (success) {
            logger.info('Player added to game', {
                gameId,
                playerId: player.id,
                username: player.username,
                isSpectator: player.isSpectator,
            });

            this.emitGameEvent(gameId, 'player:joined', {
                gameId,
                player: player.getPublicInfo(),
            });
        }

        return success;
    }

    async removePlayer(gameId: string, playerId: string): Promise<boolean> {
        const gameState = this.games.get(gameId);
        if (!gameState) return false;

        const player = gameState.getPlayer(playerId);
        const success = gameState.removePlayer(playerId);

        if (success && player) {
            logger.info('Player removed from game', {
                gameId,
                playerId,
                username: player.username,
            });

            this.emitGameEvent(gameId, 'player:left', {
                gameId,
                playerId,
                username: player.username,
            });

            // CORRE√á√ÉO 1: Usar a string literal
            if (gameState.status === 'PLAYING') {
                const alivePlayers = gameState.getAlivePlayers();
                if (alivePlayers.length < 3) {
                    await this.endGame(gameId, 'Insufficient players');
                    return true;
                }
                await this.checkWinCondition(gameId);
            }
        }

        return success;
    }

    //====================================================================
    // GAME STATE MANAGEMENT
    //====================================================================
    async getGameState(gameId: string): Promise<GameState | null> {
        return this.games.get(gameId) || null;
    }

    async updateGameState(gameId: string, updates: Partial<GameState>): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) return;

        Object.assign(gameState, updates, { updatedAt: new Date() });

        this.emitGameEvent(gameId, 'game:state-updated', {
            gameId,
            updates,
        });
    }

    //====================================================================
    // PLAYER ACTIONS
    //====================================================================
    async performPlayerAction(gameId: string, playerId: string, action: any): Promise<boolean> {
        const gameState = this.games.get(gameId);
        if (!gameState) return false;

        const player = gameState.getPlayer(playerId);
        if (!player || !player.isAlive) return false;

        if (gameState.phase === GamePhase.NIGHT && player.canAct()) {
            return player.performAction(action.type, action.targetId);
        }

        return false;
    }

    //====================================================================
    // PHASE MANAGEMENT
    //====================================================================
    async nextPhase(gameId: string): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) return;

        const currentPhase = gameState.phase;

        try {
            switch (currentPhase) {
                case GamePhase.NIGHT:
                    await this.processNightResults(gameState);
                    await this.changePhase(gameState, GamePhase.DAY, gameState.config.dayDuration);
                    break;

                case GamePhase.DAY:
                    await this.changePhase(gameState, GamePhase.VOTING, gameState.config.votingDuration);
                    break;

                case GamePhase.VOTING:
                    await this.processVotingResults(gameState);
                    // CORRE√á√ÉO 1: Usar a string literal
                    if (gameState.status === 'PLAYING') {
                        await this.changePhase(gameState, GamePhase.NIGHT, gameState.config.nightDuration);
                    }
                    break;

                default:
                    break;
            }

            await this.checkWinCondition(gameId);
        } catch (error) {
            logger.error('Error during phase transition', error instanceof Error ? error : new Error('Unknown phase error'), {
                gameId,
                currentPhase,
            });
        }
    }

    //====================================================================
    // PHASE TRANSITION HELPERS
    //====================================================================
    private async startFirstNight(gameState: GameState): Promise<void> {
        await this.changePhase(gameState, GamePhase.NIGHT, gameState.config.nightDuration);

        gameState.addEvent('FIRST_NIGHT_STARTED', {
            message: 'A primeira noite chegou √† vila. Os poderes especiais acordam...',
        });
    }

    private async changePhase(gameState: GameState, newPhase: GamePhase, duration: number): Promise<void> {
        gameState.changePhase(newPhase, duration);

        setTimeout(() => {
            this.nextPhase(gameState.gameId);
        }, duration);

        this.emitGameEvent(gameState.gameId, 'phase:changed', {
            gameId: gameState.gameId,
            phase: newPhase,
            duration,
            timeLeft: duration,
        });
    }

    private async processNightResults(gameState: GameState): Promise<void> {
        const deaths: string[] = [];

        gameState.nightActions.forEach(action => {
            if (action.type === 'WEREWOLF_KILL' && action.targetId) {
                const target = gameState.getPlayer(action.targetId);
                if (target && target.isAlive && !target.isProtected) {
                    target.kill('NIGHT_KILL');
                    deaths.push(action.targetId);
                }
            }
        });

        gameState.nightActions = [];

        if (deaths.length > 0) {
            deaths.forEach(playerId => {
                const player = gameState.getPlayer(playerId);
                if (player) {
                    gameState.addEvent('PLAYER_DIED', {
                        playerId,
                        playerName: player.username,
                        cause: 'NIGHT_KILL',
                    });
                }
            });
        } else {
            gameState.addEvent('NO_DEATHS', {
                message: 'Ningu√©m morreu durante a noite.',
            });
        }
    }

    private async processVotingResults(gameState: GameState): Promise<void> {
        const result = gameState.getMostVotedPlayer();

        if (result) {
            const player = gameState.getPlayer(result.playerId);
            if (player && player.role) {
                if (player.role === Role.JESTER) {
                    gameState.endGame(Faction.NEUTRAL, [player.id]);

                    this.emitGameEvent(gameState.gameId, 'jester:wins', {
                        gameId: gameState.gameId,
                        jesterId: player.id,
                        jesterName: player.username,
                    });

                    await this.endGame(gameState.gameId, 'Jester executed and wins');
                    return;
                }

                player.kill('EXECUTION');

                gameState.addEvent('PLAYER_EXECUTED', {
                    playerId: player.id,
                    playerName: player.username,
                    role: player.role,
                    votes: result.votes,
                });
            }
        } else {
            gameState.addEvent('NO_EXECUTION', {
                reason: 'No majority or tie vote',
            });
        }
    }

    //====================================================================
    // WIN CONDITION CHECKING
    //====================================================================
    private async checkWinCondition(gameId: string): Promise<void> {
        const gameState = this.games.get(gameId);
        // CORRE√á√ÉO 1: Usar a string literal
        if (!gameState || gameState.status !== 'PLAYING') return;

        const alivePlayers = gameState.getAlivePlayers();
        const winCondition = WinConditionCalculator.calculateWinCondition(
            alivePlayers.map(p => ({ playerId: p.id, role: p.role! }))
        );

        if (winCondition.hasWinner) {
            await this.endGame(gameId);
        }
    }

    //====================================================================
    // VOTING SYSTEM
    //====================================================================
    async castVote(gameId: string, voterId: string, targetId: string): Promise<boolean> {
        const gameState = this.games.get(gameId);
        if (!gameState) return false;

        const success = gameState.addVote(voterId, targetId);

        if (success) {
            this.emitGameEvent(gameId, 'vote:cast', {
                gameId,
                voterId,
                targetId,
                voteCounts: Object.fromEntries(gameState.getVoteCounts()),
            });
        }

        return success;
    }

    async removeVote(gameId: string, voterId: string): Promise<boolean> {
        const gameState = this.games.get(gameId);
        if (!gameState) return false;

        const success = gameState.removeVote(voterId);

        if (success) {
            this.emitGameEvent(gameId, 'vote:removed', {
                gameId,
                voterId,
                voteCounts: Object.fromEntries(gameState.getVoteCounts()),
            });
        }

        return success;
    }

    //====================================================================
    // EVENT SYSTEM
    //====================================================================
    onGameEvent(gameId: string, event: string, handler: (data: any) => void): void {
        const gameHandlers = this.eventHandlers.get(gameId);
        if (!gameHandlers) return;

        if (!gameHandlers.has(event)) {
            gameHandlers.set(event, []);
        }

        gameHandlers.get(event)!.push(handler);
    }

    private emitGameEvent(gameId: string, event: string, data: any): void {
        const gameHandlers = this.eventHandlers.get(gameId);
        if (!gameHandlers) return;

        const handlers = gameHandlers.get(event);
        if (handlers) {
            handlers.forEach(handler => {
                try {
                    handler(data);
                } catch (error) {
                    logger.error('Error in game event handler', error instanceof Error ? error : new Error('Unknown handler error'), {
                        gameId,
                        event,
                    });
                }
            });
        }
    }

    //====================================================================
    // UTILITY METHODS
    //====================================================================
    private generateGameResults(gameState: GameState): GameResults {
        const results: GameResults = {
            gameId: gameState.gameId,
            roomId: gameState.roomId,
            duration: gameState.finishedAt
                ? gameState.finishedAt.getTime() - (gameState.startedAt?.getTime() || 0)
                : 0,
            totalDays: gameState.day,

            // CORRE√á√ÉO: Incluir a propriedade 'winningFaction' apenas se ela n√£o for undefined.
            ...(gameState.winningFaction && { winningFaction: gameState.winningFaction }),

            winningPlayers: gameState.winningPlayers,
            players: gameState.players.map(player => ({
                id: player.id,
                userId: player.userId,
                username: player.username,
                role: player.role ?? Role.VILLAGER,
                faction: player.faction ?? Faction.TOWN,
                survived: player.isAlive,
                won: gameState.winningPlayers.includes(player.id),
                // Manter a corre√ß√£o anterior
                eliminationReason: player.eliminationReason ?? '',
                killedBy: player.killedBy ?? '',
            })),
            events: gameState.events,
        };

        return results;
    }

    //====================================================================
    // ADMINISTRATIVE METHODS
    //====================================================================
    getActiveGamesCount(): number {
        return Array.from(this.games.values())
            // CORRE√á√ÉO 1: Usar a string literal
            .filter(game => game.status === 'PLAYING').length;
    }

    getAllGames(): GameState[] {
        return Array.from(this.games.values());
    }

    async getGamesByRoom(roomId: string): Promise<GameState[]> {
        const games = Array.from(this.games.values())
            .filter(game => game.roomId === roomId);
        return Promise.resolve(games);
    }

    async forceEndGame(gameId: string, reason: string): Promise<boolean> {
        const gameState = this.games.get(gameId);
        if (!gameState) return false;

        await this.endGame(gameId, reason);
        return true;
    }

    getGameStats(gameId: string): any {
        const gameState = this.games.get(gameId);
        if (!gameState) return null;

        return {
            gameId,
            status: gameState.status,
            phase: gameState.phase,
            day: gameState.day,
            playerCount: gameState.players.length,
            aliveCount: gameState.getAlivePlayers().length,
            spectatorCount: gameState.spectators.length,
            timeLeft: gameState.timeLeft,
            events: gameState.events.length,
        };
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    async cleanup(): Promise<void> {
        this.games.clear();
        this.eventHandlers.clear();

        logger.info('GameEngine cleanup completed');
    }
}
</file>

<file path="backend/src/game/PhaseManager.ts">
// üê∫ LOBISOMEM ONLINE - Phase Manager (REFATORADO)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service

import { GameState } from './Game';
import { RoleDistributor, RoleRevealManager } from './RoleSystem';
import { GamePhase, Faction, Role } from '@/utils/constants';
import type { IGameEngine, NightAction, NightResults } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// PHASE MANAGER CLASS - REFATORADA
//====================================================================
export class PhaseManager {
    private gameState: GameState;
    private gameEngine: IGameEngine;
    private currentPhaseTimer?: NodeJS.Timeout;

    constructor(gameState: GameState, gameEngine: IGameEngine) {
        this.gameState = gameState;
        this.gameEngine = gameEngine;
    }

    //====================================================================
    // PHASE CONTROL
    //====================================================================
    async startFirstNight(): Promise<void> {
        logger.info('Starting first night phase', { gameId: this.gameState.gameId });

        // CORRE√á√ÉO 2: Usar o enum GamePhase
        await this.changePhase(GamePhase.NIGHT, this.gameState.config.nightDuration);

        this.gameState.addEvent('FIRST_NIGHT_STARTED', {
            message: 'A primeira noite chegou √† vila. Os poderes especiais acordam...',
            // CORRE√á√ÉO 2: Usar o enum GamePhase
            roles: this.getRolesForPhase(GamePhase.NIGHT),
        });
    }

    async nextPhase(): Promise<void> {
        const currentPhase = this.gameState.phase;

        try {
            switch (currentPhase) {
                case GamePhase.LOBBY:
                    // Should not happen during game
                    break;

                case GamePhase.NIGHT:
                    await this.processNightResults();
                    // CORRE√á√ÉO 2: Usar o enum GamePhase
                    await this.changePhase(GamePhase.DAY, this.gameState.config.dayDuration);
                    break;

                case GamePhase.DAY:
                    // CORRE√á√ÉO 2: Usar o enum GamePhase
                    await this.changePhase(GamePhase.VOTING, this.gameState.config.votingDuration);
                    break;

                case GamePhase.VOTING:
                    await this.processVotingResults();
                    // Check if game ended, otherwise go to next night
                    if (this.gameState.status === 'PLAYING') {
                        // CORRE√á√ÉO 2: Usar o enum GamePhase
                        await this.changePhase(GamePhase.NIGHT, this.gameState.config.nightDuration);
                    }
                    break;

                case GamePhase.ENDED:
                    // Game has ended, no more phases
                    break;
            }
        } catch (error) {
            logger.error('Error during phase transition', error instanceof Error ? error : new Error('Unknown phase error'), {
                gameId: this.gameState.gameId,
                currentPhase,
            });
        }
    }

    private async changePhase(newPhase: GamePhase, duration: number): Promise<void> {
        const oldPhase = this.gameState.phase;

        if (this.currentPhaseTimer) {
            clearTimeout(this.currentPhaseTimer);
        }

        this.gameState.changePhase(newPhase, duration);

        logger.info('Phase changed', {
            gameId: this.gameState.gameId,
            from: oldPhase,
            to: newPhase,
            duration,
            day: this.gameState.day,
        });

        this.currentPhaseTimer = setTimeout(() => {
            this.nextPhase();
        }, duration);

        await this.onPhaseStart(newPhase);
    }


    //====================================================================
    // PHASE-SPECIFIC LOGIC
    //====================================================================
    private async onPhaseStart(phase: GamePhase): Promise<void> {
        switch (phase) {
            case 'NIGHT':
                await this.onNightStart();
                break;

            case 'DAY':
                await this.onDayStart();
                break;

            case 'VOTING':
                await this.onVotingStart();
                break;
        }
    }

    private async onNightStart(): Promise<void> {
        this.gameState.addEvent('NIGHT_STARTED', {
            day: this.gameState.day,
            message: `Noite ${this.gameState.day} - A vila dorme, mas alguns acordam...`,
            activeRoles: this.getRolesForPhase('NIGHT'),
            duration: this.gameState.config.nightDuration,
        });

        // Clear previous night's actions
        this.gameState.nightActions = [];

        // Reset player states for night
        this.gameState.players.forEach(player => {
            if (player.isAlive) {
                player.hasActed = false;
                player.removeProtection(); // Remove previous protection
            }
        });
    }

    private async onDayStart(): Promise<void> {
        this.gameState.addEvent('DAY_STARTED', {
            day: this.gameState.day,
            message: `Dia ${this.gameState.day} - O sol nasce e a vila acorda...`,
            duration: this.gameState.config.dayDuration,
        });
    }

    private async onVotingStart(): Promise<void> {
        const alivePlayers = this.gameState.getAlivePlayers();

        this.gameState.addEvent('VOTING_STARTED', {
            day: this.gameState.day,
            message: 'Hora da vota√ß√£o! Escolham quem ser√° executado.',
            eligibleVoters: alivePlayers.map(p => ({ id: p.id, username: p.username })),
            duration: this.gameState.config.votingDuration,
        });

        this.gameState.players.forEach(player => {
            if (player.isAlive) {
                // CORRE√á√ÉO 3: Usar o m√©todo da classe Player que lida com 'undefined' corretamente
                player.unvote();
            }
        });
    }

    //====================================================================
    // NIGHT RESULTS PROCESSING
    //====================================================================
    private async processNightResults(): Promise<void> {
        logger.info('Processing night results', {
            gameId: this.gameState.gameId,
            day: this.gameState.day,
            actionsCount: this.gameState.nightActions.length,
        });

        // Get all night actions sorted by priority
        const actions = this.gameState.nightActions.sort((a, b) => a.priority - b.priority);

        // Track what happened during the night
        const nightResults = {
            protections: [] as string[],
            investigations: [] as { investigatorId: string; targetId: string; result: string }[],
            attacks: [] as { attackerId: string; targetId: string; successful: boolean }[],
            deaths: [] as { playerId: string; cause: string; killedBy?: string }[],
        };

        // Process actions by priority
        for (const action of actions) {
            await this.processNightAction(action, nightResults);
        }

        // Apply deaths
        nightResults.deaths.forEach(death => {
            const player = this.gameState.getPlayer(death.playerId);
            if (player && player.isAlive) {
                player.kill(death.cause as any, death.killedBy);
            }
        });

        // Generate night summary
        await this.generateNightSummary(nightResults);
    }

    private async processNightAction(action: any, results: any): Promise<void> {
        const actor = this.gameState.getPlayer(action.playerId);
        if (!actor || !actor.isAlive) return;

        switch (action.type) {
            case 'PROTECT':
                await this.processProtection(action, results);
                break;

            case 'INVESTIGATE':
                await this.processInvestigation(action, results);
                break;

            case 'WEREWOLF_KILL':
                await this.processWerewolfKill(action, results);
                break;

            case 'VIGILANTE_KILL':
                await this.processVigilanteKill(action, results);
                break;

            case 'SERIAL_KILL':
                await this.processSerialKill(action, results);
                break;
        }
    }

    private async processProtection(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target) return;

        // Check if doctor can protect this target
        if (!target.canBeProtectedByDoctor) {
            this.gameState.addEvent('PROTECTION_FAILED', {
                doctorId: action.playerId,
                targetId: action.targetId,
                reason: 'N√£o pode proteger a mesma pessoa duas noites seguidas',
            }, [action.playerId]);
            return;
        }

        target.protect();
        results.protections.push(action.targetId);

        this.gameState.addEvent('PROTECTION_APPLIED', {
            doctorId: action.playerId,
            targetId: action.targetId,
        }, [action.playerId]);
    }

    private async processInvestigation(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target || !target.role) return;

        // ‚úÖ USAR RoleRevealManager em vez de reimplementar
        const result = RoleRevealManager.getInvestigationResult(target.role);

        results.investigations.push({
            investigatorId: action.playerId,
            targetId: action.targetId,
            result,
        });

        this.gameState.addEvent('INVESTIGATION_RESULT', {
            investigatorId: action.playerId,
            targetId: action.targetId,
            targetName: target.username,
            result,
        }, [action.playerId]);
    }

    private async processWerewolfKill(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target || !target.isAlive) return;

        const successful = !target.isProtected;

        results.attacks.push({
            attackerId: action.playerId,
            targetId: action.targetId,
            successful,
        });

        if (successful) {
            results.deaths.push({
                playerId: action.targetId,
                cause: 'NIGHT_KILL',
                killedBy: 'werewolves',
            });
        }
    }

    private async processVigilanteKill(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        const vigilante = this.gameState.getPlayer(action.playerId);

        if (!target || !target.isAlive || !vigilante) return;

        const successful = !target.isProtected;

        results.attacks.push({
            attackerId: action.playerId,
            targetId: action.targetId,
            successful,
        });

        if (successful) {
            results.deaths.push({
                playerId: action.targetId,
                cause: 'VIGILANTE',
                killedBy: action.playerId,
            });

            // If vigilante killed a town member, they feel guilty and lose next action
            if (target.faction === 'TOWN') {
                // Mark vigilante as having guilt (would need to track this)
                this.gameState.addEvent('VIGILANTE_GUILT', {
                    vigilanteId: action.playerId,
                    killedTownMember: action.targetId,
                }, [action.playerId]);
            }
        }
    }

    private async processSerialKill(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target || !target.isAlive) return;

        // Serial Killer is immune to doctor protection on first night
        const isFirstNight = this.gameState.day === 1;
        const successful = !target.isProtected || isFirstNight;

        results.attacks.push({
            attackerId: action.playerId,
            targetId: action.targetId,
            successful,
        });

        if (successful) {
            results.deaths.push({
                playerId: action.targetId,
                cause: 'SERIAL_KILLER',
                killedBy: action.playerId,
            });
        }
    }

    //====================================================================
    // VOTING RESULTS PROCESSING
    //====================================================================
    private async processVotingResults(): Promise<void> {
        const result = this.gameState.getMostVotedPlayer();

        if (result) {
            const player = this.gameState.getPlayer(result.playerId);
            if (player && player.role) { // Garante que player e role existem
                if (player.role === Role.JESTER) {
                    // CORRE√á√ÉO 4: Usar o enum Faction
                    this.gameState.endGame(Faction.NEUTRAL, [player.id]);

                    this.gameState.addEvent('JESTER_WINS', {
                        playerId: player.id,
                        playerName: player.username,
                        message: 'O Bobo da Corte venceu ao ser executado!',
                    });

                    logger.info('Jester wins by execution', {
                        gameId: this.gameState.gameId,
                        playerId: player.id,
                        playerName: player.username,
                    });

                    return;
                }

                player.kill('EXECUTION');

                this.gameState.addEvent('PLAYER_EXECUTED', {
                    playerId: player.id,
                    playerName: player.username,
                    role: player.role,
                    faction: player.faction,
                    votes: result.votes,
                    totalVoters: this.gameState.getAlivePlayers().length,
                });

                logger.info('Player executed by vote', {
                    gameId: this.gameState.gameId,
                    playerId: player.id,
                    playerName: player.username,
                    role: player.role,
                    votes: result.votes,
                });
            }
        } else {
            this.gameState.addEvent('NO_EXECUTION', {
                reason: 'Empate na vota√ß√£o ou votos insuficientes',
                voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
            });

            logger.info('No execution - tie or insufficient votes', {
                gameId: this.gameState.gameId,
                voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
            });
        }

        const winCondition = this.gameState.checkWinCondition();
        if (winCondition.hasWinner && this.gameState.status === 'PLAYING') {
            this.gameState.endGame(winCondition.winningFaction!, winCondition.winningPlayers!);
        }
    }

    //====================================================================
    // UTILITY METHODS
    //====================================================================
    private getRolesForPhase(phase: string): string[] {
        return RoleDistributor.getRolesThatActDuring(phase);
    }

    private async generateNightSummary(results: any): Promise<void> {
        const messages = [];

        // Deaths
        if (results.deaths.length > 0) {
            results.deaths.forEach((death: any) => {
                const player = this.gameState.getPlayer(death.playerId);
                if (player) {
                    let causeMessage = '';
                    switch (death.cause) {
                        case 'NIGHT_KILL':
                            causeMessage = 'foi encontrado morto pela manh√£';
                            break;
                        case 'VIGILANTE':
                            causeMessage = 'foi executado pelo vigilante';
                            break;
                        case 'SERIAL_KILLER':
                            causeMessage = 'foi brutalmente assassinado';
                            break;
                    }
                    messages.push(`${player.username} ${causeMessage}.`);
                }
            });
        } else {
            messages.push('Ningu√©m morreu durante a noite.');
        }

        this.gameState.addEvent('NIGHT_SUMMARY', {
            day: this.gameState.day,
            deaths: results.deaths,
            messages,
            protections: results.protections.length,
            investigations: results.investigations.length,
            attacks: results.attacks.length,
        });
    }

    //====================================================================
    // TIMER MANAGEMENT
    //====================================================================
    getRemainingTime(): number {
        this.gameState.updateTimeLeft();
        return this.gameState.timeLeft;
    }

    isPhaseExpired(): boolean {
        return this.gameState.isPhaseExpired();
    }

    async forceNextPhase(): Promise<void> {
        if (this.currentPhaseTimer) {
            clearTimeout(this.currentPhaseTimer);
        }
        await this.nextPhase();
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    cleanup(): void {
        if (this.currentPhaseTimer) {
            clearTimeout(this.currentPhaseTimer);
            // CORRE√á√ÉO 5: Usar delete em vez de atribuir undefined
            delete this.currentPhaseTimer;
        }
    }
}
</file>

<file path="backend/src/game/RoleSystem.ts">
// üê∫ LOBISOMEM ONLINE - Role System and Distribution (CORRIGIDO DEFINITIVAMENTE)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service

import { Role, Faction } from '@/utils/constants';

//====================================================================
// ROLE CONFIGURATION INTERFACE
//====================================================================
export interface RoleConfiguration {
    role: Role;
    faction: Faction;
    name: string;
    description: string;
    abilities: string[];
    goalDescription: string;
    canAct: boolean;
    actsDuring: string[];
    hasNightChat: boolean;
    immuneToInvestigation: boolean;
    maxActions?: number;
    priority: number; // Action priority (lower = executes first)
}

//====================================================================
// ROLE DEFINITIONS (Based on Town of Salem)
//====================================================================
const roleConfigurations: Record<Role, RoleConfiguration> = {
    // TOWN ROLES
    [Role.VILLAGER]: {
        role: Role.VILLAGER,
        faction: Faction.TOWN,
        name: 'Alde√£o',
        description: 'Cidad√£o comum da vila sem poderes especiais',
        abilities: ['Votar durante o dia'],
        goalDescription: 'Eliminar todos os Lobisomens e inimigos da vila',
        canAct: false,
        actsDuring: [],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 999, // No actions
    },

    [Role.SHERIFF]: {
        role: Role.SHERIFF,
        faction: Faction.TOWN,
        name: 'Investigador',
        description: 'Investiga pessoas durante a noite para descobrir se s√£o suspeitas',
        abilities: [
            'Investigar uma pessoa por noite',
            'Descobre se o alvo √© "SUSPEITO" ou "N√ÉO SUSPEITO"',
            'Lobisomens e Serial Killers aparecem como SUSPEITO',
            'Vila e Neutros pac√≠ficos aparecem como N√ÉO SUSPEITO'
        ],
        goalDescription: 'Encontrar e eliminar todos os Lobisomens usando suas investiga√ß√µes',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 3, // After protections but before kills
    },

    [Role.DOCTOR]: {
        role: Role.DOCTOR,
        faction: Faction.TOWN,
        name: 'M√©dico',
        description: 'Protege pessoas da morte durante a noite',
        abilities: [
            'Proteger uma pessoa por noite de ataques',
            'N√£o pode proteger a mesma pessoa duas noites seguidas',
            'N√£o pode se proteger duas noites seguidas',
            'Prote√ß√£o impede morte por qualquer fonte noturna'
        ],
        goalDescription: 'Manter a vila viva e eliminar os Lobisomens',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 1, // First to act - protections applied before attacks
    },

    [Role.VIGILANTE]: {
        role: Role.VIGILANTE,
        faction: Faction.TOWN,
        name: 'Vigilante',
        description: 'Pode matar suspeitos durante a noite, mas tem consequ√™ncias',
        abilities: [
            'Matar uma pessoa por noite (m√°ximo 3 vezes)',
            'Se matar um inocente (Vila), fica de luto e perde a pr√≥xima a√ß√£o',
            'Pode matar Lobisomens, Serial Killers e Neutros malignos',
            'Suas balas s√£o limitadas - use com sabedoria'
        ],
        goalDescription: 'Eliminar os inimigos da vila usando for√ßa letal',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: false,
        immuneToInvestigation: false,
        maxActions: 3,
        priority: 4, // After investigations
    },

    // WEREWOLF ROLES
    [Role.WEREWOLF]: {
        role: Role.WEREWOLF,
        faction: Faction.WEREWOLF,
        name: 'Lobisomem',
        description: 'Elimina alde√µes durante a noite em coordena√ß√£o com a alcateia',
        abilities: [
            'Votar em quem matar durante a noite com outros Lobisomens',
            'Chat secreto com outros Lobisomens durante a noite',
            'Pode blefar como qualquer role durante o dia',
            'Aparece como SUSPEITO para o Investigador'
        ],
        goalDescription: 'Igualar ou superar o n√∫mero de alde√µes vivos',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: true,
        immuneToInvestigation: false,
        priority: 5, // Werewolf kills
    },

    [Role.WEREWOLF_KING]: {
        role: Role.WEREWOLF_KING,
        faction: Faction.WEREWOLF,
        name: 'Rei dos Lobisomens',
        description: 'L√≠der da alcateia com imunidade especial √† investiga√ß√£o',
        abilities: [
            'Liderar vota√ß√£o de morte noturna da alcateia',
            'IMUNE √† investiga√ß√£o do Sheriff (aparece como N√ÉO SUSPEITO)',
            'Chat secreto com outros Lobisomens durante a noite',
            'Pode coordenar estrat√©gias e bleffs da alcateia'
        ],
        goalDescription: 'Comandar a alcateia para dominar a vila',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: true,
        immuneToInvestigation: true, // SPECIAL: Immune to Sheriff
        priority: 5, // Werewolf kills (same as regular werewolf)
    },

    // NEUTRAL ROLES
    [Role.JESTER]: {
        role: Role.JESTER,
        faction: Faction.NEUTRAL,
        name: 'Bobo da Corte',
        description: 'Vence sendo executado por vota√ß√£o durante o dia',
        abilities: [
            'Objetivo √∫nico: ser executado por vota√ß√£o popular',
            'N√£o pode ser morto √† noite (prote√ß√£o b√°sica)',
            'Deve agir de forma suspeita sem ser √≥bvio demais',
            'Se executado, VENCE SOZINHO independente de outros'
        ],
        goalDescription: 'Ser executado por vota√ß√£o popular durante o dia',
        canAct: false,
        actsDuring: [],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 999, // No night actions
    },

    [Role.SERIAL_KILLER]: {
        role: Role.SERIAL_KILLER,
        faction: Faction.NEUTRAL,
        name: 'Assassino em S√©rie',
        description: 'Mata uma pessoa por noite, vence sendo o √∫ltimo sobrevivente',
        abilities: [
            'Matar uma pessoa por noite',
            'Imune a prote√ß√£o do Doctor na primeira noite',
            'Aparece como SUSPEITO para o Investigador',
            'Deve eliminar TODOS os outros jogadores para vencer'
        ],
        goalDescription: 'Ser o √∫ltimo sobrevivente - eliminar todos os outros',
        canAct: true,
        actsDuring: ['NIGHT'],
        hasNightChat: false,
        immuneToInvestigation: false,
        priority: 6, // After werewolf kills
    },
};

//====================================================================
// ROLE DISTRIBUTION SYSTEM
//====================================================================
export type RoleDistribution = Record<Role, number>;

const balancedRoleDistributions: Record<number, RoleDistribution> = {
    // 6 players - Minimum composition
    6: {
        [Role.VILLAGER]: 1,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 0,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 0,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 0,
    },

    // 7 players
    7: {
        [Role.VILLAGER]: 2,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 0,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 0,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 0,
    },

    // 8 players
    8: {
        [Role.VILLAGER]: 2,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 0,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 0,
    },

    // 9 players - Balanced composition
    9: {
        [Role.VILLAGER]: 2,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 1,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 10 players
    10: {
        [Role.VILLAGER]: 3,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 1,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 11 players
    11: {
        [Role.VILLAGER]: 4,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 1,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 12 players - Standard composition
    12: {
        [Role.VILLAGER]: 4,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 13 players
    13: {
        [Role.VILLAGER]: 5,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 14 players
    14: {
        [Role.VILLAGER]: 6,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 2,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },

    // 15 players - Maximum composition
    15: {
        [Role.VILLAGER]: 6,
        [Role.SHERIFF]: 1,
        [Role.DOCTOR]: 1,
        [Role.VIGILANTE]: 1,
        [Role.WEREWOLF]: 3,
        [Role.WEREWOLF_KING]: 1,
        [Role.JESTER]: 1,
        [Role.SERIAL_KILLER]: 1,
    },
};

//====================================================================
// ROLE DISTRIBUTION LOGIC - SEM EXPORT NA DECLARA√á√ÉO
//====================================================================
class RoleDistributor {
    /**
 * Get balanced role distribution for a given number of players
 */
    static getRoleDistribution(playerCount: number): RoleDistribution {
        // Use exact match if available
        if (balancedRoleDistributions[playerCount]) {
            // Adicionando '!' aqui tamb√©m por consist√™ncia e seguran√ßa m√°xima.
            return { ...balancedRoleDistributions[playerCount]! };
        }

        // 1. Prepara a lista de contagens de jogadores dispon√≠veis.
        const sortedCounts = Object.keys(balancedRoleDistributions)
            .map(Number)
            .sort((a, b) => a - b);

        // 2. "Guard Clause" para provar ao TS que o array n√£o est√° vazio.
        if (sortedCounts.length === 0) {
            throw new Error("FATAL: No balanced role distributions are defined.");
        }

        // 3. Encontra o valor mais pr√≥ximo.
        let closest: number | undefined;
        for (const count of sortedCounts) {
            if (count >= playerCount) {
                closest = count;
                break;
            }
        }

        // 4. Garante que 'lastCount' e 'chosenCount' s√£o n√∫meros.
        const lastCount = sortedCounts[sortedCounts.length - 1]!;
        const chosenCount = closest ?? lastCount;

        // 5. A SOLU√á√ÉO PARA O NOVO ERRO:
        // Afirmamos que o resultado do acesso ao objeto n√£o ser√° undefined.
        const baseDistribution = { ...balancedRoleDistributions[chosenCount]! };

        // Agora, 'baseDistribution' √© garantidamente do tipo 'RoleDistribution',
        // resolvendo os erros nas linhas seguintes.
        if (chosenCount > playerCount) {
            return this.adjustRoleDistribution(baseDistribution, playerCount);
        }

        return baseDistribution;
    }

    /**
     * Adjust role distribution to match exact player count
     */
    private static adjustRoleDistribution(distribution: RoleDistribution, targetCount: number): RoleDistribution {
        const newDistribution = { ...distribution };
        const currentTotal = Object.values(newDistribution).reduce((sum, count) => sum + count, 0);
        const difference = currentTotal - targetCount;

        if (difference > 0) {
            // Remove roles starting with villagers, then neutrals
            const removeOrder: Role[] = [Role.VILLAGER, Role.SERIAL_KILLER, Role.JESTER, Role.WEREWOLF, Role.VIGILANTE];

            let toRemove = difference;
            for (const role of removeOrder) {
                if (toRemove <= 0) break;
                const canRemove = Math.min(newDistribution[role], toRemove);
                newDistribution[role] -= canRemove;
                toRemove -= canRemove;
            }
        }

        return newDistribution;
    }

    /**
 * Distribute roles to players randomly while maintaining balance
 */
    static distributeRolesToPlayers(playerIds: string[], distribution: RoleDistribution): Map<string, Role> {
        const roles: Role[] = [];

        // Create array of roles based on distribution
        Object.entries(distribution).forEach(([role, count]) => {
            for (let i = 0; i < count; i++) {
                roles.push(role as Role);
            }
        });

        // Shuffle arrays
        const shuffledPlayers = this.shuffleArray([...playerIds]);
        const shuffledRoles = this.shuffleArray([...roles]);

        // Create assignment map
        const roleAssignment = new Map<string, Role>();
        shuffledPlayers.forEach((playerId, index) => {
            // CORRE√á√ÉO: Verificar se o √≠ndice existe no array antes de acessar
            if (index < shuffledRoles.length) {
                const role = shuffledRoles[index];
                if (role) { // Verifica√ß√£o adicional para garantir que role n√£o √© undefined
                    roleAssignment.set(playerId, role);
                }
            }
        });

        return roleAssignment;
    }

    /**
     * Validate if a role distribution is balanced
     */
    static validateDistribution(distribution: RoleDistribution): {
        isValid: boolean;
        issues: string[];
        recommendations: string[];
    } {
        const issues: string[] = [];
        const recommendations: string[] = [];

        const totalPlayers = Object.values(distribution).reduce((sum, count) => sum + count, 0);
        const townCount = distribution[Role.VILLAGER] + distribution[Role.SHERIFF] + distribution[Role.DOCTOR] + distribution[Role.VIGILANTE];
        const werewolfCount = distribution[Role.WEREWOLF] + distribution[Role.WEREWOLF_KING];
        const neutralCount = distribution[Role.JESTER] + distribution[Role.SERIAL_KILLER];

        // Basic validation
        if (totalPlayers < 6) {
            issues.push('M√≠nimo de 6 jogadores necess√°rio');
        }

        if (totalPlayers > 15) {
            issues.push('M√°ximo de 15 jogadores permitido');
        }

        // Balance validation
        const werewolfRatio = werewolfCount / totalPlayers;
        if (werewolfRatio < 0.2) {
            issues.push('Muito poucos Lobisomens - jogo pode ser desequilibrado para a Vila');
        }

        if (werewolfRatio > 0.4) {
            issues.push('Muitos Lobisomens - jogo pode ser desequilibrado para os Lobisomens');
        }

        // Essential roles validation
        if (distribution[Role.SHERIFF] === 0 && totalPlayers >= 7) {
            recommendations.push('Adicionar pelo menos 1 Investigador para jogos com 7+ jogadores');
        }

        if (distribution[Role.DOCTOR] === 0 && totalPlayers >= 8) {
            recommendations.push('Adicionar pelo menos 1 M√©dico para jogos com 8+ jogadores');
        }

        // Power roles balance
        const powerRoles = distribution[Role.SHERIFF] + distribution[Role.DOCTOR] + distribution[Role.VIGILANTE];
        if (powerRoles > werewolfCount + 1) {
            recommendations.push('Muitas roles de poder da Vila podem desequilibrar o jogo');
        }

        return {
            isValid: issues.length === 0,
            issues,
            recommendations,
        };
    }

    /**
     * Get role configuration for a specific role
     */
    static getRoleConfig(role: Role): RoleConfiguration {
        return roleConfigurations[role];
    }

    /**
     * Get all roles that can act during a specific phase
     */
    static getRolesThatActDuring(phase: string): Role[] {
        return Object.values(roleConfigurations)
            .filter(config => config.actsDuring.includes(phase))
            .map(config => config.role);
    }

    /**
     * Get roles ordered by action priority
     */
    static getRolesByPriority(): Role[] {
        return Object.values(roleConfigurations)
            .sort((a, b) => a.priority - b.priority)
            .map(config => config.role);
    }

    /**
     * Check if a role is part of a specific faction
     */
    static isRoleInFaction(role: Role, faction: Faction): boolean {
        return roleConfigurations[role].faction === faction;
    }

    /**
     * Get all roles from a specific faction
     */
    static getRolesFromFaction(faction: Faction): Role[] {
        return Object.values(roleConfigurations)
            .filter(config => config.faction === faction)
            .map(config => config.role);
    }

    /**
     * Fisher-Yates shuffle algorithm - CORRE√á√ÉO para exactOptionalPropertyTypes
     */
    private static shuffleArray<T>(array: T[]): T[] {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            // CORRE√á√ÉO: Garantir que os elementos existem antes do swap
            const temp = shuffled[i];
            const swapTarget = shuffled[j];
            if (temp !== undefined && swapTarget !== undefined) {
                shuffled[i] = swapTarget;
                shuffled[j] = temp;
            }
        }
        return shuffled;
    }
}

//====================================================================
// ROLE REVEAL UTILITIES - SEM EXPORT NA DECLARA√á√ÉO
//====================================================================
class RoleRevealManager {
    /**
     * Get information that should be revealed when a player dies
     */
    static getDeathReveal(role: Role): {
        role: Role;
        faction: Faction;
        name: string;
        description: string;
    } {
        const config = roleConfigurations[role];
        return {
            role: config.role,
            faction: config.faction,
            name: config.name,
            description: config.description,
        };
    }

    /**
     * Get investigation result for Sheriff
     */
    static getInvestigationResult(targetRole: Role): 'SUSPICIOUS' | 'NOT_SUSPICIOUS' {
        const config = roleConfigurations[targetRole];

        // Werewolf King is immune to investigation
        if (config.immuneToInvestigation) {
            return 'NOT_SUSPICIOUS';
        }

        // Werewolves and Serial Killer are suspicious
        if (config.faction === Faction.WEREWOLF || targetRole === Role.SERIAL_KILLER) {
            return 'SUSPICIOUS';
        }

        // Town and peaceful neutrals are not suspicious
        return 'NOT_SUSPICIOUS';
    }

    /**
     * Check if a role has night chat access
     */
    static hasNightChat(role: Role): boolean {
        return roleConfigurations[role].hasNightChat;
    }

    /**
     * Get roles that share night chat (Werewolves)
     */
    static getNightChatRoles(): Role[] {
        return Object.values(roleConfigurations)
            .filter(config => config.hasNightChat)
            .map(config => config.role);
    }
}

//====================================================================
// WIN CONDITION CALCULATOR - SEM EXPORT NA DECLARA√á√ÉO
//====================================================================
class WinConditionCalculator {
    /**
     * Calculate win condition based on alive players and their roles
     */
    static calculateWinCondition(alivePlayers: { playerId: string; role: Role }[]): {
        hasWinner: boolean;
        winningFaction?: Faction;
        winningPlayers?: string[];
        reason?: string;
    } {
        if (alivePlayers.length === 0) {
            return { hasWinner: false };
        }

        // Group players by faction
        const factionGroups = new Map<Faction, { playerId: string; role: Role }[]>();

        alivePlayers.forEach(player => {
            const faction = roleConfigurations[player.role].faction;
            const players = factionGroups.get(faction) || [];
            players.push(player);
            factionGroups.set(faction, players);
        });

        const townPlayers = factionGroups.get(Faction.TOWN) || [];
        const werewolfPlayers = factionGroups.get(Faction.WEREWOLF) || [];
        const neutralPlayers = factionGroups.get(Faction.NEUTRAL) || [];

        // Check for Jester win (this would be handled separately when someone is executed)
        const jester = neutralPlayers.find(p => p.role === Role.JESTER);
        // Jester win is handled in execution logic, not here

        // Werewolves win if they equal or outnumber town
        if (werewolfPlayers.length >= townPlayers.length && townPlayers.length > 0) {
            return {
                hasWinner: true,
                winningFaction: Faction.WEREWOLF,
                winningPlayers: werewolfPlayers.map(p => p.playerId),
                reason: 'Lobisomens igualam ou superam o n√∫mero da Vila',
            };
        }

        // Town wins if no werewolves left
        if (werewolfPlayers.length === 0 && townPlayers.length > 0) {
            return {
                hasWinner: true,
                winningFaction: Faction.TOWN,
                winningPlayers: townPlayers.map(p => p.playerId),
                reason: 'Todos os Lobisomens foram eliminados',
            };
        }

        // Serial Killer wins if alone
        const serialKiller = neutralPlayers.find(p => p.role === Role.SERIAL_KILLER);
        if (townPlayers.length + werewolfPlayers.length === 0 && serialKiller) {
            return {
                hasWinner: true,
                winningFaction: Faction.NEUTRAL,
                winningPlayers: [serialKiller.playerId],
                reason: 'Assassino em S√©rie eliminou todos os outros',
            };
        }

        return { hasWinner: false };
    }

    /**
     * Check if Jester wins by being executed
     */
    static checkJesterWin(executedRole: Role): boolean {
        return executedRole === Role.JESTER;
    }
}

//====================================================================
// EXPORTS (CORRIGIDOS - APENAS UMA VEZ)
//====================================================================
export {
    roleConfigurations as ROLE_CONFIGURATIONS,
    balancedRoleDistributions as BALANCED_ROLE_DISTRIBUTIONS,
    RoleDistributor,
    RoleRevealManager,
    WinConditionCalculator,
};
</file>

<file path="backend/src/game/TimerManager.ts">
// üê∫ LOBISOMEM ONLINE - Timer Manager (CORRIGIDO PARA exactOptionalPropertyTypes)
import type { GameConfig } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// TIMER INTERFACE - CORRIGIDA PARA exactOptionalPropertyTypes
//====================================================================
export interface GameTimer {
    id: string;
    type: 'PHASE' | 'WARNING' | 'CUSTOM';
    startTime: number;
    duration: number;
    remaining: number;
    isActive: boolean;
    callback?: () => void;
    timeout?: NodeJS.Timeout; // CORRE√á√ÉO: Opcional, pode n√£o existir
}

//====================================================================
// TIMER MANAGER CLASS - CORRIGIDO PARA exactOptionalPropertyTypes
//====================================================================
export class TimerManager {
    private timers = new Map<string, GameTimer>();
    private config: GameConfig;
    private updateInterval?: NodeJS.Timeout; // CORRE√á√ÉO: Opcional, pode n√£o existir

    constructor(config: GameConfig) {
        this.config = config;
        this.startUpdateLoop();

        logger.info('TimerManager initialized', {
            nightDuration: config.nightDuration,
            dayDuration: config.dayDuration,
            votingDuration: config.votingDuration,
        });
    }

    //====================================================================
    // TIMER CREATION
    //====================================================================
    createPhaseTimer(
        phase: 'NIGHT' | 'DAY' | 'VOTING',
        gameId: string,
        onComplete: () => void,
        onWarning?: (timeLeft: number) => void
    ): string {
        const duration = this.getPhaseDuration(phase);
        const timerId = `${gameId}-${phase}-${Date.now()}`;

        const timer: GameTimer = {
            id: timerId,
            type: 'PHASE',
            startTime: Date.now(),
            duration,
            remaining: duration,
            isActive: true,
            callback: onComplete,
        };

        // Set timeout for completion
        timer.timeout = setTimeout(() => {
            this.handleTimerExpired(timerId);
        }, duration);

        this.timers.set(timerId, timer);

        // Create warning timers if provided
        if (onWarning) {
            this.createWarningTimers(gameId, phase, duration, onWarning);
        }

        logger.info('Phase timer created', {
            timerId,
            phase,
            duration: this.formatTime(duration),
            gameId,
        });

        return timerId;
    }

    createCustomTimer(
        id: string,
        duration: number,
        callback: () => void,
        type: 'WARNING' | 'CUSTOM' = 'CUSTOM'
    ): string {
        const timer: GameTimer = {
            id,
            type,
            startTime: Date.now(),
            duration,
            remaining: duration,
            isActive: true,
            callback,
        };

        timer.timeout = setTimeout(() => {
            this.handleTimerExpired(id);
        }, duration);

        this.timers.set(id, timer);

        logger.debug('Custom timer created', {
            id,
            duration: this.formatTime(duration),
            type
        });

        return id;
    }

    private createWarningTimers(
        gameId: string,
        phase: string,
        duration: number,
        onWarning: (timeLeft: number) => void
    ): void {
        // 30 second warning
        if (duration > 30000) {
            const warning30Id = `${gameId}-${phase}-warning-30`;
            setTimeout(() => onWarning(30000), duration - 30000);
        }

        // 10 second warning
        if (duration > 10000) {
            const warning10Id = `${gameId}-${phase}-warning-10`;
            setTimeout(() => onWarning(10000), duration - 10000);
        }
    }

    //====================================================================
    // TIMER MANAGEMENT
    //====================================================================
    getTimer(timerId: string): GameTimer | undefined {
        return this.timers.get(timerId);
    }

    pauseTimer(timerId: string): boolean {
        const timer = this.timers.get(timerId);
        if (!timer || !timer.isActive) return false;

        timer.isActive = false;
        timer.remaining = timer.duration - (Date.now() - timer.startTime);

        // CORRE√á√ÉO: Clear timeout se existir
        if (timer.timeout) {
            clearTimeout(timer.timeout);
            // CORRE√á√ÉO: Remover propriedade ao inv√©s de atribuir undefined
            delete timer.timeout;
        }

        logger.debug('Timer paused', { timerId, remaining: this.formatTime(timer.remaining) });
        return true;
    }

    resumeTimer(timerId: string): boolean {
        const timer = this.timers.get(timerId);
        if (!timer || timer.isActive) return false;

        timer.isActive = true;
        timer.startTime = Date.now();
        timer.duration = timer.remaining;

        // Set new timeout for remaining time
        timer.timeout = setTimeout(() => {
            this.handleTimerExpired(timerId);
        }, timer.remaining);

        logger.debug('Timer resumed', { timerId, remaining: this.formatTime(timer.remaining) });
        return true;
    }

    extendTimer(timerId: string, additionalTime: number): boolean {
        const timer = this.timers.get(timerId);
        if (!timer) return false;

        timer.duration += additionalTime;

        if (timer.isActive) {
            timer.remaining = timer.duration - (Date.now() - timer.startTime);

            // Reset timeout with new duration
            if (timer.timeout) {
                clearTimeout(timer.timeout);
            }
            timer.timeout = setTimeout(() => {
                this.handleTimerExpired(timerId);
            }, timer.remaining);
        } else {
            timer.remaining += additionalTime;
        }

        logger.info('Timer extended', {
            timerId,
            additionalTime: this.formatTime(additionalTime),
            newDuration: this.formatTime(timer.duration),
            remaining: this.formatTime(timer.remaining),
        });

        return true;
    }

    stopTimer(timerId: string): boolean {
        const timer = this.timers.get(timerId);
        if (!timer) return false;

        timer.isActive = false;

        if (timer.timeout) {
            clearTimeout(timer.timeout);
            // CORRE√á√ÉO: Remover propriedade ao inv√©s de atribuir undefined
            delete timer.timeout;
        }

        this.timers.delete(timerId);

        logger.debug('Timer stopped', { timerId });
        return true;
    }

    stopAllTimers(): void {
        this.timers.forEach((timer, timerId) => {
            if (timer.timeout) {
                clearTimeout(timer.timeout);
            }
        });

        this.timers.clear();

        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            // CORRE√á√ÉO: Remover propriedade ao inv√©s de atribuir undefined
            delete this.updateInterval;
        }

        logger.info('All timers stopped');
    }

    //====================================================================
    // TIMER UPDATES
    //====================================================================
    private startUpdateLoop(): void {
        this.updateInterval = setInterval(() => {
            this.updateAllTimers();
        }, 1000); // Update every second
    }

    private updateAllTimers(): void {
        const now = Date.now();

        this.timers.forEach((timer) => {
            if (!timer.isActive) return;

            // Calculate remaining time
            timer.remaining = Math.max(0, timer.duration - (now - timer.startTime));
        });
    }

    private handleTimerExpired(timerId: string): void {
        const timer = this.timers.get(timerId);
        if (!timer) return;

        logger.debug('Timer expired', {
            timerId,
            type: timer.type,
            duration: this.formatTime(timer.duration),
        });

        // Execute callback
        if (timer.callback) {
            try {
                timer.callback();
            } catch (error) {
                logger.error('Error executing timer callback', error instanceof Error ? error : new Error('Unknown timer error'), {
                    timerId,
                    type: timer.type,
                });
            }
        }

        // Remove timer
        this.stopTimer(timerId);
    }

    //====================================================================
    // PHASE DURATION HELPERS
    //====================================================================
    private getPhaseDuration(phase: 'NIGHT' | 'DAY' | 'VOTING'): number {
        switch (phase) {
            case 'NIGHT':
                return this.config.nightDuration;
            case 'DAY':
                return this.config.dayDuration;
            case 'VOTING':
                return this.config.votingDuration;
            default:
                return 60000; // 1 minute default
        }
    }

    //====================================================================
    // TIMER INFORMATION
    //====================================================================
    getAllActiveTimers(): GameTimer[] {
        return Array.from(this.timers.values()).filter(timer => timer.isActive);
    }

    getTimersByType(type: 'PHASE' | 'WARNING' | 'CUSTOM'): GameTimer[] {
        return Array.from(this.timers.values()).filter(timer => timer.type === type);
    }

    getRemainingTime(timerId: string): number {
        const timer = this.timers.get(timerId);
        if (!timer) return 0;

        if (!timer.isActive) return timer.remaining;

        const elapsed = Date.now() - timer.startTime;
        return Math.max(0, timer.duration - elapsed);
    }

    getTimeElapsed(timerId: string): number {
        const timer = this.timers.get(timerId);
        if (!timer) return 0;

        if (!timer.isActive) return timer.duration - timer.remaining;

        return Math.min(timer.duration, Date.now() - timer.startTime);
    }

    getTimerProgress(timerId: string): number {
        const timer = this.timers.get(timerId);
        if (!timer || timer.duration === 0) return 0;

        const elapsed = this.getTimeElapsed(timerId);
        return Math.min(100, (elapsed / timer.duration) * 100);
    }

    //====================================================================
    // UTILITY METHODS
    //====================================================================
    formatTime(milliseconds: number): string {
        const totalSeconds = Math.ceil(milliseconds / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;

        if (minutes > 0) {
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        } else {
            return `${seconds}s`;
        }
    }

    //====================================================================
    // STATISTICS
    //====================================================================
    getTimerStats(): {
        total: number;
        active: number;
        paused: number;
        byType: Record<string, number>;
    } {
        const allTimers = Array.from(this.timers.values());

        const stats = {
            total: allTimers.length,
            active: allTimers.filter(t => t.isActive).length,
            paused: allTimers.filter(t => !t.isActive).length,
            byType: {
                PHASE: 0,
                WARNING: 0,
                CUSTOM: 0,
            },
        };

        allTimers.forEach(timer => {
            stats.byType[timer.type]++;
        });

        return stats;
    }

    //====================================================================
    // PHASE-SPECIFIC TIMERS
    //====================================================================
    createNightTimer(gameId: string, onComplete: () => void, onWarning?: (timeLeft: number) => void): string {
        return this.createPhaseTimer('NIGHT', gameId, onComplete, onWarning);
    }

    createDayTimer(gameId: string, onComplete: () => void, onWarning?: (timeLeft: number) => void): string {
        return this.createPhaseTimer('DAY', gameId, onComplete, onWarning);
    }

    createVotingTimer(gameId: string, onComplete: () => void, onWarning?: (timeLeft: number) => void): string {
        return this.createPhaseTimer('VOTING', gameId, onComplete, onWarning);
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    cleanup(): void {
        this.stopAllTimers();
        logger.info('TimerManager cleanup completed');
    }

    //====================================================================
    // HEALTH CHECK
    //====================================================================
    healthCheck(): {
        status: 'healthy' | 'unhealthy';
        isRunning: boolean;
        stats: any;
        issues: string[];
    } {
        const issues: string[] = [];
        const stats = this.getTimerStats();

        if (!this.updateInterval) {
            issues.push('Timer update loop is not running');
        }

        // Check for stuck timers
        const now = Date.now();
        this.timers.forEach((timer, timerId) => {
            if (timer.isActive) {
                const elapsed = now - timer.startTime;
                if (elapsed > timer.duration * 1.5) { // 50% overtime tolerance
                    issues.push(`Timer ${timerId} appears to be stuck`);
                }
            }
        });

        return {
            status: issues.length === 0 ? 'healthy' : 'unhealthy',
            isRunning: !!this.updateInterval,
            stats,
            issues,
        };
    }
}
</file>

<file path="backend/src/routes/rooms.ts">
// üê∫ LOBISOMEM ONLINE - Room Routes
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí lobby-service

import { Router } from 'express';
import {
  listRooms,
  createRoom,
  joinRoom,
  joinRoomByCode,
  getRoomDetails,
  deleteRoom
} from '@/controllers/roomController';
import { requireAuth } from '@/middleware/auth';

const router = Router();

//====================================================================
// ROOM ROUTES - ALL REQUIRE AUTHENTICATION
//====================================================================

/**
 * @route GET /api/rooms
 * @desc List public rooms
 * @access Private
 */
router.get('/', requireAuth, listRooms);

/**
 * @route POST /api/rooms
 * @desc Create new room
 * @access Private
 * @body { name, isPrivate?, maxPlayers?, maxSpectators? }
 */
router.post('/', requireAuth, createRoom);

/**
 * @route GET /api/rooms/:id
 * @desc Get room details by ID
 * @access Private
 */
router.get('/:id', requireAuth, getRoomDetails);

/**
 * @route POST /api/rooms/:id/join
 * @desc Join room by ID
 * @access Private
 * @body { asSpectator? }
 */
router.post('/:id/join', requireAuth, joinRoom);

/**
 * @route POST /api/rooms/join-by-code
 * @desc Join room by 6-digit code
 * @access Private
 * @body { code, asSpectator? }
 */
router.post('/join-by-code', requireAuth, joinRoomByCode);

/**
 * @route DELETE /api/rooms/:id
 * @desc Delete room (host only)
 * @access Private
 */
router.delete('/:id', requireAuth, deleteRoom);

export default router;
</file>

<file path="backend/src/utils/helper.ts">
// üê∫ LOBISOMEM ONLINE - Helper Utilities
// Common utility functions used throughout the application

import crypto from 'crypto';
import { THEMED_NICKNAMES, ROLE_DISTRIBUTIONS, GAME_LIMITS } from './constants';
import type { Role, RoleDistribution } from '@/types/game';

// =============================================================================
// STRING UTILITIES
// =============================================================================

/**
 * Generate a random room code
 */
export function generateRoomCode(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

/**
 * Generate a cryptographically secure random string
 */
export function generateSecureToken(length: number = 32): string {
  return crypto.randomBytes(length).toString('hex');
}

/**
 * Generate a random nickname from themed list
 */
export function generateRandomNickname(usedNicknames: Set<string> = new Set()): string {
  const availableNicknames = THEMED_NICKNAMES.filter(nickname => !usedNicknames.has(nickname));

  if (availableNicknames.length === 0) {
    // Fallback to numbered nicknames if all are used
    let counter = 1;
    let nickname = '';
    do {
      nickname = `Cidad√£o ${counter}`;
      counter++;
    } while (usedNicknames.has(nickname));

    return nickname;
  }

  return availableNicknames[Math.floor(Math.random() * availableNicknames.length)];
}

/**
 * Slugify a string for URLs
 */
export function slugify(text: string): string {
  return text
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9 -]/g, '') // Remove special characters
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-'); // Replace multiple hyphens with single
}

/**
 * Capitalize first letter of each word
 */
export function titleCase(text: string): string {
  return text.replace(/\w\S*/g, (txt) =>
    txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
  );
}

/**
 * Truncate text to specified length
 */
export function truncate(text: string, length: number, suffix: string = '...'): string {
  if (text.length <= length) return text;
  return text.substring(0, length - suffix.length) + suffix;
}

// =============================================================================
// ARRAY UTILITIES
// =============================================================================

/**
 * Shuffle an array using Fisher-Yates algorithm
 */
export function shuffleArray<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * Get random element from array
 */
export function randomElement<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)];
}

/**
 * Get multiple random elements from array
 */
export function randomElements<T>(array: T[], count: number): T[] {
  const shuffled = shuffleArray(array);
  return shuffled.slice(0, Math.min(count, array.length));
}

/**
 * Chunk array into smaller arrays
 */
export function chunkArray<T>(array: T[], chunkSize: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    chunks.push(array.slice(i, i + chunkSize));
  }
  return chunks;
}

// =============================================================================
// TIME UTILITIES
// =============================================================================

/**
 * Add milliseconds to a date
 */
export function addMilliseconds(date: Date, ms: number): Date {
  return new Date(date.getTime() + ms);
}

/**
 * Check if a date is expired
 */
export function isExpired(date: Date): boolean {
  return date.getTime() < Date.now();
}

/**
 * Format duration in milliseconds to human readable string
 */
export function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }

  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }

  return `${seconds}s`;
}

/**
 * Get time remaining until target date
 */
export function getTimeRemaining(targetDate: Date): number {
  return Math.max(0, targetDate.getTime() - Date.now());
}

// =============================================================================
// GAME UTILITIES
// =============================================================================

/**
 * Get role distribution based on player count
 */
export function getRoleDistribution(playerCount: number): RoleDistribution {
  // Find the closest predefined distribution
  const availableCounts = Object.keys(ROLE_DISTRIBUTIONS).map(Number).sort((a, b) => a - b);

  let targetCount = availableCounts.find(count => count >= playerCount);
  if (!targetCount) {
    targetCount = availableCounts[availableCounts.length - 1]; // Use largest if exceeds max
  }

  const distribution = ROLE_DISTRIBUTIONS[targetCount as keyof typeof ROLE_DISTRIBUTIONS];

  // Adjust distribution if needed to match exact player count
  if (targetCount > playerCount) {
    return adjustRoleDistribution(distribution, playerCount);
  }

  return distribution;
}

/**
 * Adjust role distribution to match exact player count
 */
function adjustRoleDistribution(distribution: RoleDistribution, targetCount: number): RoleDistribution {
  const newDistribution = { ...distribution };
  const currentTotal = Object.values(newDistribution).reduce((sum, count) => sum + count, 0);
  const difference = currentTotal - targetCount;

  if (difference > 0) {
    // Remove roles starting with villagers
    let toRemove = difference;
    const removeOrder: Role[] = ['VILLAGER', 'WEREWOLF', 'JESTER', 'SERIAL_KILLER'];

    for (const role of removeOrder) {
      if (toRemove <= 0) break;
      const canRemove = Math.min(newDistribution[role], toRemove);
      newDistribution[role] -= canRemove;
      toRemove -= canRemove;
    }
  }

  return newDistribution;
}

/**
 * Distribute roles to players randomly
 */
export function distributeRoles(playerIds: string[], distribution: RoleDistribution): Map<string, Role> {
  const roles: Role[] = [];

  // Create array of roles based on distribution
  for (const [role, count] of Object.entries(distribution)) {
    for (let i = 0; i < count; i++) {
      roles.push(role as Role);
    }
  }

  // Shuffle players and roles
  const shuffledPlayers = shuffleArray(playerIds);
  const shuffledRoles = shuffleArray(roles);

  // Create map of player to role
  const roleAssignment = new Map<string, Role>();
  shuffledPlayers.forEach((playerId, index) => {
    if (index < shuffledRoles.length) {
      roleAssignment.set(playerId, shuffledRoles[index]);
    }
  });

  return roleAssignment;
}

/**
 * Check if game can start with current player count
 */
export function canStartGame(playerCount: number): boolean {
  return playerCount >= GAME_LIMITS.MIN_PLAYERS && playerCount <= GAME_LIMITS.MAX_PLAYERS;
}

/**
 * Calculate win condition for current game state
 */
export function calculateWinCondition(alivePlayers: { role: Role; playerId: string }[]): {
  hasWinner: boolean;
  winningFaction?: string;
  winningPlayers?: string[];
} {
  const aliveByFaction = alivePlayers.reduce((acc, player) => {
    let faction: string;

    if (['VILLAGER', 'SHERIFF', 'DOCTOR', 'VIGILANTE'].includes(player.role)) {
      faction = 'TOWN';
    } else if (['WEREWOLF', 'WEREWOLF_KING'].includes(player.role)) {
      faction = 'WEREWOLF';
    } else {
      faction = 'NEUTRAL';
    }

    if (!acc[faction]) acc[faction] = [];
    acc[faction].push(player.playerId);

    return acc;
  }, {} as Record<string, string[]>);

  const townCount = aliveByFaction.TOWN?.length || 0;
  const werewolfCount = aliveByFaction.WEREWOLF?.length || 0;
  const neutralCount = aliveByFaction.NEUTRAL?.length || 0;

  // Werewolves win if they equal or outnumber town
  if (werewolfCount >= townCount && townCount > 0) {
    return {
      hasWinner: true,
      winningFaction: 'WEREWOLF',
      winningPlayers: aliveByFaction.WEREWOLF,
    };
  }

  // Town wins if no werewolves left
  if (werewolfCount === 0 && townCount > 0) {
    return {
      hasWinner: true,
      winningFaction: 'TOWN',
      winningPlayers: aliveByFaction.TOWN,
    };
  }

  // Serial killer wins if alone
  if (townCount + werewolfCount === 0 && neutralCount === 1) {
    return {
      hasWinner: true,
      winningFaction: 'SERIAL_KILLER',
      winningPlayers: aliveByFaction.NEUTRAL,
    };
  }

  return { hasWinner: false };
}

// =============================================================================
// VALIDATION UTILITIES
// =============================================================================

/**
 * Check if string contains profanity (basic filter)
 */
export function containsProfanity(text: string): boolean {
  const profanityList = [
    'fuck', 'shit', 'damn', 'bitch', 'ass', 'hell',
    'porra', 'merda', 'caralho', 'puta', 'fodase', 'buceta'
    // Add more words as needed
  ];

  const lowerText = text.toLowerCase();
  return profanityList.some(word => lowerText.includes(word));
}

/**
 * Clean profanity from text
 */
export function cleanProfanity(text: string): string {
  if (!containsProfanity(text)) return text;

  const replacements = [
    'barbaridade', 'caramba', 'nossa', 'eita', 'puxa', 'xi'
  ];

  return randomElement(replacements);
}

// =============================================================================
// OBJECT UTILITIES
// =============================================================================

/**
 * Deep clone an object
 */
export function deepClone<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Remove undefined properties from object
 */
export function removeUndefined<T extends Record<string, any>>(obj: T): Partial<T> {
  const cleaned: Partial<T> = {};

  for (const [key, value] of Object.entries(obj)) {
    if (value !== undefined) {
      cleaned[key as keyof T] = value;
    }
  }

  return cleaned;
}

/**
 * Pick specific properties from object
 */
export function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>;

  for (const key of keys) {
    if (key in obj) {
      result[key] = obj[key];
    }
  }

  return result;
}

/**
 * Omit specific properties from object
 */
export function omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {
  const result = { ...obj } as any;

  for (const key of keys) {
    delete result[key];
  }

  return result;
}
</file>

<file path="backend/src/utils/logger.ts">
// üê∫ LOBISOMEM ONLINE - Logger Utility
// Structured logging for the application

import { config } from '@/config/environment';

// =============================================================================
// LOG LEVELS
// =============================================================================
export enum LogLevel {
  ERROR = 'ERROR',
  WARN = 'WARN',
  INFO = 'INFO',
  DEBUG = 'DEBUG',
}

// =============================================================================
// LOG ENTRY INTERFACE
// =============================================================================
export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: string;
  service: string;
  module?: string;
  userId?: string;
  roomId?: string;
  gameId?: string;
  metadata?: Record<string, any>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

// =============================================================================
// LOGGER CLASS
// =============================================================================
class Logger {
  private serviceName: string;
  private moduleContext?: string;

  constructor(serviceName: string = config.SERVICE_ID, moduleContext?: string) {
    this.serviceName = serviceName;
    this.moduleContext = moduleContext;
  }

  /**
   * Create a child logger for a specific module
   */
  child(moduleContext: string): Logger {
    return new Logger(this.serviceName, moduleContext);
  }

  /**
   * Log an error message
   */
  error(message: string, error?: Error, metadata?: Record<string, any>): void {
    this.log(LogLevel.ERROR, message, { error, metadata });
  }

  /**
   * Log a warning message
   */
  warn(message: string, metadata?: Record<string, any>): void {
    this.log(LogLevel.WARN, message, { metadata });
  }

  /**
   * Log an info message
   */
  info(message: string, metadata?: Record<string, any>): void {
    this.log(LogLevel.INFO, message, { metadata });
  }

  /**
   * Log a debug message
   */
  debug(message: string, metadata?: Record<string, any>): void {
    if (config.IS_DEVELOPMENT) {
      this.log(LogLevel.DEBUG, message, { metadata });
    }
  }

  /**
   * Log game-specific events
   */
  game(
    level: LogLevel,
    message: string,
    gameContext: {
      userId?: string;
      roomId?: string;
      gameId?: string;
      phase?: string;
      action?: string;
    },
    metadata?: Record<string, any>
  ): void {
    this.log(level, message, {
      metadata: {
        ...gameContext,
        ...metadata,
      },
    });
  }

  /**
   * Log WebSocket events
   */
  websocket(
    level: LogLevel,
    message: string,
    wsContext: {
      userId?: string;
      roomId?: string;
      connectionId?: string;
      event?: string;
    },
    metadata?: Record<string, any>
  ): void {
    this.log(level, message, {
      metadata: {
        ...wsContext,
        ...metadata,
        type: 'websocket',
      },
    });
  }

  /**
   * Log authentication events
   */
  auth(
    level: LogLevel,
    message: string,
    authContext: {
      userId?: string;
      email?: string;
      action?: string;
      ip?: string;
    },
    metadata?: Record<string, any>
  ): void {
    this.log(level, message, {
      metadata: {
        ...authContext,
        ...metadata,
        type: 'auth',
      },
    });
  }

  /**
   * Core logging method
   */
  private log(
    level: LogLevel,
    message: string,
    context?: {
      error?: Error;
      metadata?: Record<string, any>;
    }
  ): void {
    const logEntry: LogEntry = {
      level,
      message,
      timestamp: new Date().toISOString(),
      service: this.serviceName,
      module: this.moduleContext,
      ...context?.metadata,
    };

    // Add error details if present
    if (context?.error) {
      logEntry.error = {
        name: context.error.name,
        message: context.error.message,
        stack: context.error.stack,
      };
    }

    // Output based on environment
    if (config.IS_PRODUCTION) {
      // Structured JSON logging for production
      console.log(JSON.stringify(logEntry));
    } else {
      // Pretty formatted logging for development
      this.prettyLog(logEntry);
    }
  }

  /**
   * Pretty print logs for development
   */
  private prettyLog(entry: LogEntry): void {
    const colors = {
      [LogLevel.ERROR]: '\x1b[31m', // Red
      [LogLevel.WARN]: '\x1b[33m',  // Yellow
      [LogLevel.INFO]: '\x1b[36m',  // Cyan
      [LogLevel.DEBUG]: '\x1b[37m', // White
    };

    const reset = '\x1b[0m';
    const color = colors[entry.level];

    const timestamp = new Date(entry.timestamp).toLocaleTimeString();
    const service = entry.service;
    const module = entry.module ? `[${entry.module}]` : '';

    let logLine = `${color}${entry.level}${reset} ${timestamp} ${service}${module}: ${entry.message}`;

    console.log(logLine);

    // Log metadata if present
    if (entry.metadata && Object.keys(entry.metadata).length > 0) {
      console.log('  Metadata:', entry.metadata);
    }

    // Log error details if present
    if (entry.error) {
      console.log('  Error:', entry.error.message);
      if (entry.error.stack && config.IS_DEVELOPMENT) {
        console.log('  Stack:', entry.error.stack);
      }
    }
  }
}

// =============================================================================
// CREATE DEFAULT LOGGER INSTANCE
// =============================================================================
export const logger = new Logger();

// =============================================================================
// SPECIALIZED LOGGERS
// =============================================================================
export const gameLogger = logger.child('game');
export const wsLogger = logger.child('websocket');
export const authLogger = logger.child('auth');
export const dbLogger = logger.child('database');
export const redisLogger = logger.child('redis');

// =============================================================================
// PERFORMANCE LOGGING
// =============================================================================
export class PerformanceLogger {
  private timers: Map<string, number> = new Map();

  /**
   * Start timing an operation
   */
  start(operationId: string): void {
    this.timers.set(operationId, Date.now());
  }

  /**
   * End timing and log the duration
   */
  end(operationId: string, description?: string): number {
    const startTime = this.timers.get(operationId);
    if (!startTime) {
      logger.warn(`Performance timer not found: ${operationId}`);
      return 0;
    }

    const duration = Date.now() - startTime;
    this.timers.delete(operationId);

    logger.debug(`Performance: ${description || operationId}`, {
      operationId,
      duration: `${duration}ms`,
    });

    return duration;
  }

  /**
   * Measure an async operation
   */
  async measure<T>(
    operationId: string,
    operation: () => Promise<T>,
    description?: string
  ): Promise<T> {
    this.start(operationId);
    try {
      const result = await operation();
      this.end(operationId, description);
      return result;
    } catch (error) {
      this.end(operationId, `${description || operationId} (failed)`);
      throw error;
    }
  }
}

export const performanceLogger = new PerformanceLogger();

// =============================================================================
// REQUEST LOGGING MIDDLEWARE HELPER
// =============================================================================
export interface RequestLogContext {
  method: string;
  url: string;
  userAgent?: string;
  ip?: string;
  userId?: string;
  statusCode?: number;
  duration?: number;
}

export function logRequest(context: RequestLogContext): void {
  const level = context.statusCode && context.statusCode >= 400 ? LogLevel.WARN : LogLevel.INFO;

  logger.log(level, `${context.method} ${context.url}`, {
    metadata: {
      type: 'http_request',
      ...context,
    },
  });
}

// =============================================================================
// EXPORT DEFAULT LOGGER
// =============================================================================
export default logger;
</file>

<file path="backend/src/utils/simpleValidators.ts">
// üê∫ LOBISOMEM ONLINE - Simple Validators for Initial Testing
// Vers√£o simplificada para evitar erros de compila√ß√£o

export interface ValidationResult {
    success: boolean;
    data?: any;
    error?: string;
}

// Simple email validation
export function validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

// Simple username validation
export function validateUsername(username: string): boolean {
    return username.length >= 3 && username.length <= 20 && /^[a-zA-Z0-9_-]+$/.test(username);
}

// Simple password validation
export function validatePassword(password: string): boolean {
    return password.length >= 6 && password.length <= 50;
}

// Simple room name validation  
export function validateRoomName(name: string): boolean {
    return name.length >= 1 && name.length <= 30;
}

// Simple room code validation
export function validateRoomCode(code: string): boolean {
    return /^\d{6}$/.test(code);
}

// WebSocket message validation
export function validateWebSocketMessage(message: any): ValidationResult {
    if (!message || typeof message !== 'object') {
        return {
            success: false,
            error: 'Message must be an object'
        };
    }

    if (!message.type || typeof message.type !== 'string') {
        return {
            success: false,
            error: 'Message must have a valid type'
        };
    }

    return {
        success: true,
        data: {
            type: message.type,
            data: message.data || {},
            timestamp: message.timestamp || new Date().toISOString(),
            messageId: message.messageId
        }
    };
}

// Simple register validation
export function validateRegisterRequest(data: any): ValidationResult {
    if (!data.email || !validateEmail(data.email)) {
        return { success: false, error: 'Invalid email' };
    }

    if (!data.username || !validateUsername(data.username)) {
        return { success: false, error: 'Invalid username' };
    }

    if (!data.password || !validatePassword(data.password)) {
        return { success: false, error: 'Invalid password' };
    }

    if (data.password !== data.confirmPassword) {
        return { success: false, error: 'Passwords do not match' };
    }

    return {
        success: true,
        data: {
            email: data.email.toLowerCase().trim(),
            username: data.username.trim(),
            password: data.password
        }
    };
}

// Simple login validation
export function validateLoginRequest(data: any): ValidationResult {
    if (!data.email || !validateEmail(data.email)) {
        return { success: false, error: 'Invalid email' };
    }

    if (!data.password || typeof data.password !== 'string') {
        return { success: false, error: 'Invalid password' };
    }

    return {
        success: true,
        data: {
            email: data.email.toLowerCase().trim(),
            password: data.password
        }
    };
}

// Simple create room validation
export function validateCreateRoomRequest(data: any): ValidationResult {
    if (!data.name || !validateRoomName(data.name)) {
        return { success: false, error: 'Invalid room name' };
    }

    return {
        success: true,
        data: {
            name: data.name.trim(),
            isPrivate: Boolean(data.isPrivate),
            maxPlayers: Math.min(Math.max(data.maxPlayers || 15, 6), 15),
            maxSpectators: Math.min(Math.max(data.maxSpectators || 5, 0), 5)
        }
    };
}
</file>

<file path="backend/src/websocket/ChannelManager.ts">
// üê∫ LOBISOMEM ONLINE - Channel Manager (Corrigido)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service
import { wsLogger } from '@/utils/logger';
import type { ConnectionManager } from './ConnectionManager';

//====================================================================
// CHANNEL MANAGER CLASS (Simplified for Task 4)
//====================================================================
export class ChannelManager {
    private roomPlayers = new Map<string, Set<string>>(); // roomId -> Set<connectionId>
    private roomSpectators = new Map<string, Set<string>>(); // roomId -> Set<connectionId>
    private connectionRooms = new Map<string, string>(); // connectionId -> roomId

    constructor(private connectionManager: ConnectionManager) {
        wsLogger.debug('ChannelManager initialized');
    }

    //====================================================================
    // ROOM MANAGEMENT (Main Use Case for Task 4)
    //====================================================================
    joinRoom(roomId: string, connectionId: string, asSpectator: boolean = false): boolean {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) {
            wsLogger.warn('Cannot join room - connection not found', { connectionId, roomId });
            return false;
        }

        // Remove from previous room if any
        const currentRoom = this.connectionRooms.get(connectionId);
        if (currentRoom) {
            this.leaveRoom(currentRoom, connectionId);
        }

        // Add to appropriate set
        if (asSpectator) {
            if (!this.roomSpectators.has(roomId)) {
                this.roomSpectators.set(roomId, new Set());
            }
            this.roomSpectators.get(roomId)!.add(connectionId);
        } else {
            if (!this.roomPlayers.has(roomId)) {
                this.roomPlayers.set(roomId, new Set());
            }
            this.roomPlayers.get(roomId)!.add(connectionId);
        }

        // Track connection's room
        this.connectionRooms.set(connectionId, roomId);

        wsLogger.debug('Connection joined room', {
            connectionId,
            userId: connection.context.userId,
            roomId,
            asSpectator,
            playersCount: this.roomPlayers.get(roomId)?.size || 0,
            spectatorsCount: this.roomSpectators.get(roomId)?.size || 0,
        });

        return true;
    }

    leaveRoom(roomId: string, connectionId: string): boolean {
        const connection = this.connectionManager.getConnection(connectionId);
        let wasInRoom = false;

        // Remove from players
        const players = this.roomPlayers.get(roomId);
        if (players && players.has(connectionId)) {
            players.delete(connectionId);
            wasInRoom = true;

            // Cleanup empty room
            if (players.size === 0) {
                this.roomPlayers.delete(roomId);
            }
        }

        // Remove from spectators
        const spectators = this.roomSpectators.get(roomId);
        if (spectators && spectators.has(connectionId)) {
            spectators.delete(connectionId);
            wasInRoom = true;

            // Cleanup empty room
            if (spectators.size === 0) {
                this.roomSpectators.delete(roomId);
            }
        }

        // Remove room tracking
        if (wasInRoom) {
            this.connectionRooms.delete(connectionId);
        }

        if (wasInRoom) {
            wsLogger.debug('Connection left room', {
                connectionId,
                userId: connection?.context.userId,
                roomId,
                playersCount: this.roomPlayers.get(roomId)?.size || 0,
                spectatorsCount: this.roomSpectators.get(roomId)?.size || 0,
            });
        }

        return wasInRoom;
    }

    //====================================================================
    // CONNECTION QUERIES
    //====================================================================
    getRoomConnections(roomId: string): Set<string> {
        const players = this.roomPlayers.get(roomId) || new Set();
        const spectators = this.roomSpectators.get(roomId) || new Set();

        const allConnections = new Set<string>();
        players.forEach(id => allConnections.add(id));
        spectators.forEach(id => allConnections.add(id));

        return allConnections;
    }

    getRoomPlayerConnections(roomId: string): Set<string> {
        return new Set(this.roomPlayers.get(roomId) || []);
    }

    getRoomSpectatorConnections(roomId: string): Set<string> {
        return new Set(this.roomSpectators.get(roomId) || []);
    }

    getConnectionRoom(connectionId: string): string | undefined {
        return this.connectionRooms.get(connectionId);
    }

    //====================================================================
    // BROADCASTING
    //====================================================================
    broadcastToRoom(
        roomId: string,
        type: string,
        data?: any,
        excludeConnectionId?: string
    ): number {
        const connections = this.getRoomConnections(roomId);
        let sentCount = 0;

        const message = {
            type,
            data,
            timestamp: new Date().toISOString(),
        };

        for (const connectionId of connections) {
            if (excludeConnectionId && connectionId === excludeConnectionId) {
                continue;
            }

            const connection = this.connectionManager.getConnection(connectionId);
            if (connection && connection.ws.readyState === connection.ws.OPEN) {
                try {
                    connection.ws.send(JSON.stringify(message));
                    sentCount++;
                } catch (error) {
                    wsLogger.error('Failed to send message to connection in room', error instanceof Error ? error : new Error('Unknown send error'), {
                        roomId,
                        connectionId,
                        type,
                    });
                }
            }
        }

        return sentCount;
    }

    broadcastToPlayers(roomId: string, type: string, data?: any, excludeConnectionId?: string): number {
        const players = this.roomPlayers.get(roomId);
        if (!players) return 0;

        let sentCount = 0;
        const message = {
            type,
            data,
            timestamp: new Date().toISOString(),
        };

        for (const connectionId of players) {
            if (excludeConnectionId && connectionId === excludeConnectionId) {
                continue;
            }

            const connection = this.connectionManager.getConnection(connectionId);
            if (connection && connection.ws.readyState === connection.ws.OPEN) {
                try {
                    connection.ws.send(JSON.stringify(message));
                    sentCount++;
                } catch (error) {
                    wsLogger.error('Failed to send message to player', error instanceof Error ? error : new Error('Unknown player send error'), {
                        roomId,
                        connectionId,
                        type,
                    });
                }
            }
        }

        return sentCount;
    }

    broadcastToSpectators(roomId: string, type: string, data?: any, excludeConnectionId?: string): number {
        const spectators = this.roomSpectators.get(roomId);
        if (!spectators) return 0;

        let sentCount = 0;
        const message = {
            type,
            data,
            timestamp: new Date().toISOString(),
        };

        for (const connectionId of spectators) {
            if (excludeConnectionId && connectionId === excludeConnectionId) {
                continue;
            }

            const connection = this.connectionManager.getConnection(connectionId);
            if (connection && connection.ws.readyState === connection.ws.OPEN) {
                try {
                    connection.ws.send(JSON.stringify(message));
                    sentCount++;
                } catch (error) {
                    wsLogger.error('Failed to send message to spectator', error instanceof Error ? error : new Error('Unknown spectator send error'), {
                        roomId,
                        connectionId,
                        type,
                    });
                }
            }
        }

        return sentCount;
    }

    //====================================================================
    // STATISTICS AND MONITORING
    //====================================================================
    getActiveRoomsCount(): number {
        const activeRooms = new Set<string>();

        for (const roomId of this.roomPlayers.keys()) {
            activeRooms.add(roomId);
        }

        for (const roomId of this.roomSpectators.keys()) {
            activeRooms.add(roomId);
        }

        return activeRooms.size;
    }

    getRoomStats(roomId: string) {
        const playersCount = this.roomPlayers.get(roomId)?.size || 0;
        const spectatorsCount = this.roomSpectators.get(roomId)?.size || 0;

        return {
            roomId,
            playersCount,
            spectatorsCount,
            totalConnections: playersCount + spectatorsCount,
        };
    }

    getAllStats() {
        const allRooms = new Set<string>();

        for (const roomId of this.roomPlayers.keys()) {
            allRooms.add(roomId);
        }

        for (const roomId of this.roomSpectators.keys()) {
            allRooms.add(roomId);
        }

        let totalConnections = 0;
        for (const roomId of allRooms) {
            const stats = this.getRoomStats(roomId);
            totalConnections += stats.totalConnections;
        }

        return {
            totalRooms: allRooms.size,
            totalConnections,
            averageRoomSize: allRooms.size > 0 ? totalConnections / allRooms.size : 0,
        };
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    removeConnectionFromAllRooms(connectionId: string): void {
        const roomId = this.connectionRooms.get(connectionId);
        if (roomId) {
            this.leaveRoom(roomId, connectionId);
        }
    }

    clear(): void {
        this.roomPlayers.clear();
        this.roomSpectators.clear();
        this.connectionRooms.clear();

        wsLogger.info('ChannelManager cleared');
    }
}
</file>

<file path="backend/src/websocket/ConnectionManager.ts">
// üê∫ LOBISOMEM ONLINE - Connection Manager (CORRIGIDO)
import { randomUUID } from 'crypto';
import { wsLogger } from '@/utils/logger';
import type WebSocket from 'ws';
import type { ConnectionContext, ConnectionMetadata, WebSocketConnection } from '@/types';

// CORRE√á√ÉO: Tipo mapeado para permitir `undefined` nas atualiza√ß√µes, possibilitando a remo√ß√£o de propriedades.
type ConnectionContextUpdates = {
    [K in keyof ConnectionContext]?: ConnectionContext[K] | undefined;
};

export class ConnectionManager {
    private connections = new Map<string, WebSocketConnection>();
    private userConnections = new Map<string, string>();

    addConnection(ws: WebSocket, context: ConnectionContext, metadata: ConnectionMetadata): string {
        const connectionId = randomUUID();
        const existingConnectionId = this.userConnections.get(context.userId);
        if (existingConnectionId) {
            this.removeConnection(existingConnectionId);
        }

        const connection: WebSocketConnection = {
            id: connectionId, ws, context, metadata,
            isAlive: true, lastPing: Date.now(), reconnectAttempts: 0,
        };

        this.connections.set(connectionId, connection);
        this.userConnections.set(context.userId, connectionId);
        return connectionId;
    }

    removeConnection(connectionId: string): boolean {
        const connection = this.connections.get(connectionId);
        if (!connection) return false;

        this.userConnections.delete(connection.context.userId);
        if (connection.ws.readyState === connection.ws.OPEN) connection.ws.close();
        this.connections.delete(connectionId);
        return true;
    }

    getConnection(connectionId: string): WebSocketConnection | undefined {
        return this.connections.get(connectionId);
    }

    getUserConnection(userId: string): string | undefined {
        return this.userConnections.get(userId);
    }

    getAllConnections(): WebSocketConnection[] {
        return Array.from(this.connections.values());
    }

    getConnectionCount(): number {
        return this.connections.size;
    }

    // CORRE√á√ÉO: Assinatura e implementa√ß√£o robustas para atualiza√ß√µes de contexto.
    updateConnectionContext(connectionId: string, updates: ConnectionContextUpdates): boolean {
        const connection = this.connections.get(connectionId);
        if (!connection) return false;

        for (const key in updates) {
            const k = key as keyof ConnectionContext;
            const value = updates[k];
            if (value === undefined) {
                delete connection.context[k];
            } else {
                // @ts-ignore - Sabemos que o tipo est√° correto aqui.
                connection.context[k] = value;
            }
        }
        return true;
    }

    markAlive(connectionId: string): boolean {
        const conn = this.getConnection(connectionId);
        if (conn) {
            conn.isAlive = true;
            conn.lastPing = Date.now();
            return true;
        }
        return false;
    }

    markDead(connectionId: string): boolean {
        const conn = this.getConnection(connectionId);
        if (conn) {
            conn.isAlive = false;
            return true;
        }
        return false;
    }

    getDeadConnections(): string[] {
        return Array.from(this.connections.values())
            .filter(c => !c.isAlive)
            .map(c => c.id);
    }

    clear(): void {
        this.connections.forEach(conn => conn.ws.close());
        this.connections.clear();
        this.userConnections.clear();
    }
}
</file>

<file path="backend/src/websocket/HeartbeatManager.ts">
// üê∫ LOBISOMEM ONLINE - Heartbeat Manager
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service
import { wsConfig } from '@/config/websocket';
import { wsLogger } from '@/utils/logger';
import type { ConnectionManager } from './ConnectionManager';

//====================================================================
// HEARTBEAT STATS INTERFACE
//====================================================================
export interface HeartbeatStats {
    totalPingsSent: number;
    totalPongsReceived: number;
    currentInterval: number;
    timeout: number;
    lastCleanup: Date;
    connectionsMonitored: number;
    deadConnectionsDetected: number;
}

//====================================================================
// HEARTBEAT MANAGER CLASS
//====================================================================
export class HeartbeatManager {
    private pingInterval: NodeJS.Timeout | null = null;
    private cleanupInterval: NodeJS.Timeout | null = null;
    private isRunning = false;
    private stats: HeartbeatStats = {
        totalPingsSent: 0,
        totalPongsReceived: 0,
        currentInterval: wsConfig.heartbeat.interval,
        timeout: wsConfig.heartbeat.timeout,
        lastCleanup: new Date(),
        connectionsMonitored: 0,
        deadConnectionsDetected: 0,
    };

    constructor(private connectionManager: ConnectionManager) { }

    //====================================================================
    // LIFECYCLE MANAGEMENT
    //====================================================================
    start(): void {
        if (this.isRunning) {
            wsLogger.warn('HeartbeatManager already running');
            return;
        }

        this.isRunning = true;

        // Start ping interval
        this.pingInterval = setInterval(() => {
            this.sendPingToAllConnections();
        }, wsConfig.heartbeat.interval);

        // Start cleanup interval (check for dead connections)
        this.cleanupInterval = setInterval(() => {
            this.cleanupDeadConnections();
        }, wsConfig.heartbeat.interval * 2); // Run cleanup less frequently

        wsLogger.info('HeartbeatManager started', {
            pingInterval: wsConfig.heartbeat.interval,
            timeout: wsConfig.heartbeat.timeout,
        });
    }

    stop(): void {
        if (!this.isRunning) {
            return;
        }

        this.isRunning = false;

        if (this.pingInterval) {
            clearInterval(this.pingInterval);
            this.pingInterval = null;
        }

        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }

        wsLogger.info('HeartbeatManager stopped');
    }

    restart(): void {
        this.stop();
        this.start();
    }

    isActive(): boolean {
        return this.isRunning;
    }

    //====================================================================
    // PING OPERATIONS
    //====================================================================
    private sendPingToAllConnections(): void {
        const connections = this.connectionManager.getAllConnections();
        let sentCount = 0;
        let failedCount = 0;

        for (const connection of connections) {
            try {
                if (connection.ws.readyState === connection.ws.OPEN) {
                    // Mark as potentially dead - will be marked alive when pong is received
                    this.connectionManager.markDead(connection.id);

                    // Send ping
                    connection.ws.ping();
                    sentCount++;

                    wsLogger.debug('Ping sent', {
                        connectionId: connection.id,
                        userId: connection.context.userId,
                    });
                } else {
                    // Connection is already closed
                    failedCount++;
                    wsLogger.debug('Skipping ping for closed connection', {
                        connectionId: connection.id,
                        readyState: connection.ws.readyState,
                    });
                }
            } catch (error) {
                failedCount++;
                wsLogger.error('Failed to send ping', error instanceof Error ? error : new Error('Unknown ping error'), {
                    connectionId: connection.id,
                    userId: connection.context.userId,
                });
            }
        }

        this.stats.totalPingsSent += sentCount;
        this.stats.connectionsMonitored = connections.length;

        if (sentCount > 0 || failedCount > 0) {
            wsLogger.debug('Ping round completed', {
                sent: sentCount,
                failed: failedCount,
                total: connections.length,
            });
        }
    }

    sendPingToConnection(connectionId: string): boolean {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) {
            wsLogger.warn('Cannot ping non-existent connection', { connectionId });
            return false;
        }

        try {
            if (connection.ws.readyState === connection.ws.OPEN) {
                this.connectionManager.markDead(connectionId);
                connection.ws.ping();

                wsLogger.debug('Individual ping sent', {
                    connectionId,
                    userId: connection.context.userId,
                });

                return true;
            } else {
                wsLogger.debug('Cannot ping closed connection', {
                    connectionId,
                    readyState: connection.ws.readyState,
                });
                return false;
            }
        } catch (error) {
            wsLogger.error('Failed to send individual ping', error instanceof Error ? error : new Error('Unknown individual ping error'), {
                connectionId,
                userId: connection.context.userId,
            });
            return false;
        }
    }

    //====================================================================
    // PONG HANDLING
    //====================================================================
    handlePong(connectionId: string): void {
        const success = this.connectionManager.markAlive(connectionId);
        if (success) {
            this.stats.totalPongsReceived++;

            wsLogger.debug('Pong received', {
                connectionId,
                responseTime: Date.now(), // Could calculate actual response time if needed
            });
        } else {
            wsLogger.warn('Received pong for unknown connection', { connectionId });
        }
    }

    //====================================================================
    // DEAD CONNECTION CLEANUP
    //====================================================================
    private cleanupDeadConnections(): void {
        const deadConnections = this.connectionManager.getDeadConnections();
        let cleanedCount = 0;

        for (const connectionId of deadConnections) {
            const connection = this.connectionManager.getConnection(connectionId);
            if (!connection) continue;

            // Check if connection has been dead for too long
            const timeSinceLastPing = Date.now() - connection.lastPing;
            const isTimedOut = timeSinceLastPing > (wsConfig.heartbeat.interval + wsConfig.heartbeat.timeout);

            if (isTimedOut) {
                wsLogger.info('Removing dead connection', {
                    connectionId,
                    userId: connection.context.userId,
                    username: connection.context.username,
                    timeSinceLastPing,
                    lastPing: new Date(connection.lastPing).toISOString(),
                });

                // Close the connection and remove it
                try {
                    if (connection.ws.readyState === connection.ws.OPEN) {
                        connection.ws.terminate(); // Force close
                    }
                } catch (error) {
                    wsLogger.error('Error terminating dead connection', error instanceof Error ? error : new Error('Unknown termination error'), {
                        connectionId,
                    });
                }

                this.connectionManager.removeConnection(connectionId);
                cleanedCount++;
                this.stats.deadConnectionsDetected++;
            }
        }

        this.stats.lastCleanup = new Date();

        if (cleanedCount > 0) {
            wsLogger.info('Dead connection cleanup completed', {
                cleanedCount,
                totalDeadConnections: deadConnections.length,
                remainingConnections: this.connectionManager.getConnectionCount(),
            });
        }
    }

    forceCleanupDeadConnections(): number {
        wsLogger.info('Force cleanup requested');
        this.cleanupDeadConnections();

        const deadConnections = this.connectionManager.getDeadConnections();
        return deadConnections.length;
    }

    //====================================================================
    // CONNECTION HEALTH MONITORING
    //====================================================================
    getConnectionHealth(connectionId: string): {
        isAlive: boolean;
        lastPing: number;
        timeSinceLastPing: number;
        isHealthy: boolean;
    } | null {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) return null;

        const now = Date.now();
        const timeSinceLastPing = now - connection.lastPing;
        const isHealthy = connection.isAlive && timeSinceLastPing < wsConfig.heartbeat.interval * 2;

        return {
            isAlive: connection.isAlive,
            lastPing: connection.lastPing,
            timeSinceLastPing,
            isHealthy,
        };
    }

    getAllConnectionsHealth(): Array<{
        connectionId: string;
        userId: string;
        username: string;
        isAlive: boolean;
        lastPing: number;
        timeSinceLastPing: number;
        isHealthy: boolean;
    }> {
        const connections = this.connectionManager.getAllConnections();
        const now = Date.now();

        return connections.map(connection => {
            const timeSinceLastPing = now - connection.lastPing;
            const isHealthy = connection.isAlive && timeSinceLastPing < wsConfig.heartbeat.interval * 2;

            return {
                connectionId: connection.id,
                userId: connection.context.userId,
                username: connection.context.username,
                isAlive: connection.isAlive,
                lastPing: connection.lastPing,
                timeSinceLastPing,
                isHealthy,
            };
        });
    }

    getHealthySummary(): {
        total: number;
        alive: number;
        dead: number;
        healthy: number;
        unhealthy: number;
    } {
        const healthData = this.getAllConnectionsHealth();

        return {
            total: healthData.length,
            alive: healthData.filter(h => h.isAlive).length,
            dead: healthData.filter(h => !h.isAlive).length,
            healthy: healthData.filter(h => h.isHealthy).length,
            unhealthy: healthData.filter(h => !h.isHealthy).length,
        };
    }

    //====================================================================
    // STATISTICS AND MONITORING
    //====================================================================
    getStats(): HeartbeatStats {
        return {
            ...this.stats,
            connectionsMonitored: this.connectionManager.getConnectionCount(),
        };
    }

    getDetailedStats() {
        const healthSummary = this.getHealthySummary();
        const baseStats = this.getStats();

        return {
            ...baseStats,
            healthSummary,
            isRunning: this.isRunning,
            uptime: this.isRunning ? Date.now() - this.stats.lastCleanup.getTime() : 0,
            pingSuccessRate: baseStats.totalPingsSent > 0
                ? (baseStats.totalPongsReceived / baseStats.totalPingsSent) * 100
                : 0,
        };
    }

    resetStats(): void {
        this.stats = {
            totalPingsSent: 0,
            totalPongsReceived: 0,
            currentInterval: wsConfig.heartbeat.interval,
            timeout: wsConfig.heartbeat.timeout,
            lastCleanup: new Date(),
            connectionsMonitored: this.connectionManager.getConnectionCount(),
            deadConnectionsDetected: 0,
        };

        wsLogger.info('HeartbeatManager stats reset');
    }

    //====================================================================
    // CONFIGURATION
    //====================================================================
    updateInterval(newInterval: number): void {
        if (newInterval < 1000) {
            throw new Error('Heartbeat interval must be at least 1000ms');
        }

        this.stats.currentInterval = newInterval;

        if (this.isRunning) {
            wsLogger.info('Updating heartbeat interval', {
                oldInterval: wsConfig.heartbeat.interval,
                newInterval,
            });

            this.restart();
        }
    }

    //====================================================================
    // HEALTH CHECK
    //====================================================================
    healthCheck(): {
        status: 'healthy' | 'unhealthy';
        isRunning: boolean;
        stats: HeartbeatStats;
        issues: string[];
    } {
        const issues: string[] = [];

        if (!this.isRunning) {
            issues.push('HeartbeatManager is not running');
        }

        const healthSummary = this.getHealthySummary();
        const unhealthyPercentage = healthSummary.total > 0
            ? (healthSummary.unhealthy / healthSummary.total) * 100
            : 0;

        if (unhealthyPercentage > 50) {
            issues.push(`${unhealthyPercentage.toFixed(1)}% of connections are unhealthy`);
        }

        if (this.stats.totalPingsSent > 0) {
            const successRate = (this.stats.totalPongsReceived / this.stats.totalPingsSent) * 100;
            if (successRate < 80) {
                issues.push(`Low ping success rate: ${successRate.toFixed(1)}%`);
            }
        }

        return {
            status: issues.length === 0 ? 'healthy' : 'unhealthy',
            isRunning: this.isRunning,
            stats: this.getStats(),
            issues,
        };
    }
}
</file>

<file path="backend/src/websocket/index.ts">
export { WebSocketManager } from './WebSocketManager';
export { ConnectionManager } from './ConnectionManager';
export { ChannelManager } from './ChannelManager';
export { MessageRouter } from './MessageRouter';
export { HeartbeatManager } from './HeartbeatManager';
</file>

<file path="backend/src/websocket/MessageRouter.ts">
// üê∫ LOBISOMEM ONLINE - Message Router (Corre√ß√£o Completa)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service
import { wsLogger } from '@/utils/logger';
import { validateWebSocketMessage } from '@/config/websocket';
import type { ConnectionManager } from './ConnectionManager';
import type { ChannelManager } from './ChannelManager';
import type { IGameStateService, IEventBus, WebSocketErrorCode } from '@/types';

//====================================================================
// MESSAGE HANDLER TYPE
//====================================================================
type MessageHandler = (connectionId: string, data: any) => Promise<void>;

//====================================================================
// MESSAGE ROUTER CLASS
//====================================================================
export class MessageRouter {
    private handlers = new Map<string, MessageHandler>();
    private broadcastToRoom: ((roomId: string, type: string, data?: any, excludeConnectionId?: string) => number) | null = null;
    private sendToUser: ((userId: string, type: string, data?: any) => boolean) | null = null;

    constructor(
        private connectionManager: ConnectionManager,
        private channelManager: ChannelManager,
        private gameStateService: IGameStateService,
        private eventBus: IEventBus
    ) {
        this.setupHandlers();
    }

    //====================================================================
    // SETUP MESSAGE HANDLERS
    //====================================================================
    private setupHandlers(): void {
        // Connection management
        this.handlers.set('ping', this.handlePing.bind(this));
        this.handlers.set('pong', this.handlePong.bind(this));
        this.handlers.set('heartbeat', this.handleHeartbeat.bind(this));

        // ‚úÖ TASK 4 - Room management (Required events)
        this.handlers.set('join-room', this.handleJoinRoom.bind(this));
        this.handlers.set('leave-room', this.handleLeaveRoom.bind(this));
        this.handlers.set('player-ready', this.handlePlayerReady.bind(this));
        this.handlers.set('start-game', this.handleStartGame.bind(this));

        // Additional handlers
        this.handlers.set('kick-player', this.handleKickPlayer.bind(this));
        this.handlers.set('chat-message', this.handleChatMessage.bind(this));
        this.handlers.set('spectate-room', this.handleSpectateRoom.bind(this));
        this.handlers.set('stop-spectating', this.handleStopSpectating.bind(this));

        // Future game actions (placeholders)
        this.handlers.set('game-action', this.handleGameAction.bind(this));
        this.handlers.set('vote', this.handleVote.bind(this));
        this.handlers.set('unvote', this.handleUnvote.bind(this));

        wsLogger.debug('Message handlers setup completed', {
            handlerCount: this.handlers.size,
            handlers: Array.from(this.handlers.keys()),
        });
    }

    //====================================================================
    // SET BROADCAST METHODS (Called by WebSocketManager)
    //====================================================================
    setBroadcastMethods(
        broadcastToRoom: (roomId: string, type: string, data?: any, excludeConnectionId?: string) => number,
        sendToUser: (userId: string, type: string, data?: any) => boolean
    ): void {
        this.broadcastToRoom = broadcastToRoom;
        this.sendToUser = sendToUser;
    }

    //====================================================================
    // MAIN MESSAGE HANDLER
    //====================================================================
    async handleMessage(connectionId: string, message: any): Promise<void> {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) {
            wsLogger.warn('Message received for non-existent connection', { connectionId });
            return;
        }

        try {
            // Validate message format
            const validation = validateWebSocketMessage(message);
            if (!validation.isValid) {
                await this.sendError(connectionId, 'INVALID_MESSAGE', validation.error || 'Invalid message format');
                return;
            }

            const validMessage = validation.message!;

            wsLogger.debug('Message received', {
                connectionId,
                userId: connection.context.userId,
                username: connection.context.username,
                type: validMessage.type,
                roomId: connection.context.roomId,
            });

            // Get and execute handler
            const handler = this.handlers.get(validMessage.type);
            if (!handler) {
                await this.sendError(connectionId, 'UNKNOWN_MESSAGE_TYPE', `Unknown message type: ${validMessage.type}`);
                return;
            }

            await handler(connectionId, validMessage.data || {});

        } catch (error) {
            wsLogger.error('Error handling message', error instanceof Error ? error : new Error('Unknown message error'), {
                connectionId,
                userId: connection.context.userId,
                messageType: message?.type,
            });

            await this.sendError(connectionId, 'HANDLER_ERROR', 'Internal error processing message');
        }
    }

    //====================================================================
    // CONNECTION HANDLERS
    //====================================================================
    private async handlePing(connectionId: string, data: any): Promise<void> {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) return;

        try {
            connection.ws.send(JSON.stringify({
                type: 'pong',
                data: { timestamp: Date.now() },
                timestamp: new Date().toISOString(),
            }));
        } catch (error) {
            wsLogger.error('Failed to send pong', error instanceof Error ? error : new Error('Unknown pong error'), { connectionId });
        }
    }

    private async handlePong(connectionId: string, data: any): Promise<void> {
        this.connectionManager.markAlive(connectionId);
    }

    private async handleHeartbeat(connectionId: string, data: any): Promise<void> {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) return;

        this.connectionManager.markAlive(connectionId);

        try {
            connection.ws.send(JSON.stringify({
                type: 'heartbeat',
                data: { timestamp: Date.now() },
                timestamp: new Date().toISOString(),
            }));
        } catch (error) {
            wsLogger.error('Failed to send heartbeat response', error instanceof Error ? error : new Error('Unknown heartbeat error'), { connectionId });
        }
    }

    //====================================================================
    // ‚úÖ TASK 4 - ROOM HANDLERS (Required Implementation)
    //====================================================================
    private async handleJoinRoom(connectionId: string, data: any): Promise<void> {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) return;

        const { roomId, asSpectator = false } = data;

        if (!roomId || typeof roomId !== 'string') {
            await this.sendError(connectionId, 'MISSING_ROOM_ID', 'Room ID is required and must be a string');
            return;
        }

        try {
            // Join the room channel
            const success = this.channelManager.joinRoom(roomId, connectionId, asSpectator);
            if (!success) {
                await this.sendError(connectionId, 'JOIN_ROOM_FAILED', 'Failed to join room');
                return;
            }

            // Update connection context
            this.connectionManager.updateConnectionContext(connectionId, {
                roomId,
                isSpectator: asSpectator,
            });

            // Get room connections for player list
            const roomConnections = this.channelManager.getRoomPlayerConnections(roomId);
            const spectatorConnections = this.channelManager.getRoomSpectatorConnections(roomId);

            const players: any[] = [];
            const spectators: any[] = [];

            // Build player list
            for (const connId of roomConnections) {
                const conn = this.connectionManager.getConnection(connId);
                if (conn) {
                    players.push({
                        id: `${roomId}-${conn.context.userId}`,
                        userId: conn.context.userId,
                        username: conn.context.username,
                        avatar: null,
                        isHost: false,
                        isReady: false,
                        isSpectator: false,
                        isConnected: true,
                        joinedAt: new Date().toISOString(),
                    });
                }
            }

            // Build spectator list
            for (const connId of spectatorConnections) {
                const conn = this.connectionManager.getConnection(connId);
                if (conn) {
                    spectators.push({
                        id: `${roomId}-${conn.context.userId}`,
                        userId: conn.context.userId,
                        username: conn.context.username,
                        avatar: null,
                        isSpectator: true,
                        isConnected: true,
                        joinedAt: new Date().toISOString(),
                    });
                }
            }

            // Create player object for this connection
            const player = {
                id: `${roomId}-${connection.context.userId}`,
                userId: connection.context.userId,
                username: connection.context.username,
                avatar: null,
                isHost: false,
                isReady: false,
                isSpectator: asSpectator,
                isConnected: true,
                joinedAt: new Date().toISOString(),
            };

            // Send room-joined event to the joining player
            await this.sendToConnection(connectionId, 'room-joined', {
                room: {
                    id: roomId,
                    name: `Room ${roomId}`,
                    code: null,
                    isPrivate: false,
                    maxPlayers: 15,
                    maxSpectators: 5,
                    status: 'WAITING',
                    hostId: '',
                    hostUsername: '',
                    currentPlayers: players.length,
                    currentSpectators: spectators.length,
                    players,
                    spectators,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                },
                player,
                yourRole: asSpectator ? 'SPECTATOR' : 'PLAYER',
            });

            // Broadcast player-joined to other room members
            if (this.broadcastToRoom) {
                this.broadcastToRoom(roomId, 'player-joined', { player }, connectionId);
            }

            // Publish event to event bus
            await this.eventBus.publish('room:player-joined', {
                roomId,
                userId: connection.context.userId,
                username: connection.context.username,
                asSpectator,
                timestamp: new Date().toISOString(),
            });

            wsLogger.info('Player joined room', {
                connectionId,
                userId: connection.context.userId,
                username: connection.context.username,
                roomId,
                asSpectator,
            });

        } catch (error) {
            wsLogger.error('Error joining room', error instanceof Error ? error : new Error('Unknown join room error'), {
                connectionId,
                roomId,
                asSpectator,
            });

            await this.sendError(connectionId, 'JOIN_ROOM_FAILED', 'Internal error joining room');
        }
    }

    private async handleLeaveRoom(connectionId: string, data: any): Promise<void> {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) return;

        const roomId: string | undefined = data?.roomId || connection.context.roomId;
        if (!roomId) {
            await this.sendError(connectionId, 'NOT_IN_ROOM', 'Not currently in a room');
            return;
        }

        try {
            // Leave the room channel
            const success = this.channelManager.leaveRoom(roomId, connectionId);
            if (!success) {
                await this.sendError(connectionId, 'LEAVE_ROOM_FAILED', 'Failed to leave room');
                return;
            }

            // Update connection context
            this.connectionManager.updateConnectionContext(connectionId, {
                roomId: undefined,
                isSpectator: false,
            });

            // Send room-left confirmation
            await this.sendToConnection(connectionId, 'room-left', { roomId });

            // Broadcast player-left to remaining room members
            if (this.broadcastToRoom) {
                this.broadcastToRoom(roomId, 'player-left', {
                    userId: connection.context.userId,
                    username: connection.context.username,
                }, connectionId);
            }

            // Publish event to event bus
            await this.eventBus.publish('room:player-left', {
                roomId,
                userId: connection.context.userId,
                username: connection.context.username,
                timestamp: new Date().toISOString(),
            });

            wsLogger.info('Player left room', {
                connectionId,
                userId: connection.context.userId,
                username: connection.context.username,
                roomId,
            });

        } catch (error) {
            wsLogger.error('Error leaving room', error instanceof Error ? error : new Error('Unknown leave room error'), {
                connectionId,
                roomId,
            });

            await this.sendError(connectionId, 'LEAVE_ROOM_FAILED', 'Internal error leaving room');
        }
    }

    private async handlePlayerReady(connectionId: string, data: any): Promise<void> {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection || !connection.context.roomId) {
            await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to set ready status');
            return;
        }

        const { ready } = data;
        if (typeof ready !== 'boolean') {
            await this.sendError(connectionId, 'INVALID_MESSAGE', 'Ready status must be boolean');
            return;
        }

        try {
            const roomId = connection.context.roomId;

            // Broadcast ready status to room
            if (this.broadcastToRoom) {
                this.broadcastToRoom(roomId, 'player-ready', {
                    userId: connection.context.userId,
                    username: connection.context.username,
                    ready,
                });
            }

            // Publish event to event bus
            await this.eventBus.publish('room:player-ready', {
                roomId,
                userId: connection.context.userId,
                username: connection.context.username,
                ready,
                timestamp: new Date().toISOString(),
            });

            wsLogger.info('Player ready status changed', {
                connectionId,
                userId: connection.context.userId,
                username: connection.context.username,
                roomId,
                ready,
            });

        } catch (error) {
            wsLogger.error('Error updating ready status', error instanceof Error ? error : new Error('Unknown ready status error'), {
                connectionId,
                ready,
            });

            await this.sendError(connectionId, 'READY_UPDATE_FAILED', 'Failed to update ready status');
        }
    }

    private async handleStartGame(connectionId: string, data: any): Promise<void> {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection || !connection.context.roomId) {
            await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to start game');
            return;
        }

        try {
            const roomId = connection.context.roomId;

            // Broadcast game starting event
            if (this.broadcastToRoom) {
                this.broadcastToRoom(roomId, 'game-starting', {
                    countdown: 5,
                });
            }

            // Simulate game start after countdown
            setTimeout(async () => {
                if (this.broadcastToRoom) {
                    this.broadcastToRoom(roomId, 'game-started', {
                        gameId: `game-${roomId}-${Date.now()}`,
                        players: [],
                        spectators: [],
                    });
                }

                // Publish event to event bus
                await this.eventBus.publish('room:game-started', {
                    roomId,
                    hostId: connection.context.userId,
                    timestamp: new Date().toISOString(),
                });
            }, 5000);

            wsLogger.info('Game start initiated', {
                connectionId,
                userId: connection.context.userId,
                username: connection.context.username,
                roomId,
            });

        } catch (error) {
            wsLogger.error('Error starting game', error instanceof Error ? error : new Error('Unknown start game error'), {
                connectionId,
            });

            await this.sendError(connectionId, 'START_GAME_FAILED', 'Failed to start game');
        }
    }

    //====================================================================
    // ADDITIONAL HANDLERS (Placeholders)
    //====================================================================
    private async handleKickPlayer(connectionId: string, data: any): Promise<void> {
        await this.sendError(connectionId, 'NOT_IMPLEMENTED', 'Kick player not yet implemented');
    }

    private async handleChatMessage(connectionId: string, data: any): Promise<void> {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) return;

        const { message, channel = 'public' } = data;

        if (!message || typeof message !== 'string') {
            await this.sendError(connectionId, 'INVALID_MESSAGE', 'Message is required and must be a string');
            return;
        }

        wsLogger.info('Chat message received', {
            connectionId,
            userId: connection.context.userId,
            message: message.substring(0, 50),
            channel,
        });
    }

    private async handleSpectateRoom(connectionId: string, data: any): Promise<void> {
        await this.handleJoinRoom(connectionId, { ...data, asSpectator: true });
    }

    private async handleStopSpectating(connectionId: string, data: any): Promise<void> {
        await this.handleLeaveRoom(connectionId, data);
    }

    private async handleGameAction(connectionId: string, data: any): Promise<void> {
        await this.sendError(connectionId, 'NOT_IMPLEMENTED', 'Game actions not yet implemented');
    }

    private async handleVote(connectionId: string, data: any): Promise<void> {
        await this.sendError(connectionId, 'NOT_IMPLEMENTED', 'Voting not yet implemented');
    }

    private async handleUnvote(connectionId: string, data: any): Promise<void> {
        await this.sendError(connectionId, 'NOT_IMPLEMENTED', 'Unvote not yet implemented');
    }

    //====================================================================
    // UTILITY METHODS
    //====================================================================
    private async sendToConnection(connectionId: string, type: string, data?: any): Promise<void> {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection || connection.ws.readyState !== connection.ws.OPEN) {
            return;
        }

        try {
            const message = {
                type,
                data,
                timestamp: new Date().toISOString(),
            };

            connection.ws.send(JSON.stringify(message));
        } catch (error) {
            wsLogger.error('Failed to send message to connection', error instanceof Error ? error : new Error('Unknown send error'), {
                connectionId,
                type,
            });
        }
    }

    private async sendError(connectionId: string, code: WebSocketErrorCode, message: string): Promise<void> {
        await this.sendToConnection(connectionId, 'error', {
            code,
            message,
        });
    }

    //====================================================================
    // HANDLER REGISTRATION (for extensibility)
    //====================================================================
    registerHandler(type: string, handler: MessageHandler): void {
        if (this.handlers.has(type)) {
            wsLogger.warn('Overriding existing message handler', { type });
        }

        this.handlers.set(type, handler);
        wsLogger.debug('Message handler registered', { type });
    }

    unregisterHandler(type: string): boolean {
        const existed = this.handlers.delete(type);
        if (existed) {
            wsLogger.debug('Message handler unregistered', { type });
        }
        return existed;
    }

    getRegisteredHandlers(): string[] {
        return Array.from(this.handlers.keys());
    }
}
</file>

<file path="backend/src/websocket/WebSocketManager.ts">
// üê∫ LOBISOMEM ONLINE - WebSocket Manager (CORRE√á√ÉO DEFINITIVA)
import { Server as HttpServer } from 'http';
// CORRE√á√ÉO: Importa 'WebSocket' e 'WebSocketServer' como valores, n√£o apenas como tipos.
import WebSocket, { WebSocketServer } from 'ws';
import { ConnectionManager } from './ConnectionManager';
import { ChannelManager } from './ChannelManager';
import { MessageRouter } from './MessageRouter';
import { HeartbeatManager } from './HeartbeatManager';
import { extractTokenFromWebSocketRequest, verifyAccessToken } from '@/config/jwt';
import { wsConfig, parseWebSocketURL, extractConnectionMetadata } from '@/config/websocket';
import { wsLogger } from '@/utils/logger';
import type { IncomingMessage } from 'http';
import type { IGameStateService, IEventBus, ConnectionContext } from '@/types';
import type { Config } from '@/config/environment';

export class WebSocketManager {
    public wss: WebSocketServer | null = null; // Tornar p√∫blico para acesso externo
    public connectionManager: ConnectionManager;
    public channelManager: ChannelManager;
    private messageRouter: MessageRouter;
    public heartbeatManager: HeartbeatManager; // Tornar p√∫blico
    private isShuttingDown = false;

    constructor(
        gameStateService: IGameStateService,
        eventBus: IEventBus,
        private config: Config
    ) {
        this.connectionManager = new ConnectionManager();
        this.channelManager = new ChannelManager(this.connectionManager);
        this.heartbeatManager = new HeartbeatManager(this.connectionManager);
        this.messageRouter = new MessageRouter(
            this.connectionManager, this.channelManager, gameStateService, eventBus
        );
        this.messageRouter.setBroadcastMethods(
            this.broadcastToRoom.bind(this), this.sendToUser.bind(this)
        );
    }

    setupWebSocketServer(httpServer: HttpServer): void {
        this.wss = new WebSocketServer({ server: httpServer, path: wsConfig.path, ...wsConfig.server });
        this.wss.on('connection', this.handleConnection.bind(this));
        this.heartbeatManager.start();
        wsLogger.info('WebSocket server started');
    }

    private async handleConnection(ws: WebSocket, request: IncomingMessage): Promise<void> {
        // ... (l√≥gica de conex√£o permanece a mesma da sua vers√£o original)
        let connectionId: string | undefined;
        try {
            const token = extractTokenFromWebSocketRequest(request);
            if (!token) return ws.close(1008, 'Authentication required');

            const payload = verifyAccessToken(token);
            const urlInfo = parseWebSocketURL(request.url || '');
            if (!urlInfo.isValid) return ws.close(1008, 'Invalid WebSocket URL');

            const context: ConnectionContext = {
                userId: payload.userId,
                username: payload.username,
                serverId: this.config.SERVICE_ID,
                isSpectator: false,
            };
            if (urlInfo.roomId) context.roomId = urlInfo.roomId;

            const metadata = extractConnectionMetadata(request);
            connectionId = this.connectionManager.addConnection(ws, context, metadata);
            wsLogger.info('WebSocket connection established', { connectionId, userId: context.userId, roomId: context.roomId });

            this.setupConnectionHandlers(ws, connectionId);

            this.sendToConnection(connectionId, 'connected', { userId: context.userId });

            if (context.roomId) {
                await this.messageRouter.handleMessage(connectionId, {
                    type: 'join-room',
                    data: { roomId: context.roomId },
                    timestamp: new Date().toISOString(),
                });
            }
        } catch (error) {
            wsLogger.error('Connection failed', error instanceof Error ? error : new Error('Unknown error'));
            ws.close(1008, 'Authentication failed');
        }
    }

    private setupConnectionHandlers(ws: WebSocket, connectionId: string): void {
        ws.on('message', async (data: Buffer) => {
            try {
                const message = JSON.parse(data.toString());
                await this.messageRouter.handleMessage(connectionId, message);
            } catch (e) { /* ignora erro de parse */ }
        });
        ws.on('pong', () => this.heartbeatManager.handlePong(connectionId));
        ws.on('close', (code, reason) => this.handleDisconnection(connectionId, code, reason.toString()));
        ws.on('error', error => wsLogger.error('WS Connection Error', error, { connectionId }));
    }

    private handleDisconnection(connectionId: string, code: number, reason: string): void {
        const conn = this.connectionManager.getConnection(connectionId);
        if (!conn) return;
        wsLogger.info('Disconnected', { connectionId, userId: conn.context.userId, code, reason });
        if (conn.context.roomId) {
            this.broadcastToRoom(conn.context.roomId, 'player-left', { userId: conn.context.userId, username: conn.context.username }, connectionId);
        }
        this.channelManager.removeConnectionFromAllRooms(connectionId);
        this.connectionManager.removeConnection(connectionId);
    }

    private sendToConnection(id: string, type: string, data?: any) {
        const conn = this.connectionManager.getConnection(id);
        // CORRE√á√ÉO: `WebSocket.OPEN` √© um valor est√°tico, por isso a importa√ß√£o de valor √© necess√°ria.
        if (conn && conn.ws.readyState === WebSocket.OPEN) {
            conn.ws.send(JSON.stringify({ type, data }));
            return true;
        }
        return false;
    }

    private broadcastToRoom(roomId: string, type: string, data?: any, excludeConnectionId?: string): number {
        return this.channelManager.broadcastToRoom(roomId, type, data, excludeConnectionId);
    }

    private sendToUser(userId: string, type: string, data?: any): boolean {
        const connId = this.connectionManager.getUserConnection(userId);
        return connId ? this.sendToConnection(connId, type, data) : false;
    }

    // CORRE√á√ÉO: Adicionando os m√©todos p√∫blicos que faltavam para `server.ts`
    public getStats() {
        return {
            totalConnections: this.connectionManager.getConnectionCount(),
            activeRooms: this.channelManager.getActiveRoomsCount(),
            heartbeat: this.heartbeatManager.getStats(),
        };
    }

    public async shutdown(): Promise<void> {
        if (this.isShuttingDown) return;
        this.isShuttingDown = true;
        wsLogger.info('Shutting down WebSocket server...');
        this.heartbeatManager.stop();
        this.wss?.close();
        this.connectionManager.clear();
        this.channelManager.clear();
        wsLogger.info('WebSocket server shutdown complete.');
    }
}
</file>

<file path="frontend/src/components/common/ErrorBoundary.tsx">
'use client';

import React, { Component, ReactNode } from 'react';
import { motion } from 'framer-motion';
import { RefreshCw, Home, AlertTriangle } from 'lucide-react';
import Button from './Button';

// =============================================================================
// ERROR BOUNDARY TYPES
// =============================================================================
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}

// =============================================================================
// ERROR BOUNDARY CLASS COMPONENT
// =============================================================================
export default class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    this.setState({
      error,
      errorInfo,
    });

    // Log error to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Error caught by ErrorBoundary:', error);
      console.error('Error info:', errorInfo);
    }

    // Call onError prop if provided
    this.props.onError?.(error, errorInfo);

    // In production, you might want to send this to an error reporting service
    // Example: Sentry, LogRocket, etc.
  }

  handleRetry = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });
  };

  handleGoHome = () => {
    window.location.href = '/';
  };

  render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default error UI
      return <DefaultErrorUI
        error={this.state.error}
        onRetry={this.handleRetry}
        onGoHome={this.handleGoHome}
      />;
    }

    return this.props.children;
  }
}

// =============================================================================
// DEFAULT ERROR UI
// =============================================================================
interface DefaultErrorUIProps {
  error: Error | null;
  onRetry: () => void;
  onGoHome: () => void;
}

function DefaultErrorUI({ error, onRetry, onGoHome }: DefaultErrorUIProps) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 to-red-950 flex items-center justify-center p-6">
      <motion.div
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        className="max-w-md w-full text-center"
      >
        {/* Error icon */}
        <motion.div
          animate={{
            scale: [1, 1.1, 1],
            rotate: [0, 5, -5, 0]
          }}
          transition={{
            duration: 2,
            repeat: Infinity,
            ease: 'easeInOut'
          }}
          className="text-8xl mb-6"
        >
          üíÄ
        </motion.div>

        {/* Title */}
        <h1 className="text-3xl font-medieval text-red-300 mb-4 text-glow">
          Algo deu errado!
        </h1>

        {/* Description */}
        <p className="text-white/70 mb-6 leading-relaxed">
          A vila foi atacada por um erro inesperado.
          N√£o se preocupe, podemos tentar novamente.
        </p>

        {/* Error message in development */}
        {process.env.NODE_ENV === 'development' && error && (
          <div className="bg-black/30 border border-red-500/30 rounded-lg p-4 mb-6 text-left">
            <div className="flex items-center mb-2">
              <AlertTriangle className="w-4 h-4 text-red-400 mr-2" />
              <span className="text-red-400 font-semibold text-sm">
                Erro de Desenvolvimento
              </span>
            </div>
            <pre className="text-red-300 text-xs overflow-auto max-h-32">
              {error.message}
            </pre>
          </div>
        )}

        {/* Action buttons */}
        <div className="space-y-3">
          <Button
            variant="medieval"
            size="lg"
            onClick={onRetry}
            className="w-full"
          >
            <RefreshCw className="w-5 h-5 mr-2" />
            Tentar Novamente
          </Button>

          <Button
            variant="ghost"
            size="lg"
            onClick={onGoHome}
            className="w-full"
          >
            <Home className="w-5 h-5 mr-2" />
            Voltar ao In√≠cio
          </Button>
        </div>

        {/* Footer */}
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 1 }}
          className="text-white/40 text-sm mt-8"
        >
          Se o problema persistir, recarregue a p√°gina
        </motion.p>
      </motion.div>
    </div>
  );
}

// =============================================================================
// HOOK FOR FUNCTIONAL COMPONENTS
// =============================================================================
export function useErrorHandler() {
  const [error, setError] = React.useState<Error | null>(null);

  const resetError = React.useCallback(() => {
    setError(null);
  }, []);

  const captureError = React.useCallback((error: Error) => {
    setError(error);
    console.error('Error captured:', error);
  }, []);

  // Throw error to be caught by ErrorBoundary
  React.useEffect(() => {
    if (error) {
      throw error;
    }
  }, [error]);

  return { captureError, resetError };
}

// =============================================================================
// SPECIFIC ERROR COMPONENTS
// =============================================================================

// Network Error
export function NetworkError({ onRetry }: { onRetry: () => void }) {
  return (
    <div className="text-center p-8">
      <div className="text-6xl mb-4">üì°</div>
      <h3 className="text-xl font-bold text-white mb-2">
        Erro de Conex√£o
      </h3>
      <p className="text-white/70 mb-6">
        N√£o foi poss√≠vel conectar com o servidor.
        Verifique sua internet e tente novamente.
      </p>
      <Button variant="primary" onClick={onRetry}>
        <RefreshCw className="w-4 h-4 mr-2" />
        Tentar Novamente
      </Button>
    </div>
  );
}

// Game Error
export function GameError({
  message,
  onRetry,
  onLeave
}: {
  message: string;
  onRetry?: () => void;
  onLeave?: () => void;
}) {
  return (
    <div className="text-center p-8">
      <div className="text-6xl mb-4">üéÆ</div>
      <h3 className="text-xl font-bold text-white mb-2">
        Erro no Jogo
      </h3>
      <p className="text-white/70 mb-6">
        {message}
      </p>
      <div className="space-y-3">
        {onRetry && (
          <Button variant="primary" onClick={onRetry} className="w-full">
            <RefreshCw className="w-4 h-4 mr-2" />
            Tentar Novamente
          </Button>
        )}
        {onLeave && (
          <Button variant="ghost" onClick={onLeave} className="w-full">
            <Home className="w-4 h-4 mr-2" />
            Sair do Jogo
          </Button>
        )}
      </div>
    </div>
  );
}

// 404 Error
export function NotFoundError() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 to-medieval-800 flex items-center justify-center p-6">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="text-center max-w-md"
      >
        <div className="text-8xl mb-6">üèöÔ∏è</div>
        <h1 className="text-4xl font-medieval text-white mb-4">
          404
        </h1>
        <h2 className="text-xl text-white/80 mb-6">
          Esta p√°gina foi devorada pelos lobos
        </h2>
        <p className="text-white/60 mb-8">
          A p√°gina que voc√™ procura n√£o existe ou foi movida para outro local.
        </p>
        <Button
          variant="medieval"
          size="lg"
          onClick={() => window.location.href = '/'}
        >
          <Home className="w-5 h-5 mr-2" />
          Voltar √† Vila
        </Button>
      </motion.div>
    </div>
  );
}
</file>

<file path="frontend/src/components/common/Layout.tsx">
'use client';

import { ReactNode, useState } from 'react';
import { motion } from 'framer-motion';
import {
  Home,
  User,
  Trophy,
  Settings,
  LogOut,
  Volume2,
  VolumeX,
  Moon,
  Sun,
  Menu,
  X
} from 'lucide-react';
import { clsx } from 'clsx';
import { useAuth } from '@/context/AuthContext';
import { useTheme } from '@/context/ThemeContext';
import { useSocket } from '@/context/SocketContext';
import Button from './Button';
import { useRouter } from 'next/navigation';

// =============================================================================
// LAYOUT PROPS
// =============================================================================
interface LayoutProps {
  children: ReactNode;
  showHeader?: boolean;
  showSidebar?: boolean;
  showFooter?: boolean;
  className?: string;
  variant?: 'default' | 'game' | 'auth' | 'landing';
}

// =============================================================================
// MAIN LAYOUT COMPONENT
// =============================================================================
export default function Layout({
  children,
  showHeader = true,
  showSidebar = true,
  showFooter = true,
  className = '',
  variant = 'default',
}: LayoutProps) {
  const { getThemeClass, getPhaseColors } = useTheme();
  const phaseColors = getPhaseColors();

  // Variant-specific layouts
  if (variant === 'auth') {
    return <AuthLayout>{children}</AuthLayout>;
  }

  if (variant === 'landing') {
    return <LandingLayout>{children}</LandingLayout>;
  }

  if (variant === 'game') {
    return <GameLayout>{children}</GameLayout>;
  }

  // Default layout
  return (
    <div className={clsx(
      'min-h-screen',
      `bg-gradient-to-br ${phaseColors.background}`,
      getThemeClass(),
      className
    )}>
      {showHeader && <Header />}

      <div className="flex">
        {showSidebar && <Sidebar />}

        <main className={clsx(
          'flex-1 transition-all duration-300',
          showSidebar ? 'ml-64' : 'ml-0',
          showHeader ? 'pt-16' : 'pt-0',
          'p-6'
        )}>
          {children}
        </main>
      </div>

      {showFooter && <Footer />}
    </div>
  );
}

// =============================================================================
// HEADER COMPONENT
// =============================================================================
function Header() {
  const { user, logout } = useAuth();
  const { isDark, toggleDarkMode, audioConfig, updateAudioConfig } = useTheme();
  const { status } = useSocket();
  const [showUserMenu, setShowUserMenu] = useState(false);

  const toggleAudio = () => {
    updateAudioConfig({ enabled: !audioConfig.enabled });
  };

  return (
    <motion.header
      initial={{ y: -100 }}
      animate={{ y: 0 }}
      className="fixed top-0 left-0 right-0 z-40 bg-medieval-900/95 backdrop-blur-sm border-b border-medieval-600"
    >
      <div className="flex items-center justify-between h-16 px-6">
        {/* Logo */}
        <div className="flex items-center space-x-3">
          <div className="text-2xl">üê∫</div>
          <h1 className="text-xl font-medieval text-glow">
            Werewolf
          </h1>

          {/* Connection status */}
          <div className={clsx(
            'w-2 h-2 rounded-full',
            status === 'connected' ? 'bg-green-400' : 'bg-red-400'
          )} />
        </div>

        {/* Controls */}
        <div className="flex items-center space-x-3">
          {/* Audio toggle */}
          <Button
            variant="ghost"
            size="sm"
            onClick={toggleAudio}
            aria-label={audioConfig.enabled ? 'Desativar som' : 'Ativar som'}
          >
            {audioConfig.enabled ?
              <Volume2 className="w-5 h-5" /> :
              <VolumeX className="w-5 h-5" />
            }
          </Button>

          {/* Theme toggle */}
          <Button
            variant="ghost"
            size="sm"
            onClick={toggleDarkMode}
            aria-label={isDark ? 'Tema claro' : 'Tema escuro'}
          >
            {isDark ?
              <Sun className="w-5 h-5" /> :
              <Moon className="w-5 h-5" />
            }
          </Button>

          {/* User menu */}
          {user && (
            <div className="relative">
              <Button
                variant="ghost"
                onClick={() => setShowUserMenu(!showUserMenu)}
                className="flex items-center space-x-2"
              >
                <div className="w-8 h-8 bg-salem-600 rounded-full flex items-center justify-center">
                  {user.avatar ? (
                    <img src={user.avatar} alt="" className="w-full h-full rounded-full" />
                  ) : (
                    <span className="text-sm font-bold">
                      {user.username.charAt(0).toUpperCase()}
                    </span>
                  )}
                </div>
                <span className="font-medium">{user.username}</span>
              </Button>

              {/* Dropdown menu */}
              {showUserMenu && (
                <motion.div
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  className="absolute right-0 mt-2 w-48 bg-medieval-800 rounded-lg shadow-medieval border border-medieval-600"
                >
                  <div className="py-2">
                    <div className="px-4 py-2 border-b border-medieval-600">
                      <p className="text-sm text-white/70">N√≠vel {user.level}</p>
                      <p className="text-xs text-white/50">{user.totalGames} jogos</p>
                    </div>

                    <Button
                      variant="ghost"
                      className="w-full justify-start px-4 py-2 text-left"
                      onClick={() => setShowUserMenu(false)}
                    >
                      <User className="w-4 h-4 mr-2" />
                      Perfil
                    </Button>

                    <Button
                      variant="ghost"
                      className="w-full justify-start px-4 py-2 text-left"
                      onClick={() => setShowUserMenu(false)}
                    >
                      <Settings className="w-4 h-4 mr-2" />
                      Configura√ß√µes
                    </Button>

                    <div className="border-t border-medieval-600 mt-2 pt-2">
                      <Button
                        variant="ghost"
                        className="w-full justify-start px-4 py-2 text-left text-red-400 hover:text-red-300"
                        onClick={() => {
                          setShowUserMenu(false);
                          logout();
                        }}
                      >
                        <LogOut className="w-4 h-4 mr-2" />
                        Sair
                      </Button>
                    </div>
                  </div>
                </motion.div>
              )}
            </div>
          )}
        </div>
      </div>
    </motion.header>
  );
}

// =============================================================================
// SIDEBAR COMPONENT
// =============================================================================
function Sidebar() {
  const router = useRouter();
  const [isCollapsed, setIsCollapsed] = useState(false);

  const menuItems = [
    { icon: Home, label: 'Lobby', href: '/lobby' },
    { icon: User, label: 'Perfil', href: '/profile' },
    { icon: Trophy, label: 'Ranking', href: '/leaderboard' },
    { icon: Settings, label: 'Configura√ß√µes', href: '/settings' },
  ];

  return (
    <motion.aside
      initial={{ x: -300 }}
      animate={{ x: 0 }}
      className={clsx(
        'fixed left-0 top-16 bottom-0 z-30',
        'bg-medieval-900/95 backdrop-blur-sm border-r border-medieval-600',
        'transition-all duration-300',
        isCollapsed ? 'w-16' : 'w-64'
      )}
    >
      {/* Toggle button */}
      <div className="p-4 border-b border-medieval-600">
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setIsCollapsed(!isCollapsed)}
          className="w-full justify-center"
        >
          {isCollapsed ? <Menu className="w-5 h-5" /> : <X className="w-5 h-5" />}
        </Button>
      </div>

      {/* Navigation */}
      <nav className="p-4 space-y-2">
        {menuItems.map((item) => (
          <Button
            key={item.href}
            variant="ghost"
            className={clsx(
              'w-full justify-start',
              isCollapsed ? 'px-2' : 'px-4'
            )}
            onClick={() => router.push(item.href)}
          >
            <item.icon className="w-5 h-5" />
            {!isCollapsed && <span className="ml-3">{item.label}</span>}
          </Button>
        ))}
      </nav>
    </motion.aside>
  );
}

// =============================================================================
// FOOTER COMPONENT
// =============================================================================
function Footer() {
  return (
    <footer className="bg-medieval-900/80 border-t border-medieval-600 py-4 px-6 mt-auto relative z-10">
      <div className="flex items-center justify-between text-sm text-white/70">
        <p>¬© 2025 Werewolf. Todos os direitos reservados.</p>
        <p>Vers√£o 1.0.0</p>
      </div>
    </footer>
  );
}

// =============================================================================
// AUTH LAYOUT
// =============================================================================
function AuthLayout({ children }: { children: ReactNode }) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-night-dark flex items-center justify-center p-4">
      <div className="w-full max-w-md">
        {/* Logo */}
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-center mb-8"
        >
          <div className="text-6xl mb-4">üê∫</div>
          <h1 className="text-3xl font-medieval text-glow">
            Werewolf
          </h1>
          <p className="text-white/70 mt-2">
            Entre na vila... se tiver coragem
          </p>
        </motion.div>

        {/* Content */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2 }}
        >
          {children}
        </motion.div>
      </div>
    </div>
  );
}

// =============================================================================
// LANDING LAYOUT
// =============================================================================
function LandingLayout({ children }: { children: ReactNode }) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-night-dark">
      {children}
    </div>
  );
}

// =============================================================================
// GAME LAYOUT
// =============================================================================
function GameLayout({ children }: { children: ReactNode }) {
  const { currentPhase, getPhaseColors } = useTheme();
  const phaseColors = getPhaseColors();

  return (
    <div className={clsx(
      'min-h-screen transition-all duration-1000',
      `bg-gradient-to-br ${phaseColors.background}`
    )}>
      {/* Game header */}
      <div className="bg-black/20 border-b border-white/10 px-6 py-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <div className="text-2xl">üê∫</div>
            <div>
              <h1 className="font-medieval text-xl text-glow">
                Werewolf
              </h1>
              <p className={clsx('text-sm', phaseColors.text)}>
                Fase: {currentPhase}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Game content */}
      <div className="relative">
        {children}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/common/LoadingSpinner.tsx">
'use client';

import { motion } from 'framer-motion';
import { clsx } from 'clsx';

// =============================================================================
// LOADING SPINNER COMPONENT
// =============================================================================
interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg' | 'xl';
  variant?: 'default' | 'medieval' | 'werewolf' | 'dots';
  className?: string;
  text?: string;
}

function LoadingSpinner({
  size = 'md',
  variant = 'default',
  className = '',
  text,
}: LoadingSpinnerProps) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
    xl: 'w-16 h-16',
  };

  if (variant === 'medieval') {
    return <MedievalSpinner size={size} className={className} text={text} />;
  }

  if (variant === 'werewolf') {
    return <WerewolfSpinner size={size} className={className} text={text} />;
  }

  if (variant === 'dots') {
    return <DotsSpinner size={size} className={className} text={text} />;
  }

  // Default spinner
  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <motion.div
        className={clsx(
          sizeClasses[size],
          'border-3 border-salem-600 border-t-transparent rounded-full'
        )}
        animate={{ rotate: 360 }}
        transition={{
          duration: 1,
          repeat: Infinity,
          ease: 'linear',
        }}
      />
      {text && (
        <p className="mt-3 text-white/70 font-medium animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// MEDIEVAL SPINNER
// =============================================================================
function MedievalSpinner({
  size,
  className,
  text
}: Pick<LoadingSpinnerProps, 'size' | 'className' | 'text'>) {
  const iconSizes = {
    sm: 'text-2xl',
    md: 'text-4xl',
    lg: 'text-6xl',
    xl: 'text-8xl',
  };

  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <motion.div
        className={clsx('text-amber-400', iconSizes[size!])}
        animate={{
          rotate: 360,
          scale: [1, 1.1, 1],
        }}
        transition={{
          rotate: {
            duration: 2,
            repeat: Infinity,
            ease: 'linear',
          },
          scale: {
            duration: 1,
            repeat: Infinity,
            ease: 'easeInOut',
          },
        }}
      >
        ‚öîÔ∏è
      </motion.div>
      {text && (
        <p className="mt-3 text-amber-300 font-medieval animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// WEREWOLF SPINNER
// =============================================================================
function WerewolfSpinner({
  size,
  className,
  text
}: Pick<LoadingSpinnerProps, 'size' | 'className' | 'text'>) {
  const iconSizes = {
    sm: 'text-2xl',
    md: 'text-4xl',
    lg: 'text-6xl',
    xl: 'text-8xl',
  };

  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <motion.div
        className={clsx('text-red-400', iconSizes[size!])}
        animate={{
          scale: [1, 1.3, 1],
          rotate: [0, 5, -5, 0],
        }}
        transition={{
          duration: 2,
          repeat: Infinity,
          ease: 'easeInOut',
        }}
      >
        üê∫
      </motion.div>
      {text && (
        <p className="mt-3 text-red-300 font-bold animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// DOTS SPINNER
// =============================================================================
function DotsSpinner({
  size,
  className,
  text
}: Pick<LoadingSpinnerProps, 'size' | 'className' | 'text'>) {
  const dotSizes = {
    sm: 'w-2 h-2',
    md: 'w-3 h-3',
    lg: 'w-4 h-4',
    xl: 'w-6 h-6',
  };

  const dotSpacing = {
    sm: 'space-x-1',
    md: 'space-x-2',
    lg: 'space-x-3',
    xl: 'space-x-4',
  };

  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <div className={clsx('flex', dotSpacing[size!])}>
        {[0, 1, 2].map((index) => (
          <motion.div
            key={index}
            className={clsx(
              dotSizes[size!],
              'bg-salem-400 rounded-full'
            )}
            animate={{
              scale: [1, 1.5, 1],
              opacity: [0.5, 1, 0.5],
            }}
            transition={{
              duration: 1.5,
              repeat: Infinity,
              delay: index * 0.2,
              ease: 'easeInOut',
            }}
          />
        ))}
      </div>
      {text && (
        <p className="mt-3 text-white/70 font-medium animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// FULLSCREEN LOADING
// =============================================================================
interface FullscreenLoadingProps {
  variant?: LoadingSpinnerProps['variant'];
  message?: string;
  submessage?: string;
}

export function FullscreenLoading({
  variant = 'medieval',
  message = 'Carregando...',
  submessage,
}: FullscreenLoadingProps) {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="fixed inset-0 z-50 flex items-center justify-center bg-medieval-900/95 backdrop-blur-sm"
    >
      <div className="text-center">
        <LoadingSpinner
          variant={variant}
          size="xl"
          text={message}
        />
        {submessage && (
          <motion.p
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.5 }}
            className="mt-4 text-white/50 text-sm"
          >
            {submessage}
          </motion.p>
        )}
      </div>
    </motion.div>
  );
}

// =============================================================================
// PAGE LOADING
// =============================================================================
export function PageLoading() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-medieval-900">
      <div className="text-center">
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          className="text-8xl mb-8"
        >
          üê∫
        </motion.div>

        <motion.h1
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
          className="text-3xl font-medieval text-glow mb-4"
        >
          Lobisomem Online
        </motion.h1>

        <LoadingSpinner
          variant="medieval"
          size="lg"
          text="Preparando a vila..."
        />
      </div>
    </div>
  );
}

// =============================================================================
// ‚úÖ EXPORTS CORRETOS - ADICIONADOS NO FINAL
// =============================================================================
export default LoadingSpinner;
</file>

<file path="frontend/src/components/room/ActionButtons.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import {
  Check,
  Clock,
  Play,
  Wifi,
  WifiOff,
  AlertCircle,
  Crown
} from 'lucide-react';

interface ActionButtonsProps {
  isHost: boolean;
  isReady: boolean;
  canStartGame: boolean;
  isConnected: boolean;
  onToggleReady: () => void;
  onStartGame: () => void;
}

export default function ActionButtons({
  isHost,
  isReady,
  canStartGame,
  isConnected,
  onToggleReady,
  onStartGame
}: ActionButtonsProps) {
  return (
    <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
      <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
        {isHost && <Crown className="w-5 h-5 text-yellow-400" />}
        {isHost ? 'Controles do Host' : 'A√ß√µes'}
      </h3>

      <div className="space-y-3">
        {/* Bot√£o Ready para todos */}
        <motion.button
          whileHover={{ scale: 1.02 }}
          whileTap={{ scale: 0.98 }}
          onClick={onToggleReady}
          disabled={!isConnected}
          className={`
            w-full py-3 px-4 rounded-lg font-medium transition-all duration-200
            flex items-center justify-center gap-2
            ${isReady
              ? 'bg-green-600 hover:bg-green-700 text-white shadow-lg'
              : 'bg-orange-600 hover:bg-orange-700 text-white'
            }
            disabled:opacity-50 disabled:cursor-not-allowed
          `}
        >
          {isReady ? (
            <>
              <Check className="w-5 h-5" />
              Pronto! (Clique para cancelar)
            </>
          ) : (
            <>
              <Clock className="w-5 h-5" />
              Marcar como Pronto
            </>
          )}
        </motion.button>

        {/* Bot√£o Start Game apenas para host */}
        {isHost && (
          <motion.button
            whileHover={canStartGame ? { scale: 1.02 } : {}}
            whileTap={canStartGame ? { scale: 0.98 } : {}}
            onClick={onStartGame}
            disabled={!canStartGame || !isConnected}
            className={`
              w-full py-3 px-4 rounded-lg font-medium transition-all duration-200
              flex items-center justify-center gap-2
              ${canStartGame
                ? 'bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white shadow-lg shadow-green-600/25'
                : 'bg-slate-600 text-slate-400 cursor-not-allowed'
              }
              disabled:opacity-50
            `}
          >
            <Play className="w-5 h-5" />
            {canStartGame ? 'üéÆ Iniciar Jogo!' : 'Aguardando jogadores prontos...'}
          </motion.button>
        )}

        {/* Informa√ß√µes adicionais para host */}
        {isHost && (
          <div className="mt-4 p-3 bg-slate-700/30 rounded-lg border border-slate-600/50">
            <div className="flex items-center gap-2 text-sm text-slate-300 mb-2">
              <AlertCircle className="w-4 h-4" />
              Requisitos para iniciar:
            </div>
            <ul className="text-xs text-slate-400 space-y-1">
              <li>‚Ä¢ M√≠nimo de 3 jogadores</li>
              <li>‚Ä¢ Todos os jogadores prontos</li>
              <li>‚Ä¢ Conex√£o est√°vel</li>
            </ul>
          </div>
        )}

        {/* Indicador de conex√£o */}
        <div className="flex items-center justify-center gap-2 text-sm pt-2 border-t border-slate-600/50">
          {isConnected ? (
            <>
              <Wifi className="w-4 h-4 text-green-500" />
              <span className="text-green-500">Conectado</span>
            </>
          ) : (
            <>
              <WifiOff className="w-4 h-4 text-red-500" />
              <span className="text-red-500">Desconectado</span>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/room/PlayerList.tsx">
import React from 'react'; // ‚úÖ CORRE√á√ÉO CRUCIAL: Adicionar esta linha.
import { motion, AnimatePresence } from 'framer-motion';
import {
  Users,
  Crown,
  Check,
  Clock,
  UserX,
  Eye
} from 'lucide-react';
import { Player } from '@/types';

interface PlayerListProps {
  players: Player[];
  spectators: Player[];
  currentUserId: string;
  isHost: boolean;
  onKickPlayer: (playerId: string) => void;
  maxPlayers: number;
  maxSpectators: number;
}

export default function PlayerList({
  players,
  spectators,
  currentUserId,
  isHost,
  onKickPlayer,
  maxPlayers,
  maxSpectators
}: PlayerListProps) {
  return (
    <div className="space-y-6">
      <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold flex items-center gap-2">
            <Users className="w-5 h-5" />
            Jogadores ({players.length}/{maxPlayers})
          </h3>
        </div>

        <div className="space-y-2">
          <AnimatePresence>
            {players.map((player) => (
              <motion.div
                key={player.id}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
                className={`
                  flex items-center justify-between p-3 rounded-lg
                  ${player.isConnected ? 'bg-slate-700/50' : 'bg-red-900/30'}
                  border ${player.isConnected ? 'border-slate-600' : 'border-red-600/50'}
                `}
              >
                <div className="flex items-center gap-3">
                  <div className="relative">
                    <div className="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white font-bold">
                      {player.username[0].toUpperCase()}
                    </div>
                    {player.isHost && (
                      <Crown className="absolute -top-1 -right-1 w-4 h-4 text-yellow-400" />
                    )}
                    <div className={`absolute -bottom-1 -right-1 w-3 h-3 rounded-full border-2 border-slate-800 ${player.isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
                  </div>

                  <div>
                    <div className="flex items-center gap-2">
                      <span className="font-medium">
                        {player.username}
                        {player.userId === currentUserId && " (Voc√™)"}
                      </span>
                      {player.isHost && (
                        <span className="text-xs bg-yellow-600 px-2 py-1 rounded-full">
                          HOST
                        </span>
                      )}
                    </div>
                    <div className="text-xs text-slate-400">
                      {player.isConnected ? 'Online' : 'Desconectado'}
                    </div>
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  <div className={`flex items-center gap-1 px-2 py-1 rounded-full text-xs ${player.isReady ? 'bg-green-600/20 text-green-400 border border-green-600/30' : 'bg-orange-600/20 text-orange-400 border border-orange-600/30'}`}>
                    {player.isReady ? (
                      <>
                        <Check className="w-3 h-3" />
                        Pronto
                      </>
                    ) : (
                      <>
                        <Clock className="w-3 h-3" />
                        Aguardando
                      </>
                    )}
                  </div>

                  {isHost && player.userId !== currentUserId && (
                    <button
                      onClick={() => onKickPlayer(player.id)}
                      className="p-1 rounded text-red-400 hover:bg-red-600/20 transition-colors"
                      title="Expulsar jogador"
                    >
                      <UserX className="w-4 h-4" />
                    </button>
                  )}
                </div>
              </motion.div>
            ))}
          </AnimatePresence>

          {Array.from({ length: maxPlayers - players.length }).map((_, index) => (
            <div key={index} className="flex items-center p-3 rounded-lg border-2 border-dashed border-slate-600">
              <div className="w-10 h-10 rounded-full bg-slate-700/50 flex items-center justify-center">
                <Users className="w-5 h-5 text-slate-500" />
              </div>
              <span className="ml-3 text-slate-500">Aguardando jogador...</span>
            </div>
          ))}
        </div>
      </div>

      {maxSpectators > 0 && (
        <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold flex items-center gap-2">
              <Eye className="w-5 h-5" />
              Espectadores ({spectators.length}/{maxSpectators})
            </h3>
          </div>

          <div className="space-y-2">
            <AnimatePresence>
              {spectators.map((spectator) => (
                <motion.div
                  key={spectator.id}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 20 }}
                  className="flex items-center justify-between p-2 rounded-lg bg-slate-700/30 border border-slate-600/50"
                >
                  <div className="flex items-center gap-2">
                    <div className="relative">
                      <div className="w-8 h-8 rounded-full bg-gradient-to-br from-slate-500 to-slate-600 flex items-center justify-center text-white text-sm">
                        {spectator.username[0].toUpperCase()}
                      </div>
                      <div className={`absolute -bottom-0.5 -right-0.5 w-2 h-2 rounded-full border border-slate-800 ${spectator.isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
                    </div>
                    <span className="text-sm">
                      {spectator.username}
                      {spectator.userId === currentUserId && " (Voc√™)"}
                    </span>
                  </div>

                  {isHost && spectator.userId !== currentUserId && (
                    <button
                      onClick={() => onKickPlayer(spectator.id)}
                      className="p-1 rounded text-red-400 hover:bg-red-600/20 transition-colors"
                      title="Expulsar espectador"
                    >
                      <UserX className="w-3 h-3" />
                    </button>
                  )}
                </motion.div>
              ))}
            </AnimatePresence>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/room/RoomChat.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { MessageCircle, Send } from 'lucide-react';
import { ChatMessage } from '@/types';

interface RoomChatProps {
  messages: ChatMessage[];
  onSendMessage: (message: string) => void;
  currentUserId: string;
  isConnected: boolean;
}

export default function RoomChat({
  messages,
  onSendMessage,
  currentUserId,
  isConnected
}: RoomChatProps) {
  const [newMessage, setNewMessage] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const handleSendMessage = (e: React.FormEvent) => {
    e.preventDefault();
    if (!newMessage.trim() || !isConnected) return;

    onSendMessage(newMessage.trim());
    setNewMessage('');
    inputRef.current?.focus();
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage(e);
    }
  };

  const formatTime = (timestamp: string) => {
    return new Date(timestamp).toLocaleTimeString('pt-BR', {
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  return (
    <div className="bg-slate-800/50 rounded-lg border border-slate-700 flex flex-col h-96">
      {/* Header */}
      <div className="p-4 border-b border-slate-700">
        <h3 className="text-lg font-semibold flex items-center gap-2">
          <MessageCircle className="w-5 h-5" />
          Chat da Sala
          {!isConnected && (
            <span className="text-xs bg-red-600/20 text-red-400 px-2 py-1 rounded-full">
              Desconectado
            </span>
          )}
        </h3>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-3 scrollbar-thin scrollbar-thumb-slate-600 scrollbar-track-slate-800">
        <AnimatePresence>
          {messages.map((message) => (
            <motion.div
              key={message.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              className={`
                ${message.channel === 'system'
                  ? 'text-center text-sm text-slate-400 italic'
                  : message.userId === currentUserId
                    ? 'flex justify-end'
                    : 'flex justify-start'
                }
              `}
            >
              {message.channel === 'system' ? (
                <span>{message.message}</span>
              ) : (
                <div className={`
                  max-w-xs p-3 rounded-lg
                  ${message.userId === currentUserId
                    ? 'bg-blue-600 text-white rounded-br-none'
                    : 'bg-slate-700 text-white rounded-bl-none'
                  }
                `}>
                  <div className="text-xs opacity-75 mb-1">
                    {message.username} ‚Ä¢ {formatTime(message.timestamp)}
                  </div>
                  <div className="break-words">{message.message}</div>
                </div>
              )}
            </motion.div>
          ))}
        </AnimatePresence>
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <form onSubmit={handleSendMessage} className="p-4 border-t border-slate-700">
        <div className="flex gap-2">
          <input
            ref={inputRef}
            type="text"
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder={isConnected ? "Digite sua mensagem..." : "Conectando..."}
            disabled={!isConnected}
            className="flex-1 px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:opacity-50"
            maxLength={200}
          />
          <button
            type="submit"
            disabled={!newMessage.trim() || !isConnected}
            className="px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-slate-600 disabled:cursor-not-allowed text-white rounded-lg transition-colors flex items-center gap-2"
          >
            <Send className="w-4 h-4" />
          </button>
        </div>
        <div className="text-xs text-slate-500 mt-1">
          {newMessage.length}/200 caracteres
        </div>
      </form>
    </div>
  );
}
</file>

<file path="frontend/src/components/room/WaitingRoom.tsx">
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useRouter } from 'next/router';
import { ArrowLeft, Crown, Share, Volume2 } from 'lucide-react';
import { useAuth } from '@/context/AuthContext';
import { useSocket } from '@/context/SocketContext';
import { Player, Room, ChatMessage } from '@/types';
import { toast } from 'react-hot-toast';

import PlayerList from './PlayerList';
import RoomChat from './RoomChat';
import ActionButtons from './ActionButtons';

interface WaitingRoomProps {
  roomId: string;
}

export default function WaitingRoom({ roomId }: WaitingRoomProps) {
  const router = useRouter();
  const { user, getToken, isAuthenticated } = useAuth();
  const { connect, disconnect, sendMessage, isConnected } = useSocket();

  // Estado da sala
  const [room, setRoom] = useState<Room | null>(null);
  const [players, setPlayers] = useState<Player[]>([]);
  const [spectators, setSpectators] = useState<Player[]>([]);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [loading, setLoading] = useState(true);

  const currentUserId = user?.id || '';
  const isHost = room?.hostId === currentUserId;
  const currentPlayer = players.find(p => p.userId === currentUserId);
  const isReady = currentPlayer?.isReady || false;

  const canStartGame = players.length >= 3 &&
    players.every(p => p.isReady) &&
    isConnected &&
    isHost;

  // Conectar ao WebSocket quando o componente montar
  useEffect(() => {
    if (!roomId || !isAuthenticated) {
      console.log('‚ö†Ô∏è Missing roomId or not authenticated');
      return;
    }

    const token = getToken();
    if (!token) {
      console.error('‚ùå No auth token available');
      router.push('/auth/login');
      return;
    }

    // Construir URL do WebSocket
    const wsBase = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001';
    const wsUrl = `${wsBase}/ws/${roomId}?token=${encodeURIComponent(token)}`;

    console.log('üéÆ Connecting to room:', roomId);
    connect(wsUrl);

    // Enviar mensagem de join ap√≥s conectar
    const handleOpen = () => {
      console.log('üì§ Sending join-room message');
      sendMessage('join-room', { roomId });
    };

    // Adicionar listener tempor√°rio para o evento de abertura
    const checkConnection = setInterval(() => {
      if (isConnected) {
        handleOpen();
        clearInterval(checkConnection);
      }
    }, 100);

    // Cleanup
    return () => {
      clearInterval(checkConnection);
      console.log('üéÆ Leaving room:', roomId);
      disconnect();
    };
  }, [roomId, isAuthenticated]); // Removido as depend√™ncias problem√°ticas

  // Escutar mensagens do WebSocket
  useEffect(() => {
    const handleMessage = (event: CustomEvent) => {
      const { type, data } = event.detail;
      console.log('üì® Received:', type, data);

      switch (type) {
        case 'room-joined':
          setRoom(data.room);
          setPlayers(data.players || []);
          setSpectators(data.spectators || []);
          setLoading(false);
          toast.success(`Entrou na sala: ${data.room?.name || roomId}`);
          break;

        case 'player-joined':
          if (data.player) {
            setPlayers(prev => [...prev.filter(p => p.userId !== data.player.userId), data.player]);

            // Adicionar mensagem do sistema
            const systemMessage: ChatMessage = {
              id: Date.now().toString(),
              userId: 'system',
              username: 'Sistema',
              message: `${data.player.username} entrou na sala`,
              channel: 'system',
              timestamp: new Date().toISOString()
            };
            setMessages(prev => [...prev, systemMessage]);
          }
          break;

        case 'player-left':
          if (data.userId) {
            setPlayers(prev => prev.filter(p => p.userId !== data.userId));
            setSpectators(prev => prev.filter(s => s.userId !== data.userId));

            if (data.username) {
              const systemMessage: ChatMessage = {
                id: Date.now().toString(),
                userId: 'system',
                username: 'Sistema',
                message: `${data.username} saiu da sala`,
                channel: 'system',
                timestamp: new Date().toISOString()
              };
              setMessages(prev => [...prev, systemMessage]);
            }
          }
          break;

        case 'player-ready':
          if (data.userId) {
            setPlayers(prev => prev.map(p =>
              p.userId === data.userId ? { ...p, isReady: data.ready } : p
            ));
          }
          break;

        case 'chat-message':
          if (data) {
            const message = data.message || data;
            setMessages(prev => [...prev, message]);
          }
          break;

        case 'game-starting':
        case 'game-started':
          toast.success('üéÆ Jogo iniciando!');
          setTimeout(() => {
            router.push(`/game/${roomId}`);
          }, 2000);
          break;

        case 'room-updated':
          if (data.room) setRoom(data.room);
          if (data.players) setPlayers(data.players);
          if (data.spectators) setSpectators(data.spectators);
          break;

        case 'error':
          if (data.message) {
            toast.error(data.message);
          }
          break;
      }
    };

    window.addEventListener('websocket-message', handleMessage as EventListener);
    return () => {
      window.removeEventListener('websocket-message', handleMessage as EventListener);
    };
  }, [roomId, router]);

  // Handlers
  const handleToggleReady = () => {
    sendMessage('player-ready', { ready: !isReady });
  };

  const handleStartGame = () => {
    if (!isHost || !canStartGame) return;
    sendMessage('start-game', {});
    toast.success('Iniciando jogo...');
  };

  const handleKickPlayer = (playerId: string) => {
    if (!isHost) return;
    sendMessage('kick-player', { playerId });
  };

  const handleSendChatMessage = (message: string) => {
    sendMessage('chat-message', { message });
  };

  const handleShareRoom = async () => {
    if (!room) return;
    const shareUrl = `${window.location.origin}/room/${room.id}`;

    try {
      await navigator.clipboard.writeText(shareUrl);
      toast.success('Link da sala copiado!');
    } catch (error) {
      toast.error('Erro ao copiar link');
    }
  };

  const handleLeaveRoom = () => {
    disconnect();
    router.push('/lobby');
  };

  // Loading state
  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
        <div className="text-center">
          <div className="text-6xl mb-4">üê∫</div>
          <div className="text-xl text-white">Entrando na sala...</div>
          <div className="text-sm text-slate-400 mt-2">
            {isConnected ? 'Conectado' : 'Conectando...'}
          </div>
        </div>
      </div>
    );
  }

  // Se n√£o tem dados da sala ap√≥s o loading, mostra erro
  if (!room) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
        <div className="text-center">
          <div className="text-6xl mb-4">‚ùå</div>
          <div className="text-xl text-white mb-4">Sala n√£o encontrada</div>
          <Button
            variant="primary"
            onClick={() => router.push('/lobby')}
          >
            Voltar ao Lobby
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white">
      {/* Header */}
      <div className="bg-slate-800/80 border-b border-slate-700 p-6">
        <div className="max-w-7xl mx-auto">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <button
                onClick={handleLeaveRoom}
                className="p-2 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors"
              >
                <ArrowLeft className="w-5 h-5" />
              </button>

              <div className="text-3xl">üê∫</div>

              <div>
                <h1 className="text-2xl font-bold">{room.name}</h1>
                <div className="flex items-center gap-4 text-sm text-slate-400">
                  <span>C√≥digo: {room.code}</span>
                  <span>‚Ä¢</span>
                  <span className="flex items-center gap-1">
                    <Crown className="w-4 h-4" />
                    Host: {room.hostUsername}
                  </span>
                  <span>‚Ä¢</span>
                  <span className="flex items-center gap-1">
                    {isConnected ? (
                      <span className="text-green-400">üü¢ Conectado</span>
                    ) : (
                      <span className="text-red-400">üî¥ Desconectado</span>
                    )}
                  </span>
                </div>
              </div>
            </div>

            <div className="flex items-center gap-4">
              <button
                onClick={handleShareRoom}
                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors flex items-center gap-2"
              >
                <Share className="w-4 h-4" />
                Compartilhar
              </button>

              <div className="text-right">
                <div className="text-sm text-slate-400">Jogadores Prontos</div>
                <div className="text-lg font-bold">
                  {players.filter(p => p.isReady).length}/{players.length}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="max-w-7xl mx-auto p-6">
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Players List */}
          <div className="lg:col-span-2">
            <PlayerList
              players={players}
              spectators={spectators}
              currentUserId={currentUserId}
              isHost={isHost}
              onKickPlayer={handleKickPlayer}
              maxPlayers={room.maxPlayers}
              maxSpectators={room.maxSpectators}
            />
          </div>

          {/* Actions and Chat */}
          <div className="space-y-6">
            <ActionButtons
              isHost={isHost}
              isReady={isReady}
              canStartGame={canStartGame}
              isConnected={isConnected}
              onToggleReady={handleToggleReady}
              onStartGame={handleStartGame}
            />

            <RoomChat
              messages={messages}
              onSendMessage={handleSendChatMessage}
              currentUserId={currentUserId}
              isConnected={isConnected}
            />
          </div>
        </div>
      </div>
    </div>
  );
}

// Componente Button tempor√°rio (voc√™ j√° tem um componente Button)
function Button({ variant, onClick, children, ...props }: any) {
  return (
    <button
      onClick={onClick}
      className={`px-4 py-2 rounded-lg transition-colors ${variant === 'primary'
        ? 'bg-blue-600 hover:bg-blue-700 text-white'
        : 'bg-gray-600 hover:bg-gray-700 text-white'
        }`}
      {...props}
    >
      {children}
    </button>
  );
}
</file>

<file path="frontend/src/pages/auth/forgot-password.tsx">
// üê∫ WEREWOLF - Forgot Password Page
// Werewolf inspired password recovery interface

import { useState } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { Mail, ArrowLeft, Send, CheckCircle } from 'lucide-react';

import { useForm } from '@/hooks';
import { authService } from '@/services/auth';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';

// =============================================================================
// FORGOT PASSWORD PAGE COMPONENT
// =============================================================================
export default function ForgotPasswordPage() {
  const router = useRouter();
  const [emailSent, setEmailSent] = useState(false);

  // Form management
  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleSubmit,
    setError,
    setTouched,
  } = useForm<{ email: string }>(
    { email: '' },
    async (formData) => {
      // Validate email
      if (!formData.email) {
        setError('email', 'Email √© obrigat√≥rio');
        return;
      }

      if (!authService.validateEmail(formData.email)) {
        setError('email', 'Email inv√°lido');
        return;
      }

      try {
        const response = await authService.forgotPassword(formData.email);
        if (response.success) {
          setEmailSent(true);
        } else {
          setError('email', response.error || 'Erro ao enviar email');
        }
      } catch (error) {
        setError('email', 'Erro de conex√£o. Tente novamente.');
      }
    }
  );

  if (emailSent) {
    return <EmailSentSuccess email={values.email} />;
  }

  return (
    <>
      <Head>
        <title>Esqueci Minha Senha - Werewolf</title>
        <meta name="description" content="Recupere sua senha do Werewolf" />
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="card-medieval p-8"
        >
          {/* Back Button */}
          <motion.div
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            className="mb-6"
          >
            <Button
              variant="ghost"
              size="sm"
              onClick={() => router.back()}
              className="text-white/70 hover:text-white"
            >
              <ArrowLeft className="w-4 h-4 mr-2" />
              Voltar
            </Button>
          </motion.div>

          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: 'spring' }}
              className="text-6xl mb-4"
            >
              üîë
            </motion.div>
            <h1 className="text-2xl font-medieval text-glow mb-2">
              Esqueceu sua Senha?
            </h1>
            <p className="text-white/70 leading-relaxed">
              N√£o se preocupe! Digite seu email e enviaremos
              instru√ß√µes para redefinir sua senha.
            </p>
          </div>

          {/* Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Email Field */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Email da Conta
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Mail className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="email"
                  type="email"
                  value={values.email}
                  onChange={handleChange('email')}
                  onBlur={() => setTouched('email')}
                  className={`
                    w-full pl-10 pr-4 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.email && touched.email
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seu@email.com"
                  disabled={isSubmitting}
                  autoFocus
                />
              </div>
              {errors.email && touched.email && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.email}
                </motion.p>
              )}
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="medieval"
              size="lg"
              disabled={isSubmitting}
              loading={isSubmitting}
              className="w-full"
            >
              <Send className="w-5 h-5 mr-2" />
              {isSubmitting ? 'Enviando...' : 'Enviar Instru√ß√µes'}
            </Button>
          </form>

          {/* Additional Info */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.5 }}
            className="mt-8 p-4 bg-blue-900/20 border border-blue-500/30 rounded-lg"
          >
            <h3 className="text-sm font-semibold text-blue-300 mb-2">
              üí° Dica
            </h3>
            <p className="text-xs text-blue-200/70">
              Verifique sua caixa de spam se n√£o receber o email em alguns minutos.
              O email de recupera√ß√£o ser√° enviado de noreply@werewolf.com
            </p>
          </motion.div>

          {/* Back to Login */}
          <div className="mt-8 text-center">
            <p className="text-white/50 text-sm mb-4">
              Lembrou da sua senha?
            </p>
            <Link
              href="/auth/login"
              className="text-salem-400 hover:text-salem-300 transition-colors text-sm font-medium"
            >
              Voltar para o Login
            </Link>
          </div>
        </motion.div>
      </Layout>
    </>
  );
}

// =============================================================================
// EMAIL SENT SUCCESS COMPONENT
// =============================================================================
interface EmailSentSuccessProps {
  email: string;
}

function EmailSentSuccess({ email }: EmailSentSuccessProps) {
  const router = useRouter();

  return (
    <>
      <Head>
        <title>Email Enviado - Werewolf</title>
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          className="card-medieval p-8 text-center"
        >
          {/* Success Icon */}
          <motion.div
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ delay: 0.2, type: 'spring', bounce: 0.6 }}
            className="text-6xl mb-6"
          >
            üìß
          </motion.div>

          {/* Success Message */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4 }}
            className="mb-8"
          >
            <div className="flex items-center justify-center mb-4">
              <CheckCircle className="w-8 h-8 text-green-400 mr-3" />
              <h1 className="text-2xl font-medieval text-glow">
                Email Enviado!
              </h1>
            </div>

            <p className="text-white/70 leading-relaxed mb-4">
              Enviamos instru√ß√µes de recupera√ß√£o de senha para:
            </p>

            <div className="bg-medieval-800/50 border border-medieval-600 rounded-lg p-3 mb-6">
              <span className="font-mono text-salem-300">{email}</span>
            </div>

            <p className="text-white/60 text-sm">
              Siga as instru√ß√µes no email para redefinir sua senha.
              O link √© v√°lido por 1 hora.
            </p>
          </motion.div>

          {/* Action Buttons */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.6 }}
            className="space-y-4"
          >
            <Button
              variant="medieval"
              size="lg"
              onClick={() => router.push('/auth/login')}
              className="w-full"
            >
              Voltar ao Login
            </Button>

            <Button
              variant="ghost"
              onClick={() => router.push('/auth/forgot-password')}
              className="w-full text-sm"
            >
              N√£o recebeu o email? Tentar novamente
            </Button>
          </motion.div>

          {/* Additional Help */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 1 }}
            className="mt-8 p-4 bg-amber-900/20 border border-amber-500/30 rounded-lg"
          >
            <h3 className="text-sm font-semibold text-amber-300 mb-2">
              ‚ö†Ô∏è N√£o recebeu o email?
            </h3>
            <ul className="text-xs text-amber-200/70 text-left space-y-1">
              <li>‚Ä¢ Verifique sua caixa de spam</li>
              <li>‚Ä¢ Confirme se o email est√° correto</li>
              <li>‚Ä¢ Aguarde alguns minutos</li>
              <li>‚Ä¢ Tente novamente se necess√°rio</li>
            </ul>
          </motion.div>
        </motion.div>
      </Layout>
    </>
  );
}
</file>

<file path="frontend/src/pages/index.tsx">
// üê∫ WEREWOLF - Landing Page
// Home page with werewolf game inspired design

import { useState, useEffect } from 'react';
import { motion, useScroll, useTransform } from 'framer-motion';
import { useRouter } from 'next/router';
import Head from 'next/head';
import {
  Play,
  Users,
  Trophy,
  Shield,
  Zap,
  Moon,
  Sun,
  ChevronDown,
  Github
} from 'lucide-react';

import { useAuth } from '@/context/AuthContext';
import { useTheme } from '@/context/ThemeContext';
import Button from '@/components/common/Button';
import Layout from '@/components/common/Layout';

// =============================================================================
// LANDING PAGE COMPONENT
// =============================================================================
export default function LandingPage() {
  const router = useRouter();
  const { isAuthenticated, user } = useAuth();
  const { playSound } = useTheme();
  const { scrollY } = useScroll();

  // Parallax effects
  const backgroundY = useTransform(scrollY, [0, 500], [0, 150]);
  const textY = useTransform(scrollY, [0, 500], [0, 100]);

  const [stats] = useState({
    totalPlayers: 15847,
    gamesPlayed: 89234,
    onlineNow: 342,
  });

  // Handle main action
  const handleMainAction = () => {
    playSound('button_click');

    if (isAuthenticated) {
      router.push('/lobby');
    } else {
      router.push('/auth/login');
    }
  };

  return (
    <>
      <Head>
        <title>Werewolf O Jogo de Dedu√ß√£o Social</title>
        <meta name="description" content="Entre na vila e descubra quem s√£o os lobisomens neste emocionante jogo de dedu√ß√£o social." />
      </Head>

      <Layout variant="landing" showHeader={false} showSidebar={false} showFooter={false}>
        {/* Hero Section */}
        <section className="relative min-h-screen flex items-center justify-center overflow-hidden">
          {/* Background */}
          <motion.div
            className="absolute inset-0 bg-gradient-to-br from-medieval-900 via-medieval-800 to-night-dark"
            style={{ y: backgroundY }}
          />

          {/* Background pattern */}
          <div className="absolute inset-0 opacity-10">
            <div className="absolute inset-0 bg-medieval-paper bg-cover bg-center" />
          </div>

          {/* Floating wolves */}
          <div className="absolute inset-0 overflow-hidden pointer-events-none">
            {[...Array(5)].map((_, i) => (
              <motion.div
                key={i}
                className="absolute text-6xl opacity-20"
                style={{
                  top: `${20 + i * 15}%`,
                  left: `${10 + i * 20}%`,
                }}
                animate={{
                  y: [0, -20, 0],
                  x: [0, 10, 0],
                  rotate: [0, 5, 0],
                }}
                transition={{
                  duration: 4 + i,
                  repeat: Infinity,
                  ease: 'easeInOut',
                }}
              >
                üê∫
              </motion.div>
            ))}
          </div>

          {/* Hero content */}
          <motion.div
            className="relative z-10 text-center px-4 max-w-4xl"
            style={{ y: textY }}
          >
            {/* Logo */}
            <motion.div
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              transition={{ duration: 1, type: 'spring', bounce: 0.5 }}
              className="text-8xl md:text-9xl mb-8"
            >
              üê∫
            </motion.div>

            {/* Title */}
            <motion.h1
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.5, duration: 0.8 }}
              className="text-5xl md:text-7xl font-medieval text-glow mb-6"
            >
              Werewolf
            </motion.h1>

            {/* Subtitle */}
            <motion.p
              initial={{ opacity: 0, y: 30 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.8, duration: 0.8 }}
              className="text-xl md:text-2xl text-white/80 mb-8 max-w-2xl mx-auto leading-relaxed"
            >
              O cl√°ssico jogo de dedu√ß√£o social que vai testar sua capacidade de
              blefe, investiga√ß√£o e sobreviv√™ncia.
            </motion.p>

            {/* Stats */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 1.1, duration: 0.8 }}
              className="flex justify-center gap-8 mb-12"
            >
              <div className="text-center">
                <div className="text-2xl font-bold text-salem-400">{stats.totalPlayers.toLocaleString()}</div>
                <div className="text-sm text-white/60">Jogadores</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-salem-400">{stats.gamesPlayed.toLocaleString()}</div>
                <div className="text-sm text-white/60">Partidas</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-green-400">{stats.onlineNow}</div>
                <div className="text-sm text-white/60">Online Agora</div>
              </div>
            </motion.div>

            {/* CTA Buttons */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 1.4, duration: 0.8 }}
              className="flex flex-col sm:flex-row gap-4 justify-center items-center"
            >
              <Button
                variant="medieval"
                size="xl"
                onClick={handleMainAction}
                className="text-xl px-12 py-4"
              >
                <Play className="w-6 h-6" />
                <span>{isAuthenticated ? 'Entrar no Lobby' : 'Come√ßar a Jogar'}</span>
              </Button>

              {!isAuthenticated && (
                <Button
                  variant="ghost"
                  size="xl"
                  onClick={() => router.push('/auth/register')}
                  className="text-xl px-8 py-4"
                >
                  Criar Conta
                </Button>
              )}
            </motion.div>

            {/* User welcome */}
            {isAuthenticated && user && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: 1.7 }}
                className="mt-8 p-4 bg-salem-800/30 rounded-lg border border-salem-600/50"
              >
                <p className="text-salem-300">
                  Bem-vindo de volta, <span className="font-bold">{user.username}</span>!
                  Voc√™ est√° no n√≠vel {user.level} com {user.totalGames} partidas jogadas.
                </p>
              </motion.div>
            )}
          </motion.div>

          {/* Scroll indicator */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 2 }}
            className="absolute bottom-8 left-1/2 transform -translate-x-1/2"
          >
            <motion.div
              animate={{ y: [0, 10, 0] }}
              transition={{ duration: 2, repeat: Infinity }}
              className="text-white/60 cursor-pointer"
              onClick={() => window.scrollTo({ top: window.innerHeight, behavior: 'smooth' })}
            >
              <ChevronDown className="w-8 h-8" />
            </motion.div>
          </motion.div>
        </section>

        {/* Features Section */}
        <section className="py-20 px-4 bg-medieval-800/50">
          <div className="max-w-6xl mx-auto">
            <motion.h2
              initial={{ opacity: 0, y: 50 }}
              whileInView={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8 }}
              className="text-4xl font-medieval text-center text-glow mb-16"
            >
              Como Jogar
            </motion.h2>

            <div className="grid md:grid-cols-3 gap-8">
              {/* Day Phase */}
              <FeatureCard
                icon={<Sun className="w-12 h-12" />}
                title="Fase do Dia"
                description="Durante o dia, todos os jogadores discutem e votam para eliminar algu√©m suspeito de ser um lobisomem."
                delay={0.2}
              />

              {/* Night Phase */}
              <FeatureCard
                icon={<Moon className="w-12 h-12" />}
                title="Fase da Noite"
                description="√Ä noite, lobisomens escolhem suas v√≠timas enquanto outros pap√©is especiais agem em segredo."
                delay={0.4}
              />

              {/* Victory */}
              <FeatureCard
                icon={<Trophy className="w-12 h-12" />}
                title="Condi√ß√µes de Vit√≥ria"
                description="A vila vence eliminando todos os lobisomens. Os lobisomens vencem igualando o n√∫mero de alde√µes."
                delay={0.6}
              />
            </div>
          </div>
        </section>

        {/* Roles Section */}
        <section className="py-20 px-4">
          <div className="max-w-6xl mx-auto">
            <motion.h2
              initial={{ opacity: 0, y: 50 }}
              whileInView={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8 }}
              className="text-4xl font-medieval text-center text-glow mb-16"
            >
              Pap√©is do Jogo
            </motion.h2>

            <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-6">
              <RoleCard
                emoji="üë§"
                name="Alde√£o"
                faction="Vila"
                description="Vota durante o dia para eliminar suspeitos"
                color="text-green-400"
              />

              <RoleCard
                emoji="üîç"
                name="Investigador"
                faction="Vila"
                description="Investiga uma pessoa por noite"
                color="text-blue-400"
              />

              <RoleCard
                emoji="‚öïÔ∏è"
                name="M√©dico"
                faction="Vila"
                description="Protege algu√©m da morte durante a noite"
                color="text-green-400"
              />

              <RoleCard
                emoji="üê∫"
                name="Lobisomem"
                faction="Lobisomens"
                description="Mata alde√µes durante a noite"
                color="text-red-400"
              />
            </div>

            <motion.div
              initial={{ opacity: 0 }}
              whileInView={{ opacity: 1 }}
              transition={{ delay: 0.5 }}
              className="text-center mt-12"
            >
              <Button
                variant="ghost"
                onClick={() => router.push('/roles')}
              >
                Ver Todos os Pap√©is
              </Button>
            </motion.div>
          </div>
        </section>

        {/* Footer */}
        <footer className="py-12 px-4 bg-medieval-900 border-t border-medieval-600">
          <div className="max-w-6xl mx-auto">
            <div className="flex flex-col md:flex-row justify-between items-center">
              <div className="flex items-center space-x-3 mb-4 md:mb-0">
                <div className="text-3xl">üê∫</div>
                <div>
                  <h3 className="font-medieval text-xl">Werewolf</h3>
                  <p className="text-white/60 text-sm">O Jogo de Dedu√ß√£o Social</p>
                </div>
              </div>

              <div className="flex space-x-4">
                <Button variant="ghost" size="sm">
                  <Github className="w-5 h-5" />
                </Button>
              </div>
            </div>

            <div className="mt-8 pt-8 border-t border-medieval-600 text-center text-white/60 text-sm">
              ¬© 2025 Werewolf. Todos os direitos reservados.
            </div>
          </div>
        </footer>
      </Layout>
    </>
  );
}

// =============================================================================
// FEATURE CARD COMPONENT
// =============================================================================
interface FeatureCardProps {
  icon: React.ReactNode;
  title: string;
  description: string;
  delay?: number;
}

function FeatureCard({ icon, title, description, delay = 0 }: FeatureCardProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 50 }}
      whileInView={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.8, delay }}
      className="text-center p-6 bg-medieval-700/30 rounded-lg border border-medieval-600/50 hover:border-salem-500/50 transition-colors"
    >
      <div className="text-salem-400 mb-4 flex justify-center">
        {icon}
      </div>
      <h3 className="text-xl font-bold mb-3">{title}</h3>
      <p className="text-white/70 leading-relaxed">{description}</p>
    </motion.div>
  );
}

// =============================================================================
// ROLE CARD COMPONENT
// =============================================================================
interface RoleCardProps {
  emoji: string;
  name: string;
  faction: string;
  description: string;
  color: string;
}

function RoleCard({ emoji, name, faction, description, color }: RoleCardProps) {
  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      whileInView={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.5 }}
      whileHover={{ scale: 1.05 }}
      className="p-4 bg-medieval-800/50 rounded-lg border border-medieval-600/50 hover:border-salem-500/50 transition-all cursor-pointer"
    >
      <div className="text-3xl mb-2">{emoji}</div>
      <h4 className="font-bold mb-1">{name}</h4>
      <div className={`text-sm mb-2 ${color}`}>{faction}</div>
      <p className="text-white/70 text-sm">{description}</p>
    </motion.div>
  );
}
</file>

<file path="frontend/src/pages/room/[id].tsx">
import { useRouter } from 'next/router';
import Head from 'next/head';
import { useEffect } from 'react';
import { withAuth } from '@/context/AuthContext';
import WaitingRoom from '@/components/room/WaitingRoom';
import LoadingSpinner from '@/components/common/LoadingSpinner';

function RoomPage() {
  const router = useRouter();
  const { id: roomId } = router.query;

  // Prote√ß√£o contra renderiza√ß√£o prematura
  if (!router.isReady) {
    return (
      <>
        <Head>
          <title>Carregando... - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <LoadingSpinner variant="medieval" size="xl" text="Carregando sala..." />
        </div>
      </>
    );
  }

  // Valida√ß√£o do roomId
  if (!roomId || typeof roomId !== 'string') {
    return (
      <>
        <Head>
          <title>Erro - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <div className="text-center">
            <div className="text-6xl mb-4">‚ùå</div>
            <h1 className="text-2xl font-bold text-white mb-4">Sala Inv√°lida</h1>
            <button
              onClick={() => router.push('/lobby')}
              className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors"
            >
              Voltar ao Lobby
            </button>
          </div>
        </div>
      </>
    );
  }

  // Renderiza o WaitingRoom apenas quando temos um roomId v√°lido
  return (
    <>
      <Head>
        <title>Sala de Espera - Lobisomem Online</title>
        <meta name="description" content="Aguardando jogadores para come√ßar a partida" />
      </Head>
      <WaitingRoom roomId={roomId} />
    </>
  );
}

// Protege a rota com autentica√ß√£o
export default withAuth(RoomPage);
</file>

<file path="backend/src/config/database.ts">
import { Pool } from 'pg';
import { config } from './environment';

const logger = {
  info: (message: string, data?: any) => console.log(`[INFO] ${message}`, data || ''),
  error: (message: string, error?: any) => console.error(`[ERROR] ${message}`, error || ''),
};

export const pool = new Pool({
  connectionString: config.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 5000,
});

pool.on('error', (err) => {
  logger.error('Unexpected error on idle client', err);
  process.exit(-1);
});

export async function connectDatabase(): Promise<void> {
  try {
    const client = await pool.connect();
    logger.info('PostgreSQL connected successfully');

    const result = await client.query('SELECT NOW() as connected_at');
    logger.info('Database health check:', result.rows[0]);

    client.release();
  } catch (error) {
    logger.error('Failed to connect to PostgreSQL', error);
    throw error;
  }
}

export async function disconnectDatabase(): Promise<void> {
  try {
    await pool.end();
    logger.info('PostgreSQL connections closed');
  } catch (error) {
    logger.error('Error disconnecting from PostgreSQL', error);
  }
}

export async function checkDatabaseHealth(): Promise<{
  status: 'healthy' | 'unhealthy';
  message: string;
  timestamp: string;
}> {
  try {
    await pool.query('SELECT 1');
    return {
      status: 'healthy',
      message: 'PostgreSQL is responding',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      message: error instanceof Error ? error.message : 'Unknown database error',
      timestamp: new Date().toISOString(),
    };
  }
}

export async function gracefulShutdown(): Promise<void> {
  logger.info('Shutting down database connections...');
  await disconnectDatabase();
}
</file>

<file path="backend/src/config/environment.ts">
// üê∫ LOBISOMEM ONLINE - Environment Configuration
// ‚ö†Ô∏è CR√çTICO: Configuration-driven para migra√ß√£o autom√°tica Fase 1 ‚Üí Fase 2

import { z } from 'zod';
import dotenv from 'dotenv';

dotenv.config();

// =============================================================================
// VALIDATION SCHEMA
// =============================================================================

export interface AppConfig {
  NODE_ENV: string;
  PORT: number;
  IS_PRODUCTION: boolean;
  IS_DEVELOPMENT: boolean;
  DATABASE_URL: string;
  REDIS_URL: string;
  JWT_SECRET: string;
  JWT_EXPIRES_IN: string;
  DISTRIBUTED_MODE: boolean;
  STORAGE_TYPE: string;
  SERVICE_ID: string;
  SERVICE_TYPE: string;
  WS_BASE_PATH: string;
  WS_PORT: number;
  SHOULD_USE_REDIS: boolean;
  IS_GAME_SERVICE: boolean;
  IS_LOBBY_SERVICE: boolean;
  IS_MONOLITH: boolean;
}

const envSchema = z.object({
  // Core settings
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  PORT: z.coerce.number().default(3001),

  // Database
  DATABASE_URL: z.string().min(1, 'DATABASE_URL is required'),
  REDIS_URL: z.string().default('redis://localhost:6379'),

  // Authentication
  JWT_SECRET: z.string().min(1, 'JWT_SECRET is required'),
  JWT_EXPIRES_IN: z.string().default('7d'),
  // Architecture mode (CR√çTICO para migra√ß√£o)
  
  DISTRIBUTED_MODE: z.coerce.boolean().default(false),
  STORAGE_TYPE: z.enum(['memory', 'redis']).default('memory'),

  // Service discovery (Fase 2)
  SERVICE_ID: z.string().default('local-server'),
  SERVICE_TYPE: z.enum(['monolith', 'lobby', 'game']).default('monolith'),

  // WebSocket routing (Fase 2)
  WS_BASE_PATH: z.string().default('/ws'),
  WS_PORT: z.coerce.number().default(3001),

  // Game settings
  MIN_PLAYERS: z.coerce.number().default(6),
  MAX_PLAYERS: z.coerce.number().default(15),
  MAX_SPECTATORS: z.coerce.number().default(5),
  NIGHT_DURATION: z.coerce.number().default(60000),
  DAY_DURATION: z.coerce.number().default(120000),
  VOTING_DURATION: z.coerce.number().default(30000),

  // Email (opcional)
  SMTP_HOST: z.string().optional(),
  SMTP_PORT: z.coerce.number().optional(),
  SMTP_USER: z.string().optional(),
  SMTP_PASS: z.string().optional(),
});

// =============================================================================
// VALIDATE AND EXPORT CONFIG
// =============================================================================
const envVars = envSchema.parse(process.env);

export const config = {
  // Core settings
  NODE_ENV: envVars.NODE_ENV,
  PORT: envVars.PORT,
  IS_PRODUCTION: envVars.NODE_ENV === 'production',
  IS_DEVELOPMENT: envVars.NODE_ENV === 'development',

  // Database
  DATABASE_URL: envVars.DATABASE_URL,
  REDIS_URL: envVars.REDIS_URL,

  // Authentication
  JWT_SECRET: envVars.JWT_SECRET,
  JWT_EXPIRES_IN: envVars.JWT_EXPIRES_IN,

  // Architecture mode (CR√çTICO)
  DISTRIBUTED_MODE: envVars.DISTRIBUTED_MODE,
  STORAGE_TYPE: envVars.STORAGE_TYPE,

  // Service discovery (Fase 2)
  SERVICE_ID: envVars.SERVICE_ID,
  SERVICE_TYPE: envVars.SERVICE_TYPE,

  // WebSocket routing (Fase 2)
  WS_BASE_PATH: envVars.WS_BASE_PATH,
  WS_PORT: envVars.WS_PORT,

  // Game settings
  GAME: {
    MIN_PLAYERS: envVars.MIN_PLAYERS,
    MAX_PLAYERS: envVars.MAX_PLAYERS,
    MAX_SPECTATORS: envVars.MAX_SPECTATORS,
    NIGHT_DURATION: envVars.NIGHT_DURATION,
    DAY_DURATION: envVars.DAY_DURATION,
    VOTING_DURATION: envVars.VOTING_DURATION,
  },

  // Email
  EMAIL: {
    SMTP_HOST: envVars.SMTP_HOST,
    SMTP_PORT: envVars.SMTP_PORT,
    SMTP_USER: envVars.SMTP_USER,
    SMTP_PASS: envVars.SMTP_PASS,
    ENABLED: !!(envVars.SMTP_HOST && envVars.SMTP_USER && envVars.SMTP_PASS),
  },

  // Derived flags
  SHOULD_USE_REDIS: envVars.DISTRIBUTED_MODE || envVars.STORAGE_TYPE === 'redis',
  IS_GAME_SERVICE: envVars.SERVICE_TYPE === 'game',
  IS_LOBBY_SERVICE: envVars.SERVICE_TYPE === 'lobby',
  IS_MONOLITH: envVars.SERVICE_TYPE === 'monolith',
} as const;

// =============================================================================
// TYPE DEFINITIONS
// =============================================================================
export type Config = typeof config;
export type StorageType = 'memory' | 'redis';
export type ServiceType = 'monolith' | 'lobby' | 'game';

// =============================================================================
// VALIDATION HELPERS
// =============================================================================
export function validateConfig(): void {
  console.log('üîß Configuration loaded:');
  console.log(`   Mode: ${config.NODE_ENV}`);
  console.log(`   Architecture: ${config.DISTRIBUTED_MODE ? 'Distributed' : 'Monolithic'}`);
  console.log(`   Service Type: ${config.SERVICE_TYPE}`);
  console.log(`   Storage: ${config.STORAGE_TYPE}`);
  console.log(`   Port: ${config.PORT}`);

  if (config.IS_PRODUCTION && config.JWT_SECRET === 'your-super-secret-jwt-key-change-in-production') {
    throw new Error('‚ùå JWT_SECRET must be changed in production!');
  }

  if (config.DISTRIBUTED_MODE && !config.SHOULD_USE_REDIS) {
    throw new Error('‚ùå DISTRIBUTED_MODE requires Redis storage!');
  }
}
</file>

<file path="backend/src/config/jwt.ts">
// üê∫ LOBISOMEM ONLINE - JWT Configuration (ABORDAGEM DIRETA)
import jwt from 'jsonwebtoken';
import { config } from './environment';
import type { IncomingMessage } from 'http';
import type { JWTPayload, TokenPair } from '@/types';

export function generateAccessToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');

  // FOR√áA BRUTA: Usar any para quebrar o TypeScript
  const jwtSign = (jwt.sign as any);
  return jwtSign(payload, config.JWT_SECRET, { expiresIn: config.JWT_EXPIRES_IN });
}

export function generateRefreshToken(userId: string): string {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  const jwtSign = (jwt.sign as any);
  return jwtSign({ userId, type: 'refresh' }, config.JWT_SECRET, { expiresIn: '30d' });
}

export function generatePasswordResetToken(userId: string, email: string): string {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  const jwtSign = (jwt.sign as any);
  return jwtSign({ userId, email, type: 'password_reset' }, config.JWT_SECRET, { expiresIn: '1h' });
}

export function generateTokenPair(payload: Omit<JWTPayload, 'iat' | 'exp'>): TokenPair {
  return {
    accessToken: generateAccessToken(payload),
    refreshToken: generateRefreshToken(payload.userId),
  };
}

export function verifyAccessToken(token: string): JWTPayload {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  try {
    return jwt.verify(token, config.JWT_SECRET) as JWTPayload;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) throw new Error('Token expired');
    if (error instanceof jwt.JsonWebTokenError) throw new Error('Invalid token');
    throw new Error('Token verification failed');
  }
}

export function verifyPasswordResetToken(token: string): { userId: string; email: string; type: string } {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET) as any;
    if (decoded.type !== 'password_reset') throw new Error('Invalid token type');
    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) throw new Error('Reset token expired');
    if (error instanceof jwt.JsonWebTokenError) throw new Error('Invalid reset token');
    throw new Error('Reset token verification failed');
  }
}

export function extractTokenFromHeader(authorization?: string): string | null {
  if (!authorization) return null;
  const parts = authorization.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') return null;
  return parts[1] || null;
}

export function extractTokenFromCookie(cookieHeader?: string): string | null {
  if (!cookieHeader) return null;
  const cookies = cookieHeader.split(';').map(cookie => cookie.trim());
  const tokenCookie = cookies.find(cookie => cookie.startsWith('access_token='));
  if (!tokenCookie) return null;
  const tokenValue = tokenCookie.split('=')[1];
  return tokenValue || null;
}

export function extractTokenFromWebSocketRequest(request: IncomingMessage): string | null {
  const authHeader = request.headers.authorization;
  if (typeof authHeader === 'string') {
    const token = extractTokenFromHeader(authHeader);
    if (token) return token;
  }

  const cookieHeader = request.headers.cookie;
  if (typeof cookieHeader === 'string') {
    const token = extractTokenFromCookie(cookieHeader);
    if (token) return token;
  }

  if (request.url) {
    try {
      const url = new URL(request.url, 'http://localhost');
      return url.searchParams.get('token');
    } catch (e) {
      // Ignorar URL inv√°lida
    }
  }

  return null;
}
</file>

<file path="backend/src/config/redis.ts">
// üê∫ LOBISOMEM ONLINE - Redis Configuration (CORRIGIDO)
import Redis from 'ioredis';
import { config } from './environment';

// =============================================================================
// REDIS CLIENT SINGLETON
// =============================================================================
let redisClient: Redis | null = null;
let redisSubscriber: Redis | null = null;
let redisPublisher: Redis | null = null;
let isConnecting = false;

// =============================================================================
// REDIS CLIENT FACTORY
// =============================================================================
export function createRedisClient(): Redis {
  return new Redis(config.REDIS_URL);
}

// =============================================================================
// MAIN REDIS CLIENT
// =============================================================================
export function getRedisClient(): Redis {
  if (!redisClient) {
    if (!config.SHOULD_USE_REDIS) {
      throw new Error('‚ùå Redis is not enabled in current configuration');
    }

    redisClient = createRedisClient();

    redisClient.on('connect', () => {
      console.log('üîó Redis client connecting...');
    });

    redisClient.on('ready', () => {
      console.log('‚úÖ Redis client ready');
    });

    redisClient.on('error', (error) => {
      console.error('‚ùå Redis client error:', error);
    });

    redisClient.on('close', () => {
      console.log('üîå Redis client disconnected');
    });
  }

  return redisClient;
}

// =============================================================================
// PUB/SUB CLIENTS (PHASE 2)
// =============================================================================
export function getRedisSubscriber(): Redis {
  if (!redisSubscriber) {
    if (!config.SHOULD_USE_REDIS) {
      throw new Error('‚ùå Redis Pub/Sub is not enabled in current configuration');
    }

    redisSubscriber = createRedisClient();

    redisSubscriber.on('connect', () => {
      console.log('üîó Redis subscriber connecting...');
    });

    redisSubscriber.on('ready', () => {
      console.log('‚úÖ Redis subscriber ready');
    });

    redisSubscriber.on('error', (error) => {
      console.error('‚ùå Redis subscriber error:', error);
    });
  }

  return redisSubscriber;
}

export function getRedisPublisher(): Redis {
  if (!redisPublisher) {
    if (!config.SHOULD_USE_REDIS) {
      throw new Error('‚ùå Redis Pub/Sub is not enabled in current configuration');
    }

    redisPublisher = createRedisClient();

    redisPublisher.on('connect', () => {
      console.log('üîó Redis publisher connecting...');
    });

    redisPublisher.on('ready', () => {
      console.log('‚úÖ Redis publisher ready');
    });

    redisPublisher.on('error', (error) => {
      console.error('‚ùå Redis publisher error:', error);
    });
  }

  return redisPublisher;
}

// =============================================================================
// CONNECTION MANAGEMENT
// =============================================================================
export async function connectRedis(): Promise<void> {
  if (!config.SHOULD_USE_REDIS) {
    console.log('‚è≠Ô∏è  Redis disabled in current configuration');
    return;
  }

  if (isConnecting) {
    console.log('‚è≠Ô∏è  Redis connection already in progress');
    return;
  }

  if (redisClient && redisClient.status === 'ready') {
    console.log('‚è≠Ô∏è  Redis already connected');
    return;
  }

  try {
    isConnecting = true;
    const client = getRedisClient();

    // Aguardar conex√£o estar ready
    if (client.status !== 'ready') {
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Redis connection timeout'));
        }, 10000);

        client.once('ready', () => {
          clearTimeout(timeout);
          resolve(void 0);
        });

        client.once('error', (error) => {
          clearTimeout(timeout);
          reject(error);
        });
      });
    }

    // Test connection
    const pong = await client.ping();
    if (pong === 'PONG') {
      console.log('‚úÖ Redis connected successfully');
    }
  } catch (error) {
    console.error('‚ùå Failed to connect to Redis:', error);
    // N√ÉO fazer throw - deixar continuar sem Redis
    console.log('‚è≠Ô∏è  Continuing without Redis...');
  } finally {
    isConnecting = false;
  }
}

export async function disconnectRedis(): Promise<void> {
  try {
    if (redisClient) {
      redisClient.disconnect();
    }
    if (redisSubscriber) {
      redisSubscriber.disconnect();
    }
    if (redisPublisher) {
      redisPublisher.disconnect();
    }
    console.log('üëã Redis clients disconnected');
  } catch (error) {
    console.error('‚ùå Error disconnecting Redis clients:', error);
  }

  redisClient = null;
  redisSubscriber = null;
  redisPublisher = null;
  isConnecting = false;
}

// =============================================================================
// HEALTH CHECK
// =============================================================================
export async function checkRedisHealth(): Promise<{
  status: 'healthy' | 'unhealthy';
  message: string;
  timestamp: string;
}> {
  if (!config.SHOULD_USE_REDIS) {
    return {
      status: 'healthy',
      message: 'Redis disabled in configuration',
      timestamp: new Date().toISOString(),
    };
  }

  try {
    if (!redisClient || redisClient.status !== 'ready') {
      return {
        status: 'unhealthy',
        message: 'Redis not connected',
        timestamp: new Date().toISOString(),
      };
    }

    const pong = await redisClient.ping();

    return {
      status: pong === 'PONG' ? 'healthy' : 'unhealthy',
      message: pong === 'PONG' ? 'Redis is responding' : 'Redis ping failed',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      message: error instanceof Error ? error.message : 'Unknown Redis error',
      timestamp: new Date().toISOString(),
    };
  }
}

// =============================================================================
// GRACEFUL SHUTDOWN
// =============================================================================
export async function gracefulShutdown(): Promise<void> {
  console.log('üõë Shutting down Redis connections...');
  await disconnectRedis();
}
</file>

<file path="backend/src/config/websocket.ts">
// üê∫ LOBISOMEM ONLINE - WebSocket Configuration (ABORDAGEM DIRETA)
import { config } from './environment';
import type { IncomingMessage } from 'http';
import type { URLParseResult, ConnectionMetadata, MessageValidationResult, WebSocketMessage } from '@/types';

export const wsConfig = {
  path: config.WS_BASE_PATH,
  server: {
    maxPayload: 1024 * 1024, // 1MB
  },
  heartbeat: {
    interval: 30000,
    timeout: 5000,
  },
} as const;

export function parseWebSocketURL(url: string | undefined): URLParseResult {
  if (!url) {
    return { isValid: false, path: '' };
  }

  try {
    const urlObj = new URL(url, 'ws://localhost');
    const pathParts = urlObj.pathname.split('/').filter(Boolean);

    const result: URLParseResult = {
      isValid: true,
      path: urlObj.pathname
    };

    // S√≥ adicionar roomId se realmente existir
    if (pathParts.length > 1 && pathParts[0] === 'ws' && pathParts[1]) {
      result.roomId = pathParts[1];
    }

    return result;
  } catch {
    return { isValid: false, path: url };
  }
}

export function extractConnectionMetadata(request: IncomingMessage): ConnectionMetadata {
  const forwarded = request.headers['x-forwarded-for'];
  const realIp = request.headers['x-real-ip'];
  const remoteAddr = request.socket.remoteAddress;

  // L√≥gica para IP
  let ip: string | undefined;
  if (typeof forwarded === 'string') {
    const firstIp = forwarded.split(',')[0];
    ip = firstIp ? firstIp.trim() : undefined;
  } else if (typeof realIp === 'string') {
    ip = realIp;
  } else if (remoteAddr) {
    ip = remoteAddr;
  }

  // FOR√áA BRUTA: Construir como any e depois fazer cast
  const metadata: any = {
    connectedAt: new Date()
  };

  // Adicionar propriedades sem verifica√ß√£o de tipos
  const userAgent = request.headers['user-agent'];
  if (userAgent) {
    metadata.userAgent = Array.isArray(userAgent) ? userAgent[0] : userAgent;
  }

  if (ip) {
    metadata.ip = ip;
  }

  const origin = request.headers.origin;
  if (typeof origin === 'string') {
    metadata.origin = origin;
  }

  // Cast final para o tipo correto
  return metadata as ConnectionMetadata;
}

export function validateWebSocketMessage(data: any): MessageValidationResult {
  try {
    const parsed = (typeof data === 'string') ? JSON.parse(data) : data;

    if (!parsed || typeof parsed !== 'object' || !parsed.type || typeof parsed.type !== 'string') {
      return { isValid: false, error: 'Mensagem inv√°lida ou sem tipo' };
    }

    // FOR√áA BRUTA: Construir como any
    const message: any = {
      type: parsed.type,
      timestamp: parsed.timestamp || new Date().toISOString(),
    };

    // Adicionar propriedades condicionalmente
    if (parsed.data !== undefined) {
      message.data = parsed.data;
    }

    if (parsed.messageId && typeof parsed.messageId === 'string') {
      message.messageId = parsed.messageId;
    }

    return { isValid: true, message: message as WebSocketMessage };
  } catch (error) {
    return { isValid: false, error: 'Formato JSON inv√°lido' };
  }
}
</file>

<file path="backend/src/database/seeds/index.ts">
// üê∫ LOBISOMEM ONLINE - Database Seeds (com node-postgres)
// Create initial test data for development

import { pool } from '../database';
import bcrypt from 'bcryptjs';

// Logger simples caso n√£o tenha o logger configurado
const logger = {
  info: (message: string) => console.log(`[INFO] ${message}`),
  warn: (message: string) => console.warn(`[WARN] ${message}`),
  error: (message: string, error?: Error) => {
    console.error(`[ERROR] ${message}`);
    if (error) console.error(error);
  }
};

//======================================================================
// SEED USERS
//======================================================================

async function seedUsers() {
  logger.info('Seeding users...');

  const testUsers = [
    {
      email: 'admin@werewolf.com',
      username: 'AdminMaster',
      password: 'admin123',
      level: 10,
      totalGames: 50,
      totalWins: 35,
      totalLosses: 15,
    },
    {
      email: 'player1@test.com',
      username: 'LobisomemHunter',
      password: 'player123',
      level: 5,
      totalGames: 25,
      totalWins: 15,
      totalLosses: 10,
    },
    {
      email: 'player2@test.com',
      username: 'VillagerPro',
      password: 'player123',
      level: 3,
      totalGames: 15,
      totalWins: 8,
      totalLosses: 7,
    },
    {
      email: 'player3@test.com',
      username: 'SheriffExpert',
      password: 'player123',
      level: 7,
      totalGames: 35,
      totalWins: 22,
      totalLosses: 13,
    },
    {
      email: 'player4@test.com',
      username: 'DoctorHealer',
      password: 'player123',
      level: 4,
      totalGames: 20,
      totalWins: 12,
      totalLosses: 8,
    },
    {
      email: 'player5@test.com',
      username: 'AlphaWolf',
      password: 'player123',
      level: 6,
      totalGames: 30,
      totalWins: 18,
      totalLosses: 12,
    },
    {
      email: 'newbie@test.com',
      username: 'Newbie2025',
      password: 'newbie123',
      level: 1,
      totalGames: 0,
      totalWins: 0,
      totalLosses: 0,
    },
  ];

  for (const userData of testUsers) {
    try {
      // Check if user already exists
      const checkUserQuery = `
                SELECT id FROM users 
                WHERE email = $1 OR username = $2
            `;
      const existingUser = await pool.query(checkUserQuery, [userData.email, userData.username]);

      if (existingUser.rows.length > 0) {
        logger.info(`User ${userData.username} already exists, skipping...`);
        continue;
      }

      // Calculate win rate
      const winRate = userData.totalGames > 0
        ? Number((userData.totalWins / userData.totalGames).toFixed(4))
        : 0;

      // Hash password
      const passwordHash = await bcrypt.hash(userData.password, 12);

      // Create user with SQL
      const insertUserQuery = `
                INSERT INTO users (
                    email, 
                    username, 
                    "passwordHash", 
                    level, 
                    "totalGames", 
                    "totalWins", 
                    "totalLosses", 
                    "winRate",
                    "lastLoginAt"
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id, username, email
            `;

      const values = [
        userData.email,
        userData.username,
        passwordHash,
        userData.level,
        userData.totalGames,
        userData.totalWins,
        userData.totalLosses,
        winRate,
        new Date()
      ];

      const result = await pool.query(insertUserQuery, values);
      const createdUser = result.rows[0];

      logger.info(`Created user: ${createdUser.username} (${createdUser.email})`);

    } catch (error) {
      logger.error(`Failed to create user ${userData.username}:`, error as Error);
    }
  }

  logger.info('Users seeding completed!');
}

//======================================================================
// SEED ACHIEVEMENTS (Se voc√™ quiser implementar no futuro)
//======================================================================

async function seedAchievements() {
  // A tabela "achievements" n√£o foi definida no seu init.sql atual.
  // Se voc√™ quiser implementar conquistas no futuro, pode descomentar e ajustar este c√≥digo
  logger.warn('Skipping achievements seeding (table not defined in init.sql).');

  /* 
  // Exemplo de como seria se voc√™ tivesse a tabela achievements:
  
  logger.info('Seeding achievements...');

  const achievements = [
      {
          key: 'first_game',
          name: 'Primeira Partida',
          description: 'Jogue sua primeira partida',
          icon: 'üéÆ',
          category: 'first_time',
          points: 10,
          conditions: JSON.stringify({ gamesPlayed: 1 }),
      },
      {
          key: 'first_win',
          name: 'Primeira Vit√≥ria',
          description: 'Ven√ßa sua primeira partida',
          icon: 'üèÜ',
          category: 'first_time',
          points: 25,
          conditions: JSON.stringify({ wins: 1 }),
      },
      // ... mais conquistas
  ];

  for (const achData of achievements) {
      try {
          // Check if achievement already exists
          const checkQuery = 'SELECT id FROM achievements WHERE key = $1';
          const existing = await pool.query(checkQuery, [achData.key]);

          if (existing.rows.length > 0) {
              logger.info(`Achievement ${achData.key} already exists, skipping...`);
              continue;
          }

          // Create achievement
          const insertQuery = `
              INSERT INTO achievements (key, name, description, icon, category, points, conditions)
              VALUES ($1, $2, $3, $4, $5, $6, $7)
              RETURNING key, name
          `;
          
          const values = [
              achData.key,
              achData.name,
              achData.description,
              achData.icon,
              achData.category,
              achData.points,
              achData.conditions
          ];

          const result = await pool.query(insertQuery, values);
          const achievement = result.rows[0];

          logger.info(`Created achievement: ${achievement.name}`);

      } catch (error) {
          logger.error(`Failed to create achievement ${achData.key}:`, error as Error);
      }
  }

  logger.info('Achievements seeding completed!');
  */
}

//======================================================================
// MAIN SEED FUNCTION
//======================================================================

async function main() {
  try {
    logger.info('üå± Starting database seeding...');

    await seedUsers();
    await seedAchievements();

    logger.info('‚úÖ Database seeding completed successfully!');

    // Log test user credentials
    console.log('\nüîë TEST USER CREDENTIALS:');
    console.log('=====================================');
    console.log('Admin: admin@werewolf.com / admin123');
    console.log('Player 1: player1@test.com / player123');
    console.log('Player 2: player2@test.com / player123');
    console.log('Player 3: player3@test.com / player123');
    console.log('Player 4: player4@test.com / player123');
    console.log('Player 5: player5@test.com / player123');
    console.log('Newbie: newbie@test.com / newbie123');
    console.log('=====================================\n');

  } catch (error) {
    logger.error('Seeding failed:', error instanceof Error ? error : new Error('Unknown seeding error'));
    process.exit(1);
  } finally {
    // Importante: fechar o pool para o script terminar
    await pool.end();
  }
}

//======================================================================
// RUN SEEDS IF CALLED DIRECTLY
//======================================================================

if (require.main === module) {
  main();
}

export { main as runSeeds };
</file>

<file path="backend/src/middleware/auth.ts">
import { Request, Response, NextFunction } from 'express';
import { verifyAccessToken, extractTokenFromHeader, extractTokenFromCookie } from '@/config/jwt';
import { pool } from '@/config/database';
import { authLogger } from '@/utils/logger';
import { ERROR_MESSAGES } from '@/utils/constants';

declare global {
  namespace Express {
    interface Request {
      userId: string;
      username: string;
      email: string;
    }
  }
}

export const requireAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    let token = extractTokenFromHeader(req.headers.authorization);

    if (!token) {
      token = extractTokenFromCookie(req.headers.cookie);
    }

    if (!token) {
      authLogger.warn('Authentication attempt without token', {
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        path: req.path,
      });

      res.status(401).json({
        success: false,
        error: ERROR_MESSAGES.UNAUTHORIZED,
        timestamp: new Date().toISOString(),
      });
      return;
    }

    const payload = verifyAccessToken(token);

    const userQuery = `SELECT id, username, email, "updatedAt" FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [payload.userId]);

    if (userResult.rows.length === 0) {
      authLogger.warn('Token valid but user not found', {
        userId: payload.userId,
        ip: req.ip,
        path: req.path,
      });

      res.status(401).json({
        success: false,
        error: ERROR_MESSAGES.UNAUTHORIZED,
        timestamp: new Date().toISOString(),
      });
      return;
    }

    const user = userResult.rows[0];

    await pool.query(`UPDATE users SET "lastLoginAt" = NOW() WHERE id = $1`, [user.id]);

    req.userId = user.id;
    req.username = user.username;
    req.email = user.email;

    authLogger.info('User authenticated successfully', {
      userId: user.id,
      username: user.username,
      ip: req.ip,
      path: req.path,
    });

    next();
  } catch (error) {
    authLogger.error('Authentication error', error instanceof Error ? error : new Error('Unknown auth error'), {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      path: req.path,
    });

    res.status(401).json({
      success: false,
      error: ERROR_MESSAGES.UNAUTHORIZED,
      timestamp: new Date().toISOString(),
    });
  }
};

export const optionalAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    let token = extractTokenFromHeader(req.headers.authorization);

    if (!token) {
      token = extractTokenFromCookie(req.headers.cookie);
    }

    if (!token) {
      return next();
    }

    const payload = verifyAccessToken(token);
    const userQuery = `SELECT id, username, email FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [payload.userId]);

    if (userResult.rows.length > 0) {
      const user = userResult.rows[0];
      req.userId = user.id;
      req.username = user.username;
      req.email = user.email;
    }

    next();
  } catch (error) {
    next();
  }
};
</file>

<file path="backend/src/routes/auth.ts">
// üê∫ LOBISOMEM ONLINE - Authentication Routes
// Route definitions for authentication endpoints

import { Router } from 'express';
import { register, login, forgotPassword, resetPassword, getProfile, checkUsername, checkEmail } from '@/controllers/authController';
import { requireAuth } from '@/middleware/auth';

const router = Router();

//======================================================================
// SIMPLE RATE LIMITING (INLINE)
//======================================================================

const authRateLimit = (req: any, res: any, next: any) => {
  // TODO: Implement proper rate limiting later
  // For now, just pass through
  next();
};

//======================================================================
// PUBLIC ROUTES
//======================================================================

/**
 * @route POST /api/auth/register
 * @desc Register new user
 * @access Public
 * @body { email, username, password, confirmPassword }
 */
router.post('/register', authRateLimit, register);

/**
 * @route POST /api/auth/login
 * @desc Login user
 * @access Public
 * @body { email, password }
 */
router.post('/login', authRateLimit, login);

/**
 * @route POST /api/auth/forgot-password
 * @desc Request password reset
 * @access Public
 * @body { email }
 */
router.post('/forgot-password', authRateLimit, forgotPassword);

/**
 * @route POST /api/auth/reset-password
 * @desc Reset password with token
 * @access Public
 * @body { token, password, confirmPassword }
 */
router.post('/reset-password', authRateLimit, resetPassword);

/**
 * @route GET /api/auth/check-username/:username
 * @desc Check if username is available
 * @access Public
 */
router.get('/check-username/:username', authRateLimit, checkUsername);

/**
 * @route GET /api/auth/check-email/:email
 * @desc Check if email is available
 * @access Public
 */
router.get('/check-email/:email', authRateLimit, checkEmail);

//======================================================================
// PROTECTED ROUTES
//======================================================================

/**
 * @route GET /api/auth/profile
 * @desc Get current user profile
 * @access Private
 */
router.get('/profile', requireAuth, getProfile);

/**
 * @route POST /api/auth/refresh
 * @desc Refresh access token
 * @access Private (refresh token)
 */
router.post('/refresh', (req, res) => {
  // TODO: Implement refresh token logic
  res.json({
    success: true,
    message: 'Refresh token endpoint - TODO',
    timestamp: new Date().toISOString(),
  });
});

/**
 * @route POST /api/auth/logout
 * @desc Logout user (invalidate token)
 * @access Private
 */
router.post('/logout', requireAuth, (req, res) => {
  // TODO: Add token to blacklist in Redis
  res.json({
    success: true,
    message: 'Logout realizado com sucesso',
    timestamp: new Date().toISOString(),
  });
});

export default router;
</file>

<file path="backend/src/types/index.ts">
// üê∫ LOBISOMEM ONLINE - Tipos Centralizados (REFATORADO)
import type WebSocket from 'ws';

// =============================================================================
// IMPORT ENUMS FROM CONSTANTS (√öNICA FONTE)
// =============================================================================
export { Role, Faction, GamePhase } from '@/utils/constants';
import { Role, Faction, GamePhase } from '@/utils/constants';

// =============================================================================
// API & HTTP
// =============================================================================
export interface ApiResponse<T = any> {
    success: boolean;
    data?: T;
    message?: string;
    error?: string;
    timestamp: string;
}

// =============================================================================
// JWT & AUTENTICA√á√ÉO
// =============================================================================
export interface JWTPayload {
    userId: string;
    username: string;
    email: string;
    avatar?: string;
    iat?: number;
    exp?: number;
}

export interface TokenPair {
    accessToken: string;
    refreshToken?: string;
}

// =============================================================================
// WEBSOCKET & CONEX√ÉO
// =============================================================================
export interface ConnectionContext {
    userId: string;
    username: string;
    serverId: string;
    isSpectator: boolean;
    roomId?: string;
}

export interface ConnectionMetadata {
    connectedAt: Date;
    userAgent?: string;
    ip?: string;
    origin?: string;
}

export interface WebSocketConnection {
    id: string;
    ws: WebSocket;
    context: ConnectionContext;
    metadata: ConnectionMetadata;
    isAlive: boolean;
    lastPing: number;
    reconnectAttempts: number;
}

export interface WebSocketMessage {
    type: string;
    timestamp: string;
    data?: any;
    messageId?: string;
}

export interface URLParseResult {
    isValid: boolean;
    path: string;
    roomId?: string;
    serverId?: string;
}

export interface MessageValidationResult {
    isValid: boolean;
    message?: WebSocketMessage;
    error?: string;
}

export type WebSocketErrorCode =
    | 'INVALID_TOKEN' | 'ROOM_NOT_FOUND' | 'ROOM_FULL' | 'NOT_IN_ROOM'
    | 'NOT_HOST' | 'GAME_ALREADY_STARTED' | 'INVALID_ACTION'
    | 'PLAYER_NOT_FOUND' | 'RATE_LIMITED' | 'INVALID_MESSAGE'
    | 'UNKNOWN_MESSAGE_TYPE' | 'HANDLER_ERROR' | 'MISSING_ROOM_ID'
    | 'JOIN_ROOM_FAILED' | 'LEAVE_ROOM_FAILED' | 'READY_UPDATE_FAILED'
    | 'START_GAME_FAILED' | 'KICK_PLAYER_FAILED' | 'NOT_IMPLEMENTED';

// =============================================================================
// GAME TYPES (COMPAT√çVEIS COM CLASSES REAIS)
// =============================================================================
export type RoomStatus = 'WAITING' | 'PLAYING' | 'FINISHED';
export type GameStatus = 'WAITING' | 'STARTING' | 'PLAYING' | 'FINISHED' | 'CANCELLED';

export interface Room {
    id: string;
    name: string;
    isPrivate: boolean;
    maxPlayers: number;
    maxSpectators: number;
    status: RoomStatus;
    hostId: string;
    hostUsername: string;
    currentPlayers: number;
    currentSpectators: number;
    createdAt: Date;
    updatedAt: Date;
    code?: string;
    serverId?: string;
}

export interface GameConfig {
    roomId: string;
    maxPlayers: number;
    maxSpectators: number;
    nightDuration: number; // milliseconds
    dayDuration: number; // milliseconds
    votingDuration: number; // milliseconds
    allowReconnection: boolean;
    reconnectionTimeout: number; // milliseconds
}

// =============================================================================
// PLAYER INTERFACE (COMPAT√çVEL COM CLASSE Player)
// =============================================================================
export interface Player {
    id: string;
    userId: string;
    username: string;
    isHost: boolean;
    isReady: boolean;
    isSpectator: boolean;
    isConnected: boolean;
    joinedAt: Date;
    lastSeen: Date;
    avatar?: string;

    // Game-specific properties
    role?: Role;
    faction?: Faction;
    isAlive?: boolean;
    isProtected?: boolean;
    hasActed?: boolean;
    hasVoted?: boolean;
    votedFor?: string;
    actionsUsed?: number;
    maxActions?: number;
    lastAction?: string;
    eliminationReason?: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER';
    killedBy?: string;
}

// =============================================================================
// GAME STATE INTERFACE (COMPAT√çVEL COM CLASSE GameState)
// ‚úÖ MUDAN√áA CHAVE: Usar estruturas que a classe realmente usa
// =============================================================================
export interface GameState {
    gameId: string;
    roomId: string;
    status: GameStatus;
    phase: GamePhase;
    day: number;
    phaseStartTime: Date;
    phaseEndTime: Date;
    timeLeft: number;

    // ‚úÖ IMPORTANTE: Compat√≠vel com a classe real que usa Map
    players: Player[]; // Para serializa√ß√£o JSON
    spectators: string[]; // IDs dos espectadores  
    eliminatedPlayers: Player[];

    hostId: string;
    events: GameEvent[];
    votes: Record<string, string>; // Para serializa√ß√£o JSON - voterId -> targetId
    nightActions: NightAction[];
    config: GameConfig;
    createdAt: Date;
    updatedAt: Date;
    startedAt?: Date;
    finishedAt?: Date;
    winningFaction?: Faction;
    winningPlayers?: string[];
}

export interface GameEvent {
    id: string;
    type: string;
    phase: GamePhase;
    day: number;
    timestamp: Date;
    data: any;
    visibleTo?: string[]; // If undefined, visible to all
}

export interface NightAction {
    playerId: string;
    type: string;
    targetId?: string;
    data?: any;
    priority: number;
}

// =============================================================================
// GAME ENGINE INTERFACES
// =============================================================================
export interface IGameEngine {
    // Game lifecycle
    createGame(hostId: string, config: GameConfig): Promise<GameState>;
    startGame(gameId: string): Promise<boolean>;
    endGame(gameId: string, reason?: string): Promise<void>;

    // Player management
    addPlayer(gameId: string, player: Player): Promise<boolean>;
    removePlayer(gameId: string, playerId: string): Promise<boolean>;

    // Game state
    getGameState(gameId: string): Promise<GameState | null>;
    updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;

    // Actions
    performPlayerAction(gameId: string, playerId: string, action: any): Promise<boolean>;

    // Phase management
    nextPhase(gameId: string): Promise<void>;

    // Events
    onGameEvent(gameId: string, event: string, handler: (data: any) => void): void;

    // Voting
    castVote?(gameId: string, voterId: string, targetId: string): Promise<boolean>;
    removeVote?(gameId: string, voterId: string): Promise<boolean>;

    // Administrative
    getActiveGamesCount?(): number;
    getAllGames?(): GameState[];
    getGamesByRoom?(roomId: string): Promise<GameState[]>;
    forceEndGame?(gameId: string, reason: string): Promise<boolean>;
    getGameStats?(gameId: string): any;
    cleanup?(): Promise<void>;
}

// =============================================================================
// ROLE SYSTEM TYPES (IMPORTADOS DE RoleSystem.ts)
// =============================================================================
export interface RoleConfiguration {
    role: Role;
    faction: Faction;
    name: string;
    description: string;
    abilities: string[];
    goalDescription: string;
    canAct: boolean;
    actsDuring: string[];
    hasNightChat: boolean;
    immuneToInvestigation: boolean;
    maxActions?: number;
    priority: number;
}

export type RoleDistribution = Record<Role, number>;

// =============================================================================
// ACTION SYSTEM TYPES
// =============================================================================
export interface GameAction {
    id: string;
    playerId: string;
    type: string;
    targetId?: string;
    data?: any;
    timestamp: Date;
    phase: string;
    day: number;
    priority: number;
    isValid: boolean;
    processed: boolean;
}

export interface ActionResult {
    success: boolean;
    actionId: string;
    message?: string;
    data?: any;
    errors?: string[];
}

// =============================================================================
// TIMER SYSTEM TYPES
// =============================================================================
export interface GameTimer {
    id: string;
    type: 'PHASE' | 'WARNING' | 'CUSTOM';
    startTime: number;
    duration: number;
    remaining: number;
    isActive: boolean;
    callback?: () => void;
    timeout?: NodeJS.Timeout; // ‚úÖ Nome correto
}

// =============================================================================
// SERVICE INTERFACES (CORRIGIDOS)
// =============================================================================
export interface ServiceMetadata {
    id: string;
    type: 'lobby' | 'game' | 'chat' | 'monolith';
    host: string;
    port: number;
    capabilities: string[];
    status: 'healthy' | 'unhealthy';
    lastHeartbeat: Date;
    maxRooms?: number;
    currentRooms?: number;
}

export interface IEventBus {
    publish<T>(channel: string, event: T): Promise<void>;
    subscribe<T>(channel: string, handler: (event: T) => void): Promise<void>;
    unsubscribe(channel: string, handler?: Function): Promise<void>;
    healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

export interface IServiceRegistry {
    registerService(serviceId: string, metadata: ServiceMetadata): Promise<void>;
    getAvailableServices(serviceType: string): Promise<string[]>;
    unregisterService(serviceId: string): Promise<void>;
    getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null>;
    healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// ‚úÖ INTERFACE CORRIGIDA - Agora retorna GameState em vez de Game inexistente
export interface IGameStateService {
    createGame(hostId: string, config: GameConfig): Promise<GameState>;
    getGame(gameId: string): Promise<GameState | null>;
    updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;
    deleteGame(gameId: string): Promise<void>;
    addPlayer(gameId: string, player: Player): Promise<void>;
    removePlayer(gameId: string, playerId: string): Promise<void>;
    updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void>;
    getGameState(gameId: string): Promise<GameState | null>;
    getPlayer(gameId: string, playerId: string): Promise<Player | null>;
    getAllPlayers(gameId: string): Promise<Player[]>;
    getGamesByRoom(roomId: string): Promise<GameState[]>;
    getActiveGamesCount(): Promise<number>;
    cleanup?(): number;
    healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// =============================================================================
// WIN CONDITION TYPES
// =============================================================================
export interface WinCondition {
    hasWinner: boolean;
    winningFaction?: Faction;
    winningPlayers?: string[];
    reason?: string;
}

// =============================================================================
// GAME STATISTICS TYPES
// =============================================================================
export interface GameStats {
    gameId: string;
    status: GameStatus;
    phase: GamePhase;
    day: number;
    playerCount: number;
    aliveCount: number;
    spectatorCount: number;
    timeLeft: number;
    events: number;
}

export interface GameResults {
    gameId: string;
    roomId: string;
    duration: number;
    totalDays: number;
    winningFaction?: Faction;
    winningPlayers: string[];
    players: PlayerResult[];
    events: GameEvent[];
}

export interface PlayerResult {
    id: string;
    userId: string;
    username: string;
    role?: Role;
    faction?: Faction;
    survived: boolean;
    won: boolean;
    eliminationReason?: string;
    killedBy?: string;
}

// =============================================================================
// PHASE MANAGER TYPES
// =============================================================================
export interface PhaseTransition {
    from: GamePhase;
    to: GamePhase;
    duration: number;
    reason?: string;
}

export interface NightResults {
    protections: string[];
    investigations: Array<{
        investigatorId: string;
        targetId: string;
        result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS';
    }>;
    attacks: Array<{
        attackerId: string;
        targetId: string;
        successful: boolean;
    }>;
    deaths: Array<{
        playerId: string;
        cause: string;
        killedBy?: string;
    }>;
}

// =============================================================================
// WEBSOCKET EVENT TYPES
// =============================================================================
export interface GameWebSocketEvents {
    // Game lifecycle events
    'game:created': { gameId: string; hostId: string; config: GameConfig };
    'game:started': { gameId: string; players: Player[]; distribution: RoleDistribution };
    'game:ended': { gameId: string; results: GameResults };

    // Phase events
    'phase:changed': { gameId: string; phase: GamePhase; duration: number; timeLeft: number };
    'phase:warning': { gameId: string; phase: GamePhase; timeLeft: number };

    // Player events
    'player:joined': { gameId: string; player: Player };
    'player:left': { gameId: string; playerId: string; username: string };
    'player:died': { gameId: string; playerId: string; role: Role; cause: string };
    'player:executed': { gameId: string; playerId: string; role: Role; votes: number };

    // Action events
    'action:submitted': { gameId: string; playerId: string; actionType: string };
    'action:result': { gameId: string; playerId: string; result: ActionResult };

    // Voting events
    'vote:cast': { gameId: string; voterId: string; targetId: string; voteCounts: Record<string, number> };
    'vote:removed': { gameId: string; voterId: string; voteCounts: Record<string, number> };
}

// =============================================================================
// WEBSOCKET MESSAGE TYPES
// =============================================================================
export interface ClientToServerEvents {
    // Room events
    'join-room': { roomId: string; asSpectator?: boolean };
    'leave-room': { roomId?: string };
    'player-ready': { ready: boolean };
    'start-game': {};

    // Game actions
    'game-action': { type: string; targetId?: string; data?: any };
    'vote': { targetId: string };
    'unvote': {};

    // Chat events
    'chat-message': { message: string; channel?: string };

    // Werewolf coordination
    'werewolf-kill-vote': { targetId: string };

    // Admin events
    'kick-player': { playerId: string };
    'force-phase': {};
    'extend-time': { additionalTime: number };
}

export interface ServerToClientEvents {
    // Connection events
    'connected': { userId: string };
    'error': { code: WebSocketErrorCode; message: string };

    // Room events
    'room-joined': { room: Room; player: Player; yourRole: string };
    'room-left': { roomId: string };
    'player-joined': { player: Player };
    'player-left': { userId: string; username: string };
    'player-ready': { userId: string; username: string; ready: boolean };

    // Game events
    'game-starting': { countdown: number };
    'game-started': { gameId: string; players: Player[]; spectators: Player[] };
    'game-state': GameState;
    'game-ended': { results: GameResults };

    // Phase events
    'phase-changed': { phase: GamePhase; timeLeft: number; day: number };
    'phase-warning': { timeLeft: number };

    // Action events
    'action-confirmed': { actionType: string; message: string };
    'action-failed': { actionType: string; error: string };

    // Voting events
    'voting-update': { votes: Record<string, string>; counts: Record<string, number> };
    'execution-result': { executedId?: string; executedName?: string; executedRole?: Role };

    // Night events
    'night-results': { deaths: any[]; messages: string[] };
    'investigation-result': { targetName: string; result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS' };

    // Chat events
    'chat-message': { userId: string; username: string; message: string; channel: string; timestamp: string };

    // Role-specific events
    'role-assigned': { role: Role; faction: Faction; abilities: string[] };
    'werewolf-chat': { senderId: string; senderName: string; message: string };
}
</file>

<file path="backend/src/utils/validators.ts">
// üê∫ LOBISOMEM ONLINE - Validation Utilities
// Input validation and sanitization functions
import { z } from 'zod';
import { GAME_LIMITS } from './constants';

//====================================================================
// BASIC VALIDATION SCHEMAS
//====================================================================
// User validation
export const emailSchema = z
  .string()
  .email('Email inv√°lido')
  .toLowerCase()
  .trim();

export const usernameSchema = z
  .string()
  .min(3, 'Username deve ter pelo menos 3 caracteres')
  .max(20, 'Username deve ter no m√°ximo 20 caracteres')
  .regex(/^[a-zA-Z0-9_-]+$/, 'Username s√≥ pode conter letras, n√∫meros, _ e -')
  .trim();

export const passwordSchema = z
  .string()
  .min(6, 'Senha deve ter pelo menos 6 caracteres')
  .max(50, 'Senha deve ter no m√°ximo 50 caracteres')
  .regex(/(?=.*[a-z])/, 'Senha deve conter pelo menos uma letra min√∫scula')
  .regex(/(?=.*[A-Z])/, 'Senha deve conter pelo menos uma letra mai√∫scula')
  .regex(/(?=.*\d)/, 'Senha deve conter pelo menos um n√∫mero');

// Room validation
export const roomNameSchema = z
  .string()
  .min(1, 'Nome da sala √© obrigat√≥rio')
  .max(GAME_LIMITS.MAX_ROOM_NAME_LENGTH, `Nome deve ter no m√°ximo ${GAME_LIMITS.MAX_ROOM_NAME_LENGTH} caracteres`)
  .trim();

export const roomCodeSchema = z
  .string()
  .length(GAME_LIMITS.ROOM_CODE_LENGTH, `C√≥digo deve ter ${GAME_LIMITS.ROOM_CODE_LENGTH} d√≠gitos`)
  .regex(/^\d+$/, 'C√≥digo deve conter apenas n√∫meros');

// Chat validation
export const chatMessageSchema = z
  .string()
  .min(1, 'Mensagem n√£o pode estar vazia')
  .max(GAME_LIMITS.MAX_MESSAGE_LENGTH, `Mensagem deve ter no m√°ximo ${GAME_LIMITS.MAX_MESSAGE_LENGTH} caracteres`)
  .trim();

//====================================================================
// AUTH REQUEST SCHEMAS
//====================================================================
export const registerRequestSchema = z.object({
  email: emailSchema,
  username: usernameSchema,
  password: passwordSchema,
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Senhas n√£o coincidem',
  path: ['confirmPassword'],
});

export const loginRequestSchema = z.object({
  email: emailSchema,
  password: z.string().min(1, 'Senha √© obrigat√≥ria'),
});

export const forgotPasswordSchema = z.object({
  email: emailSchema,
});

export const resetPasswordSchema = z.object({
  token: z.string().min(1, 'Token √© obrigat√≥rio'),
  password: passwordSchema,
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Senhas n√£o coincidem',
  path: ['confirmPassword'],
});

//====================================================================
// ROOM REQUEST SCHEMAS
//====================================================================
export const createRoomSchema = z.object({
  name: roomNameSchema,
  isPrivate: z.boolean().optional().default(false),
  maxPlayers: z
    .number()
    .min(GAME_LIMITS.MIN_PLAYERS, `M√≠nimo ${GAME_LIMITS.MIN_PLAYERS} jogadores`)
    .max(GAME_LIMITS.MAX_PLAYERS, `M√°ximo ${GAME_LIMITS.MAX_PLAYERS} jogadores`)
    .optional()
    .default(GAME_LIMITS.MAX_PLAYERS),
  maxSpectators: z
    .number()
    .min(0, 'N√∫mero de espectadores n√£o pode ser negativo')
    .max(GAME_LIMITS.MAX_SPECTATORS, `M√°ximo ${GAME_LIMITS.MAX_SPECTATORS} espectadores`)
    .optional()
    .default(GAME_LIMITS.MAX_SPECTATORS),
});

export const joinRoomSchema = z.object({
  roomId: z.string().cuid().optional(),
  code: roomCodeSchema.optional(),
  asSpectator: z.boolean().optional().default(false),
}).refine((data) => data.roomId || data.code, {
  message: 'Room ID ou c√≥digo √© obrigat√≥rio',
});

export const updateRoomSchema = z.object({
  name: roomNameSchema.optional(),
  maxPlayers: z
    .number()
    .min(GAME_LIMITS.MIN_PLAYERS)
    .max(GAME_LIMITS.MAX_PLAYERS)
    .optional(),
  maxSpectators: z
    .number()
    .min(0)
    .max(GAME_LIMITS.MAX_SPECTATORS)
    .optional(),
});

//====================================================================
// GAME REQUEST SCHEMAS
//====================================================================
export const gameActionSchema = z.object({
  type: z.enum(['INVESTIGATE', 'PROTECT', 'KILL', 'VOTE']),
  targetId: z.string().cuid().optional(),
  data: z.record(z.any()).optional(),
});

export const voteSchema = z.object({
  targetId: z.string().cuid('ID do alvo inv√°lido'),
});

//====================================================================
// CHAT SCHEMAS
//====================================================================
export const chatMessageRequestSchema = z.object({
  message: chatMessageSchema,
  channel: z.enum(['public', 'werewolf', 'spectator']).optional().default('public'),
});

//====================================================================
// PAGINATION SCHEMAS
//====================================================================
export const paginationSchema = z.object({
  page: z
    .string()
    .transform((val) => parseInt(val))
    .pipe(z.number().min(1, 'P√°gina deve ser maior que 0'))
    .optional()
    .default('1'),
  limit: z
    .string()
    .transform((val) => parseInt(val))
    .pipe(z.number().min(1).max(100, 'Limite m√°ximo de 100 itens por p√°gina'))
    .optional()
    .default('10'),
  sortBy: z.string().optional(),
  sortOrder: z.enum(['asc', 'desc']).optional().default('desc'),
});

//====================================================================
// CUSTOM VALIDATION FUNCTIONS
//====================================================================
/**
 * Validate if a string is a valid CUID
 */
export function isValidCuid(id: string): boolean {
  return z.string().cuid().safeParse(id).success;
}

/**
 * Validate if a user can perform an action in a game
 */
export function canPerformAction(
  role: string,
  phase: string,
  action: string
): boolean {
  const nightActions = ['INVESTIGATE', 'PROTECT', 'KILL'];
  const dayActions = ['VOTE'];

  if (phase === 'NIGHT' && nightActions.includes(action)) {
    return ['SHERIFF', 'DOCTOR', 'WEREWOLF', 'WEREWOLF_KING', 'VIGILANTE', 'SERIAL_KILLER'].includes(role);
  }

  if (phase === 'VOTING' && action === 'VOTE') {
    return true; // Everyone can vote
  }

  return false;
}

/**
 * Validate room code format
 */
export function generateRoomCode(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

/**
 * Sanitize chat message (remove harmful content)
 */
export function sanitizeChatMessage(message: string): string {
  return message
    .trim()
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // Remove script tags
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .substring(0, GAME_LIMITS.MAX_MESSAGE_LENGTH);
}

/**
 * Validate if email domain is allowed
 */
export function isAllowedEmailDomain(email: string): boolean {
  // Add email domain restrictions if needed
  const blockedDomains = ['tempmail.com', '10minutemail.com'];
  const domain = email.split('@')[1];
  if (!domain) return false;
  return !blockedDomains.includes(domain.toLowerCase());
}

/**
 * Validate username availability pattern
 */
export function hasValidUsernamePattern(username: string): boolean {
  // Block offensive patterns
  const blockedPatterns = [
    /admin/i,
    /moderator/i,
    /system/i,
    /bot/i,
    /fuck/i,
    /shit/i,
    // Add more as needed
  ];

  return !blockedPatterns.some(pattern => pattern.test(username));
}

/**
 * Rate limiting validation
 */
export function validateRateLimit(
  requests: number,
  windowMs: number,
  maxRequests: number
): { allowed: boolean; retryAfter?: number } {
  if (requests >= maxRequests) {
    return {
      allowed: false,
      retryAfter: windowMs,
    };
  }

  return { allowed: true };
}

//====================================================================
// WEBSOCKET VALIDATION
//====================================================================
export const websocketMessageSchema = z.object({
  type: z.string().min(1, 'Message type is required'),
  data: z.any().optional(),
  timestamp: z.string().optional(),
  messageId: z.string().optional(),
});

//====================================================================
// EXPORT VALIDATION HELPER
//====================================================================
export function createValidator<T>(schema: z.ZodSchema<T>) {
  return (data: unknown): { success: true; data: T } | { success: false; errors: string[] } => {
    const result = schema.safeParse(data);

    if (result.success) {
      return { success: true, data: result.data };
    }

    const errors = result.error.errors.map(err =>
      `${err.path.join('.')}: ${err.message}`
    );

    return { success: false, errors };
  };
}
</file>

<file path="backend/src/websocket/ServiceFactory.ts">
// üê∫ LOBISOMEM ONLINE - Service Factory (REFATORADO)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí microservices
import { config } from '@/config/environment';
import { getRedisClient } from '@/config/redis';
import { logger } from '@/utils/logger';
import { GameState, Player } from '@/game/Game'; // ‚úÖ Usar classe real
import type {
    IGameStateService,
    IEventBus,
    IServiceRegistry,
    GameConfig,
    ServiceMetadata
} from '@/types';

//====================================================================
// MEMORY IMPLEMENTATIONS (PHASE 1) - CORRIGIDAS
//====================================================================

class MemoryGameStateService implements IGameStateService {
    private games = new Map<string, GameState>(); // ‚úÖ Usar GameState n√£o Game
    private players = new Map<string, Map<string, Player>>();

    async createGame(hostId: string, config: GameConfig): Promise<GameState> {
        const gameId = `game-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        // ‚úÖ Criar GameState real
        const gameState = new GameState(gameId, config, hostId);

        this.games.set(gameId, gameState);
        this.players.set(gameId, new Map());

        logger.info('Game created in memory', { gameId, hostId });
        return gameState;
    }

    async getGame(gameId: string): Promise<GameState | null> {
        return this.games.get(gameId) || null;
    }

    async updateGameState(gameId: string, updates: Partial<GameState>): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) throw new Error(`Game ${gameId} not found`);

        // ‚úÖ Aplicar updates na classe real
        Object.assign(gameState, updates);
        gameState.updatedAt = new Date();
    }

    async deleteGame(gameId: string): Promise<void> {
        this.games.delete(gameId);
        this.players.delete(gameId);
        logger.info('Game deleted from memory', { gameId });
    }

    async addPlayer(gameId: string, player: Player): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) throw new Error(`Game ${gameId} not found`);

        // ‚úÖ Usar m√©todo da classe GameState
        const success = gameState.addPlayer(player);
        if (!success) {
            throw new Error('Failed to add player to game');
        }

        // Manter cache de players para queries r√°pidas
        const gamePlayers = this.players.get(gameId)!;
        gamePlayers.set(player.id, player);
    }

    async removePlayer(gameId: string, playerId: string): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) return;

        gameState.removePlayer(playerId);

        const gamePlayers = this.players.get(gameId);
        if (gamePlayers) {
            gamePlayers.delete(playerId);
        }
    }

    async updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) return;

        const player = gameState.getPlayer(playerId);
        if (player) {
            Object.assign(player, updates);
        }

        // Atualizar cache tamb√©m
        const gamePlayers = this.players.get(gameId);
        if (gamePlayers) {
            const cachedPlayer = gamePlayers.get(playerId);
            if (cachedPlayer) {
                Object.assign(cachedPlayer, updates);
            }
        }
    }

    async getGameState(gameId: string): Promise<GameState | null> {
        // ‚úÖ Retornar o estado real da classe
        return this.games.get(gameId) || null;
    }

    async getPlayer(gameId: string, playerId: string): Promise<Player | null> {
        const gameState = this.games.get(gameId);
        return gameState?.getPlayer(playerId) || null;
    }

    async getAllPlayers(gameId: string): Promise<Player[]> {
        const gameState = this.games.get(gameId);
        return gameState ? gameState.players : [];
    }

    async getGamesByRoom(roomId: string): Promise<GameState[]> {
        const games: GameState[] = [];
        for (const gameState of this.games.values()) {
            if (gameState.roomId === roomId) {
                games.push(gameState);
            }
        }
        return games;
    }

    async getActiveGamesCount(): Promise<number> {
        let count = 0;
        for (const gameState of this.games.values()) {
            if (gameState.status === 'PLAYING' || gameState.status === 'STARTING') {
                count++;
            }
        }
        return count;
    }

    cleanup(): number {
        const count = this.games.size;
        this.games.clear();
        this.players.clear();
        return count;
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return {
            status: 'healthy',
            message: `Memory storage OK - ${this.games.size} games active`
        };
    }
}

class LocalEventBus implements IEventBus {
    private listeners = new Map<string, Array<(event: any) => void>>();

    async publish<T>(channel: string, event: T): Promise<void> {
        const channelListeners = this.listeners.get(channel) || [];
        for (const listener of channelListeners) {
            try {
                listener(event);
            } catch (error) {
                logger.error('Error in event listener', error instanceof Error ? error : new Error('Unknown listener error'), {
                    channel,
                    event: typeof event === 'object' ? JSON.stringify(event) : String(event)
                });
            }
        }
    }

    async subscribe<T>(channel: string, handler: (event: T) => void): Promise<void> {
        if (!this.listeners.has(channel)) {
            this.listeners.set(channel, []);
        }
        this.listeners.get(channel)!.push(handler);
    }

    async unsubscribe(channel: string): Promise<void> {
        this.listeners.delete(channel);
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return {
            status: 'healthy',
            message: `Local EventBus OK - ${this.listeners.size} channels`
        };
    }
}

class MockServiceRegistry implements IServiceRegistry {
    private services = new Map<string, ServiceMetadata>();

    async registerService(serviceId: string, metadata: ServiceMetadata): Promise<void> {
        this.services.set(serviceId, metadata);
        logger.debug('Service registered', { serviceId, type: metadata.type });
    }

    async getAvailableServices(serviceType: string): Promise<string[]> {
        const services: string[] = [];
        for (const [serviceId, metadata] of this.services.entries()) {
            if (metadata.type === serviceType) {
                services.push(serviceId);
            }
        }
        return services;
    }

    async unregisterService(serviceId: string): Promise<void> {
        this.services.delete(serviceId);
        logger.debug('Service unregistered', { serviceId });
    }

    async getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null> {
        return this.services.get(serviceId) || null;
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return {
            status: 'healthy',
            message: `Mock Registry OK - ${this.services.size} services`
        };
    }
}

//====================================================================
// REDIS IMPLEMENTATIONS (PHASE 2) - PLACEHOLDERS CORRIGIDOS
//====================================================================

class RedisGameStateService implements IGameStateService {
    constructor(private redisUrl: string) { }

    async createGame(hostId: string, config: GameConfig): Promise<GameState> {
        // TODO: Implementar Redis
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getGame(gameId: string): Promise<GameState | null> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async updateGameState(gameId: string, updates: Partial<GameState>): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async deleteGame(gameId: string): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async addPlayer(gameId: string, player: Player): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async removePlayer(gameId: string, playerId: string): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getGameState(gameId: string): Promise<GameState | null> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getPlayer(gameId: string, playerId: string): Promise<Player | null> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getAllPlayers(gameId: string): Promise<Player[]> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getGamesByRoom(roomId: string): Promise<GameState[]> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getActiveGamesCount(): Promise<number> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    cleanup(): number {
        return 0;
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return { status: 'unhealthy', message: 'Redis GameStateService not implemented' };
    }
}

class RedisEventBus implements IEventBus {
    constructor(private redisUrl: string) { }

    async publish<T>(channel: string, event: T): Promise<void> {
        // TODO: Implementar Redis Pub/Sub
        throw new Error('Redis EventBus not implemented yet');
    }

    async subscribe<T>(channel: string, handler: (event: T) => void): Promise<void> {
        throw new Error('Redis EventBus not implemented yet');
    }

    async unsubscribe(channel: string): Promise<void> {
        throw new Error('Redis EventBus not implemented yet');
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return { status: 'unhealthy', message: 'Redis EventBus not implemented' };
    }
}

class RedisServiceRegistry implements IServiceRegistry {
    constructor(private redisUrl: string) { }

    async registerService(serviceId: string, metadata: ServiceMetadata): Promise<void> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async getAvailableServices(serviceType: string): Promise<string[]> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async unregisterService(serviceId: string): Promise<void> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return { status: 'unhealthy', message: 'Redis ServiceRegistry not implemented' };
    }
}

//====================================================================
// SERVICE FACTORY - CORRIGIDA
//====================================================================

export class ServiceFactory {
    private static instances = new Map<string, any>();

    static getGameStateService(): IGameStateService {
        if (!this.instances.has('gameState')) {
            const service = config.STORAGE_TYPE === 'redis'
                ? new RedisGameStateService(config.REDIS_URL)
                : new MemoryGameStateService();
            this.instances.set('gameState', service);
            logger.info('GameStateService initialized', { type: config.STORAGE_TYPE });
        }
        return this.instances.get('gameState');
    }

    static getEventBus(): IEventBus {
        if (!this.instances.has('eventBus')) {
            const bus = config.DISTRIBUTED_MODE
                ? new RedisEventBus(config.REDIS_URL)
                : new LocalEventBus();
            this.instances.set('eventBus', bus);
            logger.info('EventBus initialized', { type: config.DISTRIBUTED_MODE ? 'redis' : 'local' });
        }
        return this.instances.get('eventBus');
    }

    static getServiceRegistry(): IServiceRegistry {
        if (!this.instances.has('serviceRegistry')) {
            const registry = config.DISTRIBUTED_MODE
                ? new RedisServiceRegistry(config.REDIS_URL)
                : new MockServiceRegistry();
            this.instances.set('serviceRegistry', registry);
            logger.info('ServiceRegistry initialized', { type: config.DISTRIBUTED_MODE ? 'redis' : 'mock' });
        }
        return this.instances.get('serviceRegistry');
    }

    static async getServicesHealth(): Promise<Record<string, any>> {
        const health: Record<string, any> = {};
        const services = [
            { name: 'gameState', service: this.getGameStateService() },
            { name: 'eventBus', service: this.getEventBus() },
            { name: 'serviceRegistry', service: this.getServiceRegistry() },
        ];

        for (const { name, service } of services) {
            try {
                if (service.healthCheck) {
                    health[name] = await service.healthCheck();
                } else {
                    health[name] = { status: 'healthy', message: 'No health check available' };
                }
            } catch (error) {
                health[name] = {
                    status: 'unhealthy',
                    message: error instanceof Error ? error.message : 'Unknown error'
                };
            }
        }
        return health;
    }

    static getServicesStats(): Record<string, any> {
        return {
            gameState: {
                type: config.STORAGE_TYPE,
                distributed: config.DISTRIBUTED_MODE
            },
            eventBus: {
                type: config.DISTRIBUTED_MODE ? 'redis' : 'local'
            },
            serviceRegistry: {
                type: config.DISTRIBUTED_MODE ? 'redis' : 'mock'
            }
        };
    }

    static async cleanup(): Promise<void> {
        const gameStateService = this.getGameStateService();
        if (gameStateService.cleanup) {
            const cleanedCount = gameStateService.cleanup();
            logger.info('GameStateService cleanup completed', { cleanedCount });
        }

        this.instances.clear();
        logger.info('ServiceFactory instances cleared');
    }

    static clearInstances(): void {
        this.instances.clear();
        logger.info('ServiceFactory instances cleared');
    }
}
</file>

<file path="database/init.sql">
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";


CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW."updatedAt" = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION calculate_win_rate(total_wins INTEGER, total_games INTEGER)
RETURNS DECIMAL(5,4) AS $$
BEGIN
    IF total_games = 0 THEN
        RETURN 0.0;
    END IF;
    RETURN ROUND((total_wins::DECIMAL / total_games::DECIMAL), 4);
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION generate_room_code()
RETURNS TEXT AS $$
BEGIN
    RETURN LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;


CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(50) UNIQUE NOT NULL,
    "passwordHash" TEXT NOT NULL,
    avatar TEXT,
    level INTEGER DEFAULT 1 NOT NULL,
    "totalGames" INTEGER DEFAULT 0 NOT NULL,
    "totalWins" INTEGER DEFAULT 0 NOT NULL,
    "totalLosses" INTEGER DEFAULT 0 NOT NULL,
    "winRate" DECIMAL(5, 4) DEFAULT 0.0000 NOT NULL,
    "createdAt" TIMESTAMPTZ DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ DEFAULT NOW(),
    "lastLoginAt" TIMESTAMPTZ
);


CREATE TABLE IF NOT EXISTS rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    code VARCHAR(6) UNIQUE,
    "isPrivate" BOOLEAN DEFAULT false NOT NULL,
    "maxPlayers" INTEGER DEFAULT 15 NOT NULL,
    "maxSpectators" INTEGER DEFAULT 5 NOT NULL,
    status VARCHAR(20) DEFAULT 'WAITING' NOT NULL,
    "hostId" UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL,
    "serverId" VARCHAR(50) DEFAULT 'local-server',
    "createdAt" TIMESTAMPTZ DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ DEFAULT NOW()
);



DROP TRIGGER IF EXISTS update_users_updated_at ON users;
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_rooms_updated_at ON rooms;
CREATE TRIGGER update_rooms_updated_at
    BEFORE UPDATE ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
CREATE INDEX IF NOT EXISTS idx_rooms_code ON rooms(code);
CREATE INDEX IF NOT EXISTS idx_rooms_status ON rooms(status);


SELECT 'Database initialized successfully!' as status;
</file>

<file path="frontend/.env.example">
# üê∫ WEREWOLF - Frontend Environment Variables

# =============================================================================
# API CONFIGURATION
# =============================================================================
# URL base da API do backend
NEXT_PUBLIC_API_URL=http://localhost:3001

# URL do WebSocket
NEXT_PUBLIC_WS_URL=ws://localhost:3001

# =============================================================================
# APPLICATION SETTINGS
# =============================================================================
# Ambiente da aplica√ß√£o
NODE_ENV=development

# URL base do site (para SEO e Open Graph)
NEXT_PUBLIC_SITE_URL=http://localhost:3000

# Nome da aplica√ß√£o
NEXT_PUBLIC_APP_NAME=Werewolf

# =============================================================================
# ERROR TRACKING (OPCIONAL)
# =============================================================================
# Sentry DSN para tracking de erros
NEXT_PUBLIC_SENTRY_DSN=

# =============================================================================
# FEATURE FLAGS
# =============================================================================
# Habilitar PWA (Progressive Web App)
NEXT_PUBLIC_ENABLE_PWA=false

# Habilitar Service Worker
NEXT_PUBLIC_ENABLE_SW=false

# Modo de debug para desenvolvimento
NEXT_PUBLIC_DEBUG=false

# =============================================================================
# SOCIAL & SEO
# =============================================================================
# Meta tags para redes sociais
NEXT_PUBLIC_FACEBOOK_APP_ID=

# =============================================================================
# GAME SETTINGS
# =============================================================================
# Configura√ß√µes do jogo que podem ser alteradas pelo frontend
NEXT_PUBLIC_MAX_USERNAME_LENGTH=20
NEXT_PUBLIC_MIN_USERNAME_LENGTH=3
NEXT_PUBLIC_MAX_ROOM_NAME_LENGTH=30

# =============================================================================
# AUDIO SETTINGS
# =============================================================================
# Configura√ß√µes de √°udio padr√£o
NEXT_PUBLIC_DEFAULT_MUSIC_VOLUME=0.3
NEXT_PUBLIC_DEFAULT_SFX_VOLUME=0.7
NEXT_PUBLIC_AUDIO_ENABLED_DEFAULT=true

# =============================================================================
# DEVELOPMENT ONLY
# =============================================================================
# Mostrar informa√ß√µes de debug no console
NEXT_PUBLIC_SHOW_DEBUG_INFO=true

# Credenciais de teste (apenas em desenvolvimento)
NEXT_PUBLIC_DEMO_EMAIL=demo@werewolf.com
NEXT_PUBLIC_DEMO_PASSWORD=demo123

# =============================================================================
# EXTERNAL SERVICES (FUTURO)
# =============================================================================
# CDN para assets est√°ticos
NEXT_PUBLIC_CDN_URL=

# API de upload de imagens
NEXT_PUBLIC_UPLOAD_API_URL=

# =============================================================================
# WEBSOCKET CONFIGURATION
# =============================================================================
# Timeout para reconex√£o do WebSocket (ms)
NEXT_PUBLIC_WS_RECONNECT_TIMEOUT=5000

# M√°ximo de tentativas de reconex√£o
NEXT_PUBLIC_WS_MAX_RECONNECT_ATTEMPTS=5

# Intervalo do heartbeat (ms)
NEXT_PUBLIC_WS_HEARTBEAT_INTERVAL=30000

# ‚úÖ ADICIONADO: Configura√ß√µes WebSocket espec√≠ficas do servidor
# Intervalo do heartbeat do servidor (ms)
WS_HEARTBEAT_INTERVAL=30000

# Timeout do ping (ms)
WS_PING_TIMEOUT=10000

# M√°ximo de tentativas de reconex√£o do servidor
WS_MAX_RECONNECT_ATTEMPTS=5

# =============================================================================
# UI CONFIGURATION
# =============================================================================
# Tema padr√£o (dark/light)
NEXT_PUBLIC_DEFAULT_THEME=dark

# Idioma padr√£o
NEXT_PUBLIC_DEFAULT_LOCALE=pt-BR

# Timezone padr√£o
NEXT_PUBLIC_DEFAULT_TIMEZONE=America/Sao_Paulo

# =============================================================================
# PERFORMANCE
# =============================================================================
# Tamanho m√°ximo de upload (em bytes)
NEXT_PUBLIC_MAX_UPLOAD_SIZE=5242880

# Cache TTL para requests da API (ms)
NEXT_PUBLIC_API_CACHE_TTL=300000

# =============================================================================
# SECURITY
# =============================================================================
# Dom√≠nios permitidos para CORS (separados por v√≠rgula)
NEXT_PUBLIC_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001

# Habilitar HTTPS em produ√ß√£o
NEXT_PUBLIC_FORCE_HTTPS=false
</file>

<file path="frontend/src/components/common/Button.tsx">
'use client';

import { forwardRef } from 'react';
import { clsx } from 'clsx';
import { useTheme } from '@/context/ThemeContext';
import { ButtonProps } from '@/types';

// =============================================================================
// LOADING SPINNER COMPONENT (Inline para evitar depend√™ncias)
// =============================================================================
const Spinner = ({ className }: { className?: string }) => (
  <svg
    className={clsx('animate-spin', className)}
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
  >
    <circle
      className="opacity-25"
      cx="12"
      cy="12"
      r="10"
      stroke="currentColor"
      strokeWidth="4"
    />
    <path
      className="opacity-75"
      fill="currentColor"
      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
    />
  </svg>
);

// =============================================================================
// BUTTON COMPONENT
// =============================================================================
const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  function Button(
    {
      children,
      variant = 'primary',
      size = 'md',
      disabled = false,
      loading = false,
      onClick,
      className = '',
      type = 'button',
      ...props
    },
    ref
  ) {
    // Safe theme hook usage with fallback
    let playSound: (soundId: string) => void;
    try {
      const theme = useTheme();
      playSound = theme?.playSound || (() => { });
    } catch (error) {
      console.warn('Theme context not available, using fallback');
      playSound = () => { };
    }

    // =============================================================================
    // VARIANT STYLES
    // =============================================================================
    const variantStyles = {
      primary: clsx(
        'bg-gradient-to-b from-blue-500 to-blue-700',
        'hover:from-blue-400 hover:to-blue-600',
        'text-white font-bold shadow-lg',
        'border-2 border-blue-400',
        'hover:shadow-xl',
        'active:from-blue-700 active:to-blue-900'
      ),

      secondary: clsx(
        'bg-gradient-to-b from-gray-600 to-gray-800',
        'hover:from-gray-500 hover:to-gray-700',
        'text-white font-semibold shadow-lg',
        'border-2 border-gray-400',
        'hover:shadow-xl'
      ),

      danger: clsx(
        'bg-gradient-to-b from-red-500 to-red-700',
        'hover:from-red-400 hover:to-red-600',
        'text-white font-bold shadow-lg',
        'border-2 border-red-300',
        'hover:shadow-xl',
        'active:from-red-700 active:to-red-900'
      ),

      medieval: clsx(
        'bg-gradient-to-b from-amber-600 to-amber-800',
        'hover:from-amber-500 hover:to-amber-700',
        'text-white font-bold text-lg shadow-lg',
        'border-3 border-amber-400',
        'hover:shadow-xl',
        'relative overflow-hidden'
      ),

      ghost: clsx(
        'bg-transparent hover:bg-white/10',
        'text-white hover:text-blue-300',
        'border border-white/30 hover:border-blue-300',
        'transition-all duration-200'
      ),

      werewolf: clsx(
        'bg-gradient-to-b from-red-800 to-red-900',
        'hover:from-red-700 hover:to-red-800',
        'text-white font-bold shadow-lg',
        'border-2 border-red-600',
        'hover:shadow-xl'
      ),

      town: clsx(
        'bg-gradient-to-b from-green-600 to-green-800',
        'hover:from-green-500 hover:to-green-700',
        'text-white font-bold shadow-lg',
        'border-2 border-green-400',
        'hover:shadow-xl'
      ),
    };

    // =============================================================================
    // SIZE STYLES
    // =============================================================================
    const sizeStyles = {
      sm: 'px-3 py-1.5 text-sm rounded-md gap-1.5',
      md: 'px-4 py-2 text-base rounded-lg gap-2',
      lg: 'px-6 py-3 text-lg rounded-xl gap-2.5',
      xl: 'px-8 py-4 text-xl rounded-xl gap-3',
    };

    // =============================================================================
    // DISABLED/LOADING STYLES
    // =============================================================================
    const disabledStyles = clsx(
      'opacity-50 cursor-not-allowed',
      'hover:shadow-none hover:transform-none',
      'pointer-events-none'
    );

    // =============================================================================
    // COMBINED CLASSES
    // =============================================================================
    const buttonClasses = clsx(
      // Base styles
      'relative inline-flex items-center justify-center',
      'font-medium transition-all duration-200',
      'transform hover:scale-105 hover:-translate-y-0.5',
      'active:scale-95 active:translate-y-0',
      'focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2',
      'select-none',

      // Variant styles
      variantStyles[variant],

      // Size styles
      sizeStyles[size],

      // State styles
      (disabled || loading) && disabledStyles,

      // Custom className
      className
    );

    // =============================================================================
    // CLICK HANDLER COM SOM
    // =============================================================================
    const handleClick = () => {
      if (disabled || loading) return;

      // Escolher som baseado no tipo de bot√£o
      let soundType = 'button_click'; // default (click3.wav)

      if (variant === 'ghost' || variant === 'secondary') {
        soundType = 'button_secondary'; // click1.wav (som leve)
      } else if (variant === 'medieval' || variant === 'primary' || variant === 'danger') {
        soundType = 'button_click'; // click3.wav (som firme)
      }

      playSound(soundType);

      // Call onClick if provided
      onClick?.();
    };

    // =============================================================================
    // RENDER
    // =============================================================================
    return (
      <button
        ref={ref}
        type={type}
        className={buttonClasses}
        onClick={handleClick}
        disabled={disabled || loading}
        {...props}
      >
        {/* Loading spinner */}
        {loading && (
          <Spinner className="w-4 h-4" />
        )}

        {/* Button content */}
        {children}

        {/* Medieval button enhancement */}
        {variant === 'medieval' && (
          <>
            {/* Top highlight */}
            <div className="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-transparent via-amber-200 to-transparent opacity-60" />

            {/* Side highlights */}
            <div className="absolute top-0 bottom-0 left-0 w-1 bg-gradient-to-b from-amber-200 via-transparent to-amber-200 opacity-40" />
            <div className="absolute top-0 bottom-0 right-0 w-1 bg-gradient-to-b from-amber-200 via-transparent to-amber-200 opacity-40" />
          </>
        )}

        {/* Glow effect for primary variants */}
        {(variant === 'primary' || variant === 'medieval') && !disabled && !loading && (
          <div className="absolute -inset-0.5 bg-gradient-to-r from-blue-400 to-amber-400 rounded-lg opacity-0 group-hover:opacity-20 blur transition-opacity duration-300 -z-10" />
        )}
      </button>
    );
  }
);

// =============================================================================
// DISPLAY NAME (CR√çTICO para forwardRef)
// =============================================================================
Button.displayName = 'Button';

// =============================================================================
// BUTTON GROUP COMPONENT
// =============================================================================
interface ButtonGroupProps {
  children: React.ReactNode;
  className?: string;
  orientation?: 'horizontal' | 'vertical';
}

export const ButtonGroup = forwardRef<HTMLDivElement, ButtonGroupProps>(
  function ButtonGroup(
    {
      children,
      className = '',
      orientation = 'horizontal'
    },
    ref
  ) {
    return (
      <div
        ref={ref}
        className={clsx(
          'inline-flex',
          orientation === 'horizontal' ? 'flex-row' : 'flex-col',
          '[&>button]:rounded-none',
          '[&>button:first-child]:rounded-l-lg',
          '[&>button:last-child]:rounded-r-lg',
          orientation === 'vertical' && '[&>button:first-child]:rounded-t-lg [&>button:first-child]:rounded-l-none',
          orientation === 'vertical' && '[&>button:last-child]:rounded-b-lg [&>button:last-child]:rounded-r-none',
          '[&>button:not(:first-child)]:border-l-0',
          orientation === 'vertical' && '[&>button:not(:first-child)]:border-l [&>button:not(:first-child)]:border-t-0',
          className
        )}
      >
        {children}
      </div>
    );
  }
);

ButtonGroup.displayName = 'ButtonGroup';

// =============================================================================
// ICON BUTTON COMPONENT
// =============================================================================
interface IconButtonProps extends Omit<ButtonProps, 'children'> {
  icon: React.ReactNode;
  'aria-label': string;
}

export const IconButton = forwardRef<HTMLButtonElement, IconButtonProps>(
  function IconButton(
    {
      icon,
      className = '',
      size = 'md',
      ...props
    },
    ref
  ) {
    const iconSizes = {
      sm: 'w-4 h-4',
      md: 'w-5 h-5',
      lg: 'w-6 h-6',
      xl: 'w-8 h-8',
    };

    return (
      <Button
        ref={ref}
        className={clsx('!p-2 aspect-square', className)}
        size={size}
        {...props}
      >
        <span className={iconSizes[size]}>{icon}</span>
      </Button>
    );
  }
);

IconButton.displayName = 'IconButton';

// =============================================================================
// DEFAULT EXPORT
// =============================================================================
export default Button;
</file>

<file path="frontend/src/components/common/Modal.tsx">
'use client';

import { useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';
import { clsx } from 'clsx';
import { useTheme } from '@/context/ThemeContext';
import { ModalProps } from '@/types';
import Button from './Button';

// =============================================================================
// MODAL COMPONENT (VERS√ÉO FINAL CORRIGIDA E FUNCIONAL)
// =============================================================================
export default function Modal({
  isOpen,
  onClose,
  title,
  children,
  className = '',
  closeOnOverlayClick = true,
  size = 'md',
  variant = 'default',
}: ModalProps & {
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  variant?: 'default' | 'medieval' | 'game' | 'error';
}) {
  const [mounted, setMounted] = useState(false);

  // Garante que o c√≥digo s√≥ rode no cliente para o createPortal
  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  // Suporte para fechar com a tecla ESC
  useEffect(() => {
    if (!isOpen) return;
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [isOpen, onClose]);

  // Bloqueio de scroll do body quando o modal est√° aberto
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  // Render guard para SSR
  if (!mounted) return null;

  // Configura√ß√µes de estilo
  const sizeClasses = {
    sm: 'max-w-md',
    md: 'max-w-lg',
    lg: 'max-w-2xl',
    xl: 'max-w-4xl',
    full: 'w-[95vw] h-[95vh]',
  };

  const variantStyles = {
    default: 'bg-medieval-800 border-medieval-600 text-white shadow-medieval',
    medieval: 'bg-gradient-to-b from-medieval-700 to-medieval-900 border-3 border-amber-600 text-white shadow-glow-gold relative overflow-hidden',
    game: 'bg-gradient-to-b from-night-light to-night-dark border-2 border-salem-500 text-white shadow-2xl backdrop-blur-sm',
    error: 'bg-gradient-to-b from-red-900 to-red-950 border-2 border-red-500 text-white shadow-glow-red',
  };

  // Configura√ß√µes de anima√ß√£o
  const overlayVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1 },
    exit: { opacity: 0 },
  };

  const modalVariants = {
    hidden: { opacity: 0, scale: 0.9, y: 20 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring', damping: 25, stiffness: 300 } },
    exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.2 } },
  };

  // Conte√∫do do modal a ser renderizado no portal
  const modalContent = (
    <AnimatePresence mode="wait">
      {isOpen && (
        // O cont√™iner pai que cobre toda a tela e atua como o overlay clic√°vel
        <motion.div
          className="fixed inset-0 z-50 flex items-center justify-center p-4"
          variants={overlayVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
          onClick={closeOnOverlayClick ? onClose : undefined}
        >
          {/* Fundo escuro puramente visual, sem eventos de clique */}
          <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" />

          {/* O conte√∫do do modal */}
          <motion.div
            className={clsx(
              'relative w-full max-h-[90vh] flex flex-col',
              'rounded-xl border-2',
              sizeClasses[size],
              variantStyles[variant],
              className
            )}
            variants={modalVariants}
            onClick={(e) => e.stopPropagation()} // Impede que o clique no modal feche-o
          >
            {/* Cabe√ßalho (fixo) */}
            {title && (
              <header className="flex-shrink-0 flex items-center justify-between p-6 border-b border-current/20">
                <h2 className={clsx('text-xl font-bold', variant === 'medieval' && 'font-medieval text-2xl text-glow')}>
                  {title}
                </h2>
                <Button variant="ghost" size="sm" onClick={onClose} className="!p-1" aria-label="Fechar modal">
                  <X className="w-5 h-5" />
                </Button>
              </header>
            )}

            {/* Corpo do modal (√°rea com rolagem) */}
            <main className="flex-1 overflow-y-auto p-6">
              {!title && (
                <Button variant="ghost" size="sm" onClick={onClose} className="!p-1 absolute top-4 right-4 z-10" aria-label="Fechar modal">
                  <X className="w-5 h-5" />
                </Button>
              )}
              {children}
            </main>

            {/* Decora√ß√µes (apenas para o tema medieval) */}
            {variant === 'medieval' && (
              <>
                <div className="absolute top-2 left-2 w-8 h-8 border-l-3 border-t-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute top-2 right-2 w-8 h-8 border-r-3 border-t-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute bottom-2 left-2 w-8 h-8 border-l-3 border-b-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute bottom-2 right-2 w-8 h-8 border-r-3 border-b-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none">
                  <div className="w-12 h-6 bg-amber-600 rounded-full border-2 border-amber-400" />
                </div>
              </>
            )}
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );

  return createPortal(modalContent, document.body);
}

// =============================================================================
// CONFIRMATION MODAL COMPONENT
// =============================================================================
interface ConfirmModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  variant?: 'danger' | 'warning' | 'info';
}

export function ConfirmModal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  variant = 'info',
}: ConfirmModalProps) {
  const { playSound } = useTheme();

  const handleConfirm = () => {
    playSound('button_click');
    onConfirm();
    onClose();
  };

  const handleCancel = () => {
    onClose();
  };

  const getVariantProps = () => {
    switch (variant) {
      case 'danger':
        return { modalVariant: 'error' as const, confirmVariant: 'danger' as const };
      case 'warning':
        return { modalVariant: 'medieval' as const, confirmVariant: 'primary' as const };
      default:
        return { modalVariant: 'default' as const, confirmVariant: 'primary' as const };
    }
  };

  const { modalVariant, confirmVariant } = getVariantProps();

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={title} variant={modalVariant} size="sm">
      <div className="space-y-6">
        <p className="text-white/90 leading-relaxed">{message}</p>
        <div className="flex gap-3 justify-end">
          <Button variant="ghost" onClick={handleCancel}>
            {cancelText}
          </Button>
          <Button variant={confirmVariant} onClick={handleConfirm}>
            {confirmText}
          </Button>
        </div>
      </div>
    </Modal>
  );
}

// =============================================================================
// ALERT MODAL COMPONENT
// =============================================================================
interface AlertModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  message: string;
  variant?: 'success' | 'error' | 'warning' | 'info';
}

export function AlertModal({
  isOpen,
  onClose,
  title,
  message,
  variant = 'info',
}: AlertModalProps) {
  const { playSound } = useTheme();

  const handleClose = () => {
    playSound('button_click');
    onClose();
  };

  const getVariantProps = () => {
    switch (variant) {
      case 'success':
        return { modalVariant: 'game' as const, icon: '‚úÖ' };
      case 'error':
        return { modalVariant: 'error' as const, icon: '‚ùå' };
      case 'warning':
        return { modalVariant: 'medieval' as const, icon: '‚ö†Ô∏è' };
      default:
        return { modalVariant: 'default' as const, icon: '‚ÑπÔ∏è' };
    }
  };

  const { modalVariant, icon } = getVariantProps();

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={`${icon} ${title}`} variant={modalVariant} size="sm">
      <div className="space-y-6">
        <p className="text-white/90 leading-relaxed">{message}</p>
        <div className="flex justify-end">
          <Button variant="primary" onClick={handleClose}>
            Entendi
          </Button>
        </div>
      </div>
    </Modal>
  );
}
</file>

<file path="frontend/src/context/AuthContext.tsx">
'use client';

import { createContext, useContext, useEffect, useState, ReactNode, useMemo } from 'react';
import { User, AuthTokens, LoginRequest, RegisterRequest } from '@/types';
import { authService } from '@/services/auth';
import { toast } from 'react-hot-toast';
import Cookies from 'js-cookie';

// =============================================================================
// CONTEXT TYPES
// =============================================================================
interface AuthContextType {
  // State
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;

  // Actions
  login: (credentials: LoginRequest) => Promise<boolean>;
  register: (data: RegisterRequest) => Promise<boolean>;
  logout: () => void;
  refreshToken: () => Promise<boolean>;
  updateUser: (updates: Partial<User>) => void;

  // Utils
  getToken: () => string | null;
  isTokenExpired: () => boolean;
}

// =============================================================================
// CONTEXT CREATION
// =============================================================================
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// =============================================================================
// PROVIDER COMPONENT
// =============================================================================
interface AuthProviderProps {
  children: ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // =============================================================================
  // ‚úÖ COMPUTED VALUES - MELHORADO COM VERIFICA√á√ÉO COMPLETA
  // =============================================================================
  const getToken = (): string | null => {
    return Cookies.get('access_token') || null;
  };

  // ‚úÖ CORRIGIDO: isAuthenticated com verifica√ß√£o completa
  const isAuthenticated = useMemo(() => {
    const token = getToken();
    return !!user && !!token && !isLoading;
  }, [user, isLoading]);

  // =============================================================================
  // TOKEN MANAGEMENT
  // =============================================================================
  const setTokens = (tokens: AuthTokens) => {
    // Set access token with 7-day expiry
    Cookies.set('access_token', tokens.accessToken, {
      expires: 7,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    });

    // Set refresh token if provided
    if (tokens.refreshToken) {
      Cookies.set('refresh_token', tokens.refreshToken, {
        expires: 30,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
      });
    }
  };

  const clearTokens = () => {
    Cookies.remove('access_token');
    Cookies.remove('refresh_token');
  };

  const isTokenExpired = (): boolean => {
    const token = getToken();
    if (!token) return true;

    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.exp * 1000 < Date.now();
    } catch {
      return true;
    }
  };

  // =============================================================================
  // ‚úÖ AUTHENTICATION ACTIONS - CORRIGIDO CONFORME O GUIA
  // =============================================================================
  const login = async (credentials: LoginRequest): Promise<boolean> => {
    setIsLoading(true);

    // ‚úÖ CORRIGIDO: A chamada de servi√ßo agora NUNCA vai dar "throw" por um erro 401
    const response = await authService.login(credentials);

    setIsLoading(false);

    if (response.success && response.data) {
      // L√≥gica de sucesso...
      setUser(response.data.user);
      setTokens(response.data.tokens);
      toast.success(`Bem-vindo de volta, ${response.data.user.username}! üê∫`);
      return true;
    } else {
      // L√≥gica de falha...
      // A mensagem de erro vem direto do backend!
      const errorMessage = response.message || response.error || 'Ocorreu uma falha.';
      toast.error(errorMessage); // Isso vai mostrar "Email ou senha incorretos"
      return false;
    }
  };

  const register = async (data: RegisterRequest): Promise<boolean> => {
    setIsLoading(true);

    // ‚úÖ CORRIGIDO: A chamada de servi√ßo agora NUNCA vai dar "throw" por um erro 409
    const response = await authService.register(data);

    setIsLoading(false);

    if (response.success && response.data) {
      // L√≥gica de sucesso...
      setUser(response.data.user);
      setTokens(response.data.tokens);
      toast.success(`Conta criada com sucesso! Bem-vindo, ${data.username}! üéÆ`);
      return true;
    } else {
      // L√≥gica de falha...
      // A mensagem de erro vem direto do backend!
      const errorMessage = response.message || response.error || 'Erro ao criar conta';
      toast.error(errorMessage); // Isso vai mostrar "Email j√° est√° em uso"
      return false;
    }
  };

  const logout = () => {
    setUser(null);
    clearTokens();
    toast.success('Logout realizado com sucesso!');

    // Redirect to home page
    if (typeof window !== 'undefined') {
      window.location.href = '/';
    }
  };

  const refreshToken = async (): Promise<boolean> => {
    try {
      const refreshToken = Cookies.get('refresh_token');
      if (!refreshToken) return false;

      const response = await authService.refreshToken(refreshToken);

      if (response.success && response.data) {
        setTokens(response.data.tokens);
        return true;
      }

      return false;
    } catch (error) {
      console.error('Refresh token error:', error);
      return false;
    }
  };

  const updateUser = (updates: Partial<User>) => {
    if (user) {
      setUser({ ...user, ...updates });
    }
  };

  // =============================================================================
  // ‚úÖ INITIALIZATION - MELHORADO COM MELHOR CONTROLE DE LOADING
  // =============================================================================
  useEffect(() => {
    const initializeAuth = async () => {
      try {
        setIsLoading(true);
        const token = getToken();

        if (!token || isTokenExpired()) {
          // Try to refresh token
          const refreshed = await refreshToken();
          if (!refreshed) {
            setIsLoading(false);
            return;
          }
        }

        // Get user profile
        const profileResponse = await authService.getProfile();
        if (profileResponse.success && profileResponse.data) {
          setUser(profileResponse.data);
        } else {
          // Token is invalid, clear it
          clearTokens();
        }
      } catch (error) {
        console.error('Auth initialization error:', error);
        clearTokens();
      } finally {
        setIsLoading(false);
      }
    };

    initializeAuth();
  }, []);

  // =============================================================================
  // TOKEN REFRESH SCHEDULER
  // =============================================================================
  useEffect(() => {
    if (!isAuthenticated) return;

    // Refresh token every 30 minutes if user is active
    const interval = setInterval(async () => {
      if (!isTokenExpired()) return;

      const refreshed = await refreshToken();
      if (!refreshed) {
        logout();
      }
    }, 30 * 60 * 1000); // 30 minutes

    return () => clearInterval(interval);
  }, [isAuthenticated]);

  // =============================================================================
  // ‚úÖ CONTEXT VALUE - MEMOIZADO PARA EVITAR RE-RENDERS DESNECESS√ÅRIOS
  // =============================================================================
  const contextValue = useMemo<AuthContextType>(() => ({
    // State
    user,
    isAuthenticated,
    isLoading,

    // Actions
    login,
    register,
    logout,
    refreshToken,
    updateUser,

    // Utils
    getToken,
    isTokenExpired,
  }), [user, isAuthenticated, isLoading]);

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
}

// =============================================================================
// HOOK
// =============================================================================
export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// =============================================================================
// HOC FOR PROTECTED ROUTES
// =============================================================================
export function withAuth<P extends object>(Component: React.ComponentType<P>) {
  return function AuthenticatedComponent(props: P) {
    const { isAuthenticated, isLoading } = useAuth();

    if (isLoading) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-medieval-900">
          <div className="text-white text-xl font-medieval">
            üê∫ Carregando...
          </div>
        </div>
      );
    }

    if (!isAuthenticated) {
      if (typeof window !== 'undefined') {
        window.location.href = '/auth/login';
      }
      return null;
    }

    return <Component {...props} />;
  };
}
</file>

<file path="frontend/src/context/ThemeContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import audioService from '@/services/audioService';

// =============================================================================
// TYPES
// =============================================================================
interface PhaseColors {
  background: string;
  text: string;
  accent: string;
  border: string;
}

interface AudioConfig {
  musicVolume: number;
  sfxVolume: number;
  enabled: boolean;
}

interface ThemeContextType {
  theme: 'werewolf' | 'medieval' | 'modern';
  setTheme: (theme: 'werewolf' | 'medieval' | 'modern') => void;
  playSound: (soundId: string) => void;
  playMusic: (musicId: string) => void;
  stopMusic: () => void;
  setMusicVolume: (volume: number) => void;
  setSoundVolume: (volume: number) => void;
  musicVolume: number;
  soundVolume: number;
  isMusicPlaying: boolean;
  isAudioUnblocked: boolean;
  getPhaseColors: () => PhaseColors;
  getThemeClass: () => string;
  audioConfig: AudioConfig;
  updateAudioConfig: (config: Partial<AudioConfig>) => void;
}

// =============================================================================
// THEME CONTEXT
// =============================================================================
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// =============================================================================
// THEME PROVIDER
// =============================================================================
export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<'werewolf' | 'medieval' | 'modern'>('werewolf');
  const [audioConfig, setAudioConfig] = useState<AudioConfig>({
    musicVolume: 0.5,
    sfxVolume: 0.7,
    enabled: true,
  });

  // =============================================================================
  // AUDIO FUNCTIONS (delegando para o audioService)
  // =============================================================================
  const playSound = (soundId: string) => {
    if (audioConfig.enabled) {
      audioService.playSound(soundId);
    }
  };

  const playMusic = (musicId: string) => {
    if (audioConfig.enabled) {
      audioService.playMusic(musicId);
    }
  };

  const stopMusic = () => {
    audioService.stopMusic();
  };

  const setMusicVolume = (volume: number) => {
    const newConfig = { ...audioConfig, musicVolume: volume };
    setAudioConfig(newConfig);
    audioService.setMusicVolume(volume);
  };

  const setSoundVolume = (volume: number) => {
    const newConfig = { ...audioConfig, sfxVolume: volume };
    setAudioConfig(newConfig);
    audioService.setSoundVolume(volume);
  };

  const updateAudioConfig = (config: Partial<AudioConfig>) => {
    const newConfig = { ...audioConfig, ...config };
    setAudioConfig(newConfig);

    // Atualizar volumes no audioService
    if (config.musicVolume !== undefined) {
      audioService.setMusicVolume(config.musicVolume);
    }
    if (config.sfxVolume !== undefined) {
      audioService.setSoundVolume(config.sfxVolume);
    }

    // Se desabilitou o √°udio, para a m√∫sica
    if (config.enabled === false) {
      audioService.stopMusic();
    }
  };

  // =============================================================================
  // THEME UTILITIES (que o Layout.tsx precisa)
  // =============================================================================
  const getPhaseColors = (): PhaseColors => {
    // Por enquanto retorna cores padr√£o do tema medieval
    // Quando implementar fases do jogo, adicionar l√≥gica aqui
    return {
      background: 'from-medieval-900 to-medieval-800',
      text: 'text-white',
      accent: 'text-salem-300',
      border: 'border-medieval-600',
    };
  };

  const getThemeClass = (): string => {
    return `theme-${theme}`;
  };

  // =============================================================================
  // THEME EFFECT
  // =============================================================================
  useEffect(() => {
    // Aplicar classes do tema
    document.documentElement.setAttribute('data-theme', theme);

    // Aplicar classes espec√≠ficas
    if (theme === 'werewolf') {
      document.documentElement.classList.add('werewolf-theme');
      document.documentElement.classList.remove('medieval-theme', 'modern-theme');
    } else if (theme === 'medieval') {
      document.documentElement.classList.add('medieval-theme');
      document.documentElement.classList.remove('werewolf-theme', 'modern-theme');
    } else {
      document.documentElement.classList.add('modern-theme');
      document.documentElement.classList.remove('werewolf-theme', 'medieval-theme');
    }
  }, [theme]);

  // =============================================================================
  // CONTEXT VALUE
  // =============================================================================
  const value: ThemeContextType = {
    theme,
    setTheme,
    playSound,
    playMusic,
    stopMusic,
    setMusicVolume,
    setSoundVolume,
    musicVolume: audioConfig.musicVolume,
    soundVolume: audioConfig.sfxVolume,
    isMusicPlaying: audioService.isMusicPlaying,
    isAudioUnblocked: audioService.isAudioUnblocked,
    getPhaseColors,
    getThemeClass,
    audioConfig,
    updateAudioConfig,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// =============================================================================
// USE THEME HOOK
// =============================================================================
export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}
</file>

<file path="frontend/src/hooks/index.ts">
// üê∫ LOBISOMEM ONLINE - Custom Hooks
// Reusable hooks for common functionality

import { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { toast } from 'react-hot-toast';

// =============================================================================
// TIPOS AUXILIARES PARA HOOKS
// =============================================================================
export interface WebSocketHookOptions {
  autoConnect?: boolean;
  heartbeatInterval?: number;
  maxReconnectAttempts?: number;
  reconnectBackoff?: 'linear' | 'exponential';
}

export interface UseWebSocketReturn {
  socket: WebSocket | null;
  status: 'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'error';
  isConnected: boolean;
  pingLatency: number;
  reconnectAttempts: number;
  connect: () => void;
  disconnect: () => void;
  sendMessage: (type: string, data?: any) => boolean;
}

// =============================================================================
// ‚úÖ WEBSOCKET HOOK COM HEARTBEAT - CORRIGIDO
// =============================================================================
export function useWebSocket(
  url: string,
  options: WebSocketHookOptions = {}
): UseWebSocketReturn {
  const {
    autoConnect = true,
    heartbeatInterval = 30000, // 30 segundos
    maxReconnectAttempts = 5,
    reconnectBackoff = 'exponential'
  } = options;

  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [status, setStatus] = useState<'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'error'>('disconnected');
  const [pingLatency, setPingLatency] = useState<number>(0);
  const [reconnectAttempts, setReconnectAttempts] = useState<number>(0);

  const heartbeatRef = useRef<NodeJS.Timeout | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const pingStartTimeRef = useRef<number>(0);
  const shouldReconnectRef = useRef<boolean>(true);

  const clearHeartbeat = useCallback(() => {
    if (heartbeatRef.current) {
      clearInterval(heartbeatRef.current);
      heartbeatRef.current = null;
    }
  }, []);

  const clearReconnectTimeout = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
  }, []);

  const startHeartbeat = useCallback(() => {
    clearHeartbeat();

    heartbeatRef.current = setInterval(() => {
      if (socket && socket.readyState === WebSocket.OPEN) {
        pingStartTimeRef.current = Date.now();
        socket.send(JSON.stringify({ type: 'ping' }));
      }
    }, heartbeatInterval);
  }, [socket, heartbeatInterval, clearHeartbeat]);

  const calculateReconnectDelay = useCallback((attempts: number) => {
    if (reconnectBackoff === 'linear') {
      return Math.min(1000 * attempts, 30000); // Max 30 segundos
    } else {
      return Math.min(1000 * Math.pow(2, attempts), 30000); // Exponencial, max 30 segundos
    }
  }, [reconnectBackoff]);

  const connect = useCallback(() => {
    // ‚úÖ CORRE√á√ÉO: Validar URL antes de conectar
    if (!url || url === '') {
      console.warn('‚ùå Cannot connect: URL is empty');
      return;
    }

    if (socket && socket.readyState === WebSocket.OPEN) {
      console.log('‚úÖ WebSocket already connected, skipping...');
      return;
    }

    setStatus('connecting');
    shouldReconnectRef.current = true;

    try {
      console.log('üîå Connecting to WebSocket:', url);
      const ws = new WebSocket(url);
      setSocket(ws);

      ws.onopen = () => {
        console.log('‚úÖ WebSocket conectado');
        setStatus('connected');
        setReconnectAttempts(0);
        startHeartbeat();
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);

          // Responder ao ping com pong
          if (message.type === 'ping') {
            ws.send(JSON.stringify({ type: 'pong' }));
          }

          // Calcular lat√™ncia do ping
          if (message.type === 'pong') {
            const latency = Date.now() - pingStartTimeRef.current;
            setPingLatency(latency);
          }

          // Dispatchar evento customizado para outros componentes
          const customEvent = new CustomEvent('websocket-message', {
            detail: message
          });
          window.dispatchEvent(customEvent);
        } catch (error) {
          console.error('Erro ao processar mensagem WebSocket:', error);
        }
      };

      ws.onclose = (event) => {
        console.log('WebSocket fechado:', event.code, event.reason);
        setSocket(null);
        clearHeartbeat();

        if (shouldReconnectRef.current && reconnectAttempts < maxReconnectAttempts) {
          setStatus('reconnecting');
          const delay = calculateReconnectDelay(reconnectAttempts);

          reconnectTimeoutRef.current = setTimeout(() => {
            setReconnectAttempts(prev => prev + 1);
            connect();
          }, delay);
        } else {
          setStatus('disconnected');
        }
      };

      ws.onerror = (error) => {
        console.error('Erro WebSocket:', error);
        setStatus('error');
      };

    } catch (error) {
      console.error('Erro ao criar WebSocket:', error);
      setStatus('error');
    }
  }, [url, startHeartbeat, reconnectAttempts, maxReconnectAttempts, calculateReconnectDelay]);

  const disconnect = useCallback(() => {
    shouldReconnectRef.current = false;
    clearHeartbeat();
    clearReconnectTimeout();

    if (socket) {
      socket.close();
      setSocket(null);
    }

    setStatus('disconnected');
    setReconnectAttempts(0);
  }, [socket, clearHeartbeat, clearReconnectTimeout]);

  const sendMessage = useCallback((type: string, data?: any): boolean => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      try {
        socket.send(JSON.stringify({ type, data }));
        return true;
      } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
        return false;
      }
    }
    return false;
  }, [socket]);

  // ‚úÖ CORRE√á√ÉO: useEffect para autoConnect sem depend√™ncias problem√°ticas
  useEffect(() => {
    if (autoConnect && url && url !== '') {
      connect();
    }

    return () => {
      disconnect();
    };
  }, [autoConnect, url]); // ‚úÖ REMOVIDO: connect e disconnect das depend√™ncias para evitar loop

  return {
    socket,
    status,
    isConnected: status === 'connected',
    pingLatency,
    reconnectAttempts,
    connect,
    disconnect,
    sendMessage,
  };
}

// =============================================================================
// LOCAL STORAGE HOOK
// =============================================================================
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  // State to store our value
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);

      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}

// =============================================================================
// DEBOUNCE HOOK
// =============================================================================
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// =============================================================================
// ASYNC OPERATION HOOK
// =============================================================================
export function useAsync<T, E = string>(
  asyncFunction: () => Promise<T>,
  immediate = true
) {
  const [status, setStatus] = useState<'idle' | 'pending' | 'success' | 'error'>('idle');
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<E | null>(null);

  const execute = useCallback(async () => {
    setStatus('pending');
    setData(null);
    setError(null);

    try {
      const response = await asyncFunction();
      setData(response);
      setStatus('success');
      return response;
    } catch (error) {
      setError(error as E);
      setStatus('error');
      throw error;
    }
  }, [asyncFunction]);

  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return {
    execute,
    status,
    data,
    error,
    isLoading: status === 'pending',
    isError: status === 'error',
    isSuccess: status === 'success',
    isIdle: status === 'idle',
  };
}

// =============================================================================
// FORM HOOK
// =============================================================================
export function useForm<T extends Record<string, any>>(
  initialValues: T,
  onSubmit: (values: T) => void | Promise<void>
) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [touched, setTouchedState] = useState<Partial<Record<keyof T, boolean>>>({});

  const setValue = useCallback((name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));

    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: undefined }));
    }
  }, [errors]);

  const setError = useCallback((name: keyof T, error: string) => {
    setErrors(prev => ({ ...prev, [name]: error }));
  }, []);

  const setTouched = useCallback((name: keyof T, isTouched = true) => {
    setTouchedState(prev => ({ ...prev, [name]: isTouched }));
  }, []);

  const handleChange = useCallback((name: keyof T) => (
    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    setValue(name, event.target.value);
  }, [setValue]);

  const handleSubmit = useCallback(async (event?: React.FormEvent) => {
    if (event) {
      event.preventDefault();
    }

    setIsSubmitting(true);

    try {
      await onSubmit(values);
    } catch (error) {
      console.error('Form submission error:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [values, onSubmit]);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouchedState({});
    setIsSubmitting(false);
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    setValue,
    setError,
    setTouched,
    handleChange,
    handleSubmit,
    reset,
    hasErrors: Object.keys(errors).length > 0,
  };
}

// =============================================================================
// COUNTDOWN HOOK
// =============================================================================
export function useCountdown(initialTime: number) {
  const [timeLeft, setTimeLeft] = useState(initialTime);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const start = useCallback(() => {
    if (!isRunning) {
      setIsRunning(true);
    }
  }, [isRunning]);

  const pause = useCallback(() => {
    setIsRunning(false);
  }, []);

  const reset = useCallback((newTime?: number) => {
    setIsRunning(false);
    setTimeLeft(newTime ?? initialTime);
  }, [initialTime]);

  const stop = useCallback(() => {
    setIsRunning(false);
    setTimeLeft(0);
  }, []);

  useEffect(() => {
    if (isRunning && timeLeft > 0) {
      intervalRef.current = setInterval(() => {
        setTimeLeft(prev => {
          if (prev <= 1) {
            setIsRunning(false);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    } else {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [isRunning, timeLeft]);

  const formatTime = useCallback((seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  }, []);

  return {
    timeLeft,
    isRunning,
    start,
    pause,
    reset,
    stop,
    formatTime: formatTime(timeLeft),
    isFinished: timeLeft === 0,
  };
}

// =============================================================================
// KEYBOARD HOOK
// =============================================================================
export function useKeyboard(key: string, callback: () => void, deps: any[] = []) {
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.key === key) {
        callback();
      }
    };

    document.addEventListener('keydown', handleKeyPress);
    return () => document.removeEventListener('keydown', handleKeyPress);
  }, [key, callback, ...deps]);
}

// =============================================================================
// ONLINE STATUS HOOK
// =============================================================================
export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );

  useEffect(() => {
    const setOnline = () => setIsOnline(true);
    const setOffline = () => setIsOnline(false);

    window.addEventListener('online', setOnline);
    window.addEventListener('offline', setOffline);

    return () => {
      window.removeEventListener('online', setOnline);
      window.removeEventListener('offline', setOffline);
    };
  }, []);

  return isOnline;
}

// =============================================================================
// COPY TO CLIPBOARD HOOK
// =============================================================================
export function useCopyToClipboard() {
  const [copiedText, setCopiedText] = useState<string | null>(null);

  const copy = useCallback(async (text: string) => {
    if (!navigator?.clipboard) {
      console.warn('Clipboard not supported');
      return false;
    }

    try {
      await navigator.clipboard.writeText(text);
      setCopiedText(text);
      toast.success('Copiado para a √°rea de transfer√™ncia!');

      // Clear copied text after 3 seconds
      setTimeout(() => setCopiedText(null), 3000);

      return true;
    } catch (error) {
      console.warn('Copy failed', error);
      toast.error('Falha ao copiar');
      setCopiedText(null);
      return false;
    }
  }, []);

  return { copy, copiedText };
}

// =============================================================================
// INTERSECTION OBSERVER HOOK
// =============================================================================
export function useIntersectionObserver(
  elementRef: React.RefObject<Element>,
  options?: IntersectionObserverInit
) {
  const [isIntersecting, setIsIntersecting] = useState(false);

  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => setIsIntersecting(entry.isIntersecting),
      options
    );

    observer.observe(element);
    return () => observer.unobserve(element);
  }, [elementRef, options]);

  return isIntersecting;
}

// =============================================================================
// PREVIOUS VALUE HOOK
// =============================================================================
export function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T>();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

// =============================================================================
// WINDOW SIZE HOOK
// =============================================================================
export function useWindowSize() {
  const [windowSize, setWindowSize] = useState<{
    width: number | undefined;
    height: number | undefined;
  }>({
    width: undefined,
    height: undefined,
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener('resize', handleResize);
    handleResize(); // Set initial size

    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return windowSize;
}

// =============================================================================
// ROUTE PROTECTION HOOK
// =============================================================================
export function useProtectedRoute(redirectTo = '/auth/login') {
  const router = useRouter();

  // This would typically use your auth context
  // For now, just a placeholder
  const isAuthenticated = false; // Replace with actual auth check

  useEffect(() => {
    if (!isAuthenticated) {
      router.push(redirectTo);
    }
  }, [isAuthenticated, router, redirectTo]);

  return isAuthenticated;
}
</file>

<file path="frontend/src/pages/_app.tsx">
// üê∫ LOBISOMEM ONLINE - Next.js App Component
// Global app configuration and providers

import type { AppProps } from 'next/app';
import Head from 'next/head';
import { Inter, Cinzel, Pirata_One } from 'next/font/google';
import { Toaster } from 'react-hot-toast';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/router';
import { useEffect } from 'react';

// Context Providers
import { AuthProvider } from '@/context/AuthContext';
import { SocketProvider } from '@/context/SocketContext';
import { ThemeProvider } from '@/context/ThemeContext';

// Components
import ErrorBoundary from '@/components/common/ErrorBoundary';
import { PageLoading } from '@/components/common/LoadingSpinner';

// Styles
import '@/styles/globals.css';

// =============================================================================
// FONT CONFIGURATION
// =============================================================================
const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
  display: 'swap',
});

const cinzel = Cinzel({
  subsets: ['latin'],
  variable: '--font-cinzel',
  display: 'swap',
});

const pirataOne = Pirata_One({
  weight: '400',
  subsets: ['latin'],
  variable: '--font-pirata',
  display: 'swap',
});

// =============================================================================
// PAGE TRANSITION VARIANTS
// =============================================================================
const pageVariants = {
  initial: {
    opacity: 0,
    y: 20,
  },
  in: {
    opacity: 1,
    y: 0,
  },
  out: {
    opacity: 0,
    y: -20,
  },
};

const pageTransition = {
  type: 'tween',
  ease: 'anticipate',
  duration: 0.3,
};

// =============================================================================
// MAIN APP COMPONENT
// =============================================================================
export default function App({ Component, pageProps, router }: AppProps) {
  const { pathname } = useRouter();

  // ‚úÖ ADICIONADO: Suprimir warnings de hydration em desenvolvimento
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      const originalError = console.error;
      console.error = (...args) => {
        if (args[0]?.includes?.('Hydration')) return;
        if (args[0]?.includes?.('Text content does not match')) return;
        originalError(...args);
      };
    }
  }, []);

  return (
    <>
      {/* HEAD com viewport no lugar correto */}
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no, viewport-fit=cover" />
      </Head>

      <ErrorBoundary>
        {/* Font variables */}
        <div className={`${inter.variable} ${cinzel.variable} ${pirataOne.variable}`}>

          {/* ‚úÖ CORRIGIDO: Ordem correta de Context Providers */}
          <ThemeProvider>
            <AuthProvider>
              <SocketProvider> {/* SocketProvider DEVE vir AP√ìS AuthProvider */}

                {/* Page Transitions */}
                <AnimatePresence mode="wait" initial={false}>
                  <motion.div
                    key={router.route}
                    initial="initial"
                    animate="in"
                    exit="out"
                    variants={pageVariants}
                    transition={pageTransition}
                  >
                    <Component {...pageProps} />
                  </motion.div>
                </AnimatePresence>

                {/* Global Toast Notifications */}
                <Toaster
                  position="top-right"
                  toastOptions={{
                    duration: 4000,
                    style: {
                      background: '#2D1B1E',
                      color: '#F4E4BC',
                      border: '1px solid #8B925A',
                      fontFamily: 'var(--font-inter)',
                    },
                    success: {
                      iconTheme: {
                        primary: '#228B22',
                        secondary: '#F4E4BC',
                      },
                    },
                    error: {
                      iconTheme: {
                        primary: '#8B0000',
                        secondary: '#F4E4BC',
                      },
                    },
                  }}
                />

                {/* Loading Overlay for Page Transitions */}
                <AnimatePresence>
                  {router.isFallback && (
                    <motion.div
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      exit={{ opacity: 0 }}
                      className="fixed inset-0 z-50"
                    >
                      <PageLoading />
                    </motion.div>
                  )}
                </AnimatePresence>

              </SocketProvider>
            </AuthProvider>
          </ThemeProvider>
        </div>
      </ErrorBoundary>
    </>
  );
}

// =============================================================================
// GLOBAL ERROR HANDLER
// =============================================================================
if (typeof window !== 'undefined') {
  // Handle global errors
  window.addEventListener('error', (event) => {
    // ‚úÖ MELHORADO: Filtrar erros de hydration
    if (event.error?.message?.includes?.('Hydration')) return;
    if (event.error?.message?.includes?.('Text content does not match')) return;

    console.error('Global error:', event.error);
    // You could send this to an error reporting service
  });

  // Handle unhandled promise rejections
  window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    // You could send this to an error reporting service
  });

  // Performance monitoring
  if (process.env.NODE_ENV === 'development') {
    // Log performance metrics in development
    window.addEventListener('load', () => {
      setTimeout(() => {
        const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
        console.log('üöÄ Page Load Performance:', {
          'DNS Lookup': navigation.domainLookupEnd - navigation.domainLookupStart,
          'TCP Connection': navigation.connectEnd - navigation.connectStart,
          'Request': navigation.responseStart - navigation.requestStart,
          'Response': navigation.responseEnd - navigation.responseStart,
          'DOM Processing': navigation.domComplete - navigation.domLoading,
          'Total Load Time': navigation.loadEventEnd - navigation.navigationStart,
        });
      }, 0);
    });
  }
}
</file>

<file path="frontend/src/pages/_document.tsx">
// üê∫ WEREWOLF - Next.js Document
// Custom HTML document structure

import { Html, Head, Main, NextScript } from 'next/document';

export default function Document() {
  return (
    <Html lang="pt-BR" className="dark"> {/* ‚úÖ ADICIONADO: lang="pt-BR" */}
      <Head>
        {/* Favicon and App Icons */}
        <link rel="icon" href="/favicon.ico" />
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
        <link rel="manifest" href="/site.webmanifest" />
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#8B925A" />
        <meta name="msapplication-TileColor" content="#2D1B1E" />
        <meta name="theme-color" content="#2D1B1E" />

        {/* ‚úÖ MELHORADO: Meta Tags mais completas */}
        <meta name="description" content="Werewolf - O cl√°ssico jogo de dedu√ß√£o social online. Entre na vila e descubra quem s√£o os lobisomens!" />
        <meta name="keywords" content="werewolf, lobisomem, jogo online, multiplayer, dedu√ß√£o social, mafia" />
        <meta name="author" content="Werewolf Team" />
        <meta name="robots" content="index, follow" />

        {/* ‚úÖ ADICIONADO: Meta tags para PWA */}
        <meta name="format-detection" content="telephone=no" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="apple-mobile-web-app-title" content="Werewolf" />

        {/* Open Graph / Facebook */}
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Werewolf - O Jogo de Dedu√ß√£o Social" />
        <meta property="og:description" content="O cl√°ssico jogo de dedu√ß√£o social online. Descubra quem s√£o os lobisomens antes que eliminem toda a vila!" />
        <meta property="og:image" content="/og-image.png" />
        <meta property="og:url" content="https://werewolf-game.com" />
        <meta property="og:site_name" content="Werewolf" />
        <meta property="og:locale" content="pt_BR" />

        {/* Twitter */}
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="Werewolf - O Jogo de Dedu√ß√£o Social" />
        <meta name="twitter:description" content="O cl√°ssico jogo de dedu√ß√£o social online. Descubra quem s√£o os lobisomens!" />
        <meta name="twitter:image" content="/og-image.png" />

        {/* DNS Prefetch for performance */}
        <link rel="dns-prefetch" href="//fonts.googleapis.com" />
        <link rel="dns-prefetch" href="//fonts.gstatic.com" />

        {/* Preconnect for critical resources */}
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />

        {/* Google Fonts - Medieval theme */}
        <link
          href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Pirata+One&family=Inter:wght@300;400;500;600;700&display=swap"
          rel="stylesheet"
        />

        {/* ‚úÖ MELHORADO: Critical CSS mais robusto */}
        <style>{`
          /* Prevent Flash of Unstyled Content */
          html {
            visibility: hidden;
            opacity: 0;
            scroll-behavior: smooth;
          }
          
          html.fonts-loaded {
            visibility: visible;
            opacity: 1;
          }

          /* Loading state */
          .page-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2D1B1E 0%, #1a1a2e 100%);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
          }

          /* Dark theme by default */
          body {
            background-color: #2D1B1E;
            color: #F4E4BC;
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
          }

          /* ‚úÖ MELHORADO: Custom scrollbar mais bonito */
          ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
          }

          ::-webkit-scrollbar-track {
            background: rgba(45, 27, 30, 0.1);
            border-radius: 4px;
          }

          ::-webkit-scrollbar-thumb {
            background: rgba(139, 146, 90, 0.5);
            border-radius: 4px;
            transition: background 0.2s ease;
          }

          ::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 146, 90, 0.8);
          }

          ::-webkit-scrollbar-corner {
            background: transparent;
          }

          /* Firefox scrollbar */
          * {
            scrollbar-width: thin;
            scrollbar-color: rgba(139, 146, 90, 0.5) rgba(45, 27, 30, 0.1);
          }

          /* Disable text selection on UI elements */
          button, .btn, .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
          }

          /* ‚úÖ MELHORADO: Focus visible para acessibilidade */
          .focus-visible,
          *:focus-visible {
            outline: 2px solid #8B925A;
            outline-offset: 2px;
            border-radius: 4px;
          }

          /* ‚úÖ ADICIONADO: Supress√£o de hydration warnings no console */
          .hydration-safe {
            opacity: 0;
          }

          .hydration-safe.hydrated {
            opacity: 1;
            transition: opacity 0.2s ease;
          }

          /* ‚úÖ ADICIONADO: Anima√ß√µes de entrada suaves */
          @keyframes fadeInUp {
            from {
              opacity: 0;
              transform: translateY(20px);
            }
            to {
              opacity: 1;
              transform: translateY(0);
            }
          }

          .fade-in-up {
            animation: fadeInUp 0.5s ease forwards;
          }

          /* ‚úÖ ADICIONADO: Preven√ß√£o de layout shift */
          .prevent-layout-shift {
            min-height: 1px;
          }

          /* ‚úÖ ADICIONADO: Estilos para loading states */
          .skeleton {
            background: linear-gradient(90deg, #2D1B1E 25%, #3D2B2E 50%, #2D1B1E 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
          }

          @keyframes loading {
            0% {
              background-position: 200% 0;
            }
            100% {
              background-position: -200% 0;
            }
          }

          /* ‚úÖ ADICIONADO: Estilos para modo high contrast */
          @media (prefers-contrast: high) {
            body {
              background-color: #000;
              color: #fff;
            }
          }

          /* ‚úÖ ADICIONADO: Estilos para reduced motion */
          @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
              animation-duration: 0.01ms !important;
              animation-iteration-count: 1 !important;
              transition-duration: 0.01ms !important;
            }
          }
        `}</style>
      </Head>

      <body>
        {/* Page loading overlay */}
        <div id="page-loading" className="page-loading">
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>üê∫</div>
            <div style={{ fontSize: '1.5rem', fontFamily: 'Cinzel, serif', color: '#8B925A' }}>
              Werewolf
            </div>
            <div style={{ fontSize: '0.9rem', color: '#F4E4BC', marginTop: '0.5rem' }}>
              Carregando...
            </div>
          </div>
        </div>

        <Main />
        <NextScript />

        {/* ‚úÖ MELHORADO: Scripts de inicializa√ß√£o mais robustos */}
        <script
          dangerouslySetInnerHTML={{
            __html: `
              document.addEventListener('DOMContentLoaded', function() {
                // Remove loading overlay with smooth transition
                const loading = document.getElementById('page-loading');
                if (loading) {
                  setTimeout(() => {
                    loading.style.opacity = '0';
                    loading.style.transition = 'opacity 0.3s ease';
                    setTimeout(() => {
                      loading.remove();
                    }, 300);
                  }, 800);
                }

                // Mark fonts as loaded
                document.documentElement.classList.add('fonts-loaded');

                // Initialize focus-visible polyfill
                try {
                  let hadKeyboardEvent = true;
                  let keyboardThrottleTimeout;

                  const detectKeyboard = function(e) {
                    if (e.metaKey || e.altKey || e.ctrlKey) return;
                    hadKeyboardEvent = true;
                    document.body.classList.add('using-keyboard');
                  };

                  const detectMouse = function() {
                    hadKeyboardEvent = false;
                    document.body.classList.remove('using-keyboard');
                  };

                  document.addEventListener('keydown', detectKeyboard, true);
                  document.addEventListener('mousedown', detectMouse, true);
                  document.addEventListener('pointerdown', detectMouse, true);
                  document.addEventListener('touchstart', detectMouse, true);
                } catch (e) {
                  console.warn('Focus-visible polyfill error:', e);
                }

                // Performance monitoring in development
                if (${process.env.NODE_ENV === 'development'}) {
                  window.addEventListener('load', function() {
                    setTimeout(() => {
                      try {
                        const navigation = performance.getEntriesByType('navigation')[0];
                        if (navigation) {
                          console.log('üìä Page Performance:', {
                            'Total Load Time': Math.round(navigation.loadEventEnd - navigation.navigationStart) + 'ms',
                            'DOM Content Loaded': Math.round(navigation.domContentLoadedEventEnd - navigation.navigationStart) + 'ms',
                            'First Paint': Math.round(performance.getEntriesByType('paint')[0]?.startTime || 0) + 'ms'
                          });
                        }
                      } catch (e) {
                        console.warn('Performance monitoring error:', e);
                      }
                    }, 1000);
                  });
                }

                // Global error handling
                window.addEventListener('error', function(e) {
                  // Filter out hydration warnings in development
                  if (e.error?.message?.includes?.('Hydration') || 
                      e.error?.message?.includes?.('Text content does not match')) {
                    return;
                  }
                  console.error('Global error:', e.error);
                });

                window.addEventListener('unhandledrejection', function(e) {
                  console.error('Unhandled promise rejection:', e.reason);
                });
              });
            `,
          }}
        />

        {/* NoScript fallback */}
        <noscript>
          <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: '#2D1B1E',
            color: '#F4E4BC',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            flexDirection: 'column',
            fontFamily: 'sans-serif',
            textAlign: 'center',
            zIndex: 9999,
          }}>
            <div style={{ fontSize: '4rem', marginBottom: '2rem' }}>üê∫</div>
            <h1 style={{ fontSize: '2rem', marginBottom: '1rem', fontFamily: 'Cinzel, serif' }}>Werewolf</h1>
            <p style={{ fontSize: '1.2rem', marginBottom: '2rem', maxWidth: '400px' }}>
              JavaScript √© necess√°rio para jogar este jogo online.
            </p>
            <p style={{ fontSize: '1rem', color: '#8B925A' }}>
              Por favor, ative o JavaScript no seu navegador e recarregue a p√°gina.
            </p>
          </div>
        </noscript>
      </body>
    </Html>
  );
}
</file>

<file path="frontend/src/pages/auth/login.tsx">
// üê∫ WEREWOLF - Login Page
// Werewolf inspired login interface

import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { Eye, EyeOff, Mail, Lock, LogIn, AlertCircle } from 'lucide-react';
import { toast } from 'react-hot-toast';

import { useAuth } from '@/context/AuthContext';
import { useTheme } from '@/context/ThemeContext';
import { useForm } from '@/hooks';
import { LoginRequest } from '@/types';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// LOGIN PAGE COMPONENT
// =============================================================================
export default function LoginPage() {
  const router = useRouter();
  const { login, isAuthenticated, isLoading } = useAuth();
  const { playSound } = useTheme();
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Form management
  const {
    values,
    errors,
    touched,
    handleChange,
    handleSubmit,
    setError: setFieldError,
    setTouched,
  } = useForm<LoginRequest>(
    {
      email: '',
      password: '',
    },
    async (formData) => {
      if (!validateForm(formData)) return;

      setIsSubmitting(true);
      setError('');

      await login(formData);
      setIsSubmitting(false);
    }
  );

  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated && !isLoading) {
      const redirectTo = router.query.redirect as string || '/lobby';
      router.push(redirectTo);
    }
  }, [isAuthenticated, isLoading, router]);

  // Form validation
  const validateForm = (data: LoginRequest): boolean => {
    let isValid = true;
    setError('');

    // Email validation
    if (!data.email) {
      setFieldError('email', 'Email √© obrigat√≥rio');
      isValid = false;
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
      setFieldError('email', 'Email inv√°lido');
      isValid = false;
    }

    // Password validation
    if (!data.password) {
      setFieldError('password', 'Senha √© obrigat√≥ria');
      isValid = false;
    } else if (data.password.length < 6) {
      setFieldError('password', 'Senha deve ter pelo menos 6 caracteres');
      isValid = false;
    }

    return isValid;
  };

  // Show loading if checking authentication
  if (isLoading) {
    return <LoadingSpinner variant="medieval" size="xl" text="Verificando autentica√ß√£o..." />;
  }

  return (
    <>
      <Head>
        <title>Login - Werewolf</title>
        <meta name="description" content="Fa√ßa login na sua conta do Werewolf" />
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="card-medieval p-8"
        >
          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: 'spring' }}
              className="text-6xl mb-4"
            >
              üê∫
            </motion.div>
            <h1 className="text-2xl font-medieval text-glow mb-2">
              Entrar na Vila
            </h1>
            <p className="text-white/70">
              Fa√ßa login para come√ßar a jogar
            </p>
          </div>

          {/* Display de erro geral */}
          {error && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              className="mb-6 p-4 bg-red-900/30 border border-red-500/50 rounded-lg flex items-center gap-3"
            >
              <AlertCircle className="w-5 h-5 text-red-400 flex-shrink-0" />
              <p className="text-red-300 text-sm">{error}</p>
            </motion.div>
          )}

          {/* Google Login Button */}
          <Button
            variant="ghost"
            size="lg"
            onClick={() => {
              playSound('button_click');
              console.log('Google login clicked');
              // TODO: Implementar login com Google
            }}
            className="w-full border border-white/20 hover:border-white/40 mb-6"
            disabled={isSubmitting}
          >
            <svg className="w-5 h-5 mr-3" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
              />
              <path
                fill="currentColor"
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
              />
              <path
                fill="currentColor"
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
              />
              <path
                fill="currentColor"
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
              />
            </svg>
            Continuar com Google
          </Button>

          {/* Divider */}
          <div className="my-6 flex items-center">
            <div className="flex-1 border-t border-medieval-600"></div>
            <span className="px-4 text-white/50 text-sm">ou</span>
            <div className="flex-1 border-t border-medieval-600"></div>
          </div>

          {/* Login Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Email Field */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Email
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Mail className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="email"
                  type="email"
                  value={values.email}
                  onChange={handleChange('email')}
                  onBlur={() => setTouched('email')}
                  className={`
                    w-full pl-10 pr-4 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.email && touched.email
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seu@email.com"
                  disabled={isSubmitting}
                />
              </div>
              {errors.email && touched.email && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.email}
                </motion.p>
              )}
            </div>

            {/* Password Field */}
            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Senha
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Lock className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  value={values.password}
                  onChange={handleChange('password')}
                  onBlur={() => setTouched('password')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.password && touched.password
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  disabled={isSubmitting}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-white/40 hover:text-white/70 transition-colors"
                  disabled={isSubmitting}
                >
                  {showPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>
              {errors.password && touched.password && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.password}
                </motion.p>
              )}
            </div>

            {/* Forgot Password Link */}
            <div className="text-right">
              <Link
                href="/auth/forgot-password"
                className="text-sm text-salem-400 hover:text-salem-300 transition-colors"
              >
                Esqueceu sua senha?
              </Link>
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="medieval"
              size="lg"
              disabled={isSubmitting}
              loading={isSubmitting}
              className="w-full"
            >
              <LogIn className="w-5 h-5 mr-2" />
              {isSubmitting ? 'Entrando...' : 'Entrar'}
            </Button>
          </form>

          {/* Register Link */}
          <div className="text-center mt-8">
            <p className="text-white/70 mb-4">
              Ainda n√£o tem uma conta?
            </p>
            <Button
              variant="ghost"
              onClick={() => router.push('/auth/register')}
              className="w-full"
              disabled={isSubmitting}
            >
              Criar Conta Gratuita
            </Button>
          </div>

          {/* Demo Credentials */}
          {process.env.NODE_ENV === 'development' && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 1 }}
              className="mt-8 p-4 bg-blue-900/20 border border-blue-500/30 rounded-lg"
            >
              <h4 className="text-sm font-semibold text-blue-300 mb-2">
                üß™ Modo Desenvolvimento
              </h4>
              <p className="text-xs text-blue-200/70 mb-2">
                Credenciais de teste:
              </p>
              <div className="text-xs font-mono text-blue-200">
                <div>Email: demo@werewolf.com</div>
                <div>Senha: demo123</div>
              </div>
              <Button
                variant="ghost"
                size="sm"
                className="mt-2 text-xs"
                onClick={() => {
                  handleChange('email')({ target: { value: 'demo@werewolf.com' } } as any);
                  handleChange('password')({ target: { value: 'demo123' } } as any);
                }}
                disabled={isSubmitting}
              >
                Preencher Automaticamente
              </Button>
            </motion.div>
          )}
        </motion.div>

        {/* Background Elements */}
        <div className="fixed inset-0 overflow-hidden pointer-events-none z-[-1]">
          {[...Array(3)].map((_, i) => (
            <motion.div
              key={i}
              className="absolute text-8xl opacity-5"
              style={{
                top: `${20 + i * 30}%`,
                left: `${10 + i * 30}%`,
              }}
              animate={{
                y: [0, -20, 0],
                rotate: [0, 5, -5, 0],
              }}
              transition={{
                duration: 6 + i * 2,
                repeat: Infinity,
                ease: 'easeInOut',
              }}
            >
              üê∫
            </motion.div>
          ))}
        </div>
      </Layout>
    </>
  );
}
</file>

<file path="frontend/src/pages/auth/register.tsx">
// üê∫ WEREWOLF - Register Page
// Werewolf inspired registration interface

import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { Eye, EyeOff, Mail, Lock, User, UserPlus, Check, X } from 'lucide-react';

import { useAuth } from '@/context/AuthContext';
import { useForm, useDebounce } from '@/hooks';
import { RegisterRequest } from '@/types';
import { authService } from '@/services/auth';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// REGISTER PAGE COMPONENT
// =============================================================================
export default function RegisterPage() {
  const router = useRouter();
  const { register, isAuthenticated, isLoading } = useAuth();
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [usernameAvailable, setUsernameAvailable] = useState<boolean | null>(null);
  const [emailAvailable, setEmailAvailable] = useState<boolean | null>(null);
  const [checkingUsername, setCheckingUsername] = useState(false);
  const [checkingEmail, setCheckingEmail] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Form management
  const {
    values,
    errors,
    touched,
    handleChange,
    handleSubmit,
    setError,
    setTouched,
  } = useForm<RegisterRequest>(
    {
      email: '',
      username: '',
      password: '',
      confirmPassword: '',
    },
    async (formData) => {
      if (!validateForm(formData)) return;

      setIsSubmitting(true);
      await register(formData);
      setIsSubmitting(false);
    }
  );

  // Debounced values for availability checking
  const debouncedUsername = useDebounce(values.username, 500);
  const debouncedEmail = useDebounce(values.email, 500);

  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated && !isLoading) {
      router.push('/lobby');
    }
  }, [isAuthenticated, isLoading, router]);

  // Check username availability
  useEffect(() => {
    if (debouncedUsername && debouncedUsername.length >= 3) {
      checkUsernameAvailability(debouncedUsername);
    } else {
      setUsernameAvailable(null);
    }
  }, [debouncedUsername]);

  // Check email availability
  useEffect(() => {
    if (debouncedEmail && authService.validateEmail(debouncedEmail)) {
      checkEmailAvailability(debouncedEmail);
    } else {
      setEmailAvailable(null);
    }
  }, [debouncedEmail]);

  // Username availability check
  const checkUsernameAvailability = async (username: string) => {
    setCheckingUsername(true);
    try {
      const response = await authService.checkUsernameAvailability(username);
      setUsernameAvailable(response.data?.available || false);
    } catch (error) {
      setUsernameAvailable(null);
    } finally {
      setCheckingUsername(false);
    }
  };

  // Email availability check
  const checkEmailAvailability = async (email: string) => {
    setCheckingEmail(true);
    try {
      const response = await authService.checkEmailAvailability(email);
      setEmailAvailable(response.data?.available || false);
    } catch (error) {
      setEmailAvailable(null);
    } finally {
      setCheckingEmail(false);
    }
  };

  // Form validation
  const validateForm = (data: RegisterRequest): boolean => {
    let isValid = true;

    // Email validation
    if (!data.email) {
      setError('email', 'Email √© obrigat√≥rio');
      isValid = false;
    } else if (!authService.validateEmail(data.email)) {
      setError('email', 'Email inv√°lido');
      isValid = false;
    } else if (emailAvailable === false) {
      setError('email', 'Este email j√° est√° em uso');
      isValid = false;
    }

    // Username validation
    const usernameValidation = authService.validateUsername(data.username);
    if (!usernameValidation.isValid) {
      setError('username', usernameValidation.errors[0]);
      isValid = false;
    } else if (usernameAvailable === false) {
      setError('username', 'Este username j√° est√° em uso');
      isValid = false;
    }

    // Password validation
    const passwordValidation = authService.validatePassword(data.password);
    if (!passwordValidation.isValid) {
      setError('password', passwordValidation.errors[0]);
      isValid = false;
    }

    // Confirm password validation
    if (data.password !== data.confirmPassword) {
      setError('confirmPassword', 'Senhas n√£o coincidem');
      isValid = false;
    }

    return isValid;
  };

  // Get field status icon
  const getFieldStatusIcon = (field: 'username' | 'email') => {
    const isChecking = field === 'username' ? checkingUsername : checkingEmail;
    const isAvailable = field === 'username' ? usernameAvailable : emailAvailable;
    const value = field === 'username' ? values.username : values.email;

    if (!value || (field === 'username' && value.length < 3)) return null;
    if (isChecking) return <LoadingSpinner size="sm" />;
    if (isAvailable === true) return <Check className="w-5 h-5 text-green-400" />;
    if (isAvailable === false) return <X className="w-5 h-5 text-red-400" />;
    return null;
  };

  // Show loading if checking authentication
  if (isLoading) {
    return <LoadingSpinner variant="medieval" size="xl" text="Verificando autentica√ß√£o..." />;
  }

  return (
    <>
      <Head>
        <title>Criar Conta - Werewolf</title>
        <meta name="description" content="Crie sua conta no Werewolf e entre na vila" />
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="card-medieval p-8"
        >
          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: 'spring' }}
              className="text-6xl mb-4"
            >
              üèòÔ∏è
            </motion.div>
            <h1 className="text-2xl font-medieval text-glow mb-2">
              Juntar-se √† Vila
            </h1>
            <p className="text-white/70">
              Crie sua conta para come√ßar a jogar
            </p>
          </div>

          {/* Google Register Button */}
          <Button
            variant="ghost"
            size="lg"
            onClick={() => {
              console.log('Google register clicked');
              // TODO: Implementar registro com Google
            }}
            className="w-full border border-white/20 hover:border-white/40 mb-6"
            disabled={isSubmitting}
          >
            <svg className="w-5 h-5 mr-3" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
              />
              <path
                fill="currentColor"
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
              />
              <path
                fill="currentColor"
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
              />
              <path
                fill="currentColor"
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
              />
            </svg>
            Criar conta com Google
          </Button>

          {/* Divider */}
          <div className="my-6 flex items-center">
            <div className="flex-1 border-t border-medieval-600"></div>
            <span className="px-4 text-white/50 text-sm">ou</span>
            <div className="flex-1 border-t border-medieval-600"></div>
          </div>

          {/* Register Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Email Field */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Email
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Mail className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="email"
                  type="email"
                  value={values.email}
                  onChange={handleChange('email')}
                  onBlur={() => setTouched('email')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.email && touched.email
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seu@email.com"
                  disabled={isSubmitting}
                />
                <div className="absolute inset-y-0 right-0 pr-3 flex items-center">
                  {getFieldStatusIcon('email')}
                </div>
              </div>
              {errors.email && touched.email && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.email}
                </motion.p>
              )}
            </div>

            {/* Username Field */}
            <div>
              <label
                htmlFor="username"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Nome de Usu√°rio
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <User className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="username"
                  type="text"
                  value={values.username}
                  onChange={handleChange('username')}
                  onBlur={() => setTouched('username')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.username && touched.username
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seunome123"
                  disabled={isSubmitting}
                />
                <div className="absolute inset-y-0 right-0 pr-3 flex items-center">
                  {getFieldStatusIcon('username')}
                </div>
              </div>
              <p className="mt-1 text-xs text-white/50">
                3-20 caracteres, apenas letras, n√∫meros, _ e -
              </p>
              {errors.username && touched.username && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.username}
                </motion.p>
              )}
            </div>

            {/* Password Field */}
            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Senha
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Lock className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  value={values.password}
                  onChange={handleChange('password')}
                  onBlur={() => setTouched('password')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.password && touched.password
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  disabled={isSubmitting}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-white/40 hover:text-white/70 transition-colors"
                  disabled={isSubmitting}
                >
                  {showPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>

              {/* Password Requirements */}
              <div className="mt-2 space-y-1">
                <PasswordRequirement
                  met={values.password.length >= 6}
                  text="Pelo menos 6 caracteres"
                />
                <PasswordRequirement
                  met={/(?=.*[a-z])/.test(values.password)}
                  text="Uma letra min√∫scula"
                />
                <PasswordRequirement
                  met={/(?=.*[A-Z])/.test(values.password)}
                  text="Uma letra mai√∫scula"
                />
                <PasswordRequirement
                  met={/(?=.*\d)/.test(values.password)}
                  text="Um n√∫mero"
                />
              </div>

              {errors.password && touched.password && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.password}
                </motion.p>
              )}
            </div>

            {/* Confirm Password Field */}
            <div>
              <label
                htmlFor="confirmPassword"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Confirmar Senha
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Lock className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="confirmPassword"
                  type={showConfirmPassword ? 'text' : 'password'}
                  value={values.confirmPassword}
                  onChange={handleChange('confirmPassword')}
                  onBlur={() => setTouched('confirmPassword')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.confirmPassword && touched.confirmPassword
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  disabled={isSubmitting}
                />
                <button
                  type="button"
                  onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-white/40 hover:text-white/70 transition-colors"
                  disabled={isSubmitting}
                >
                  {showConfirmPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>
              {errors.confirmPassword && touched.confirmPassword && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.confirmPassword}
                </motion.p>
              )}
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="medieval"
              size="lg"
              disabled={isSubmitting || usernameAvailable === false || emailAvailable === false}
              loading={isSubmitting}
              className="w-full"
            >
              <UserPlus className="w-5 h-5 mr-2" />
              {isSubmitting ? 'Criando conta...' : 'Criar Conta'}
            </Button>
          </form>

          {/* Login Link */}
          <div className="text-center mt-8">
            <p className="text-white/70 mb-4">
              J√° tem uma conta?
            </p>
            <Button
              variant="ghost"
              onClick={() => router.push('/auth/login')}
              className="w-full"
              disabled={isSubmitting}
            >
              Fazer Login
            </Button>
          </div>
        </motion.div>
      </Layout>
    </>
  );
}

// =============================================================================
// PASSWORD REQUIREMENT COMPONENT
// =============================================================================
interface PasswordRequirementProps {
  met: boolean;
  text: string;
}

function PasswordRequirement({ met, text }: PasswordRequirementProps) {
  return (
    <motion.div
      initial={{ opacity: 0, x: -10 }}
      animate={{ opacity: 1, x: 0 }}
      className="flex items-center text-xs"
    >
      {met ? (
        <Check className="w-3 h-3 text-green-400 mr-2" />
      ) : (
        <X className="w-3 h-3 text-red-400 mr-2" />
      )}
      <span className={met ? 'text-green-400' : 'text-red-400'}>
        {text}
      </span>
    </motion.div>
  );
}
</file>

<file path="backend/src/controllers/authController.ts">
import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import { pool } from '@/config/database';
import { generateTokenPair, generatePasswordResetToken, verifyPasswordResetToken } from '@/config/jwt';
import { authLogger } from '@/utils/logger';
import { ERROR_MESSAGES } from '@/utils/constants';
import {
  validateRegisterRequest,
  validateLoginRequest,
  validateEmail
} from '@/utils/simpleValidators';
import type { ApiResponse } from '@/types';

export const register = async (req: Request, res: Response): Promise<void> => {
  try {
    const validation = validateRegisterRequest(req.body);
    if (!validation.success) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: validation.error,
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { email, username, password } = validation.data!;

    const existingUserQuery = `
      SELECT id, email, username FROM users 
      WHERE email = $1 OR username = $2
    `;
    const existingUserResult = await pool.query(existingUserQuery, [email.toLowerCase(), username.toLowerCase()]);

    if (existingUserResult.rows.length > 0) {
      const existingUser = existingUserResult.rows[0];
      authLogger.warn('Registration attempt with existing credentials', {
        email,
        username,
        existingField: existingUser.email === email.toLowerCase() ? 'email' : 'username',
        ip: req.ip,
      });

      res.status(409).json({
        success: false,
        error: 'USER_ALREADY_EXISTS',
        message: existingUser.email === email.toLowerCase()
          ? 'Email j√° est√° em uso'
          : 'Username j√° est√° em uso',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const passwordHash = await bcrypt.hash(password, 12);

    // ‚úÖ CORRIGIDO: Query SQL com todas as colunas camelCase entre aspas duplas
    const createUserQuery = `
      INSERT INTO users (email, username, "passwordHash", level, "totalGames", "totalWins", "totalLosses", "winRate", "createdAt", "updatedAt")
      VALUES ($1, $2, $3, 1, 0, 0, 0, 0.0, NOW(), NOW())
      RETURNING id, email, username, level, "totalGames", "totalWins", "totalLosses", "winRate", "createdAt", "updatedAt", "lastLoginAt"
    `;
    const userResult = await pool.query(createUserQuery, [email.toLowerCase(), username, passwordHash]);
    const user = userResult.rows[0];

    const tokens = generateTokenPair({
      userId: user.id,
      username: user.username,
      email: user.email,
    });

    authLogger.info('User registered successfully', {
      userId: user.id,
      username: user.username,
      email: user.email,
      ip: req.ip,
    });

    res.status(201).json({
      success: true,
      data: {
        user,
        tokens: {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
        },
      },
      message: 'Usu√°rio criado com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    authLogger.error('Registration error', error instanceof Error ? error : new Error('Unknown registration error'), {
      email: req.body?.email,
      username: req.body?.username,
      ip: req.ip,
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const login = async (req: Request, res: Response): Promise<void> => {
  try {
    const validation = validateLoginRequest(req.body);
    if (!validation.success) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: validation.error,
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { email, password } = validation.data!;

    const userQuery = `SELECT * FROM users WHERE email = $1`;
    const userResult = await pool.query(userQuery, [email.toLowerCase()]);

    if (userResult.rows.length === 0) {
      authLogger.warn('Login attempt with non-existent email', {
        email,
        ip: req.ip,
      });

      res.status(401).json({
        success: false,
        error: 'INVALID_CREDENTIALS',
        message: 'Email ou senha incorretos',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];
    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);

    if (!isPasswordValid) {
      authLogger.warn('Login attempt with invalid password', {
        userId: user.id,
        email: user.email,
        ip: req.ip,
      });

      res.status(401).json({
        success: false,
        error: 'INVALID_CREDENTIALS',
        message: 'Email ou senha incorretos',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    await pool.query(`UPDATE users SET "lastLoginAt" = NOW() WHERE id = $1`, [user.id]);

    const tokens = generateTokenPair({
      userId: user.id,
      username: user.username,
      email: user.email,
    });

    const { passwordHash, ...userWithoutPassword } = user;

    authLogger.info('User logged in successfully', {
      userId: user.id,
      username: user.username,
      email: user.email,
      ip: req.ip,
    });

    res.json({
      success: true,
      data: {
        user: userWithoutPassword,
        tokens: {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
        },
      },
      message: 'Login realizado com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    authLogger.error('Login error', error instanceof Error ? error : new Error('Unknown login error'), {
      email: req.body?.email,
      ip: req.ip,
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const forgotPassword = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email } = req.body;

    if (!email || !validateEmail(email)) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Email inv√°lido',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, email FROM users WHERE email = $1`;
    const userResult = await pool.query(userQuery, [email.toLowerCase()]);

    if (userResult.rows.length === 0) {
      authLogger.warn('Password reset attempt for non-existent email', {
        email,
        ip: req.ip,
      });

      res.json({
        success: true,
        message: 'Se o email existir, um link de recupera√ß√£o ser√° enviado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];
    const resetToken = generatePasswordResetToken(user.id, user.email);

    authLogger.info('Password reset token generated', {
      userId: user.id,
      email: user.email,
      ip: req.ip,
    });

    console.log(`Password reset token for ${email}: ${resetToken}`);
    console.log(`Reset URL: http://localhost:3000/auth/reset-password?token=${resetToken}`);

    res.json({
      success: true,
      data: {
        resetToken,
        resetUrl: `http://localhost:3000/auth/reset-password?token=${resetToken}`,
      },
      message: 'Link de recupera√ß√£o enviado para o email',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    authLogger.error('Forgot password error', error instanceof Error ? error : new Error('Unknown forgot password error'), {
      email: req.body?.email,
      ip: req.ip,
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const resetPassword = async (req: Request, res: Response): Promise<void> => {
  try {
    const { token, password } = req.body;

    if (!token || typeof token !== 'string') {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Token √© obrigat√≥rio',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    if (!password || typeof password !== 'string' || password.length < 6) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Senha deve ter pelo menos 6 caracteres',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    let tokenPayload;
    try {
      tokenPayload = verifyPasswordResetToken(token);
    } catch (error) {
      authLogger.warn('Invalid password reset token used', {
        token: token.slice(0, 20) + '...',
        ip: req.ip,
      });

      res.status(400).json({
        success: false,
        error: 'INVALID_TOKEN',
        message: 'Token inv√°lido ou expirado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, email FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [tokenPayload.userId]);

    if (userResult.rows.length === 0 || userResult.rows[0].email !== tokenPayload.email) {
      authLogger.warn('Password reset token user mismatch', {
        tokenUserId: tokenPayload.userId,
        tokenEmail: tokenPayload.email,
        userExists: userResult.rows.length > 0,
        ip: req.ip,
      });

      res.status(400).json({
        success: false,
        error: 'INVALID_TOKEN',
        message: 'Token inv√°lido',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const passwordHash = await bcrypt.hash(password, 12);
    await pool.query(`UPDATE users SET "passwordHash" = $1, "updatedAt" = NOW() WHERE id = $2`, [passwordHash, tokenPayload.userId]);

    authLogger.info('Password reset successfully', {
      userId: tokenPayload.userId,
      email: tokenPayload.email,
      ip: req.ip,
    });

    res.json({
      success: true,
      message: 'Senha alterada com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    authLogger.error('Reset password error', error instanceof Error ? error : new Error('Unknown reset password error'), {
      ip: req.ip,
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const getProfile = async (req: Request, res: Response): Promise<void> => {
  try {
    const userQuery = `
      SELECT id, email, username, avatar, level, "totalGames", "totalWins", "totalLosses", "winRate", "createdAt", "updatedAt", "lastLoginAt"
      FROM users WHERE id = $1
    `;
    const userResult = await pool.query(userQuery, [req.userId]);

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: ERROR_MESSAGES.NOT_FOUND,
        message: 'Usu√°rio n√£o encontrado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    res.json({
      success: true,
      data: userResult.rows[0],
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    authLogger.error('Get profile error', error instanceof Error ? error : new Error('Unknown profile error'), {
      userId: req.userId,
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const checkUsername = async (req: Request, res: Response): Promise<void> => {
  try {
    const { username } = req.params;

    if (!username || typeof username !== 'string') {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Username √© obrigat√≥rio',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id FROM users WHERE username = $1`;
    const userResult = await pool.query(userQuery, [username.toLowerCase()]);

    res.json({
      success: true,
      data: { available: userResult.rows.length === 0 },
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error('Check username error', error instanceof Error ? error : new Error('Unknown check username error'), {
      username: req.params?.username,
      ip: req.ip,
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const checkEmail = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email } = req.params;

    if (!email || typeof email !== 'string' || !validateEmail(email)) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Email v√°lido √© obrigat√≥rio',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id FROM users WHERE email = $1`;
    const userResult = await pool.query(userQuery, [email.toLowerCase()]);

    res.json({
      success: true,
      data: { available: userResult.rows.length === 0 },
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error('Check email error', error instanceof Error ? error : new Error('Unknown check email error'), {
      email: req.params?.email,
      ip: req.ip,
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};
</file>

<file path="backend/src/controllers/roomController.ts">
import { Request, Response } from 'express';
import { pool } from '@/config/database';
import { generateRoomCode } from '@/utils/helper';
import { logger } from '@/utils/logger';
import { ERROR_MESSAGES, GAME_LIMITS } from '@/utils/constants';
import { validateCreateRoomRequest, validateRoomCode } from '@/utils/simpleValidators';
import type { ApiResponse } from '@/types';
import type { Room, RoomStatus } from '@/types';

export const listRooms = async (req: Request, res: Response): Promise<void> => {
  try {
    logger.info('Listing public rooms', { userId: req.userId });

    const roomsQuery = `
            SELECT 
                r.id, r.name, r."isPrivate", r."maxPlayers", r."maxSpectators", 
                r.status, r."createdAt", u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r."isPrivate" = false AND r.status IN ('WAITING', 'PLAYING')
            ORDER BY r."createdAt" DESC
            LIMIT 50
        `;
    const roomsResult = await pool.query(roomsQuery);

    const roomsMetadata = roomsResult.rows.map((room: any) => ({
      id: room.id,
      name: room.name,
      isPrivate: room.isPrivate,
      currentPlayers: 0,
      maxPlayers: room.maxPlayers,
      currentSpectators: 0,
      maxSpectators: room.maxSpectators,
      status: room.status as RoomStatus,
      hostUsername: room.hostUsername,
      createdAt: room.createdAt,
      canJoin: room.status === 'WAITING',
      isFull: false
    }));

    res.json({
      success: true,
      data: {
        rooms: roomsMetadata,
        total: roomsMetadata.length
      },
      message: 'Salas p√∫blicas listadas com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to list rooms', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const createRoom = async (req: Request, res: Response): Promise<void> => {
  try {
    const validation = validateCreateRoomRequest(req.body);
    if (!validation.success) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: validation.error,
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { name, isPrivate, maxPlayers, maxSpectators } = validation.data!;

    const existingRoomQuery = `
            SELECT id FROM rooms 
            WHERE "hostId" = $1 AND status IN ('WAITING', 'PLAYING')
        `;
    const existingRoomResult = await pool.query(existingRoomQuery, [req.userId]);

    if (existingRoomResult.rows.length > 0) {
      res.status(409).json({
        success: false,
        error: 'ROOM_ALREADY_EXISTS',
        message: 'Voc√™ j√° possui uma sala ativa',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    let roomCode: string | undefined;
    if (isPrivate) {
      let attempts = 0;
      do {
        roomCode = generateRoomCode();
        const existingCodeQuery = `SELECT id FROM rooms WHERE code = $1`;
        const existingCodeResult = await pool.query(existingCodeQuery, [roomCode]);
        if (existingCodeResult.rows.length === 0) break;
        attempts++;
      } while (attempts < 10);

      if (attempts >= 10) {
        res.status(500).json({
          success: false,
          error: ERROR_MESSAGES.SERVER_ERROR,
          message: 'N√£o foi poss√≠vel gerar c√≥digo √∫nico',
          timestamp: new Date().toISOString(),
        } as ApiResponse);
        return;
      }
    }

    const createRoomQuery = `
            INSERT INTO rooms (name, code, "isPrivate", "maxPlayers", "maxSpectators", "hostId", status, "serverId", "createdAt", "updatedAt")
            VALUES ($1, $2, $3, $4, $5, $6, 'WAITING', 'local-server', NOW(), NOW())
            RETURNING *
        `;
    const roomResult = await pool.query(createRoomQuery, [
      name,
      roomCode,
      isPrivate || false,
      maxPlayers || GAME_LIMITS.MAX_PLAYERS,
      maxSpectators || GAME_LIMITS.MAX_SPECTATORS,
      req.userId
    ]);
    const room = roomResult.rows[0];

    logger.info('Room created successfully', {
      roomId: room.id,
      hostId: req.userId,
      code: roomCode,
      isPrivate
    });

    const wsUrl = `ws://localhost:3001/ws/room/${room.id}`;

    res.status(201).json({
      success: true,
      data: {
        room: {
          id: room.id,
          name: room.name,
          code: room.code,
          isPrivate: room.isPrivate,
          maxPlayers: room.maxPlayers,
          maxSpectators: room.maxSpectators,
          status: room.status,
          hostId: room.hostId,
          hostUsername: req.username,
          currentPlayers: 0,
          currentSpectators: 0,
          serverId: room.serverId,
          createdAt: room.createdAt,
          updatedAt: room.updatedAt
        },
        wsUrl,
        joinUrl: wsUrl,
        code: room.code
      },
      message: 'Sala criada com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to create room', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      username: req.username,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const joinRoom = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id: roomId } = req.params;
    const { asSpectator = false } = req.body;

    const roomQuery = `
            SELECT r.*, u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r.id = $1
        `;
    const roomResult = await pool.query(roomQuery, [roomId]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    if (room.status !== 'WAITING') {
      res.status(409).json({
        success: false,
        error: 'ROOM_NOT_JOINABLE',
        message: 'A sala n√£o est√° aceitando novos jogadores',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, username, avatar FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [req.userId]);

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'USER_NOT_FOUND',
        message: 'Usu√°rio n√£o encontrado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];

    const player = {
      id: `${roomId}-${user.id}`,
      userId: user.id,
      username: user.username,
      avatar: user.avatar,
      isHost: room.hostId === user.id,
      isReady: false,
      isSpectator: asSpectator,
      isConnected: false,
      joinedAt: new Date(),
      lastSeen: new Date()
    };

    const wsUrl = `ws://localhost:3001/ws/room/${roomId}`;

    res.json({
      success: true,
      data: {
        room: {
          id: room.id,
          name: room.name,
          code: room.code,
          isPrivate: room.isPrivate,
          maxPlayers: room.maxPlayers,
          maxSpectators: room.maxSpectators,
          status: room.status,
          hostId: room.hostId,
          hostUsername: room.hostUsername,
          currentPlayers: 0,
          currentSpectators: 0,
          serverId: room.serverId,
          createdAt: room.createdAt,
          updatedAt: room.updatedAt
        },
        player,
        wsUrl,
        joinUrl: wsUrl,
        yourRole: player.isHost ? 'HOST' : (player.isSpectator ? 'SPECTATOR' : 'PLAYER')
      },
      message: 'Entrou na sala com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to join room', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      username: req.username,
      roomId: req.params.id,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const joinRoomByCode = async (req: Request, res: Response): Promise<void> => {
  try {
    const { code } = req.body;

    if (!code || !validateRoomCode(code)) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'C√≥digo inv√°lido - deve ter 6 d√≠gitos',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { asSpectator = false } = req.body;

    const roomQuery = `
            SELECT r.*, u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r.code = $1
        `;
    const roomResult = await pool.query(roomQuery, [code]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada com este c√≥digo',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    if (room.status !== 'WAITING') {
      res.status(409).json({
        success: false,
        error: 'ROOM_NOT_JOINABLE',
        message: 'A sala n√£o est√° aceitando novos jogadores',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, username, avatar FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [req.userId]);

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'USER_NOT_FOUND',
        message: 'Usu√°rio n√£o encontrado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];

    const player = {
      id: `${room.id}-${user.id}`,
      userId: user.id,
      username: user.username,
      avatar: user.avatar,
      isHost: room.hostId === user.id,
      isReady: false,
      isSpectator: asSpectator,
      isConnected: false,
      joinedAt: new Date(),
      lastSeen: new Date()
    };

    const wsUrl = `ws://localhost:3001/ws/room/${room.id}`;

    res.json({
      success: true,
      data: {
        room: {
          id: room.id,
          name: room.name,
          code: room.code,
          isPrivate: room.isPrivate,
          maxPlayers: room.maxPlayers,
          maxSpectators: room.maxSpectators,
          status: room.status,
          hostId: room.hostId,
          hostUsername: room.hostUsername,
          currentPlayers: 0,
          currentSpectators: 0,
          serverId: room.serverId,
          createdAt: room.createdAt,
          updatedAt: room.updatedAt
        },
        player,
        wsUrl,
        joinUrl: wsUrl,
        yourRole: player.isHost ? 'HOST' : (player.isSpectator ? 'SPECTATOR' : 'PLAYER')
      },
      message: 'Entrou na sala com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to join room by code', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      username: req.username,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const getRoomDetails = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id: roomId } = req.params;

    const roomQuery = `
            SELECT r.*, u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r.id = $1
        `;
    const roomResult = await pool.query(roomQuery, [roomId]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    res.json({
      success: true,
      data: {
        id: room.id,
        name: room.name,
        code: room.code,
        isPrivate: room.isPrivate,
        maxPlayers: room.maxPlayers,
        maxSpectators: room.maxSpectators,
        status: room.status,
        hostId: room.hostId,
        hostUsername: room.hostUsername,
        currentPlayers: 0,
        currentSpectators: 0,
        serverId: room.serverId,
        createdAt: room.createdAt,
        updatedAt: room.updatedAt
      },
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to get room details', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      roomId: req.params.id
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const deleteRoom = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id: roomId } = req.params;

    const roomQuery = `SELECT id, "hostId" FROM rooms WHERE id = $1`;
    const roomResult = await pool.query(roomQuery, [roomId]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    if (room.hostId !== req.userId) {
      res.status(403).json({
        success: false,
        error: ERROR_MESSAGES.FORBIDDEN,
        message: 'Apenas o host pode deletar a sala',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    await pool.query(`DELETE FROM rooms WHERE id = $1`, [roomId]);

    res.json({
      success: true,
      message: 'Sala deletada com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to delete room', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      roomId: req.params.id
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};
</file>

<file path="backend/src/server.ts">
// üê∫ LOBISOMEM ONLINE - Server Entry Point (CORRE√á√ÉO DEFINITIVA)
import http from 'http';
import app from './app';
import { config, validateConfig } from '@/config/environment';
import { connectDatabase, gracefulShutdown as shutdownDatabase } from '@/config/database';
import { connectRedis, gracefulShutdown as shutdownRedis } from '@/config/redis';
import { ServiceFactory } from './websocket/ServiceFactory';
import { WebSocketManager } from '@/websocket/WebSocketManager';
import { logger } from '@/utils/logger';

let server: http.Server;
let wsManager: WebSocketManager;

// Fun√ß√£o de retry para conex√£o com o banco
const connectWithRetry = async (connectFn: () => Promise<void>, retries = 5, delay = 5000) => {
  for (let i = 1; i <= retries; i++) {
    try {
      await connectFn();
      logger.info('Database connected successfully.');
      return;
    } catch (error) {
      logger.error(`Database connection attempt ${i} failed. Retrying in ${delay / 1000}s...`, { error });
      if (i === retries) {
        throw new Error(`Could not connect to the database after ${retries} attempts.`);
      }
      await new Promise(res => setTimeout(res, delay));
    }
  }
};

async function startServer(): Promise<void> {
  try {
    validateConfig();

    // Conectar banco (obrigat√≥rio) com retry
    await connectWithRetry(connectDatabase);

    // Conectar Redis (opcional - n√£o falha se der erro)
    if (config.SHOULD_USE_REDIS) {
      try {
        await connectRedis();
      } catch (error) {
        logger.warn('Redis connection failed, continuing without Redis', { error: error instanceof Error ? error.message : 'Unknown error' });
      }
    }

    const gameStateService = ServiceFactory.getGameStateService();
    const eventBus = ServiceFactory.getEventBus();

    server = http.createServer(app);

    if (config.IS_MONOLITH || config.IS_GAME_SERVICE) {
      wsManager = new WebSocketManager(gameStateService, eventBus, config);
      wsManager.setupWebSocketServer(server);
    }

    server.listen(config.PORT, () => {
      logger.info(`Server running at http://localhost:${config.PORT}`);
    });

    setupGracefulShutdown(server);

  } catch (error) {
    logger.error('Failed to start server', error instanceof Error ? error : new Error('Unknown server start error'));
    process.exit(1);
  }
}

function setupGracefulShutdown(server: http.Server): void {
  const shutdown = async (signal: string) => {
    logger.info(`Received ${signal}. Starting graceful shutdown...`);
    server.close(async () => {
      logger.info('HTTP server closed.');
      if (wsManager) await wsManager.shutdown();
      await shutdownDatabase();
      if (config.SHOULD_USE_REDIS) {
        try {
          await shutdownRedis();
        } catch (error) {
          logger.warn('Error shutting down Redis', { error: error instanceof Error ? error.message : 'Unknown error' });
        }
      }
      ServiceFactory.clearInstances();
      logger.info('Graceful shutdown completed.');
      process.exit(0);
    });
  };

  process.on('SIGTERM', () => shutdown('SIGTERM'));
  process.on('SIGINT', () => shutdown('SIGINT'));
}

if (require.main === module) {
  startServer();
}

export default app;
</file>

<file path="backend/src/utils/constants.ts">
// üê∫ LOBISOMEM ONLINE - Constants (REFATORADO)
// ‚úÖ APENAS defini√ß√µes b√°sicas - roles v√™m de RoleSystem.ts

//====================================================================
// ENUMS DEFINITIONS (√öNICOS AQUI)
//====================================================================
export enum Role {
  // Town roles
  VILLAGER = 'VILLAGER',
  SHERIFF = 'SHERIFF',
  DOCTOR = 'DOCTOR',
  VIGILANTE = 'VIGILANTE',
  // Werewolf roles
  WEREWOLF = 'WEREWOLF',
  WEREWOLF_KING = 'WEREWOLF_KING',
  // Neutral roles
  JESTER = 'JESTER',
  SERIAL_KILLER = 'SERIAL_KILLER',
}

export enum Faction {
  TOWN = 'TOWN',
  WEREWOLF = 'WEREWOLF',
  NEUTRAL = 'NEUTRAL',
}

export enum GamePhase {
  LOBBY = 'LOBBY',
  NIGHT = 'NIGHT',
  DAY = 'DAY',
  VOTING = 'VOTING',
  ENDED = 'ENDED',
}

//====================================================================
// GAME LIMITS
//====================================================================
export const GAME_LIMITS = {
  MIN_PLAYERS: 6,
  MAX_PLAYERS: 15,
  MAX_SPECTATORS: 5,

  // Room limits
  MAX_ROOM_NAME_LENGTH: 30,
  ROOM_CODE_LENGTH: 6,

  // Time limits (milliseconds)
  NIGHT_DURATION: 60000, // 60 seconds
  DAY_DURATION: 120000, // 2 minutes
  VOTING_DURATION: 30000, // 30 seconds

  // Chat limits
  MAX_MESSAGE_LENGTH: 500,
  CHAT_RATE_LIMIT: 5, // messages per 10 seconds

  // Reconnection
  RECONNECT_TIMEOUT: 120000, // 2 minutes
  MAX_RECONNECT_ATTEMPTS: 5,

  // Heartbeat
  HEARTBEAT_INTERVAL: 30000, // 30 seconds
  HEARTBEAT_TIMEOUT: 5000, // 5 seconds
} as const;

//====================================================================
// THEMED NICKNAMES (MEDIEVAL PORTUGUESE)
//====================================================================
export const THEMED_NICKNAMES = [
  // Profiss√µes
  'Jo√£o Ferreiro', 'Maria Padeira', 'Pedro Lenhador', 'Ana Tecel√£',
  'Carlos Moleiro', 'Isabel Costureira', 'Francisco Carpinteiro', 'Catarina Oleira',
  'Manuel Sapateiro', 'Teresa Lavadeira', 'Ant√≥nio Pedreiro', 'Beatriz Bordadeira',
  'Jos√© Curtidor', 'Lu√≠sa Fiandeira', 'Miguel Cordoeiro', 'Clara Rendilheira',

  // Nomes medievais
  'Afonso o Bravo', 'Constan√ßa a S√°bia', 'Nuno o Valente', 'Urraca a Bela',
  'Sancho o Forte', 'Mafalda a Justa', 'Garcia o Leal', 'Elvira a Piedosa',
  'Bermudo o Jovem', 'Teresa a Corajosa', 'Ramiro o Audaz', 'Sancha a Prudente',

  // Alcunhas regionais
  'Pedro do Norte', 'Maria da Ribeira', 'Jo√£o da Montanha', 'Ana do Vale',
  'Carlos da Floresta', 'Isabel da Ponte', 'Francisco da Torre', 'Catarina do Campo',
  'Manuel do Rio', 'Teresa da Vila', 'Ant√≥nio da Pra√ßa', 'Beatriz do Castelo',

  // Caracter√≠sticas
  'Rodrigo Barba-Ruiva', 'Leonor Olhos-Verdes', 'Vasco Perna-de-Pau', 'Marta Cabelo-Dourado',
  'Egas M√£o-de-Ferro', 'Violante Voz-Doce', '√Ålvaro P√©-Ligeiro', 'Branca Riso-F√°cil',
] as const;

//====================================================================
// CHAT CHANNELS
//====================================================================
export const CHAT_CHANNELS = {
  LOBBY: 'lobby',
  ROOM: 'room',
  PUBLIC: 'public',
  WEREWOLF: 'werewolf',
  SPECTATOR: 'spectator',
  SYSTEM: 'system',
} as const;

//====================================================================
// INVESTIGATION RESULTS
//====================================================================
export const INVESTIGATION_RESULTS = {
  SUSPICIOUS: 'SUSPICIOUS',
  NOT_SUSPICIOUS: 'NOT_SUSPICIOUS',
} as const;

//====================================================================
// WIN CONDITIONS
//====================================================================
export const WIN_CONDITIONS = {
  TOWN_WINS: 'All werewolves have been eliminated',
  WEREWOLF_WINS: 'Werewolves equal or outnumber the town',
  JESTER_WINS: 'Jester was executed by vote',
  SERIAL_KILLER_WINS: 'Serial Killer is the last survivor',
} as const;

//====================================================================
// ACHIEVEMENT CATEGORIES
//====================================================================
export const ACHIEVEMENT_CATEGORIES = {
  FIRST_TIME: 'first_time',
  SURVIVAL: 'survival',
  ROLE_MASTERY: 'role_mastery',
  SOCIAL: 'social',
  STRATEGIC: 'strategic',
  SPECIAL: 'special',
} as const;

//====================================================================
// SYSTEM MESSAGES
//====================================================================
export const SYSTEM_MESSAGES = {
  GAME_STARTED: 'üéÆ O jogo come√ßou! Boa sorte a todos!',
  NIGHT_PHASE: 'üåô A noite caiu sobre a vila...',
  DAY_PHASE: '‚òÄ O sol nasceu. √â hora de discutir!',
  VOTING_PHASE: 'üó≥ Hora da vota√ß√£o! Escolham com sabedoria.',
  PLAYER_ELIMINATED: (name: string, role: string) => `üíÄ ${name} foi eliminado! Era um(a) ${role}.`,
  GAME_ENDED: (faction: string) => `üèÜ Fim de jogo! ${faction} venceu!`,
  PLAYER_JOINED: (name: string) => `üëã ${name} entrou na sala.`,
  PLAYER_LEFT: (name: string) => `üëã ${name} saiu da sala.`,
  RECONNECTED: (name: string) => `üîÑ ${name} reconectou-se.`,
} as const;

//====================================================================
// ERROR MESSAGES
//====================================================================
export const ERROR_MESSAGES = {
  UNAUTHORIZED: 'Token de acesso inv√°lido ou expirado',
  FORBIDDEN: 'Voc√™ n√£o tem permiss√£o para esta a√ß√£o',
  NOT_FOUND: 'Recurso n√£o encontrado',
  ROOM_FULL: 'A sala est√° cheia',
  GAME_IN_PROGRESS: 'O jogo j√° est√° em andamento',
  INVALID_ACTION: 'A√ß√£o inv√°lida',
  RATE_LIMITED: 'Muitas tentativas. Tente novamente mais tarde',
  VALIDATION_FAILED: 'Dados inv√°lidos fornecidos',
  SERVER_ERROR: 'Erro interno do servidor',
} as const;
</file>

<file path="frontend/src/context/SocketContext.tsx">
'use client';

import { createContext, useContext, ReactNode, useCallback, useRef, useState } from 'react';

// Tipos simplificados
export interface WebSocketContextType {
  socket: WebSocket | null;
  isConnected: boolean;
  connect: (url: string) => void;
  disconnect: () => void;
  sendMessage: (type: string, data?: any) => boolean;
}

const SocketContext = createContext<WebSocketContextType | undefined>(undefined);

export function SocketProvider({ children }: { children: ReactNode }) {
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const socketRef = useRef<WebSocket | null>(null);

  const connect = useCallback((url: string) => {
    // Valida√ß√£o b√°sica
    if (!url || url.includes('undefined')) {
      console.error('‚ùå Invalid WebSocket URL:', url);
      return;
    }

    // Se j√° est√° conectado na mesma URL, n√£o faz nada
    if (socketRef.current?.url === url && socketRef.current.readyState === WebSocket.OPEN) {
      console.log('‚úÖ Already connected to', url);
      return;
    }

    // Desconecta conex√£o anterior se existir
    if (socketRef.current) {
      socketRef.current.close();
    }

    console.log('üîå Connecting to WebSocket:', url);

    try {
      const ws = new WebSocket(url);
      socketRef.current = ws;

      ws.onopen = () => {
        console.log('‚úÖ WebSocket connected');
        setSocket(ws);
        setIsConnected(true);
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          // Dispara evento customizado para componentes ouvirem
          window.dispatchEvent(new CustomEvent('websocket-message', { detail: message }));
        } catch (error) {
          console.error('‚ùå Error parsing message:', error);
        }
      };

      ws.onclose = () => {
        console.log('üîå WebSocket disconnected');
        setSocket(null);
        setIsConnected(false);
        socketRef.current = null;
      };

      ws.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
      };

    } catch (error) {
      console.error('‚ùå Failed to create WebSocket:', error);
    }
  }, []);

  const disconnect = useCallback(() => {
    if (socketRef.current) {
      console.log('üîå Disconnecting WebSocket');
      socketRef.current.close();
      socketRef.current = null;
      setSocket(null);
      setIsConnected(false);
    }
  }, []);

  const sendMessage = useCallback((type: string, data?: any): boolean => {
    if (socketRef.current?.readyState === WebSocket.OPEN) {
      try {
        socketRef.current.send(JSON.stringify({ type, data }));
        return true;
      } catch (error) {
        console.error('‚ùå Error sending message:', error);
        return false;
      }
    }
    console.warn('‚ö†Ô∏è WebSocket not connected');
    return false;
  }, []);

  const value: WebSocketContextType = {
    socket,
    isConnected,
    connect,
    disconnect,
    sendMessage,
  };

  return (
    <SocketContext.Provider value={value}>
      {children}
    </SocketContext.Provider>
  );
}

export function useSocket(): WebSocketContextType {
  const context = useContext(SocketContext);
  if (!context) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
}
</file>

<file path="frontend/src/types/index.ts">
// üê∫ LOBISOMEM ONLINE - Frontend Types
// Baseado no Town of Salem

// =============================================================================
// ‚úÖ USER & AUTHENTICATION - TIPOS COMPLETOS
// =============================================================================
export interface User {
  id: string;
  username: string;
  email: string;
  avatar?: string;
  level: number;
  totalGames: number;
  totalWins: number;
  totalLosses: number;
  winRate: number;
  createdAt: string;
  updatedAt?: string;
  lastLoginAt?: string;

  // ‚úÖ ADICIONADO: Campos extras para o perfil
  bio?: string;
  country?: string;
  preferredLanguage?: string;
  timezone?: string;
  isVerified?: boolean;
  isBanned?: boolean;
  banReason?: string;
  banExpiresAt?: string;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken?: string;
  expiresIn?: number;
  tokenType?: string;
}

export interface LoginRequest {
  email: string;
  password: string;
  rememberMe?: boolean;
}

export interface RegisterRequest {
  email: string;
  username: string;
  password: string;
  confirmPassword: string;
  acceptTerms?: boolean;
  newsletter?: boolean;
}

// ‚úÖ CORRIGIDO: AuthResponse com estrutura consistente
export interface AuthResponse {
  success: boolean;
  data?: {
    user: User;
    tokens: AuthTokens;
  };
  error?: string;
  message?: string;
  timestamp: string;
}

// ‚úÖ ADICIONADO: Tipos para verifica√ß√£o de disponibilidade
export interface AvailabilityCheckResponse {
  success: boolean;
  data?: {
    available: boolean;
    suggestions?: string[];
  };
  error?: string;
}

// ‚úÖ ADICIONADO: Tipos para reset de senha
export interface ForgotPasswordRequest {
  email: string;
}

export interface ResetPasswordRequest {
  token: string;
  password: string;
  confirmPassword: string;
}

// =============================================================================
// GAME TYPES
// =============================================================================
export enum GamePhase {
  LOBBY = 'LOBBY',
  NIGHT = 'NIGHT',
  DAY = 'DAY',
  VOTING = 'VOTING',
  ENDED = 'ENDED',
}

export enum Role {
  VILLAGER = 'VILLAGER',
  SHERIFF = 'SHERIFF',
  DOCTOR = 'DOCTOR',
  VIGILANTE = 'VIGILANTE',
  WEREWOLF = 'WEREWOLF',
  WEREWOLF_KING = 'WEREWOLF_KING',
  JESTER = 'JESTER',
  SERIAL_KILLER = 'SERIAL_KILLER',
}

export enum Faction {
  TOWN = 'TOWN',
  WEREWOLF = 'WEREWOLF',
  NEUTRAL = 'NEUTRAL',
}

export interface Player {
  id: string;
  userId: string;
  username: string;
  nickname?: string;
  avatar?: string;
  role?: Role;
  faction?: Faction;
  isAlive: boolean;
  isHost: boolean;
  isReady: boolean;
  isSpectator: boolean;
  isConnected: boolean;
  votedFor?: string;
  votesReceived: number;
  hasActed: boolean;
  houseNumber?: number; // Para Town of Salem visual

  // ‚úÖ ADICIONADO: Campos extras para gameplay
  isProtected?: boolean;
  isJailed?: boolean;
  lastWill?: string;
  deathNote?: string;
  killedBy?: string;
  diedAt?: string;
}

export interface GameState {
  gameId: string;
  roomId: string;
  phase: GamePhase;
  timeLeft: number;
  currentDay: number;
  players: Player[];
  spectators: Player[];
  events: GameEvent[];
  yourRole?: Role;
  yourFaction?: Faction;
  winners?: {
    faction: Faction;
    players: string[];
  };

  // ‚úÖ ADICIONADO: Estado adicional do jogo
  phaseHistory: GamePhase[];
  eliminatedPlayers: Player[];
  nightActions: NightAction[];
  votingResults: VotingResult[];
}

export interface GameEvent {
  id: string;
  type: string;
  message: string;
  timestamp: string;
  visible: boolean;
  phase: GamePhase;
  day: number;

  // ‚úÖ ADICIONADO: Contexto adicional
  playerId?: string;
  targetId?: string;
  metadata?: Record<string, any>;
}

// ‚úÖ ADICIONADO: Tipos para a√ß√µes noturnas
export interface NightAction {
  id: string;
  playerId: string;
  targetId?: string;
  action: string;
  timestamp: string;
  successful: boolean;
  blocked?: boolean;
  reason?: string;
}

// =============================================================================
// ROOM TYPES
// =============================================================================
export interface Room {
  id: string;
  name: string;
  code?: string;
  isPrivate: boolean;
  maxPlayers: number;
  maxSpectators: number;
  currentPlayers: number;
  currentSpectators: number;
  status: 'WAITING' | 'PLAYING' | 'FINISHED';
  hostId: string;
  hostUsername: string;
  canJoin: boolean;
  createdAt: string;
  updatedAt?: string;

  // ‚úÖ ADICIONADO: Configura√ß√µes da sala
  settings: RoomSettings;
}

// ‚úÖ ADICIONADO: Configura√ß√µes detalhadas da sala
export interface RoomSettings {
  gameMode: 'CLASSIC' | 'RANKED' | 'CUSTOM';
  timeDay: number; // segundos
  timeNight: number; // segundos
  timeVoting: number; // segundos
  allowSpectators: boolean;
  autoStart: boolean;
  customRoles?: Role[];
  bannedPlayers?: string[];
}

export interface CreateRoomRequest {
  name: string;
  isPrivate?: boolean;
  maxPlayers?: number;
  maxSpectators?: number;
  settings?: Partial<RoomSettings>;
}

// =============================================================================
// ‚úÖ WEBSOCKET TYPES - MELHORADOS
// =============================================================================
export interface WebSocketMessage {
  type: string;
  data?: any;
  timestamp?: string;
  messageId?: string;
  roomId?: string;
  userId?: string;
}

export interface ChatMessage {
  id: string;
  userId: string;
  username: string;
  message: string;
  channel: 'public' | 'werewolf' | 'spectator' | 'system' | 'dead';
  timestamp: string;
  filtered?: boolean;

  // ‚úÖ ADICIONADO: Metadata para chat
  isWhisper?: boolean;
  targetUserId?: string;
  edited?: boolean;
  editedAt?: string;
}

export enum SocketEvent {
  // Connection
  CONNECT = 'connect',
  DISCONNECT = 'disconnect',
  ERROR = 'error',
  AUTH = 'auth',

  // Room events
  JOIN_ROOM = 'join-room',
  LEAVE_ROOM = 'leave-room',
  PLAYER_READY = 'player-ready',
  START_GAME = 'start-game',
  ROOM_UPDATED = 'room-updated',

  // Game events
  GAME_STATE = 'game-state',
  PHASE_CHANGE = 'phase-change',
  GAME_ACTION = 'game-action',
  VOTE = 'vote',
  NIGHT_ACTION = 'night-action',

  // Chat events
  CHAT_MESSAGE = 'chat-message',
  WHISPER = 'whisper',

  // System events
  PLAYER_JOINED = 'player-joined',
  PLAYER_LEFT = 'player-left',
  PLAYER_DISCONNECTED = 'player-disconnected',
  PLAYER_RECONNECTED = 'player-reconnected',
  GAME_STARTED = 'game-started',
  GAME_ENDED = 'game-ended',
  PLAYER_ELIMINATED = 'player-eliminated',
  SYSTEM_MESSAGE = 'system-message',
}

// =============================================================================
// VOTING TYPES
// =============================================================================
export interface Vote {
  voterId: string;
  targetId: string;
  timestamp: string;
  weight?: number; // Para roles especiais
}

export interface VotingResult {
  eliminated?: {
    playerId: string;
    username: string;
    role: Role;
    voteCount: number;
  };
  votes: VoteCount[];
  isTie: boolean;
  abstentions: number;
  totalVoters: number;
}

export interface VoteCount {
  playerId: string;
  username: string;
  votes: number;
  voters: string[];
  percentage: number;
}

// =============================================================================
// ‚úÖ UI TYPES - EXPANDIDOS
// =============================================================================
export interface ThemeConfig {
  isDark: boolean;
  currentPhase: GamePhase;
  soundEnabled: boolean;
  musicVolume: number;
  sfxVolume: number;

  // ‚úÖ ADICIONADO: Configura√ß√µes visuais
  animationsEnabled: boolean;
  highContrast: boolean;
  fontSize: 'small' | 'medium' | 'large';
  colorBlindMode: boolean;
}

export interface NotificationConfig {
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
  duration?: number;
  persistent?: boolean;
  action?: {
    label: string;
    onClick: () => void;
  };

  // ‚úÖ ADICIONADO: Notifica√ß√£o avan√ßada
  sound?: boolean;
  icon?: string;
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
}

// =============================================================================
// ‚úÖ API RESPONSE TYPES - MELHORADOS
// =============================================================================
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
  timestamp: string;
  statusCode?: number;

  // ‚úÖ ADICIONADO: Metadata da resposta
  requestId?: string;
  version?: string;
  cached?: boolean;
}

export interface PaginatedResponse<T> {
  items: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // ‚úÖ ADICIONADO: Filtros aplicados
  filters?: Record<string, any>;
  sort?: {
    field: string;
    direction: 'asc' | 'desc';
  };
}

// =============================================================================
// LEADERBOARD TYPES
// =============================================================================
export interface LeaderboardEntry {
  rank: number;
  user: {
    id: string;
    username: string;
    avatar?: string;
    level: number;
    country?: string;
  };
  points: number;
  totalGames: number;
  winRate: number;
  favoriteRole?: Role;

  // ‚úÖ ADICIONADO: Estat√≠sticas extras
  currentStreak: number;
  longestStreak: number;
  lastGameAt?: string;
}

// =============================================================================
// ‚úÖ STATISTICS TYPES - EXPANDIDOS
// =============================================================================
export interface UserStatistics {
  totalGames: number;
  totalWins: number;
  totalLosses: number;
  winRate: number;
  level: number;
  favoriteRole?: Role;
  longestWinStreak: number;
  currentStreak: number;
  roleStats: RoleStatistics[];
  recentGames: GameSummary[];

  // ‚úÖ ADICIONADO: Estat√≠sticas avan√ßadas
  averageGameDuration: number;
  survivalRate: number;
  eliminationRate: number;
  mvpCount: number;
  perfectGames: number;
  comebackWins: number;
}

export interface RoleStatistics {
  role: Role;
  gamesPlayed: number;
  wins: number;
  winRate: number;

  // ‚úÖ ADICIONADO: Stats espec√≠ficos por role
  averageSurvivalTime: number;
  successfulActions: number;
  totalActions: number;
  mvpCount: number;
}

export interface GameSummary {
  gameId: string;
  role: Role;
  faction: Faction;
  won: boolean;
  survived: boolean;
  playedAt: string;
  duration: number;

  // ‚úÖ ADICIONADO: Detalhes do jogo
  totalPlayers: number;
  daysSurvived: number;
  actionsPerformed: number;
  mvp: boolean;
  eliminatedBy?: string;
  finalPosition: number;
}

// =============================================================================
// ‚úÖ COMPONENT PROP TYPES - MELHORADOS
// =============================================================================
export interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger' | 'medieval' | 'ghost' | 'outline';
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  disabled?: boolean;
  loading?: boolean;
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  className?: string;
  type?: 'button' | 'submit' | 'reset';

  // ‚úÖ ADICIONADO: Props extras
  fullWidth?: boolean;
  icon?: React.ReactNode;
  iconPosition?: 'left' | 'right';
  tooltip?: string;
  ariaLabel?: string;
}

export interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  className?: string;
  closeOnOverlayClick?: boolean;

  // ‚úÖ ADICIONADO: Props extras
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  variant?: 'default' | 'medieval' | 'dark';
  showCloseButton?: boolean;
  preventScroll?: boolean;
  zIndex?: number;
}

// =============================================================================
// ‚úÖ FORM TYPES - EXPANDIDOS
// =============================================================================
export interface FormError {
  field: string;
  message: string;
  code?: string;
}

export interface ValidationResult {
  isValid: boolean;
  errors: FormError[];
  warnings?: FormError[];
}

// ‚úÖ ADICIONADO: Tipos para formul√°rios complexos
export interface FormField<T = any> {
  name: string;
  label: string;
  type: 'text' | 'email' | 'password' | 'number' | 'select' | 'checkbox' | 'radio' | 'textarea';
  value: T;
  required?: boolean;
  disabled?: boolean;
  placeholder?: string;
  options?: Array<{ label: string; value: any }>;
  validation?: (value: T) => ValidationResult;
}

export interface FormState<T = Record<string, any>> {
  values: T;
  errors: Record<keyof T, string>;
  touched: Record<keyof T, boolean>;
  isSubmitting: boolean;
  isValid: boolean;
}

// =============================================================================
// ‚úÖ AUDIO TYPES - EXPANDIDOS
// =============================================================================
export interface AudioConfig {
  musicVolume: number;
  sfxVolume: number;
  enabled: boolean;

  // ‚úÖ ADICIONADO: Configura√ß√µes avan√ßadas
  muteOnBackground: boolean;
  spatialAudio: boolean;
  audioQuality: 'low' | 'medium' | 'high';
}

export interface SoundEffect {
  id: string;
  url: string;
  volume?: number;
  loop?: boolean;

  // ‚úÖ ADICIONADO: Propriedades extras
  preload?: boolean;
  category: 'ui' | 'game' | 'ambient' | 'voice';
  duration?: number;
  fadeIn?: number;
  fadeOut?: number;
}

export interface MusicTrack {
  id: string;
  name: string;
  url: string;
  loop: boolean;
  volume: number;

  // ‚úÖ ADICIONADO: Metadata da m√∫sica
  artist?: string;
  duration?: number;
  genre?: string;
  mood?: 'calm' | 'tense' | 'action' | 'victory' | 'defeat';
}

// =============================================================================
// ‚úÖ ACCESSIBILITY TYPES
// =============================================================================
export interface AccessibilityConfig {
  reduceMotion: boolean;
  highContrast: boolean;
  largeText: boolean;
  screenReader: boolean;
  keyboardNavigation: boolean;
  colorBlindFriendly: boolean;
}

// =============================================================================
// ‚úÖ PERFORMANCE TYPES
// =============================================================================
export interface PerformanceMetrics {
  fps: number;
  memoryUsage: number;
  networkLatency: number;
  renderTime: number;
  jsHeapSize: number;
}

// =============================================================================
// ‚úÖ ERROR HANDLING TYPES
// =============================================================================
export interface ErrorInfo {
  message: string;
  stack?: string;
  code?: string | number;
  timestamp: string;
  userId?: string;
  context?: Record<string, any>;
}

export interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
}

// =============================================================================
// ‚úÖ LOCALIZATION TYPES
// =============================================================================
export interface LocaleConfig {
  language: string;
  region: string;
  dateFormat: string;
  timeFormat: string;
  numberFormat: string;
  currency: string;
}

export interface TranslationKey {
  key: string;
  defaultValue: string;
  interpolation?: Record<string, any>;
}

// =============================================================================
// ‚úÖ ANALYTICS TYPES
// =============================================================================
export interface AnalyticsEvent {
  event: string;
  category: string;
  action: string;
  label?: string;
  value?: number;
  customData?: Record<string, any>;
  timestamp: string;
}

export interface UserSession {
  sessionId: string;
  userId?: string;
  startTime: string;
  endTime?: string;
  pageViews: number;
  events: AnalyticsEvent[];
  device: {
    type: 'desktop' | 'mobile' | 'tablet';
    os: string;
    browser: string;
  };
}

// =============================================================================
// ‚úÖ SECURITY TYPES
// =============================================================================
export interface SecurityConfig {
  rateLimit: {
    requests: number;
    window: number; // milliseconds
  };
  csrf: {
    enabled: boolean;
    tokenName: string;
  };
  encryption: {
    algorithm: string;
    keyLength: number;
  };
}

export interface Permission {
  id: string;
  name: string;
  description: string;
  category: string;
}

export interface Role {
  id: string;
  name: string;
  permissions: Permission[];
  isAdmin: boolean;
}

// =============================================================================
// ‚úÖ FILE HANDLING TYPES
// =============================================================================
export interface FileUpload {
  file: File;
  progress: number;
  status: 'pending' | 'uploading' | 'completed' | 'error';
  error?: string;
  url?: string;
}

export interface FileConfig {
  maxSize: number; // bytes
  allowedTypes: string[];
  allowedExtensions: string[];
  compressionEnabled: boolean;
  compressionQuality: number;
}

// =============================================================================
// ‚úÖ CACHE TYPES
// =============================================================================
export interface CacheConfig {
  ttl: number; // time to live in milliseconds
  maxSize: number; // maximum items in cache
  strategy: 'lru' | 'fifo' | 'lfu';
}

export interface CacheItem<T = any> {
  key: string;
  value: T;
  timestamp: number;
  ttl: number;
  hits: number;
}

// =============================================================================
// ‚úÖ WEBHOOK TYPES
// =============================================================================
export interface WebhookEvent {
  id: string;
  type: string;
  data: any;
  timestamp: string;
  signature?: string;
  retryCount: number;
}

export interface WebhookConfig {
  url: string;
  secret: string;
  events: string[];
  active: boolean;
  retryAttempts: number;
  retryDelay: number;
}

// =============================================================================
// ‚úÖ UTILITY TYPES
// =============================================================================
export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type RequiredKeys<T, K extends keyof T> = T & Required<Pick<T, K>>;
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};
export type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
};

// =============================================================================
// ‚úÖ BRAND TYPES FOR TYPE SAFETY
// =============================================================================
export type UserId = string & { readonly __brand: unique symbol };
export type RoomId = string & { readonly __brand: unique symbol };
export type GameId = string & { readonly __brand: unique symbol };
export type SessionId = string & { readonly __brand: unique symbol };
export type TokenId = string & { readonly __brand: unique symbol };

// =============================================================================
// ‚úÖ ENVIRONMENT TYPES
// =============================================================================
export interface EnvironmentConfig {
  NODE_ENV: 'development' | 'production' | 'test';
  API_URL: string;
  WS_URL: string;
  VERSION: string;
  BUILD_TIME: string;
  SENTRY_DSN?: string;
  ANALYTICS_ID?: string;
}

// =============================================================================
// ‚úÖ FEATURE FLAGS
// =============================================================================
export interface FeatureFlags {
  enableNewLobby: boolean;
  enableVoiceChat: boolean;
  enableRankedMode: boolean;
  enableCustomRoles: boolean;
  enableSpectatorMode: boolean;
  enableReplaySystem: boolean;
  enableAchievements: boolean;
  enableDarkMode: boolean;
  enableBetaFeatures: boolean;
}

// =============================================================================
// ‚úÖ EXPORT HELPERS
// =============================================================================

// Type guards
export function isUser(obj: any): obj is User {
  return obj && typeof obj.id === 'string' && typeof obj.username === 'string';
}

export function isApiResponse<T>(obj: any): obj is ApiResponse<T> {
  return obj && typeof obj.success === 'boolean' && typeof obj.timestamp === 'string';
}

export function isWebSocketMessage(obj: any): obj is WebSocketMessage {
  return obj && typeof obj.type === 'string';
}

// Utility functions for types
export function createUserId(id: string): UserId {
  return id as UserId;
}

export function createRoomId(id: string): RoomId {
  return id as RoomId;
}

export function createGameId(id: string): GameId {
  return id as GameId;
}

// Default values
export const DEFAULT_USER_STATS: UserStatistics = {
  totalGames: 0,
  totalWins: 0,
  totalLosses: 0,
  winRate: 0,
  level: 1,
  longestWinStreak: 0,
  currentStreak: 0,
  roleStats: [],
  recentGames: [],
  averageGameDuration: 0,
  survivalRate: 0,
  eliminationRate: 0,
  mvpCount: 0,
  perfectGames: 0,
  comebackWins: 0,
};

export const DEFAULT_THEME_CONFIG: ThemeConfig = {
  isDark: true,
  currentPhase: GamePhase.LOBBY,
  soundEnabled: true,
  musicVolume: 0.7,
  sfxVolume: 0.8,
  animationsEnabled: true,
  highContrast: false,
  fontSize: 'medium',
  colorBlindMode: false,
};

export const DEFAULT_AUDIO_CONFIG: AudioConfig = {
  musicVolume: 0.7,
  sfxVolume: 0.8,
  enabled: true,
  muteOnBackground: true,
  spatialAudio: false,
  audioQuality: 'medium',
};

export const DEFAULT_ACCESSIBILITY_CONFIG: AccessibilityConfig = {
  reduceMotion: false,
  highContrast: false,
  largeText: false,
  screenReader: false,
  keyboardNavigation: true,
  colorBlindFriendly: false,
};

export interface RoomSettings {
  gameMode: 'CLASSIC' | 'RANKED' | 'CUSTOM';
  timeDay: number; // segundos
  timeNight: number; // segundos
  timeVoting: number; // segundos
  allowSpectators: boolean;
  autoStart: boolean;
  customRoles?: Role[];
  bannedPlayers?: string[];
}

// Atualizar interface Room existente para incluir settings:
export interface Room {
  id: string;
  name: string;
  code?: string;
  isPrivate: boolean;
  maxPlayers: number;
  maxSpectators: number;
  currentPlayers: number;
  currentSpectators: number;
  status: 'WAITING' | 'PLAYING' | 'FINISHED';
  hostId: string;
  hostUsername: string;
  canJoin: boolean;
  createdAt: string;
  updatedAt?: string;
  settings: RoomSettings; // ‚úÖ NOVO CAMPO
}
</file>

<file path="frontend/src/pages/lobby.tsx">
// üê∫ LOBISOMEM ONLINE - Lobby Page (VERS√ÉO FINAL CORRITA)

import { useState, useEffect, useCallback } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/router';
import { motion } from 'framer-motion';

import { useAuth } from '@/context/AuthContext';
import { useSocket } from '@/context/SocketContext';
import { useTheme } from '@/context/ThemeContext';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// ‚úÖ IMPORTAR APENAS OS MODAIS REAIS
import CreateRoomModal from '@/components/lobby/CreateRoomModal';
import JoinRoomModal from '@/components/lobby/JoinRoomModal';

// =============================================================================
// ‚úÖ COMPONENTE SEGURO PARA N√öMEROS (RESOLVE HYDRATION ERROR)
// =============================================================================
interface SafeNumberDisplayProps {
  value: number;
  className?: string;
}

function SafeNumberDisplay({ value, className = "" }: SafeNumberDisplayProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <span className={className}>{value}</span>;
  }

  return (
    <span className={className}>
      {value.toLocaleString('pt-BR')}
    </span>
  );
}

// =============================================================================
// √çCONES INLINE
// =============================================================================
const PlusIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
  </svg>
);

const SearchIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
  </svg>
);

const RefreshIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
  </svg>
);

const UsersIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a4 4 0 11-8 0 4 4 0 018 0z" />
  </svg>
);

const EyeIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
  </svg>
);

const PlayIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.586a1 1 0 01.707.293l2.414 2.414a1 1 0 00.707.293H15M9 10v4a4 4 0 008 0v-4M9 10V9a4 4 0 118 0v1M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
  </svg>
);

const ClockIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const HashIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14" />
  </svg>
);

// =============================================================================
// TYPES
// =============================================================================
interface MockRoom {
  id: string;
  name: string;
  currentPlayers: number;
  maxPlayers: number;
  currentSpectators: number;
  maxSpectators: number;
  status: 'WAITING' | 'PLAYING' | 'FINISHED';
  isPrivate: boolean;
  hostUsername: string;
  createdAt: string;
}

// =============================================================================
// LOBBY PAGE COMPONENT
// =============================================================================
function LobbyPage() {
  const router = useRouter();
  const { user, isAuthenticated, isLoading: isAuthLoading } = useAuth();
  const { isConnected } = useSocket();
  const { playSound, playMusic, stopMusic } = useTheme();

  // State
  const [rooms, setRooms] = useState<MockRoom[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterStatus, setFilterStatus] = useState<'ALL' | 'WAITING' | 'PLAYING'>('ALL');
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showJoinCodeModal, setShowJoinCodeModal] = useState(false);

  // ‚úÖ CORRE√á√ÉO: Estado para evitar m√∫ltiplas chamadas de m√∫sica
  const [musicStarted, setMusicStarted] = useState(false);

  // ‚úÖ PROTE√á√ÉO DE ROTA
  useEffect(() => {
    if (!isAuthLoading && !isAuthenticated) {
      router.push('/auth/login');
      return;
    }
  }, [isAuthLoading, isAuthenticated, router]);

  // ‚úÖ CORRE√á√ÉO: Iniciar m√∫sica com preven√ß√£o de m√∫ltiplas execu√ß√µes
  useEffect(() => {
    if (!isAuthLoading && isAuthenticated && !musicStarted) {
      console.log('üéµ Iniciando m√∫sica do lobby...');
      const musicOptions = ['medieval_tavern01', 'medieval_tavern02', 'medieval_tavern03'];
      const randomMusic = musicOptions[Math.floor(Math.random() * musicOptions.length)];
      playMusic(randomMusic);
      setMusicStarted(true);
    }
  }, [isAuthLoading, isAuthenticated, musicStarted]); // ‚úÖ REMOVIDO: playMusic das depend√™ncias

  // ‚úÖ ADICIONADO: Cleanup quando sair da p√°gina
  useEffect(() => {
    return () => {
      if (musicStarted) {
        console.log('üéµ Parando m√∫sica do lobby...');
        stopMusic();
      }
    };
  }, [musicStarted]);

  // Gerar salas mock
  useEffect(() => {
    if (isAuthLoading || !isAuthenticated) return;

    const generateMockRooms = (): MockRoom[] => {
      const mockNames = [
        'Vila Misteriosa', 'Lobos da Madrugada', 'Cidade Sombria',
        'Noite Eterna', 'Ca√ßadores de Lobos', 'Vila Assombrada',
        'Lua Cheia', 'Territ√≥rio Selvagem', 'Ref√∫gio Seguro'
      ];

      return Array.from({ length: 12 }, (_, i) => ({
        id: `room-${i + 1}`,
        name: mockNames[i] || `Sala ${i + 1}`,
        currentPlayers: Math.floor(Math.random() * 12) + 3,
        maxPlayers: 15,
        currentSpectators: Math.floor(Math.random() * 3),
        maxSpectators: 5,
        status: (['WAITING', 'PLAYING', 'WAITING'] as const)[Math.floor(Math.random() * 3)],
        isPrivate: Math.random() > 0.7,
        hostUsername: `Player${Math.floor(Math.random() * 1000)}`,
        createdAt: new Date(Date.now() - Math.random() * 3600000).toISOString(),
      }));
    };

    setTimeout(() => {
      setRooms(generateMockRooms());
      setLoading(false);
    }, 1000);
  }, [isAuthLoading, isAuthenticated]);

  // Filter rooms
  const filteredRooms = rooms.filter(room => {
    const matchesSearch = room.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      room.hostUsername.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = filterStatus === 'ALL' || room.status === filterStatus;
    return matchesSearch && matchesFilter && !room.isPrivate;
  });

  // Handlers
  const handleJoinRoom = useCallback((roomId: string) => {
    console.log('üö™ Joining room:', roomId);
    playSound('button_click');
    router.push(`/room/${roomId}`);
  }, [router, playSound]);

  const handleSpectateRoom = useCallback((roomId: string) => {
    console.log('üëÅÔ∏è Spectating room:', roomId);
    playSound('button_click');
    router.push(`/room/${roomId}?spectate=true`);
  }, [router, playSound]);

  const handleCreateRoom = useCallback(() => {
    console.log('üèóÔ∏è Opening create room modal');
    playSound('button_click');
    setShowCreateModal(true);
  }, [playSound]);

  const handleJoinByCode = useCallback(() => {
    console.log('üîë Opening join by code modal');
    playSound('button_click');
    setShowJoinCodeModal(true);
  }, [playSound]);

  const handleRefresh = useCallback(() => {
    console.log('üîÑ Refreshing room list');
    playSound('button_click');
    setLoading(true);
    setTimeout(() => {
      window.location.reload();
    }, 500);
  }, [playSound]);

  // Loading state
  if (isAuthLoading) {
    return (
      <>
        <Head>
          <title>Lobby - Lobisomem Online</title>
        </Head>
        <Layout>
          <div className="flex justify-center items-center min-h-[50vh]">
            <LoadingSpinner
              variant="medieval"
              size="xl"
              text="Verificando autentica√ß√£o..."
            />
          </div>
        </Layout>
      </>
    );
  }

  if (!isAuthenticated) {
    return null;
  }

  return (
    <>
      <Head>
        <title>Lobby - Werewolf</title>
        <meta name="description" content="Encontre e participe de partidas de Werewolf" />
      </Head>

      <Layout>
        <div className="space-y-6">
          {/* Header */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="flex flex-col lg:flex-row justify-between items-start lg:items-center gap-4"
          >
            <div>
              <h1 className="text-3xl font-medieval text-glow">
                üèòÔ∏è Lobby Principal
              </h1>
              <p className="text-white/70 mt-2">
                Bem-vindo de volta, {user?.username || 'Jogador'}! Encontre uma partida ou crie sua pr√≥pria sala.
              </p>
            </div>

            {/* Connection Status */}
            <div className="flex items-center gap-3">
              <div className={`flex items-center gap-2 px-3 py-1 rounded-full text-sm ${isConnected
                ? 'bg-green-900/30 text-green-300 border border-green-500/30'
                : 'bg-red-900/30 text-red-300 border border-red-500/30'
                }`}>
                <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-400' : 'bg-red-400'}`} />
                {isConnected ? 'Online' : 'Desconectado'}
              </div>
            </div>
          </motion.div>

          {/* Action Buttons */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.1 }}
            className="flex flex-wrap gap-3"
          >
            <Button
              variant="medieval"
              size="lg"
              onClick={handleCreateRoom}
              className="flex-1 min-w-[200px]"
            >
              <PlusIcon />
              <span>Criar Sala</span>
            </Button>

            <Button
              variant="secondary"
              size="lg"
              onClick={handleJoinByCode}
              className="flex-1 min-w-[200px]"
            >
              <HashIcon />
              <span>Entrar por C√≥digo</span>
            </Button>

            <Button
              variant="ghost"
              size="lg"
              onClick={handleRefresh}
              disabled={loading}
            >
              <RefreshIcon />
            </Button>
          </motion.div>

          {/* Search and Filters */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
            className="flex flex-col sm:flex-row gap-4"
          >
            {/* Search */}
            <div className="flex-1 relative">
              <div className="absolute left-3 top-1/2 transform -translate-y-1/2">
                <SearchIcon />
              </div>
              <input
                type="text"
                placeholder="Buscar salas..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-4 py-3 bg-medieval-800/50 border border-medieval-600 rounded-lg text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent"
              />
            </div>

            {/* Filter */}
            <div className="flex gap-2">
              {(['ALL', 'WAITING', 'PLAYING'] as const).map((filter) => (
                <Button
                  key={filter}
                  variant={filterStatus === filter ? 'primary' : 'ghost'}
                  size="md"
                  onClick={() => setFilterStatus(filter)}
                >
                  {filter === 'ALL' ? 'Todas' : filter === 'WAITING' ? 'Aguardando' : 'Em Jogo'}
                </Button>
              ))}
            </div>
          </motion.div>

          {/* Rooms List */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3 }}
          >
            {loading ? (
              <div className="flex justify-center py-12">
                <LoadingSpinner variant="medieval" size="lg" text="Carregando salas..." />
              </div>
            ) : (
              <div className="grid gap-4">
                {filteredRooms.length > 0 ? (
                  filteredRooms.map((room, index) => (
                    <RoomCard
                      key={room.id}
                      room={room}
                      onJoin={() => handleJoinRoom(room.id)}
                      onSpectate={() => handleSpectateRoom(room.id)}
                      delay={index * 0.05}
                    />
                  ))
                ) : (
                  <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    className="text-center py-12 text-white/60"
                  >
                    <div className="text-6xl mb-4">üèöÔ∏è</div>
                    <h3 className="text-xl font-semibold mb-2">Nenhuma sala encontrada</h3>
                    <p>Tente ajustar os filtros ou criar uma nova sala.</p>
                  </motion.div>
                )}
              </div>
            )}
          </motion.div>
        </div>

        {/* ‚úÖ APENAS OS MODAIS REAIS - SEM Modal GEN√âRICO */}
        <CreateRoomModal
          isOpen={showCreateModal}
          onClose={() => setShowCreateModal(false)}
        />

        <JoinRoomModal
          isOpen={showJoinCodeModal}
          onClose={() => setShowJoinCodeModal(false)}
        />
      </Layout>
    </>
  );
}

// =============================================================================
// ROOM CARD COMPONENT
// =============================================================================
interface RoomCardProps {
  room: MockRoom;
  onJoin: () => void;
  onSpectate: () => void;
  delay?: number;
}

function RoomCard({ room, onJoin, onSpectate, delay = 0 }: RoomCardProps) {
  const canJoin = room.status === 'WAITING' && room.currentPlayers < room.maxPlayers;
  const canSpectate = room.currentSpectators < room.maxSpectators;

  const getStatusColor = () => {
    switch (room.status) {
      case 'WAITING': return 'text-green-400 bg-green-900/30 border-green-500/30';
      case 'PLAYING': return 'text-yellow-400 bg-yellow-900/30 border-yellow-500/30';
      case 'FINISHED': return 'text-gray-400 bg-gray-900/30 border-gray-500/30';
    }
  };

  const getStatusText = () => {
    switch (room.status) {
      case 'WAITING': return 'Aguardando';
      case 'PLAYING': return 'Em Jogo';
      case 'FINISHED': return 'Finalizada';
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay }}
      whileHover={{ scale: 1.02 }}
      className="bg-medieval-800/30 border border-medieval-600 rounded-lg p-4 hover:border-salem-500/50 transition-all"
    >
      <div className="flex items-center justify-between">
        <div className="flex-1 min-w-0">
          {/* Room Info */}
          <div className="flex items-center gap-3 mb-2">
            <h3 className="font-semibold text-white truncate">{room.name}</h3>

            {room.isPrivate && (
              <span className="text-yellow-400">üîí</span>
            )}

            <div className={`px-2 py-1 rounded text-xs border ${getStatusColor()}`}>
              {getStatusText()}
            </div>
          </div>

          {/* Room Details */}
          <div className="flex items-center flex-wrap gap-x-4 gap-y-1 text-sm text-white/70">
            <div className="flex items-center gap-1">
              <UsersIcon />
              <span>
                <SafeNumberDisplay value={room.currentPlayers} />
                /
                <SafeNumberDisplay value={room.maxPlayers} />
              </span>
            </div>

            <div className="flex items-center gap-1">
              <EyeIcon />
              <span>
                <SafeNumberDisplay value={room.currentSpectators} />
                /
                <SafeNumberDisplay value={room.maxSpectators} />
              </span>
            </div>

            <div className="flex items-center gap-1">
              <span>Host: {room.hostUsername}</span>
            </div>

            <div className="flex items-center gap-1">
              <ClockIcon />
              <span>{new Date(room.createdAt).toLocaleTimeString()}</span>
            </div>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex gap-2 ml-4">
          {canSpectate && (
            <Button
              variant="ghost"
              size="sm"
              onClick={onSpectate}
            >
              <EyeIcon />
            </Button>
          )}

          <Button
            variant={canJoin ? 'primary' : 'secondary'}
            size="sm"
            onClick={onJoin}
            disabled={!canJoin && !canSpectate}
          >
            <PlayIcon />
            <span>
              {canJoin ? 'Entrar' : room.status === 'PLAYING' ? 'Assistir' : 'Lotada'}
            </span>
          </Button>
        </div>
      </div>
    </motion.div>
  );
}

export default LobbyPage;
</file>

<file path="package.json">
{
  "name": "werewolf-online",
  "version": "1.0.0",
  "description": "üê∫ Lobisomem Online - Plataforma de Jogos Multiplayer em Tempo Real",
  "private": true,
  "workspaces": [
    "backend",
    "frontend"
  ],
  "scripts": {
    "//": "--- DOCKER COMMANDS (for complete environment) ---",
    "dev:docker": "docker-compose -f docker-compose.dev.yml up --build",
    "dev:down": "docker-compose -f docker-compose.dev.yml down",
    "dev:clean": "docker-compose -f docker-compose.dev.yml down --volumes --remove-orphans",
    "dev:logs": "docker-compose -f docker-compose.dev.yml logs -f",
    "dev:logs:backend": "docker-compose -f docker-compose.dev.yml logs -f backend",
    "// ": "--- LOCAL DEVELOPMENT (run services individually without Docker) ---",
    "dev:backend": "npm run dev --workspace=backend",
    "dev:frontend": "npm run dev --workspace=frontend",
    "// ": "--- MONOREPO UTILITIES ---",
    "install:all": "npm install",
    "build:all": "npm run build --workspaces",
    "lint:all": "npm run lint --workspaces --if-present",
    "test:all": "npm run test --workspaces --if-present"
  },
  "keywords": [
    "werewolf",
    "game",
    "multiplayer",
    "websocket",
    "realtime",
    "typescript",
    "monorepo"
  ],
  "author": "Werewolf Team",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.9.0"
  }
}
</file>

<file path="backend/src/app.ts">
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import morgan from 'morgan';
import { config } from '@/config/environment';
import { checkDatabaseHealth } from '@/config/database';
import { checkRedisHealth } from '@/config/redis';
import { ServiceFactory } from '@/websocket/ServiceFactory';
import authRoutes from '@/routes/auth';
import roomRoutes from '@/routes/rooms';

const app = express();

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "ws:", "wss:"],
    },
  },
  crossOriginEmbedderPolicy: false,
}));

app.use(cors({
  origin: function (origin, callback) {
    if (!origin) return callback(null, true);

    const allowedOrigins = [
      'http://localhost:3000',
      'http://localhost:3001',
      'https://localhost:3000',
      'https://localhost:3001',
    ];

    if (config.IS_PRODUCTION) {
      allowedOrigins.push('https://your-domain.com');
    }

    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'X-Request-Time',
    'X-Request-ID'
  ],
}));

app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

if (config.IS_DEVELOPMENT) {
  app.use(morgan('dev'));
} else {
  app.use(morgan('combined'));
}

app.get('/health', async (req, res) => {
  try {
    const dbHealth = await checkDatabaseHealth();
    const redisHealth = await checkRedisHealth();
    const servicesHealth = await ServiceFactory.getServicesHealth();
    const servicesStats = ServiceFactory.getServicesStats();

    const health = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      service: {
        id: config.SERVICE_ID,
        type: config.SERVICE_TYPE,
        mode: config.DISTRIBUTED_MODE ? 'distributed' : 'monolithic',
      },
      database: dbHealth,
      redis: redisHealth,
      services: servicesHealth,
      stats: servicesStats,
      uptime: process.uptime(),
      memory: process.memoryUsage(),
    };

    let hasUnhealthyService = false;

    if (config.DISTRIBUTED_MODE) {
      hasUnhealthyService = Object.values(servicesHealth).some(
        (service: any) => service.status === 'unhealthy'
      );
    } else {
      const criticalServices = ['gameState'];
      hasUnhealthyService = criticalServices.some(serviceName => {
        const service = servicesHealth[serviceName];
        return service && service.status === 'unhealthy';
      });
    }

    const isSystemHealthy =
      dbHealth.status === 'healthy' &&
      (!config.SHOULD_USE_REDIS || redisHealth.status === 'healthy') &&
      !hasUnhealthyService;

    if (!isSystemHealthy) {
      res.status(503).json(health);
      return;
    }

    res.json(health);
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

app.get('/health/ready', (req, res) => {
  res.json({
    status: 'ready',
    timestamp: new Date().toISOString(),
    service: config.SERVICE_ID,
  });
});

app.get('/health/live', (req, res) => {
  res.json({
    status: 'alive',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
  });
});

app.get('/health/websocket', async (req, res) => {
  try {
    const servicesHealth = await ServiceFactory.getServicesHealth();
    const servicesStats = ServiceFactory.getServicesStats();

    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: servicesHealth,
      stats: servicesStats,
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'WebSocket health check failed',
    });
  }
});

app.use('/api/auth', authRoutes);
app.use('/api/rooms', roomRoutes);

app.get('/', (req, res) => {
  res.json({
    message: 'üê∫ Werewolf Online API',
    version: '1.0.0',
    phase: config.DISTRIBUTED_MODE ? 'Phase 2 (Distributed)' : 'Phase 1 (Monolithic)',
    service: config.SERVICE_TYPE,
    timestamp: new Date().toISOString(),
    websocket: {
      enabled: config.IS_MONOLITH || config.IS_GAME_SERVICE,
      path: config.WS_BASE_PATH,
      url: `ws://localhost:${config.PORT}${config.WS_BASE_PATH}`,
    },
    endpoints: {
      health: '/health',
      websocketHealth: '/health/websocket',
      ready: '/health/ready',
      live: '/health/live',
      auth: {
        register: 'POST /api/auth/register',
        login: 'POST /api/auth/login',
        forgotPassword: 'POST /api/auth/forgot-password',
        resetPassword: 'POST /api/auth/reset-password',
        profile: 'GET /api/auth/profile',
        logout: 'POST /api/auth/logout',
      },
      rooms: {
        list: 'GET /api/rooms',
        create: 'POST /api/rooms',
        details: 'GET /api/rooms/:id',
        join: 'POST /api/rooms/:id/join',
        joinByCode: 'POST /api/rooms/join-by-code',
        delete: 'DELETE /api/rooms/:id',
      },
      websocket: {
        connect: `WS ${config.WS_BASE_PATH}`,
        events: [
          'join-room', 'leave-room', 'player-ready', 'start-game',
          'chat-message', 'game-action', 'vote', 'kick-player'
        ],
      },
    },
  });
});

app.use((req, res, next) => {
  res.status(404).json({
    error: 'Not Found',
    message: `Route ${req.method} ${req.path} not found`,
    timestamp: new Date().toISOString(),
  });
});

app.use((error: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('‚ùå Express Error:', error);

  const isDev = config.IS_DEVELOPMENT;
  res.status(500).json({
    error: 'Internal Server Error',
    message: isDev ? error.message : 'Something went wrong',
    timestamp: new Date().toISOString(),
    ...(isDev && { stack: error.stack }),
  });
});

export default app;
</file>

</files>
