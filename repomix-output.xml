This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.env.example
backend/src/app.ts
backend/src/config/database.ts
backend/src/config/environment.ts
backend/src/config/jwt.ts
backend/src/config/redis.ts
backend/src/config/websocket.ts
backend/src/controllers/authController.ts
backend/src/controllers/roomController.ts
backend/src/database/init.sql
backend/src/database/seeds/index.ts
backend/src/game/ActionManager.ts
backend/src/game/Game.ts
backend/src/game/GameEngine.ts
backend/src/game/PhaseManager.ts
backend/src/game/RoleSystem.ts
backend/src/game/TimerManager.ts
backend/src/middleware/auth.ts
backend/src/routes/auth.ts
backend/src/routes/rooms.ts
backend/src/server.ts
backend/src/types/index.ts
backend/src/utils/constants.ts
backend/src/utils/helper.ts
backend/src/utils/logger.ts
backend/src/utils/simpleValidators.ts
backend/src/utils/validators.ts
backend/src/websocket/ChannelManager.ts
backend/src/websocket/ConnectionManager.ts
backend/src/websocket/HeartbeatManager.ts
backend/src/websocket/index.ts
backend/src/websocket/MessageRouter.ts
backend/src/websocket/ServiceFactory.ts
backend/src/websocket/WebSocketManager.ts
database/init.sql
frontend/.env.example
frontend/src/components/common/Button.tsx
frontend/src/components/common/ErrorBoundary.tsx
frontend/src/components/common/Layout.tsx
frontend/src/components/common/LoadingSpinner.tsx
frontend/src/components/common/Modal.tsx
frontend/src/components/game/ActionPanel.tsx
frontend/src/components/game/ChatGigante.tsx
frontend/src/components/game/GameBoard.tsx
frontend/src/components/game/PhaseIndicator.tsx
frontend/src/components/game/PlayerCircle.tsx
frontend/src/components/game/PlayerList.tsx
frontend/src/components/game/RoleCard.tsx
frontend/src/components/game/TimerDisplay.tsx
frontend/src/components/game/WillNotes.tsx
frontend/src/components/lobby/CreateRoomModal.tsx
frontend/src/components/lobby/JoinRoomModal.tsx
frontend/src/components/room/ActionButtons.tsx
frontend/src/components/room/PlayerList.tsx
frontend/src/components/room/RoomChat.tsx
frontend/src/components/room/WaitingRoom.tsx
frontend/src/context/AuthContext.tsx
frontend/src/context/GameContext.tsx
frontend/src/context/SocketContext.tsx
frontend/src/context/ThemeContext.tsx
frontend/src/hooks/index.ts
frontend/src/pages/_app.tsx
frontend/src/pages/_document.tsx
frontend/src/pages/auth/forgot-password.tsx
frontend/src/pages/auth/login.tsx
frontend/src/pages/auth/register.tsx
frontend/src/pages/game/[gameId].tsx
frontend/src/pages/index.tsx
frontend/src/pages/lobby.tsx
frontend/src/pages/roles.tsx
frontend/src/pages/room/[id].tsx
frontend/src/types/index.ts
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# üê∫ LOBISOMEM ONLINE - Environment Variables

# =============================================================================
# CORE SETTINGS
# =============================================================================
NODE_ENV=development
PORT=3001

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
DATABASE_URL=postgresql://werewolf:werewolf123@localhost:5432/werewolf_dev
REDIS_URL=redis://localhost:6379

# =============================================================================
# AUTHENTICATION
# =============================================================================
JWT_SECRET=your-super-secret-jwt-key-change-in-production
JWT_EXPIRES_IN=7d

# =============================================================================
# ARCHITECTURE MODE (CR√çTICO PARA MIGRA√á√ÉO)
# =============================================================================
# Fase 1: false | Fase 2: true
DISTRIBUTED_MODE=false

# memory (Fase 1) | redis (Fase 2)
STORAGE_TYPE=memory

# =============================================================================
# SERVICE DISCOVERY (FASE 2)
# =============================================================================
SERVICE_ID=local-server
SERVICE_TYPE=monolith
# monolith | lobby | game

# =============================================================================
# WEBSOCKET CONFIGURATION
# =============================================================================
WS_BASE_PATH=/ws
WS_PORT=3001

# =============================================================================
# GAME SETTINGS
# =============================================================================
MIN_PLAYERS=6
MAX_PLAYERS=15
MAX_SPECTATORS=5
NIGHT_DURATION=60000
DAY_DURATION=120000
VOTING_DURATION=30000

# =============================================================================
# EMAIL (OPCIONAL)
# =============================================================================
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# =============================================================================
# FRONTEND CONFIGURATION
# =============================================================================
NEXT_PUBLIC_API_URL=http://localhost:3001
NEXT_PUBLIC_WS_URL=ws://localhost:3001
</file>

<file path="backend/src/database/init.sql">
-- Garante que a extens√£o para UUIDs seja criada
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tabela de usu√°rios com UUID como chave prim√°ria
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(50) UNIQUE NOT NULL,
    "passwordHash" TEXT NOT NULL, -- "passwordHash" entre aspas por causa do case
    avatar TEXT,
    level INTEGER DEFAULT 1 NOT NULL,
    "totalGames" INTEGER DEFAULT 0 NOT NULL,
    "totalWins" INTEGER DEFAULT 0 NOT NULL,
    "totalLosses" INTEGER DEFAULT 0 NOT NULL,
    "winRate" DECIMAL(5, 4) DEFAULT 0.0000 NOT NULL, -- Maior precis√£o
    "createdAt" TIMESTAMPTZ DEFAULT NOW(), -- TIMESTAMPTZ √© melhor para fusos hor√°rios
    "updatedAt" TIMESTAMPTZ DEFAULT NOW(),
    "lastLoginAt" TIMESTAMPTZ
);

-- Tabela de salas
CREATE TABLE IF NOT EXISTS rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    code VARCHAR(6) UNIQUE,
    "isPrivate" BOOLEAN DEFAULT false NOT NULL,
    "maxPlayers" INTEGER DEFAULT 15 NOT NULL,
    "maxSpectators" INTEGER DEFAULT 5 NOT NULL,
    status VARCHAR(20) DEFAULT 'WAITING' NOT NULL,
    "hostId" UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL, -- Evitar apagar salas se o host for deletado
    "serverId" VARCHAR(50) DEFAULT 'local-server',
    "createdAt" TIMESTAMPTZ DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ DEFAULT NOW()
);

-- √çndices para melhor performance
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_rooms_code ON rooms(code);
CREATE INDEX IF NOT EXISTS idx_rooms_status ON rooms(status);

-- Fun√ß√£o para atualizar o campo "updatedAt" automaticamente
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW."updatedAt" = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers para usar a fun√ß√£o acima
-- Dropa o trigger se ele j√° existir, para evitar erros ao rodar o script de novo
DROP TRIGGER IF EXISTS update_users_updated_at ON users;
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_rooms_updated_at ON rooms;
CREATE TRIGGER update_rooms_updated_at BEFORE UPDATE ON rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="backend/src/game/PhaseManager.ts">
// üê∫ LOBISOMEM ONLINE - Phase Manager (REFATORADO)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service

import { GameState } from './Game';
import { RoleDistributor, RoleRevealManager } from './RoleSystem';
import { GamePhase, Faction, Role } from '@/utils/constants';
import type { IGameEngine, NightAction, NightResults } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// PHASE MANAGER CLASS - REFATORADA
//====================================================================
export class PhaseManager {
    private gameState: GameState;
    private gameEngine: IGameEngine;
    private currentPhaseTimer?: NodeJS.Timeout;

    constructor(gameState: GameState, gameEngine: IGameEngine) {
        this.gameState = gameState;
        this.gameEngine = gameEngine;
    }

    //====================================================================
    // PHASE CONTROL
    //====================================================================
    async startFirstNight(): Promise<void> {
        logger.info('Starting first night phase', { gameId: this.gameState.gameId });

        // CORRE√á√ÉO 2: Usar o enum GamePhase
        await this.changePhase(GamePhase.NIGHT, this.gameState.config.nightDuration);

        this.gameState.addEvent('FIRST_NIGHT_STARTED', {
            message: 'A primeira noite chegou √† vila. Os poderes especiais acordam...',
            // CORRE√á√ÉO 2: Usar o enum GamePhase
            roles: this.getRolesForPhase(GamePhase.NIGHT),
        });
    }

    async nextPhase(): Promise<void> {
        const currentPhase = this.gameState.phase;

        try {
            switch (currentPhase) {
                case GamePhase.LOBBY:
                    // Should not happen during game
                    break;

                case GamePhase.NIGHT:
                    await this.processNightResults();
                    // CORRE√á√ÉO 2: Usar o enum GamePhase
                    await this.changePhase(GamePhase.DAY, this.gameState.config.dayDuration);
                    break;

                case GamePhase.DAY:
                    // CORRE√á√ÉO 2: Usar o enum GamePhase
                    await this.changePhase(GamePhase.VOTING, this.gameState.config.votingDuration);
                    break;

                case GamePhase.VOTING:
                    await this.processVotingResults();
                    // Check if game ended, otherwise go to next night
                    if (this.gameState.status === 'PLAYING') {
                        // CORRE√á√ÉO 2: Usar o enum GamePhase
                        await this.changePhase(GamePhase.NIGHT, this.gameState.config.nightDuration);
                    }
                    break;

                case GamePhase.ENDED:
                    // Game has ended, no more phases
                    break;
            }
        } catch (error) {
            logger.error('Error during phase transition', error instanceof Error ? error : new Error('Unknown phase error'), {
                gameId: this.gameState.gameId,
                currentPhase,
            });
        }
    }

    private async changePhase(newPhase: GamePhase, duration: number): Promise<void> {
        const oldPhase = this.gameState.phase;

        if (this.currentPhaseTimer) {
            clearTimeout(this.currentPhaseTimer);
        }

        this.gameState.changePhase(newPhase, duration);

        logger.info('Phase changed', {
            gameId: this.gameState.gameId,
            from: oldPhase,
            to: newPhase,
            duration,
            day: this.gameState.day,
        });

        this.currentPhaseTimer = setTimeout(() => {
            this.nextPhase();
        }, duration);

        await this.onPhaseStart(newPhase);
    }


    //====================================================================
    // PHASE-SPECIFIC LOGIC
    //====================================================================
    private async onPhaseStart(phase: GamePhase): Promise<void> {
        switch (phase) {
            case 'NIGHT':
                await this.onNightStart();
                break;

            case 'DAY':
                await this.onDayStart();
                break;

            case 'VOTING':
                await this.onVotingStart();
                break;
        }
    }

    private async onNightStart(): Promise<void> {
        this.gameState.addEvent('NIGHT_STARTED', {
            day: this.gameState.day,
            message: `Noite ${this.gameState.day} - A vila dorme, mas alguns acordam...`,
            activeRoles: this.getRolesForPhase('NIGHT'),
            duration: this.gameState.config.nightDuration,
        });

        // Clear previous night's actions
        this.gameState.nightActions = [];

        // Reset player states for night
        this.gameState.players.forEach(player => {
            if (player.isAlive) {
                player.hasActed = false;
                player.removeProtection(); // Remove previous protection
            }
        });
    }

    private async onDayStart(): Promise<void> {
        this.gameState.addEvent('DAY_STARTED', {
            day: this.gameState.day,
            message: `Dia ${this.gameState.day} - O sol nasce e a vila acorda...`,
            duration: this.gameState.config.dayDuration,
        });
    }

    private async onVotingStart(): Promise<void> {
        const alivePlayers = this.gameState.getAlivePlayers();

        this.gameState.addEvent('VOTING_STARTED', {
            day: this.gameState.day,
            message: 'Hora da vota√ß√£o! Escolham quem ser√° executado.',
            eligibleVoters: alivePlayers.map(p => ({ id: p.id, username: p.username })),
            duration: this.gameState.config.votingDuration,
        });

        this.gameState.players.forEach(player => {
            if (player.isAlive) {
                // CORRE√á√ÉO 3: Usar o m√©todo da classe Player que lida com 'undefined' corretamente
                player.unvote();
            }
        });
    }

    //====================================================================
    // NIGHT RESULTS PROCESSING
    //====================================================================
    private async processNightResults(): Promise<void> {
        logger.info('Processing night results', {
            gameId: this.gameState.gameId,
            day: this.gameState.day,
            actionsCount: this.gameState.nightActions.length,
        });

        // Get all night actions sorted by priority
        const actions = this.gameState.nightActions.sort((a, b) => a.priority - b.priority);

        // Track what happened during the night
        const nightResults = {
            protections: [] as string[],
            investigations: [] as { investigatorId: string; targetId: string; result: string }[],
            attacks: [] as { attackerId: string; targetId: string; successful: boolean }[],
            deaths: [] as { playerId: string; cause: string; killedBy?: string }[],
        };

        // Process actions by priority
        for (const action of actions) {
            await this.processNightAction(action, nightResults);
        }

        // Apply deaths
        nightResults.deaths.forEach(death => {
            const player = this.gameState.getPlayer(death.playerId);
            if (player && player.isAlive) {
                player.kill(death.cause as any, death.killedBy);
            }
        });

        // Generate night summary
        await this.generateNightSummary(nightResults);
    }

    private async processNightAction(action: any, results: any): Promise<void> {
        const actor = this.gameState.getPlayer(action.playerId);
        if (!actor || !actor.isAlive) return;

        switch (action.type) {
            case 'PROTECT':
                await this.processProtection(action, results);
                break;

            case 'INVESTIGATE':
                await this.processInvestigation(action, results);
                break;

            case 'WEREWOLF_KILL':
                await this.processWerewolfKill(action, results);
                break;

            case 'VIGILANTE_KILL':
                await this.processVigilanteKill(action, results);
                break;

            case 'SERIAL_KILL':
                await this.processSerialKill(action, results);
                break;
        }
    }

    private async processProtection(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target) return;

        // Check if doctor can protect this target
        if (!target.canBeProtectedByDoctor) {
            this.gameState.addEvent('PROTECTION_FAILED', {
                doctorId: action.playerId,
                targetId: action.targetId,
                reason: 'N√£o pode proteger a mesma pessoa duas noites seguidas',
            }, [action.playerId]);
            return;
        }

        target.protect();
        results.protections.push(action.targetId);

        this.gameState.addEvent('PROTECTION_APPLIED', {
            doctorId: action.playerId,
            targetId: action.targetId,
        }, [action.playerId]);
    }

    private async processInvestigation(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target || !target.role) return;

        // ‚úÖ USAR RoleRevealManager em vez de reimplementar
        const result = RoleRevealManager.getInvestigationResult(target.role);

        results.investigations.push({
            investigatorId: action.playerId,
            targetId: action.targetId,
            result,
        });

        this.gameState.addEvent('INVESTIGATION_RESULT', {
            investigatorId: action.playerId,
            targetId: action.targetId,
            targetName: target.username,
            result,
        }, [action.playerId]);
    }

    private async processWerewolfKill(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target || !target.isAlive) return;

        const successful = !target.isProtected;

        results.attacks.push({
            attackerId: action.playerId,
            targetId: action.targetId,
            successful,
        });

        if (successful) {
            results.deaths.push({
                playerId: action.targetId,
                cause: 'NIGHT_KILL',
                killedBy: 'werewolves',
            });
        }
    }

    private async processVigilanteKill(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        const vigilante = this.gameState.getPlayer(action.playerId);

        if (!target || !target.isAlive || !vigilante) return;

        const successful = !target.isProtected;

        results.attacks.push({
            attackerId: action.playerId,
            targetId: action.targetId,
            successful,
        });

        if (successful) {
            results.deaths.push({
                playerId: action.targetId,
                cause: 'VIGILANTE',
                killedBy: action.playerId,
            });

            // If vigilante killed a town member, they feel guilty and lose next action
            if (target.faction === 'TOWN') {
                // Mark vigilante as having guilt (would need to track this)
                this.gameState.addEvent('VIGILANTE_GUILT', {
                    vigilanteId: action.playerId,
                    killedTownMember: action.targetId,
                }, [action.playerId]);
            }
        }
    }

    private async processSerialKill(action: any, results: any): Promise<void> {
        const target = this.gameState.getPlayer(action.targetId);
        if (!target || !target.isAlive) return;

        // Serial Killer is immune to doctor protection on first night
        const isFirstNight = this.gameState.day === 1;
        const successful = !target.isProtected || isFirstNight;

        results.attacks.push({
            attackerId: action.playerId,
            targetId: action.targetId,
            successful,
        });

        if (successful) {
            results.deaths.push({
                playerId: action.targetId,
                cause: 'SERIAL_KILLER',
                killedBy: action.playerId,
            });
        }
    }

    //====================================================================
    // VOTING RESULTS PROCESSING
    //====================================================================
    private async processVotingResults(): Promise<void> {
        const result = this.gameState.getMostVotedPlayer();

        if (result) {
            const player = this.gameState.getPlayer(result.playerId);
            if (player && player.role) { // Garante que player e role existem
                if (player.role === Role.JESTER) {
                    // CORRE√á√ÉO 4: Usar o enum Faction
                    this.gameState.endGame(Faction.NEUTRAL, [player.id]);

                    this.gameState.addEvent('JESTER_WINS', {
                        playerId: player.id,
                        playerName: player.username,
                        message: 'O Bobo da Corte venceu ao ser executado!',
                    });

                    logger.info('Jester wins by execution', {
                        gameId: this.gameState.gameId,
                        playerId: player.id,
                        playerName: player.username,
                    });

                    return;
                }

                player.kill('EXECUTION');

                this.gameState.addEvent('PLAYER_EXECUTED', {
                    playerId: player.id,
                    playerName: player.username,
                    role: player.role,
                    faction: player.faction,
                    votes: result.votes,
                    totalVoters: this.gameState.getAlivePlayers().length,
                });

                logger.info('Player executed by vote', {
                    gameId: this.gameState.gameId,
                    playerId: player.id,
                    playerName: player.username,
                    role: player.role,
                    votes: result.votes,
                });
            }
        } else {
            this.gameState.addEvent('NO_EXECUTION', {
                reason: 'Empate na vota√ß√£o ou votos insuficientes',
                voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
            });

            logger.info('No execution - tie or insufficient votes', {
                gameId: this.gameState.gameId,
                voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
            });
        }

        const winCondition = this.gameState.checkWinCondition();
        if (winCondition.hasWinner && this.gameState.status === 'PLAYING') {
            this.gameState.endGame(winCondition.winningFaction!, winCondition.winningPlayers!);
        }
    }

    //====================================================================
    // UTILITY METHODS
    //====================================================================
    private getRolesForPhase(phase: string): string[] {
        return RoleDistributor.getRolesThatActDuring(phase);
    }

    private async generateNightSummary(results: any): Promise<void> {
        const messages = [];

        // Deaths
        if (results.deaths.length > 0) {
            results.deaths.forEach((death: any) => {
                const player = this.gameState.getPlayer(death.playerId);
                if (player) {
                    let causeMessage = '';
                    switch (death.cause) {
                        case 'NIGHT_KILL':
                            causeMessage = 'foi encontrado morto pela manh√£';
                            break;
                        case 'VIGILANTE':
                            causeMessage = 'foi executado pelo vigilante';
                            break;
                        case 'SERIAL_KILLER':
                            causeMessage = 'foi brutalmente assassinado';
                            break;
                    }
                    messages.push(`${player.username} ${causeMessage}.`);
                }
            });
        } else {
            messages.push('Ningu√©m morreu durante a noite.');
        }

        this.gameState.addEvent('NIGHT_SUMMARY', {
            day: this.gameState.day,
            deaths: results.deaths,
            messages,
            protections: results.protections.length,
            investigations: results.investigations.length,
            attacks: results.attacks.length,
        });
    }

    //====================================================================
    // TIMER MANAGEMENT
    //====================================================================
    getRemainingTime(): number {
        this.gameState.updateTimeLeft();
        return this.gameState.timeLeft;
    }

    isPhaseExpired(): boolean {
        return this.gameState.isPhaseExpired();
    }

    async forceNextPhase(): Promise<void> {
        if (this.currentPhaseTimer) {
            clearTimeout(this.currentPhaseTimer);
        }
        await this.nextPhase();
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    cleanup(): void {
        if (this.currentPhaseTimer) {
            clearTimeout(this.currentPhaseTimer);
            // CORRE√á√ÉO 5: Usar delete em vez de atribuir undefined
            delete this.currentPhaseTimer;
        }
    }
}
</file>

<file path="backend/src/game/TimerManager.ts">
// üê∫ LOBISOMEM ONLINE - Timer Manager (CORRIGIDO PARA exactOptionalPropertyTypes)
import type { GameConfig } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// TIMER INTERFACE - CORRIGIDA PARA exactOptionalPropertyTypes
//====================================================================
export interface GameTimer {
    id: string;
    type: 'PHASE' | 'WARNING' | 'CUSTOM';
    startTime: number;
    duration: number;
    remaining: number;
    isActive: boolean;
    callback?: () => void;
    timeout?: NodeJS.Timeout; // CORRE√á√ÉO: Opcional, pode n√£o existir
}

//====================================================================
// TIMER MANAGER CLASS - CORRIGIDO PARA exactOptionalPropertyTypes
//====================================================================
export class TimerManager {
    private timers = new Map<string, GameTimer>();
    private config: GameConfig;
    private updateInterval?: NodeJS.Timeout; // CORRE√á√ÉO: Opcional, pode n√£o existir

    constructor(config: GameConfig) {
        this.config = config;
        this.startUpdateLoop();

        logger.info('TimerManager initialized', {
            nightDuration: config.nightDuration,
            dayDuration: config.dayDuration,
            votingDuration: config.votingDuration,
        });
    }

    //====================================================================
    // TIMER CREATION
    //====================================================================
    createPhaseTimer(
        phase: 'NIGHT' | 'DAY' | 'VOTING',
        gameId: string,
        onComplete: () => void,
        onWarning?: (timeLeft: number) => void
    ): string {
        const duration = this.getPhaseDuration(phase);
        const timerId = `${gameId}-${phase}-${Date.now()}`;

        const timer: GameTimer = {
            id: timerId,
            type: 'PHASE',
            startTime: Date.now(),
            duration,
            remaining: duration,
            isActive: true,
            callback: onComplete,
        };

        // Set timeout for completion
        timer.timeout = setTimeout(() => {
            this.handleTimerExpired(timerId);
        }, duration);

        this.timers.set(timerId, timer);

        // Create warning timers if provided
        if (onWarning) {
            this.createWarningTimers(gameId, phase, duration, onWarning);
        }

        logger.info('Phase timer created', {
            timerId,
            phase,
            duration: this.formatTime(duration),
            gameId,
        });

        return timerId;
    }

    createCustomTimer(
        id: string,
        duration: number,
        callback: () => void,
        type: 'WARNING' | 'CUSTOM' = 'CUSTOM'
    ): string {
        const timer: GameTimer = {
            id,
            type,
            startTime: Date.now(),
            duration,
            remaining: duration,
            isActive: true,
            callback,
        };

        timer.timeout = setTimeout(() => {
            this.handleTimerExpired(id);
        }, duration);

        this.timers.set(id, timer);

        logger.debug('Custom timer created', {
            id,
            duration: this.formatTime(duration),
            type
        });

        return id;
    }

    private createWarningTimers(
        gameId: string,
        phase: string,
        duration: number,
        onWarning: (timeLeft: number) => void
    ): void {
        // 30 second warning
        if (duration > 30000) {
            const warning30Id = `${gameId}-${phase}-warning-30`;
            setTimeout(() => onWarning(30000), duration - 30000);
        }

        // 10 second warning
        if (duration > 10000) {
            const warning10Id = `${gameId}-${phase}-warning-10`;
            setTimeout(() => onWarning(10000), duration - 10000);
        }
    }

    //====================================================================
    // TIMER MANAGEMENT
    //====================================================================
    getTimer(timerId: string): GameTimer | undefined {
        return this.timers.get(timerId);
    }

    pauseTimer(timerId: string): boolean {
        const timer = this.timers.get(timerId);
        if (!timer || !timer.isActive) return false;

        timer.isActive = false;
        timer.remaining = timer.duration - (Date.now() - timer.startTime);

        // CORRE√á√ÉO: Clear timeout se existir
        if (timer.timeout) {
            clearTimeout(timer.timeout);
            // CORRE√á√ÉO: Remover propriedade ao inv√©s de atribuir undefined
            delete timer.timeout;
        }

        logger.debug('Timer paused', { timerId, remaining: this.formatTime(timer.remaining) });
        return true;
    }

    resumeTimer(timerId: string): boolean {
        const timer = this.timers.get(timerId);
        if (!timer || timer.isActive) return false;

        timer.isActive = true;
        timer.startTime = Date.now();
        timer.duration = timer.remaining;

        // Set new timeout for remaining time
        timer.timeout = setTimeout(() => {
            this.handleTimerExpired(timerId);
        }, timer.remaining);

        logger.debug('Timer resumed', { timerId, remaining: this.formatTime(timer.remaining) });
        return true;
    }

    extendTimer(timerId: string, additionalTime: number): boolean {
        const timer = this.timers.get(timerId);
        if (!timer) return false;

        timer.duration += additionalTime;

        if (timer.isActive) {
            timer.remaining = timer.duration - (Date.now() - timer.startTime);

            // Reset timeout with new duration
            if (timer.timeout) {
                clearTimeout(timer.timeout);
            }
            timer.timeout = setTimeout(() => {
                this.handleTimerExpired(timerId);
            }, timer.remaining);
        } else {
            timer.remaining += additionalTime;
        }

        logger.info('Timer extended', {
            timerId,
            additionalTime: this.formatTime(additionalTime),
            newDuration: this.formatTime(timer.duration),
            remaining: this.formatTime(timer.remaining),
        });

        return true;
    }

    stopTimer(timerId: string): boolean {
        const timer = this.timers.get(timerId);
        if (!timer) return false;

        timer.isActive = false;

        if (timer.timeout) {
            clearTimeout(timer.timeout);
            // CORRE√á√ÉO: Remover propriedade ao inv√©s de atribuir undefined
            delete timer.timeout;
        }

        this.timers.delete(timerId);

        logger.debug('Timer stopped', { timerId });
        return true;
    }

    stopAllTimers(): void {
        this.timers.forEach((timer, timerId) => {
            if (timer.timeout) {
                clearTimeout(timer.timeout);
            }
        });

        this.timers.clear();

        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            // CORRE√á√ÉO: Remover propriedade ao inv√©s de atribuir undefined
            delete this.updateInterval;
        }

        logger.info('All timers stopped');
    }

    //====================================================================
    // TIMER UPDATES
    //====================================================================
    private startUpdateLoop(): void {
        this.updateInterval = setInterval(() => {
            this.updateAllTimers();
        }, 1000); // Update every second
    }

    private updateAllTimers(): void {
        const now = Date.now();

        this.timers.forEach((timer) => {
            if (!timer.isActive) return;

            // Calculate remaining time
            timer.remaining = Math.max(0, timer.duration - (now - timer.startTime));
        });
    }

    private handleTimerExpired(timerId: string): void {
        const timer = this.timers.get(timerId);
        if (!timer) return;

        logger.debug('Timer expired', {
            timerId,
            type: timer.type,
            duration: this.formatTime(timer.duration),
        });

        // Execute callback
        if (timer.callback) {
            try {
                timer.callback();
            } catch (error) {
                logger.error('Error executing timer callback', error instanceof Error ? error : new Error('Unknown timer error'), {
                    timerId,
                    type: timer.type,
                });
            }
        }

        // Remove timer
        this.stopTimer(timerId);
    }

    //====================================================================
    // PHASE DURATION HELPERS
    //====================================================================
    private getPhaseDuration(phase: 'NIGHT' | 'DAY' | 'VOTING'): number {
        switch (phase) {
            case 'NIGHT':
                return this.config.nightDuration;
            case 'DAY':
                return this.config.dayDuration;
            case 'VOTING':
                return this.config.votingDuration;
            default:
                return 60000; // 1 minute default
        }
    }

    //====================================================================
    // TIMER INFORMATION
    //====================================================================
    getAllActiveTimers(): GameTimer[] {
        return Array.from(this.timers.values()).filter(timer => timer.isActive);
    }

    getTimersByType(type: 'PHASE' | 'WARNING' | 'CUSTOM'): GameTimer[] {
        return Array.from(this.timers.values()).filter(timer => timer.type === type);
    }

    getRemainingTime(timerId: string): number {
        const timer = this.timers.get(timerId);
        if (!timer) return 0;

        if (!timer.isActive) return timer.remaining;

        const elapsed = Date.now() - timer.startTime;
        return Math.max(0, timer.duration - elapsed);
    }

    getTimeElapsed(timerId: string): number {
        const timer = this.timers.get(timerId);
        if (!timer) return 0;

        if (!timer.isActive) return timer.duration - timer.remaining;

        return Math.min(timer.duration, Date.now() - timer.startTime);
    }

    getTimerProgress(timerId: string): number {
        const timer = this.timers.get(timerId);
        if (!timer || timer.duration === 0) return 0;

        const elapsed = this.getTimeElapsed(timerId);
        return Math.min(100, (elapsed / timer.duration) * 100);
    }

    //====================================================================
    // UTILITY METHODS
    //====================================================================
    formatTime(milliseconds: number): string {
        const totalSeconds = Math.ceil(milliseconds / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;

        if (minutes > 0) {
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        } else {
            return `${seconds}s`;
        }
    }

    //====================================================================
    // STATISTICS
    //====================================================================
    getTimerStats(): {
        total: number;
        active: number;
        paused: number;
        byType: Record<string, number>;
    } {
        const allTimers = Array.from(this.timers.values());

        const stats = {
            total: allTimers.length,
            active: allTimers.filter(t => t.isActive).length,
            paused: allTimers.filter(t => !t.isActive).length,
            byType: {
                PHASE: 0,
                WARNING: 0,
                CUSTOM: 0,
            },
        };

        allTimers.forEach(timer => {
            stats.byType[timer.type]++;
        });

        return stats;
    }

    //====================================================================
    // PHASE-SPECIFIC TIMERS
    //====================================================================
    createNightTimer(gameId: string, onComplete: () => void, onWarning?: (timeLeft: number) => void): string {
        return this.createPhaseTimer('NIGHT', gameId, onComplete, onWarning);
    }

    createDayTimer(gameId: string, onComplete: () => void, onWarning?: (timeLeft: number) => void): string {
        return this.createPhaseTimer('DAY', gameId, onComplete, onWarning);
    }

    createVotingTimer(gameId: string, onComplete: () => void, onWarning?: (timeLeft: number) => void): string {
        return this.createPhaseTimer('VOTING', gameId, onComplete, onWarning);
    }

    //====================================================================
    // CLEANUP
    //====================================================================
    cleanup(): void {
        this.stopAllTimers();
        logger.info('TimerManager cleanup completed');
    }

    //====================================================================
    // HEALTH CHECK
    //====================================================================
    healthCheck(): {
        status: 'healthy' | 'unhealthy';
        isRunning: boolean;
        stats: any;
        issues: string[];
    } {
        const issues: string[] = [];
        const stats = this.getTimerStats();

        if (!this.updateInterval) {
            issues.push('Timer update loop is not running');
        }

        // Check for stuck timers
        const now = Date.now();
        this.timers.forEach((timer, timerId) => {
            if (timer.isActive) {
                const elapsed = now - timer.startTime;
                if (elapsed > timer.duration * 1.5) { // 50% overtime tolerance
                    issues.push(`Timer ${timerId} appears to be stuck`);
                }
            }
        });

        return {
            status: issues.length === 0 ? 'healthy' : 'unhealthy',
            isRunning: !!this.updateInterval,
            stats,
            issues,
        };
    }
}
</file>

<file path="backend/src/routes/rooms.ts">
// üê∫ LOBISOMEM ONLINE - Room Routes
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí lobby-service

import { Router } from 'express';
import {
  listRooms,
  createRoom,
  joinRoom,
  joinRoomByCode,
  getRoomDetails,
  deleteRoom
} from '@/controllers/roomController';
import { requireAuth } from '@/middleware/auth';

const router = Router();

//====================================================================
// ROOM ROUTES - ALL REQUIRE AUTHENTICATION
//====================================================================

/**
 * @route GET /api/rooms
 * @desc List public rooms
 * @access Private
 */
router.get('/', requireAuth, listRooms);

/**
 * @route POST /api/rooms
 * @desc Create new room
 * @access Private
 * @body { name, isPrivate?, maxPlayers?, maxSpectators? }
 */
router.post('/', requireAuth, createRoom);

/**
 * @route GET /api/rooms/:id
 * @desc Get room details by ID
 * @access Private
 */
router.get('/:id', requireAuth, getRoomDetails);

/**
 * @route POST /api/rooms/:id/join
 * @desc Join room by ID
 * @access Private
 * @body { asSpectator? }
 */
router.post('/:id/join', requireAuth, joinRoom);

/**
 * @route POST /api/rooms/join-by-code
 * @desc Join room by 6-digit code
 * @access Private
 * @body { code, asSpectator? }
 */
router.post('/join-by-code', requireAuth, joinRoomByCode);

/**
 * @route DELETE /api/rooms/:id
 * @desc Delete room (host only)
 * @access Private
 */
router.delete('/:id', requireAuth, deleteRoom);

export default router;
</file>

<file path="backend/src/utils/helper.ts">
// üê∫ LOBISOMEM ONLINE - Helper Utilities
// Common utility functions used throughout the application

import crypto from 'crypto';
import { THEMED_NICKNAMES, ROLE_DISTRIBUTIONS, GAME_LIMITS } from './constants';
import type { Role, RoleDistribution } from '@/types/game';

// =============================================================================
// STRING UTILITIES
// =============================================================================

/**
 * Generate a random room code
 */
export function generateRoomCode(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

/**
 * Generate a cryptographically secure random string
 */
export function generateSecureToken(length: number = 32): string {
  return crypto.randomBytes(length).toString('hex');
}

/**
 * Generate a random nickname from themed list
 */
export function generateRandomNickname(usedNicknames: Set<string> = new Set()): string {
  const availableNicknames = THEMED_NICKNAMES.filter(nickname => !usedNicknames.has(nickname));

  if (availableNicknames.length === 0) {
    // Fallback to numbered nicknames if all are used
    let counter = 1;
    let nickname = '';
    do {
      nickname = `Cidad√£o ${counter}`;
      counter++;
    } while (usedNicknames.has(nickname));

    return nickname;
  }

  return availableNicknames[Math.floor(Math.random() * availableNicknames.length)];
}

/**
 * Slugify a string for URLs
 */
export function slugify(text: string): string {
  return text
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9 -]/g, '') // Remove special characters
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-'); // Replace multiple hyphens with single
}

/**
 * Capitalize first letter of each word
 */
export function titleCase(text: string): string {
  return text.replace(/\w\S*/g, (txt) =>
    txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
  );
}

/**
 * Truncate text to specified length
 */
export function truncate(text: string, length: number, suffix: string = '...'): string {
  if (text.length <= length) return text;
  return text.substring(0, length - suffix.length) + suffix;
}

// =============================================================================
// ARRAY UTILITIES
// =============================================================================

/**
 * Shuffle an array using Fisher-Yates algorithm
 */
export function shuffleArray<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * Get random element from array
 */
export function randomElement<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)];
}

/**
 * Get multiple random elements from array
 */
export function randomElements<T>(array: T[], count: number): T[] {
  const shuffled = shuffleArray(array);
  return shuffled.slice(0, Math.min(count, array.length));
}

/**
 * Chunk array into smaller arrays
 */
export function chunkArray<T>(array: T[], chunkSize: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    chunks.push(array.slice(i, i + chunkSize));
  }
  return chunks;
}

// =============================================================================
// TIME UTILITIES
// =============================================================================

/**
 * Add milliseconds to a date
 */
export function addMilliseconds(date: Date, ms: number): Date {
  return new Date(date.getTime() + ms);
}

/**
 * Check if a date is expired
 */
export function isExpired(date: Date): boolean {
  return date.getTime() < Date.now();
}

/**
 * Format duration in milliseconds to human readable string
 */
export function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }

  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }

  return `${seconds}s`;
}

/**
 * Get time remaining until target date
 */
export function getTimeRemaining(targetDate: Date): number {
  return Math.max(0, targetDate.getTime() - Date.now());
}

// =============================================================================
// GAME UTILITIES
// =============================================================================

/**
 * Get role distribution based on player count
 */
export function getRoleDistribution(playerCount: number): RoleDistribution {
  // Find the closest predefined distribution
  const availableCounts = Object.keys(ROLE_DISTRIBUTIONS).map(Number).sort((a, b) => a - b);

  let targetCount = availableCounts.find(count => count >= playerCount);
  if (!targetCount) {
    targetCount = availableCounts[availableCounts.length - 1]; // Use largest if exceeds max
  }

  const distribution = ROLE_DISTRIBUTIONS[targetCount as keyof typeof ROLE_DISTRIBUTIONS];

  // Adjust distribution if needed to match exact player count
  if (targetCount > playerCount) {
    return adjustRoleDistribution(distribution, playerCount);
  }

  return distribution;
}

/**
 * Adjust role distribution to match exact player count
 */
function adjustRoleDistribution(distribution: RoleDistribution, targetCount: number): RoleDistribution {
  const newDistribution = { ...distribution };
  const currentTotal = Object.values(newDistribution).reduce((sum, count) => sum + count, 0);
  const difference = currentTotal - targetCount;

  if (difference > 0) {
    // Remove roles starting with villagers
    let toRemove = difference;
    const removeOrder: Role[] = ['VILLAGER', 'WEREWOLF', 'JESTER', 'SERIAL_KILLER'];

    for (const role of removeOrder) {
      if (toRemove <= 0) break;
      const canRemove = Math.min(newDistribution[role], toRemove);
      newDistribution[role] -= canRemove;
      toRemove -= canRemove;
    }
  }

  return newDistribution;
}

/**
 * Distribute roles to players randomly
 */
export function distributeRoles(playerIds: string[], distribution: RoleDistribution): Map<string, Role> {
  const roles: Role[] = [];

  // Create array of roles based on distribution
  for (const [role, count] of Object.entries(distribution)) {
    for (let i = 0; i < count; i++) {
      roles.push(role as Role);
    }
  }

  // Shuffle players and roles
  const shuffledPlayers = shuffleArray(playerIds);
  const shuffledRoles = shuffleArray(roles);

  // Create map of player to role
  const roleAssignment = new Map<string, Role>();
  shuffledPlayers.forEach((playerId, index) => {
    if (index < shuffledRoles.length) {
      roleAssignment.set(playerId, shuffledRoles[index]);
    }
  });

  return roleAssignment;
}

/**
 * Check if game can start with current player count
 */
export function canStartGame(playerCount: number): boolean {
  return playerCount >= GAME_LIMITS.MIN_PLAYERS && playerCount <= GAME_LIMITS.MAX_PLAYERS;
}

/**
 * Calculate win condition for current game state
 */
export function calculateWinCondition(alivePlayers: { role: Role; playerId: string }[]): {
  hasWinner: boolean;
  winningFaction?: string;
  winningPlayers?: string[];
} {
  const aliveByFaction = alivePlayers.reduce((acc, player) => {
    let faction: string;

    if (['VILLAGER', 'SHERIFF', 'DOCTOR', 'VIGILANTE'].includes(player.role)) {
      faction = 'TOWN';
    } else if (['WEREWOLF', 'WEREWOLF_KING'].includes(player.role)) {
      faction = 'WEREWOLF';
    } else {
      faction = 'NEUTRAL';
    }

    if (!acc[faction]) acc[faction] = [];
    acc[faction].push(player.playerId);

    return acc;
  }, {} as Record<string, string[]>);

  const townCount = aliveByFaction.TOWN?.length || 0;
  const werewolfCount = aliveByFaction.WEREWOLF?.length || 0;
  const neutralCount = aliveByFaction.NEUTRAL?.length || 0;

  // Werewolves win if they equal or outnumber town
  if (werewolfCount >= townCount && townCount > 0) {
    return {
      hasWinner: true,
      winningFaction: 'WEREWOLF',
      winningPlayers: aliveByFaction.WEREWOLF,
    };
  }

  // Town wins if no werewolves left
  if (werewolfCount === 0 && townCount > 0) {
    return {
      hasWinner: true,
      winningFaction: 'TOWN',
      winningPlayers: aliveByFaction.TOWN,
    };
  }

  // Serial killer wins if alone
  if (townCount + werewolfCount === 0 && neutralCount === 1) {
    return {
      hasWinner: true,
      winningFaction: 'SERIAL_KILLER',
      winningPlayers: aliveByFaction.NEUTRAL,
    };
  }

  return { hasWinner: false };
}

// =============================================================================
// VALIDATION UTILITIES
// =============================================================================

/**
 * Check if string contains profanity (basic filter)
 */
export function containsProfanity(text: string): boolean {
  const profanityList = [
    'fuck', 'shit', 'damn', 'bitch', 'ass', 'hell',
    'porra', 'merda', 'caralho', 'puta', 'fodase', 'buceta'
    // Add more words as needed
  ];

  const lowerText = text.toLowerCase();
  return profanityList.some(word => lowerText.includes(word));
}

/**
 * Clean profanity from text
 */
export function cleanProfanity(text: string): string {
  if (!containsProfanity(text)) return text;

  const replacements = [
    'barbaridade', 'caramba', 'nossa', 'eita', 'puxa', 'xi'
  ];

  return randomElement(replacements);
}

// =============================================================================
// OBJECT UTILITIES
// =============================================================================

/**
 * Deep clone an object
 */
export function deepClone<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Remove undefined properties from object
 */
export function removeUndefined<T extends Record<string, any>>(obj: T): Partial<T> {
  const cleaned: Partial<T> = {};

  for (const [key, value] of Object.entries(obj)) {
    if (value !== undefined) {
      cleaned[key as keyof T] = value;
    }
  }

  return cleaned;
}

/**
 * Pick specific properties from object
 */
export function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>;

  for (const key of keys) {
    if (key in obj) {
      result[key] = obj[key];
    }
  }

  return result;
}

/**
 * Omit specific properties from object
 */
export function omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {
  const result = { ...obj } as any;

  for (const key of keys) {
    delete result[key];
  }

  return result;
}
</file>

<file path="backend/src/utils/simpleValidators.ts">
// üê∫ LOBISOMEM ONLINE - Simple Validators for Initial Testing
// Vers√£o simplificada para evitar erros de compila√ß√£o

export interface ValidationResult {
    success: boolean;
    data?: any;
    error?: string;
}

// Simple email validation
export function validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

// Simple username validation
export function validateUsername(username: string): boolean {
    return username.length >= 3 && username.length <= 20 && /^[a-zA-Z0-9_-]+$/.test(username);
}

// Simple password validation
export function validatePassword(password: string): boolean {
    return password.length >= 6 && password.length <= 50;
}

// Simple room name validation  
export function validateRoomName(name: string): boolean {
    return name.length >= 1 && name.length <= 30;
}

// Simple room code validation
export function validateRoomCode(code: string): boolean {
    return /^\d{6}$/.test(code);
}

// WebSocket message validation
export function validateWebSocketMessage(message: any): ValidationResult {
    if (!message || typeof message !== 'object') {
        return {
            success: false,
            error: 'Message must be an object'
        };
    }

    if (!message.type || typeof message.type !== 'string') {
        return {
            success: false,
            error: 'Message must have a valid type'
        };
    }

    return {
        success: true,
        data: {
            type: message.type,
            data: message.data || {},
            timestamp: message.timestamp || new Date().toISOString(),
            messageId: message.messageId
        }
    };
}

// Simple register validation
export function validateRegisterRequest(data: any): ValidationResult {
    if (!data.email || !validateEmail(data.email)) {
        return { success: false, error: 'Invalid email' };
    }

    if (!data.username || !validateUsername(data.username)) {
        return { success: false, error: 'Invalid username' };
    }

    if (!data.password || !validatePassword(data.password)) {
        return { success: false, error: 'Invalid password' };
    }

    if (data.password !== data.confirmPassword) {
        return { success: false, error: 'Passwords do not match' };
    }

    return {
        success: true,
        data: {
            email: data.email.toLowerCase().trim(),
            username: data.username.trim(),
            password: data.password
        }
    };
}

// Simple login validation
export function validateLoginRequest(data: any): ValidationResult {
    if (!data.email || !validateEmail(data.email)) {
        return { success: false, error: 'Invalid email' };
    }

    if (!data.password || typeof data.password !== 'string') {
        return { success: false, error: 'Invalid password' };
    }

    return {
        success: true,
        data: {
            email: data.email.toLowerCase().trim(),
            password: data.password
        }
    };
}

// Simple create room validation
export function validateCreateRoomRequest(data: any): ValidationResult {
    if (!data.name || !validateRoomName(data.name)) {
        return { success: false, error: 'Invalid room name' };
    }

    return {
        success: true,
        data: {
            name: data.name.trim(),
            isPrivate: Boolean(data.isPrivate),
            maxPlayers: Math.min(Math.max(data.maxPlayers || 15, 6), 15),
            maxSpectators: Math.min(Math.max(data.maxSpectators || 5, 0), 5)
        }
    };
}
</file>

<file path="backend/src/websocket/HeartbeatManager.ts">
// üê∫ LOBISOMEM ONLINE - Heartbeat Manager
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service
import { wsConfig } from '@/config/websocket';
import { wsLogger } from '@/utils/logger';
import type { ConnectionManager } from './ConnectionManager';

//====================================================================
// HEARTBEAT STATS INTERFACE
//====================================================================
export interface HeartbeatStats {
    totalPingsSent: number;
    totalPongsReceived: number;
    currentInterval: number;
    timeout: number;
    lastCleanup: Date;
    connectionsMonitored: number;
    deadConnectionsDetected: number;
}

//====================================================================
// HEARTBEAT MANAGER CLASS
//====================================================================
export class HeartbeatManager {
    private pingInterval: NodeJS.Timeout | null = null;
    private cleanupInterval: NodeJS.Timeout | null = null;
    private isRunning = false;
    private stats: HeartbeatStats = {
        totalPingsSent: 0,
        totalPongsReceived: 0,
        currentInterval: wsConfig.heartbeat.interval,
        timeout: wsConfig.heartbeat.timeout,
        lastCleanup: new Date(),
        connectionsMonitored: 0,
        deadConnectionsDetected: 0,
    };

    constructor(private connectionManager: ConnectionManager) { }

    //====================================================================
    // LIFECYCLE MANAGEMENT
    //====================================================================
    start(): void {
        if (this.isRunning) {
            wsLogger.warn('HeartbeatManager already running');
            return;
        }

        this.isRunning = true;

        // Start ping interval
        this.pingInterval = setInterval(() => {
            this.sendPingToAllConnections();
        }, wsConfig.heartbeat.interval);

        // Start cleanup interval (check for dead connections)
        this.cleanupInterval = setInterval(() => {
            this.cleanupDeadConnections();
        }, wsConfig.heartbeat.interval * 2); // Run cleanup less frequently

        wsLogger.info('HeartbeatManager started', {
            pingInterval: wsConfig.heartbeat.interval,
            timeout: wsConfig.heartbeat.timeout,
        });
    }

    stop(): void {
        if (!this.isRunning) {
            return;
        }

        this.isRunning = false;

        if (this.pingInterval) {
            clearInterval(this.pingInterval);
            this.pingInterval = null;
        }

        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }

        wsLogger.info('HeartbeatManager stopped');
    }

    restart(): void {
        this.stop();
        this.start();
    }

    isActive(): boolean {
        return this.isRunning;
    }

    //====================================================================
    // PING OPERATIONS
    //====================================================================
    private sendPingToAllConnections(): void {
        const connections = this.connectionManager.getAllConnections();
        let sentCount = 0;
        let failedCount = 0;

        for (const connection of connections) {
            try {
                if (connection.ws.readyState === connection.ws.OPEN) {
                    // Mark as potentially dead - will be marked alive when pong is received
                    this.connectionManager.markDead(connection.id);

                    // Send ping
                    connection.ws.ping();
                    sentCount++;

                    wsLogger.debug('Ping sent', {
                        connectionId: connection.id,
                        userId: connection.context.userId,
                    });
                } else {
                    // Connection is already closed
                    failedCount++;
                    wsLogger.debug('Skipping ping for closed connection', {
                        connectionId: connection.id,
                        readyState: connection.ws.readyState,
                    });
                }
            } catch (error) {
                failedCount++;
                wsLogger.error('Failed to send ping', error instanceof Error ? error : new Error('Unknown ping error'), {
                    connectionId: connection.id,
                    userId: connection.context.userId,
                });
            }
        }

        this.stats.totalPingsSent += sentCount;
        this.stats.connectionsMonitored = connections.length;

        if (sentCount > 0 || failedCount > 0) {
            wsLogger.debug('Ping round completed', {
                sent: sentCount,
                failed: failedCount,
                total: connections.length,
            });
        }
    }

    sendPingToConnection(connectionId: string): boolean {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) {
            wsLogger.warn('Cannot ping non-existent connection', { connectionId });
            return false;
        }

        try {
            if (connection.ws.readyState === connection.ws.OPEN) {
                this.connectionManager.markDead(connectionId);
                connection.ws.ping();

                wsLogger.debug('Individual ping sent', {
                    connectionId,
                    userId: connection.context.userId,
                });

                return true;
            } else {
                wsLogger.debug('Cannot ping closed connection', {
                    connectionId,
                    readyState: connection.ws.readyState,
                });
                return false;
            }
        } catch (error) {
            wsLogger.error('Failed to send individual ping', error instanceof Error ? error : new Error('Unknown individual ping error'), {
                connectionId,
                userId: connection.context.userId,
            });
            return false;
        }
    }

    //====================================================================
    // PONG HANDLING
    //====================================================================
    handlePong(connectionId: string): void {
        const success = this.connectionManager.markAlive(connectionId);
        if (success) {
            this.stats.totalPongsReceived++;

            wsLogger.debug('Pong received', {
                connectionId,
                responseTime: Date.now(), // Could calculate actual response time if needed
            });
        } else {
            wsLogger.warn('Received pong for unknown connection', { connectionId });
        }
    }

    //====================================================================
    // DEAD CONNECTION CLEANUP
    //====================================================================
    private cleanupDeadConnections(): void {
        const deadConnections = this.connectionManager.getDeadConnections();
        let cleanedCount = 0;

        for (const connectionId of deadConnections) {
            const connection = this.connectionManager.getConnection(connectionId);
            if (!connection) continue;

            // Check if connection has been dead for too long
            const timeSinceLastPing = Date.now() - connection.lastPing;
            const isTimedOut = timeSinceLastPing > (wsConfig.heartbeat.interval + wsConfig.heartbeat.timeout);

            if (isTimedOut) {
                wsLogger.info('Removing dead connection', {
                    connectionId,
                    userId: connection.context.userId,
                    username: connection.context.username,
                    timeSinceLastPing,
                    lastPing: new Date(connection.lastPing).toISOString(),
                });

                // Close the connection and remove it
                try {
                    if (connection.ws.readyState === connection.ws.OPEN) {
                        connection.ws.terminate(); // Force close
                    }
                } catch (error) {
                    wsLogger.error('Error terminating dead connection', error instanceof Error ? error : new Error('Unknown termination error'), {
                        connectionId,
                    });
                }

                this.connectionManager.removeConnection(connectionId);
                cleanedCount++;
                this.stats.deadConnectionsDetected++;
            }
        }

        this.stats.lastCleanup = new Date();

        if (cleanedCount > 0) {
            wsLogger.info('Dead connection cleanup completed', {
                cleanedCount,
                totalDeadConnections: deadConnections.length,
                remainingConnections: this.connectionManager.getConnectionCount(),
            });
        }
    }

    forceCleanupDeadConnections(): number {
        wsLogger.info('Force cleanup requested');
        this.cleanupDeadConnections();

        const deadConnections = this.connectionManager.getDeadConnections();
        return deadConnections.length;
    }

    //====================================================================
    // CONNECTION HEALTH MONITORING
    //====================================================================
    getConnectionHealth(connectionId: string): {
        isAlive: boolean;
        lastPing: number;
        timeSinceLastPing: number;
        isHealthy: boolean;
    } | null {
        const connection = this.connectionManager.getConnection(connectionId);
        if (!connection) return null;

        const now = Date.now();
        const timeSinceLastPing = now - connection.lastPing;
        const isHealthy = connection.isAlive && timeSinceLastPing < wsConfig.heartbeat.interval * 2;

        return {
            isAlive: connection.isAlive,
            lastPing: connection.lastPing,
            timeSinceLastPing,
            isHealthy,
        };
    }

    getAllConnectionsHealth(): Array<{
        connectionId: string;
        userId: string;
        username: string;
        isAlive: boolean;
        lastPing: number;
        timeSinceLastPing: number;
        isHealthy: boolean;
    }> {
        const connections = this.connectionManager.getAllConnections();
        const now = Date.now();

        return connections.map(connection => {
            const timeSinceLastPing = now - connection.lastPing;
            const isHealthy = connection.isAlive && timeSinceLastPing < wsConfig.heartbeat.interval * 2;

            return {
                connectionId: connection.id,
                userId: connection.context.userId,
                username: connection.context.username,
                isAlive: connection.isAlive,
                lastPing: connection.lastPing,
                timeSinceLastPing,
                isHealthy,
            };
        });
    }

    getHealthySummary(): {
        total: number;
        alive: number;
        dead: number;
        healthy: number;
        unhealthy: number;
    } {
        const healthData = this.getAllConnectionsHealth();

        return {
            total: healthData.length,
            alive: healthData.filter(h => h.isAlive).length,
            dead: healthData.filter(h => !h.isAlive).length,
            healthy: healthData.filter(h => h.isHealthy).length,
            unhealthy: healthData.filter(h => !h.isHealthy).length,
        };
    }

    //====================================================================
    // STATISTICS AND MONITORING
    //====================================================================
    getStats(): HeartbeatStats {
        return {
            ...this.stats,
            connectionsMonitored: this.connectionManager.getConnectionCount(),
        };
    }

    getDetailedStats() {
        const healthSummary = this.getHealthySummary();
        const baseStats = this.getStats();

        return {
            ...baseStats,
            healthSummary,
            isRunning: this.isRunning,
            uptime: this.isRunning ? Date.now() - this.stats.lastCleanup.getTime() : 0,
            pingSuccessRate: baseStats.totalPingsSent > 0
                ? (baseStats.totalPongsReceived / baseStats.totalPingsSent) * 100
                : 0,
        };
    }

    resetStats(): void {
        this.stats = {
            totalPingsSent: 0,
            totalPongsReceived: 0,
            currentInterval: wsConfig.heartbeat.interval,
            timeout: wsConfig.heartbeat.timeout,
            lastCleanup: new Date(),
            connectionsMonitored: this.connectionManager.getConnectionCount(),
            deadConnectionsDetected: 0,
        };

        wsLogger.info('HeartbeatManager stats reset');
    }

    //====================================================================
    // CONFIGURATION
    //====================================================================
    updateInterval(newInterval: number): void {
        if (newInterval < 1000) {
            throw new Error('Heartbeat interval must be at least 1000ms');
        }

        this.stats.currentInterval = newInterval;

        if (this.isRunning) {
            wsLogger.info('Updating heartbeat interval', {
                oldInterval: wsConfig.heartbeat.interval,
                newInterval,
            });

            this.restart();
        }
    }

    //====================================================================
    // HEALTH CHECK
    //====================================================================
    healthCheck(): {
        status: 'healthy' | 'unhealthy';
        isRunning: boolean;
        stats: HeartbeatStats;
        issues: string[];
    } {
        const issues: string[] = [];

        if (!this.isRunning) {
            issues.push('HeartbeatManager is not running');
        }

        const healthSummary = this.getHealthySummary();
        const unhealthyPercentage = healthSummary.total > 0
            ? (healthSummary.unhealthy / healthSummary.total) * 100
            : 0;

        if (unhealthyPercentage > 50) {
            issues.push(`${unhealthyPercentage.toFixed(1)}% of connections are unhealthy`);
        }

        if (this.stats.totalPingsSent > 0) {
            const successRate = (this.stats.totalPongsReceived / this.stats.totalPingsSent) * 100;
            if (successRate < 80) {
                issues.push(`Low ping success rate: ${successRate.toFixed(1)}%`);
            }
        }

        return {
            status: issues.length === 0 ? 'healthy' : 'unhealthy',
            isRunning: this.isRunning,
            stats: this.getStats(),
            issues,
        };
    }
}
</file>

<file path="backend/src/websocket/index.ts">
export { WebSocketManager } from './WebSocketManager';
export { ConnectionManager } from './ConnectionManager';
export { ChannelManager } from './ChannelManager';
export { MessageRouter } from './MessageRouter';
export { HeartbeatManager } from './HeartbeatManager';
</file>

<file path="frontend/src/components/common/ErrorBoundary.tsx">
'use client';

import React, { Component, ReactNode } from 'react';
import { motion } from 'framer-motion';
import { RefreshCw, Home, AlertTriangle } from 'lucide-react';
import Button from './Button';

// =============================================================================
// ERROR BOUNDARY TYPES
// =============================================================================
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}

// =============================================================================
// ERROR BOUNDARY CLASS COMPONENT
// =============================================================================
export default class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    this.setState({
      error,
      errorInfo,
    });

    // Log error to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Error caught by ErrorBoundary:', error);
      console.error('Error info:', errorInfo);
    }

    // Call onError prop if provided
    this.props.onError?.(error, errorInfo);

    // In production, you might want to send this to an error reporting service
    // Example: Sentry, LogRocket, etc.
  }

  handleRetry = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });
  };

  handleGoHome = () => {
    window.location.href = '/';
  };

  render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default error UI
      return <DefaultErrorUI
        error={this.state.error}
        onRetry={this.handleRetry}
        onGoHome={this.handleGoHome}
      />;
    }

    return this.props.children;
  }
}

// =============================================================================
// DEFAULT ERROR UI
// =============================================================================
interface DefaultErrorUIProps {
  error: Error | null;
  onRetry: () => void;
  onGoHome: () => void;
}

function DefaultErrorUI({ error, onRetry, onGoHome }: DefaultErrorUIProps) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 to-red-950 flex items-center justify-center p-6">
      <motion.div
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        className="max-w-md w-full text-center"
      >
        {/* Error icon */}
        <motion.div
          animate={{
            scale: [1, 1.1, 1],
            rotate: [0, 5, -5, 0]
          }}
          transition={{
            duration: 2,
            repeat: Infinity,
            ease: 'easeInOut'
          }}
          className="text-8xl mb-6"
        >
          üíÄ
        </motion.div>

        {/* Title */}
        <h1 className="text-3xl font-medieval text-red-300 mb-4 text-glow">
          Algo deu errado!
        </h1>

        {/* Description */}
        <p className="text-white/70 mb-6 leading-relaxed">
          A vila foi atacada por um erro inesperado.
          N√£o se preocupe, podemos tentar novamente.
        </p>

        {/* Error message in development */}
        {process.env.NODE_ENV === 'development' && error && (
          <div className="bg-black/30 border border-red-500/30 rounded-lg p-4 mb-6 text-left">
            <div className="flex items-center mb-2">
              <AlertTriangle className="w-4 h-4 text-red-400 mr-2" />
              <span className="text-red-400 font-semibold text-sm">
                Erro de Desenvolvimento
              </span>
            </div>
            <pre className="text-red-300 text-xs overflow-auto max-h-32">
              {error.message}
            </pre>
          </div>
        )}

        {/* Action buttons */}
        <div className="space-y-3">
          <Button
            variant="medieval"
            size="lg"
            onClick={onRetry}
            className="w-full"
          >
            <RefreshCw className="w-5 h-5 mr-2" />
            Tentar Novamente
          </Button>

          <Button
            variant="ghost"
            size="lg"
            onClick={onGoHome}
            className="w-full"
          >
            <Home className="w-5 h-5 mr-2" />
            Voltar ao In√≠cio
          </Button>
        </div>

        {/* Footer */}
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 1 }}
          className="text-white/40 text-sm mt-8"
        >
          Se o problema persistir, recarregue a p√°gina
        </motion.p>
      </motion.div>
    </div>
  );
}

// =============================================================================
// HOOK FOR FUNCTIONAL COMPONENTS
// =============================================================================
export function useErrorHandler() {
  const [error, setError] = React.useState<Error | null>(null);

  const resetError = React.useCallback(() => {
    setError(null);
  }, []);

  const captureError = React.useCallback((error: Error) => {
    setError(error);
    console.error('Error captured:', error);
  }, []);

  // Throw error to be caught by ErrorBoundary
  React.useEffect(() => {
    if (error) {
      throw error;
    }
  }, [error]);

  return { captureError, resetError };
}

// =============================================================================
// SPECIFIC ERROR COMPONENTS
// =============================================================================

// Network Error
export function NetworkError({ onRetry }: { onRetry: () => void }) {
  return (
    <div className="text-center p-8">
      <div className="text-6xl mb-4">üì°</div>
      <h3 className="text-xl font-bold text-white mb-2">
        Erro de Conex√£o
      </h3>
      <p className="text-white/70 mb-6">
        N√£o foi poss√≠vel conectar com o servidor.
        Verifique sua internet e tente novamente.
      </p>
      <Button variant="primary" onClick={onRetry}>
        <RefreshCw className="w-4 h-4 mr-2" />
        Tentar Novamente
      </Button>
    </div>
  );
}

// Game Error
export function GameError({
  message,
  onRetry,
  onLeave
}: {
  message: string;
  onRetry?: () => void;
  onLeave?: () => void;
}) {
  return (
    <div className="text-center p-8">
      <div className="text-6xl mb-4">üéÆ</div>
      <h3 className="text-xl font-bold text-white mb-2">
        Erro no Jogo
      </h3>
      <p className="text-white/70 mb-6">
        {message}
      </p>
      <div className="space-y-3">
        {onRetry && (
          <Button variant="primary" onClick={onRetry} className="w-full">
            <RefreshCw className="w-4 h-4 mr-2" />
            Tentar Novamente
          </Button>
        )}
        {onLeave && (
          <Button variant="ghost" onClick={onLeave} className="w-full">
            <Home className="w-4 h-4 mr-2" />
            Sair do Jogo
          </Button>
        )}
      </div>
    </div>
  );
}

// 404 Error
export function NotFoundError() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 to-medieval-800 flex items-center justify-center p-6">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="text-center max-w-md"
      >
        <div className="text-8xl mb-6">üèöÔ∏è</div>
        <h1 className="text-4xl font-medieval text-white mb-4">
          404
        </h1>
        <h2 className="text-xl text-white/80 mb-6">
          Esta p√°gina foi devorada pelos lobos
        </h2>
        <p className="text-white/60 mb-8">
          A p√°gina que voc√™ procura n√£o existe ou foi movida para outro local.
        </p>
        <Button
          variant="medieval"
          size="lg"
          onClick={() => window.location.href = '/'}
        >
          <Home className="w-5 h-5 mr-2" />
          Voltar √† Vila
        </Button>
      </motion.div>
    </div>
  );
}
</file>

<file path="frontend/src/components/common/LoadingSpinner.tsx">
'use client';

import { motion } from 'framer-motion';
import { clsx } from 'clsx';

// =============================================================================
// LOADING SPINNER COMPONENT
// =============================================================================
interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg' | 'xl';
  variant?: 'default' | 'medieval' | 'werewolf' | 'dots';
  className?: string;
  text?: string;
}

function LoadingSpinner({
  size = 'md',
  variant = 'default',
  className = '',
  text,
}: LoadingSpinnerProps) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
    xl: 'w-16 h-16',
  };

  if (variant === 'medieval') {
    return <MedievalSpinner size={size} className={className} text={text} />;
  }

  if (variant === 'werewolf') {
    return <WerewolfSpinner size={size} className={className} text={text} />;
  }

  if (variant === 'dots') {
    return <DotsSpinner size={size} className={className} text={text} />;
  }

  // Default spinner
  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <motion.div
        className={clsx(
          sizeClasses[size],
          'border-3 border-salem-600 border-t-transparent rounded-full'
        )}
        animate={{ rotate: 360 }}
        transition={{
          duration: 1,
          repeat: Infinity,
          ease: 'linear',
        }}
      />
      {text && (
        <p className="mt-3 text-white/70 font-medium animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// MEDIEVAL SPINNER
// =============================================================================
function MedievalSpinner({
  size,
  className,
  text
}: Pick<LoadingSpinnerProps, 'size' | 'className' | 'text'>) {
  const iconSizes = {
    sm: 'text-2xl',
    md: 'text-4xl',
    lg: 'text-6xl',
    xl: 'text-8xl',
  };

  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <motion.div
        className={clsx('text-amber-400', iconSizes[size!])}
        animate={{
          rotate: 360,
          scale: [1, 1.1, 1],
        }}
        transition={{
          rotate: {
            duration: 2,
            repeat: Infinity,
            ease: 'linear',
          },
          scale: {
            duration: 1,
            repeat: Infinity,
            ease: 'easeInOut',
          },
        }}
      >
        ‚öîÔ∏è
      </motion.div>
      {text && (
        <p className="mt-3 text-amber-300 font-medieval animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// WEREWOLF SPINNER
// =============================================================================
function WerewolfSpinner({
  size,
  className,
  text
}: Pick<LoadingSpinnerProps, 'size' | 'className' | 'text'>) {
  const iconSizes = {
    sm: 'text-2xl',
    md: 'text-4xl',
    lg: 'text-6xl',
    xl: 'text-8xl',
  };

  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <motion.div
        className={clsx('text-red-400', iconSizes[size!])}
        animate={{
          scale: [1, 1.3, 1],
          rotate: [0, 5, -5, 0],
        }}
        transition={{
          duration: 2,
          repeat: Infinity,
          ease: 'easeInOut',
        }}
      >
        üê∫
      </motion.div>
      {text && (
        <p className="mt-3 text-red-300 font-bold animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// DOTS SPINNER
// =============================================================================
function DotsSpinner({
  size,
  className,
  text
}: Pick<LoadingSpinnerProps, 'size' | 'className' | 'text'>) {
  const dotSizes = {
    sm: 'w-2 h-2',
    md: 'w-3 h-3',
    lg: 'w-4 h-4',
    xl: 'w-6 h-6',
  };

  const dotSpacing = {
    sm: 'space-x-1',
    md: 'space-x-2',
    lg: 'space-x-3',
    xl: 'space-x-4',
  };

  return (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <div className={clsx('flex', dotSpacing[size!])}>
        {[0, 1, 2].map((index) => (
          <motion.div
            key={index}
            className={clsx(
              dotSizes[size!],
              'bg-salem-400 rounded-full'
            )}
            animate={{
              scale: [1, 1.5, 1],
              opacity: [0.5, 1, 0.5],
            }}
            transition={{
              duration: 1.5,
              repeat: Infinity,
              delay: index * 0.2,
              ease: 'easeInOut',
            }}
          />
        ))}
      </div>
      {text && (
        <p className="mt-3 text-white/70 font-medium animate-pulse">
          {text}
        </p>
      )}
    </div>
  );
}

// =============================================================================
// FULLSCREEN LOADING
// =============================================================================
interface FullscreenLoadingProps {
  variant?: LoadingSpinnerProps['variant'];
  message?: string;
  submessage?: string;
}

export function FullscreenLoading({
  variant = 'medieval',
  message = 'Carregando...',
  submessage,
}: FullscreenLoadingProps) {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="fixed inset-0 z-50 flex items-center justify-center bg-medieval-900/95 backdrop-blur-sm"
    >
      <div className="text-center">
        <LoadingSpinner
          variant={variant}
          size="xl"
          text={message}
        />
        {submessage && (
          <motion.p
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.5 }}
            className="mt-4 text-white/50 text-sm"
          >
            {submessage}
          </motion.p>
        )}
      </div>
    </motion.div>
  );
}

// =============================================================================
// PAGE LOADING
// =============================================================================
export function PageLoading() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-medieval-900">
      <div className="text-center">
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          className="text-8xl mb-8"
        >
          üê∫
        </motion.div>

        <motion.h1
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
          className="text-3xl font-medieval text-glow mb-4"
        >
          Lobisomem Online
        </motion.h1>

        <LoadingSpinner
          variant="medieval"
          size="lg"
          text="Preparando a vila..."
        />
      </div>
    </div>
  );
}

// =============================================================================
// ‚úÖ EXPORTS CORRETOS - ADICIONADOS NO FINAL
// =============================================================================
export default LoadingSpinner;
</file>

<file path="frontend/src/components/game/PhaseIndicator.tsx">
import React from 'react';
import { useGame } from '@/context/GameContext';
import type { GamePhase } from '@/types';

// =============================================================================
// PHASE CONFIGURATION
// =============================================================================
const PHASE_CONFIG = {
  LOBBY: {
    icon: 'üè∞',
    name: 'Sala de Espera',
    description: 'Aguardando jogadores',
    bgColor: 'bg-medieval-700',
    textColor: 'text-white/80',
    borderColor: 'border-medieval-600',
  },
  NIGHT: {
    icon: 'üåô',
    name: 'Noite',
    description: 'A√ß√µes secretas',
    bgColor: 'bg-blue-900',
    textColor: 'text-blue-200',
    borderColor: 'border-blue-700',
  },
  DAY: {
    icon: '‚òÄÔ∏è',
    name: 'Dia',
    description: 'Discuss√£o',
    bgColor: 'bg-amber-700',
    textColor: 'text-amber-200',
    borderColor: 'border-amber-600',
  },
  VOTING: {
    icon: 'üó≥Ô∏è',
    name: 'Vota√ß√£o',
    description: 'Execu√ß√£o',
    bgColor: 'bg-red-800',
    textColor: 'text-red-200',
    borderColor: 'border-red-600',
  },
} as const;

// =============================================================================
// PHASE INDICATOR COMPONENT - COMPACTO PARA HEADER
// =============================================================================
export default function PhaseIndicator() {
  const { gameState } = useGame();

  if (!gameState) {
    return (
      <div className="flex items-center space-x-2">
        <div className="animate-pulse bg-medieval-700 h-10 w-32 rounded-lg"></div>
      </div>
    );
  }

  const phase = gameState.phase as GamePhase;
  const config = PHASE_CONFIG[phase];
  const isNight = phase === 'NIGHT';

  return (
    <div className="flex items-center space-x-3">

      {/* Main Phase Display */}
      <div className={`
        ${config.bgColor} ${config.borderColor} ${config.textColor}
        border-2 rounded-lg px-4 py-2 flex items-center space-x-2
        ${isNight ? 'animate-pulse' : ''}
        transition-all duration-500 min-w-0
      `}>

        {/* Phase Icon */}
        <div className="text-xl flex-shrink-0">
          {config.icon}
        </div>

        {/* Phase Info */}
        <div className="min-w-0">
          <div className="flex items-center space-x-2">
            <span className="font-bold text-sm">
              {config.name}
            </span>

            {/* Day Counter */}
            {(phase === 'DAY' || phase === 'VOTING') && gameState.day > 0 && (
              <span className="bg-white/20 text-xs px-2 py-1 rounded-full font-medium">
                Dia {gameState.day}
              </span>
            )}
          </div>

          <p className="text-xs opacity-90">
            {config.description}
          </p>
        </div>
      </div>

      {/* Phase Progress Indicator */}
      <div className="hidden md:flex items-center space-x-2">
        <div className="w-1 h-8 bg-medieval-700 rounded-full overflow-hidden">
          <div
            className={`
              w-full transition-all duration-1000 ease-out
              ${phase === 'LOBBY' ? 'h-1/4 bg-medieval-500' : ''}
              ${phase === 'NIGHT' ? 'h-2/4 bg-blue-500' : ''}
              ${phase === 'DAY' ? 'h-3/4 bg-amber-500' : ''}
              ${phase === 'VOTING' ? 'h-full bg-red-500' : ''}
            `}
          />
        </div>

        {/* Quick Phase Info */}
        <div className="text-xs text-white/70 max-w-[120px]">
          {phase === 'LOBBY' && 'Preparando...'}
          {phase === 'NIGHT' && 'Roles agem'}
          {phase === 'DAY' && 'Discuss√£o livre'}
          {phase === 'VOTING' && 'Escolham um alvo'}
        </div>
      </div>

      {/* Atmospheric Effects - Only on larger screens */}
      {isNight && (
        <div className="hidden lg:flex items-center space-x-1 text-blue-400">
          <span className="animate-bounce" style={{ animationDelay: '0ms' }}>‚≠ê</span>
          <span className="animate-bounce" style={{ animationDelay: '200ms' }}>‚ú®</span>
          <span className="animate-bounce" style={{ animationDelay: '400ms' }}>üåü</span>
        </div>
      )}

      {(phase === 'DAY' || phase === 'VOTING') && (
        <div className="hidden lg:flex items-center space-x-1 text-amber-400">
          <span className="animate-pulse" style={{ animationDelay: '0ms' }}>‚òÄÔ∏è</span>
          {phase === 'VOTING' && (
            <span className="animate-pulse" style={{ animationDelay: '500ms' }}>‚öñÔ∏è</span>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/WillNotes.tsx">
import React, { useState, useEffect } from 'react';
import { useGame } from '@/context/GameContext';

// =============================================================================
// WILL NOTES COMPONENT - TESTAMENTO E ANOTA√á√ïES
// =============================================================================
export default function WillNotes() {
  const { gameState, me } = useGame();

  const [will, setWill] = useState('');
  const [notes, setNotes] = useState('');
  const [activeTab, setActiveTab] = useState<'will' | 'notes'>('will');

  // =============================================================================
  // LOAD FROM LOCALSTORAGE
  // =============================================================================
  useEffect(() => {
    if (gameState?.gameId) {
      const savedWill = localStorage.getItem(`will-${gameState.gameId}`);
      const savedNotes = localStorage.getItem(`notes-${gameState.gameId}`);

      if (savedWill) setWill(savedWill);
      if (savedNotes) setNotes(savedNotes);
    }
  }, [gameState?.gameId]);

  // =============================================================================
  // SAVE TO LOCALSTORAGE
  // =============================================================================
  useEffect(() => {
    if (gameState?.gameId) {
      localStorage.setItem(`will-${gameState.gameId}`, will);
    }
  }, [will, gameState?.gameId]);

  useEffect(() => {
    if (gameState?.gameId) {
      localStorage.setItem(`notes-${gameState.gameId}`, notes);
    }
  }, [notes, gameState?.gameId]);

  // =============================================================================
  // TEMPLATE HELPERS
  // =============================================================================
  const insertTemplate = (template: string) => {
    if (activeTab === 'will') {
      setWill(prev => prev + (prev ? '\n' : '') + template);
    } else {
      setNotes(prev => prev + (prev ? '\n' : '') + template);
    }
  };

  const getWillTemplates = () => [
    'Meu nome √© [NOME] e eu sou [ROLE].',
    'N1: [INVESTIGA√á√ÉO/A√á√ÉO]',
    'D1: [SUSPEITAS]',
    'Se eu morrer, suspeitem de: [NOMES]',
    'Confiem em: [NOMES]',
  ];

  const getNotesTemplates = () => [
    'üîç INVESTIGA√á√ïES:',
    '‚ö° SUSPEITOS:',
    '‚úÖ CONFIRMADOS:',
    'üê∫ POSS√çVEIS LOBISOMENS:',
    'üìù CLAIMS:',
  ];

  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Header with Tabs */}
      <div className="flex-shrink-0 border-b border-medieval-600 p-4">
        <div className="flex items-center justify-between mb-3">
          <h3 className="text-lg font-bold text-white flex items-center space-x-2">
            <span>üìú</span>
            <span>Anota√ß√µes</span>
          </h3>

          {/* Character count */}
          <div className="text-xs text-white/50">
            {activeTab === 'will' ? will.length : notes.length}/1000
          </div>
        </div>

        {/* Tab buttons */}
        <div className="flex space-x-1">
          <button
            onClick={() => setActiveTab('will')}
            className={`
              px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200
              ${activeTab === 'will'
                ? 'bg-amber-600 text-white'
                : 'bg-medieval-700/50 text-white/70 hover:bg-medieval-700'
              }
            `}
          >
            üìú Testamento
          </button>

          <button
            onClick={() => setActiveTab('notes')}
            className={`
              px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200
              ${activeTab === 'notes'
                ? 'bg-blue-600 text-white'
                : 'bg-medieval-700/50 text-white/70 hover:bg-medieval-700'
              }
            `}
          >
            üìù Notas
          </button>
        </div>
      </div>

      {/* Content Area */}
      <div className="flex-1 flex flex-col">

        {/* Templates */}
        <div className="flex-shrink-0 border-b border-medieval-600 p-2">
          <div className="text-xs text-white/70 mb-2">Templates r√°pidos:</div>
          <div className="flex flex-wrap gap-1">
            {(activeTab === 'will' ? getWillTemplates() : getNotesTemplates()).map((template, index) => (
              <button
                key={index}
                onClick={() => insertTemplate(template)}
                className="text-xs bg-medieval-700 hover:bg-medieval-600 text-white/80 px-2 py-1 rounded transition-all duration-200"
                title={`Inserir: ${template}`}
              >
                {template.split(':')[0] || template.substring(0, 10)}...
              </button>
            ))}
          </div>
        </div>

        {/* Text Area */}
        <div className="flex-1 p-4">
          <textarea
            value={activeTab === 'will' ? will : notes}
            onChange={(e) => {
              const value = e.target.value.substring(0, 1000); // Limit characters
              if (activeTab === 'will') {
                setWill(value);
              } else {
                setNotes(value);
              }
            }}
            placeholder={
              activeTab === 'will'
                ? `Escreva seu testamento aqui...\n\nExemplo:\nMeu nome √© ${me?.username} e eu sou ${me?.role || '[ROLE]'}.\nN1: Investiguei Jo√£o - SUSPEITO\nD1: Jo√£o est√° mentindo sobre sua role\nSe eu morrer, suspeitem de Jo√£o e Maria`
                : `Suas anota√ß√µes pessoais...\n\nüîç INVESTIGA√á√ïES:\n- Jo√£o: SUSPEITO (N1)\n- Maria: INOCENTE (N2)\n\n‚ö° SUSPEITOS:\n- Jo√£o (mentiu sobre role)\n- Pedro (comportamento estranho)\n\n‚úÖ CONFIRMADOS:\n- Ana (Doctor claim + salvou algu√©m)`
            }
            className="w-full h-full bg-medieval-900/50 border border-medieval-600 rounded-lg p-3 text-white placeholder-white/30 text-sm resize-none focus:outline-none focus:border-amber-400 font-mono leading-relaxed"
            style={{ minHeight: '200px' }}
          />
        </div>

        {/* Tips */}
        <div className="flex-shrink-0 border-t border-medieval-600 p-3">
          <div className="text-xs text-white/50">
            {activeTab === 'will' ? (
              <div>
                <div className="flex items-center space-x-1 mb-1">
                  <span>üí°</span>
                  <span>Dica: Seu testamento ser√° revelado quando voc√™ morrer</span>
                </div>
                <div>Use-o para deixar informa√ß√µes importantes para seu time!</div>
              </div>
            ) : (
              <div>
                <div className="flex items-center space-x-1 mb-1">
                  <span>üí°</span>
                  <span>Dica: Use as notas para rastrear suas investiga√ß√µes</span>
                </div>
                <div>Mantenha registro de quem √© suspeito e por qu√™!</div>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Game Info Panel */}
      <div className="flex-shrink-0 border-t border-medieval-600 p-3 bg-medieval-900/30">
        <div className="text-xs space-y-1">
          <div className="flex justify-between">
            <span className="text-white/70">Sua Role:</span>
            <span className="text-purple-300">{me?.role || 'Aguardando...'}</span>
          </div>

          <div className="flex justify-between">
            <span className="text-white/70">Fac√ß√£o:</span>
            <span className={`${me?.faction === 'TOWN' ? 'text-green-400' :
              me?.faction === 'WEREWOLF' ? 'text-red-400' :
                'text-purple-400'
              }`}>
              {me?.faction === 'TOWN' ? 'Vila' :
                me?.faction === 'WEREWOLF' ? 'Lobisomem' :
                  me?.faction === 'NEUTRAL' ? 'Neutro' : 'Aguardando...'}
            </span>
          </div>

          {gameState && (
            <div className="flex justify-between">
              <span className="text-white/70">Dia:</span>
              <span className="text-amber-400">{gameState.day}</span>
            </div>
          )}

          <div className="flex justify-between">
            <span className="text-white/70">Status:</span>
            <span className={me?.isAlive ? 'text-green-400' : 'text-red-400'}>
              {me?.isAlive ? 'Vivo' : 'Morto'}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/lobby/CreateRoomModal.tsx">
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { X, Users, Eye, Lock, Globe, Settings } from 'lucide-react';
import { useRouter } from 'next/router';
import { toast } from 'react-hot-toast';

import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';
import { apiService } from '@/services/api';

interface CreateRoomModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface RoomSettings {
  gameMode: 'CLASSIC' | 'RANKED' | 'CUSTOM';
  timeDay: number;
  timeNight: number;
  timeVoting: number;
  allowSpectators: boolean;
  autoStart: boolean;
}

export default function CreateRoomModal({
  isOpen,
  onClose,
}: CreateRoomModalProps) {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  const [formData, setFormData] = useState({
    name: '',
    isPrivate: false,
    maxPlayers: 12,
    maxSpectators: 8,
  });

  const [settings, setSettings] = useState<RoomSettings>({
    gameMode: 'CLASSIC',
    timeDay: 300,
    timeNight: 120,
    timeVoting: 180,
    allowSpectators: true,
    autoStart: false,
  });

  const [showAdvanced, setShowAdvanced] = useState(false);

  /* -------------------------------------------------------------------------- */
  /*                                 Handlers                                   */
  /* -------------------------------------------------------------------------- */
  const handleInputChange = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleSettingsChange = (field: keyof RoomSettings, value: any) => {
    setSettings(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.name.trim()) {
      toast.error('Nome da sala √© obrigat√≥rio');
      return;
    }
    if (formData.name.length < 3) {
      toast.error('Nome da sala deve ter pelo menos 3 caracteres');
      return;
    }

    setLoading(true);

    try {
      /* ------------------------------ Cria a sala ----------------------------- */
      const response = await apiService.post('/api/rooms', {
        ...formData,
        settings,
      });

      toast.success('Sala criada com sucesso!');
      onClose();

      /* ----------------------- Redireciona para a nova sala ----------------------- */
      const roomId =
        response.data?.data?.room?.id ?? response.data?.room?.id ?? null;

      if (roomId) {
        router.push(`/room/${roomId}`);
      } else {
        console.error(
          'ERRO CR√çTICO: N√£o foi poss√≠vel obter o ID da sala.',
          response.data,
        );
        toast.error('N√£o foi poss√≠vel redirecionar para a sala.');
      }
    } catch (error: any) {
      console.error('Erro ao criar sala:', error);
      toast.error(
        error.response?.data?.message || 'Erro inesperado ao criar sala',
      );
    } finally {
      setLoading(false);
    }
  };

  const handleClose = () => {
    if (!loading) {
      setFormData({
        name: '',
        isPrivate: false,
        maxPlayers: 12,
        maxSpectators: 8,
      });
      setSettings({
        gameMode: 'CLASSIC',
        timeDay: 300,
        timeNight: 120,
        timeVoting: 180,
        allowSpectators: true,
        autoStart: false,
      });
      setShowAdvanced(false);
      onClose();
    }
  };

  /* -------------------------------------------------------------------------- */
  /*                                   JSX                                      */
  /* -------------------------------------------------------------------------- */
  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title="üê∫ Criar Nova Sala"
      size="lg"
      variant="medieval"
    >
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Nome da Sala */}
        <div>
          <label className="block text-sm font-medium text-slate-300 mb-2">
            Nome da Sala *
          </label>
          <input
            type="text"
            value={formData.name}
            onChange={e => handleInputChange('name', e.target.value)}
            placeholder="Digite o nome da sua sala."
            maxLength={50}
            className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            disabled={loading}
          />
          <div className="text-xs text-slate-500 mt-1">
            {formData.name.length}/50 caracteres
          </div>
        </div>

        {/* Configura√ß√µes B√°sicas */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* M√°ximo de Jogadores */}
          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
              <Users className="w-4 h-4 inline mr-2" />
              M√°ximo de Jogadores
            </label>
            <select
              value={formData.maxPlayers}
              onChange={e =>
                handleInputChange('maxPlayers', parseInt(e.target.value))
              }
              className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={loading}
            >
              {[6, 8, 10, 12, 14, 16].map(num => (
                <option key={num} value={num}>
                  {num} jogadores
                </option>
              ))}
            </select>
          </div>

          {/* M√°ximo de Espectadores */}
          <div>
            <label className="block text-sm font-medium text-slate-300 mb-2">
              <Eye className="w-4 h-4 inline mr-2" />
              M√°ximo de Espectadores
            </label>
            <select
              value={formData.maxSpectators}
              onChange={e =>
                handleInputChange('maxSpectators', parseInt(e.target.value))
              }
              className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={loading}
            >
              {[0, 4, 8, 12, 16, 20].map(num => (
                <option key={num} value={num}>
                  {num === 0 ? 'Sem espectadores' : `${num} espectadores`}
                </option>
              ))}
            </select>
          </div>
        </div>

        {/* Tipo de Sala */}
        <div>
          <label className="block text-sm font-medium text-slate-300 mb-3">
            Tipo de Sala
          </label>
          <div className="grid grid-cols-2 gap-3">
            <button
              type="button"
              onClick={() => handleInputChange('isPrivate', false)}
              className={`p-4 rounded-lg border-2 transition-all ${!formData.isPrivate
                ? 'border-green-500 bg-green-500/10 text-green-400'
                : 'border-slate-600 bg-slate-700/50 text-slate-300'
                }`}
              disabled={loading}
            >
              <Globe className="w-6 h-6 mx-auto mb-2" />
              <div className="font-medium">P√∫blica</div>
              <div className="text-xs opacity-75">Vis√≠vel no lobby</div>
            </button>

            <button
              type="button"
              onClick={() => handleInputChange('isPrivate', true)}
              className={`p-4 rounded-lg border-2 transition-all ${formData.isPrivate
                ? 'border-blue-500 bg-blue-500/10 text-blue-400'
                : 'border-slate-600 bg-slate-700/50 text-slate-300'
                }`}
              disabled={loading}
            >
              <Lock className="w-6 h-6 mx-auto mb-2" />
              <div className="font-medium">Privada</div>
              <div className="text-xs opacity-75">Apenas por c√≥digo</div>
            </button>
          </div>
        </div>

        {/* Configura√ß√µes Avan√ßadas (colapse) */}
        <div>
          <button
            type="button"
            onClick={() => setShowAdvanced(!showAdvanced)}
            className="flex items-center gap-2 text-slate-300 hover:text-white transition-colors"
            disabled={loading}
          >
            <Settings className="w-4 h-4" />
            Configura√ß√µes Avan√ßadas
            <motion.div
              animate={{ rotate: showAdvanced ? 180 : 0 }}
              transition={{ duration: 0.2 }}
            >
              <X className="w-4 h-4" />
            </motion.div>
          </button>

          {showAdvanced && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              className="mt-4 p-4 bg-slate-800/50 rounded-lg border border-slate-600 space-y-4"
            >
              {/* Modo de Jogo */}
              <div>
                <label className="block text-sm font-medium text-slate-300 mb-2">
                  Modo de Jogo
                </label>
                <select
                  value={settings.gameMode}
                  onChange={e =>
                    handleSettingsChange(
                      'gameMode',
                      e.target.value as RoomSettings['gameMode'],
                    )
                  }
                  className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded text-white"
                  disabled={loading}
                >
                  <option value="CLASSIC">Cl√°ssico</option>
                  <option value="RANKED">Ranqueado</option>
                  <option value="CUSTOM">Personalizado</option>
                </select>
              </div>

              {/* Tempos */}
              <div className="grid grid-cols-3 gap-3">
                <div>
                  <label className="block text-xs text-slate-400 mb-1">
                    Tempo Dia (seg)
                  </label>
                  <input
                    type="number"
                    min={60}
                    max={600}
                    value={settings.timeDay}
                    onChange={e =>
                      handleSettingsChange(
                        'timeDay',
                        parseInt(e.target.value, 10),
                      )
                    }
                    className="w-full px-2 py-1 bg-slate-700 border border-slate-600 rounded text-white text-sm"
                    disabled={loading}
                  />
                </div>

                <div>
                  <label className="block text-xs text-slate-400 mb-1">
                    Tempo Noite (seg)
                  </label>
                  <input
                    type="number"
                    min={30}
                    max={300}
                    value={settings.timeNight}
                    onChange={e =>
                      handleSettingsChange(
                        'timeNight',
                        parseInt(e.target.value, 10),
                      )
                    }
                    className="w-full px-2 py-1 bg-slate-700 border border-slate-600 rounded text-white text-sm"
                    disabled={loading}
                  />
                </div>

                <div>
                  <label className="block text-xs text-slate-400 mb-1">
                    Tempo Vota√ß√£o (seg)
                  </label>
                  <input
                    type="number"
                    min={60}
                    max={300}
                    value={settings.timeVoting}
                    onChange={e =>
                      handleSettingsChange(
                        'timeVoting',
                        parseInt(e.target.value, 10),
                      )
                    }
                    className="w-full px-2 py-1 bg-slate-700 border border-slate-600 rounded text-white text-sm"
                    disabled={loading}
                  />
                </div>
              </div>

              {/* Op√ß√µes */}
              <div className="space-y-2">
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={settings.allowSpectators}
                    onChange={e =>
                      handleSettingsChange('allowSpectators', e.target.checked)
                    }
                    className="rounded"
                    disabled={loading}
                  />
                  <span className="text-sm text-slate-300">
                    Permitir espectadores
                  </span>
                </label>

                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={settings.autoStart}
                    onChange={e =>
                      handleSettingsChange('autoStart', e.target.checked)
                    }
                    className="rounded"
                    disabled={loading}
                  />
                  <span className="text-sm text-slate-300">
                    In√≠cio autom√°tico quando todos estiverem prontos
                  </span>
                </label>
              </div>
            </motion.div>
          )}
        </div>

        {/* Bot√µes */}
        <div className="flex justify-end gap-3 pt-4 border-t border-slate-700">
          <Button variant="ghost" onClick={handleClose} disabled={loading}>
            Cancelar
          </Button>

          <Button
            type="submit"
            variant="primary"
            loading={loading}
            className="min-w-[120px]"
          >
            {loading ? 'Criando...' : 'Criar Sala'}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
</file>

<file path="frontend/src/components/lobby/JoinRoomModal.tsx">
import React, { useState } from 'react';
import { Eye, X } from 'lucide-react';
import { toast } from 'react-hot-toast';
import { motion } from 'framer-motion';
import { useRouter } from 'next/router';

import Modal from '@/components/common/Modal';
import Button from '@/components/common/Button';
import { apiService } from '@/services/api';

interface JoinRoomModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function JoinRoomModal({ isOpen, onClose }: JoinRoomModalProps) {
  const router = useRouter();

  const [roomCode, setRoomCode] = useState('');
  const [asSpectator, setAsSpectator] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!roomCode.trim()) {
      toast.error('Informe o c√≥digo da sala');
      return;
    }

    setLoading(true);

    try {
      const response = await apiService.post('/api/rooms/join-by-code', {
        code: roomCode.toUpperCase(),
        asSpectator,
      });

      toast.success(`${asSpectator ? 'Espectando' : 'Entrou na'} sala com sucesso!`);
      onClose();

      // ‚úÖ CORRE√á√ÉO APLICADA AQUI
      const roomId =
        response.data?.data?.room?.id ?? response.data?.room?.id ?? null;

      if (roomId) {
        router.push(`/room/${roomId}`);
      } else {
        console.error(
          'ERRO CR√çTICO: N√£o foi poss√≠vel obter o ID da sala da resposta da API.',
          response.data
        );
        toast.error('Ocorreu um erro ao redirecionar para a sala.');
      }
    } catch (error: any) {
      console.error('Erro ao entrar na sala:', error);
      toast.error(
        error.response?.data?.message || 'Erro inesperado ao entrar na sala'
      );
    } finally {
      setLoading(false);
    }
  };

  const handleClose = () => {
    if (!loading) {
      setRoomCode('');
      setAsSpectator(false);
      onClose();
    }
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title="üîë Entrar em uma Sala"
      size="md"
      variant="medieval"
    >
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* C√≥digo da Sala */}
        <div>
          <label className="block text-sm font-medium text-slate-300 mb-2">
            C√≥digo da Sala
          </label>
          <input
            type="text"
            value={roomCode}
            onChange={(e) => setRoomCode(e.target.value)}
            placeholder="Ex: ABC123"
            maxLength={10}
            className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 uppercase tracking-widest"
            disabled={loading}
          />
        </div>

        {/* Entrar como Espectador */}
        <div className="flex items-center gap-2">
          <input
            id="spectator"
            type="checkbox"
            checked={asSpectator}
            onChange={(e) => setAsSpectator(e.target.checked)}
            className="rounded"
            disabled={loading}
          />
          <label htmlFor="spectator" className="text-sm text-slate-300 flex items-center gap-2">
            <Eye className="w-4 h-4" />
            Entrar como espectador
          </label>
        </div>

        {/* Bot√µes */}
        <div className="flex justify-end gap-3 pt-4 border-t border-slate-700">
          <Button variant="ghost" onClick={handleClose} disabled={loading}>
            Cancelar
          </Button>

          <Button
            type="submit"
            variant="primary"
            loading={loading}
            className="min-w-[120px]"
          >
            {loading ? 'Entrando...' : 'Entrar'}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
</file>

<file path="frontend/src/pages/auth/forgot-password.tsx">
// üê∫ WEREWOLF - Forgot Password Page
// Werewolf inspired password recovery interface

import { useState } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { Mail, ArrowLeft, Send, CheckCircle } from 'lucide-react';

import { useForm } from '@/hooks';
import { authService } from '@/services/auth';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';

// =============================================================================
// FORGOT PASSWORD PAGE COMPONENT
// =============================================================================
export default function ForgotPasswordPage() {
  const router = useRouter();
  const [emailSent, setEmailSent] = useState(false);

  // Form management
  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleSubmit,
    setError,
    setTouched,
  } = useForm<{ email: string }>(
    { email: '' },
    async (formData) => {
      // Validate email
      if (!formData.email) {
        setError('email', 'Email √© obrigat√≥rio');
        return;
      }

      if (!authService.validateEmail(formData.email)) {
        setError('email', 'Email inv√°lido');
        return;
      }

      try {
        const response = await authService.forgotPassword(formData.email);
        if (response.success) {
          setEmailSent(true);
        } else {
          setError('email', response.error || 'Erro ao enviar email');
        }
      } catch (error) {
        setError('email', 'Erro de conex√£o. Tente novamente.');
      }
    }
  );

  if (emailSent) {
    return <EmailSentSuccess email={values.email} />;
  }

  return (
    <>
      <Head>
        <title>Esqueci Minha Senha - Werewolf</title>
        <meta name="description" content="Recupere sua senha do Werewolf" />
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="card-medieval p-8"
        >
          {/* Back Button */}
          <motion.div
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            className="mb-6"
          >
            <Button
              variant="ghost"
              size="sm"
              onClick={() => router.back()}
              className="text-white/70 hover:text-white"
            >
              <ArrowLeft className="w-4 h-4 mr-2" />
              Voltar
            </Button>
          </motion.div>

          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: 'spring' }}
              className="text-6xl mb-4"
            >
              üîë
            </motion.div>
            <h1 className="text-2xl font-medieval text-glow mb-2">
              Esqueceu sua Senha?
            </h1>
            <p className="text-white/70 leading-relaxed">
              N√£o se preocupe! Digite seu email e enviaremos
              instru√ß√µes para redefinir sua senha.
            </p>
          </div>

          {/* Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Email Field */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Email da Conta
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Mail className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="email"
                  type="email"
                  value={values.email}
                  onChange={handleChange('email')}
                  onBlur={() => setTouched('email')}
                  className={`
                    w-full pl-10 pr-4 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.email && touched.email
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seu@email.com"
                  disabled={isSubmitting}
                  autoFocus
                />
              </div>
              {errors.email && touched.email && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.email}
                </motion.p>
              )}
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="medieval"
              size="lg"
              disabled={isSubmitting}
              loading={isSubmitting}
              className="w-full"
            >
              <Send className="w-5 h-5 mr-2" />
              {isSubmitting ? 'Enviando...' : 'Enviar Instru√ß√µes'}
            </Button>
          </form>

          {/* Additional Info */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.5 }}
            className="mt-8 p-4 bg-blue-900/20 border border-blue-500/30 rounded-lg"
          >
            <h3 className="text-sm font-semibold text-blue-300 mb-2">
              üí° Dica
            </h3>
            <p className="text-xs text-blue-200/70">
              Verifique sua caixa de spam se n√£o receber o email em alguns minutos.
              O email de recupera√ß√£o ser√° enviado de noreply@werewolf.com
            </p>
          </motion.div>

          {/* Back to Login */}
          <div className="mt-8 text-center">
            <p className="text-white/50 text-sm mb-4">
              Lembrou da sua senha?
            </p>
            <Link
              href="/auth/login"
              className="text-salem-400 hover:text-salem-300 transition-colors text-sm font-medium"
            >
              Voltar para o Login
            </Link>
          </div>
        </motion.div>
      </Layout>
    </>
  );
}

// =============================================================================
// EMAIL SENT SUCCESS COMPONENT
// =============================================================================
interface EmailSentSuccessProps {
  email: string;
}

function EmailSentSuccess({ email }: EmailSentSuccessProps) {
  const router = useRouter();

  return (
    <>
      <Head>
        <title>Email Enviado - Werewolf</title>
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          className="card-medieval p-8 text-center"
        >
          {/* Success Icon */}
          <motion.div
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ delay: 0.2, type: 'spring', bounce: 0.6 }}
            className="text-6xl mb-6"
          >
            üìß
          </motion.div>

          {/* Success Message */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4 }}
            className="mb-8"
          >
            <div className="flex items-center justify-center mb-4">
              <CheckCircle className="w-8 h-8 text-green-400 mr-3" />
              <h1 className="text-2xl font-medieval text-glow">
                Email Enviado!
              </h1>
            </div>

            <p className="text-white/70 leading-relaxed mb-4">
              Enviamos instru√ß√µes de recupera√ß√£o de senha para:
            </p>

            <div className="bg-medieval-800/50 border border-medieval-600 rounded-lg p-3 mb-6">
              <span className="font-mono text-salem-300">{email}</span>
            </div>

            <p className="text-white/60 text-sm">
              Siga as instru√ß√µes no email para redefinir sua senha.
              O link √© v√°lido por 1 hora.
            </p>
          </motion.div>

          {/* Action Buttons */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.6 }}
            className="space-y-4"
          >
            <Button
              variant="medieval"
              size="lg"
              onClick={() => router.push('/auth/login')}
              className="w-full"
            >
              Voltar ao Login
            </Button>

            <Button
              variant="ghost"
              onClick={() => router.push('/auth/forgot-password')}
              className="w-full text-sm"
            >
              N√£o recebeu o email? Tentar novamente
            </Button>
          </motion.div>

          {/* Additional Help */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 1 }}
            className="mt-8 p-4 bg-amber-900/20 border border-amber-500/30 rounded-lg"
          >
            <h3 className="text-sm font-semibold text-amber-300 mb-2">
              ‚ö†Ô∏è N√£o recebeu o email?
            </h3>
            <ul className="text-xs text-amber-200/70 text-left space-y-1">
              <li>‚Ä¢ Verifique sua caixa de spam</li>
              <li>‚Ä¢ Confirme se o email est√° correto</li>
              <li>‚Ä¢ Aguarde alguns minutos</li>
              <li>‚Ä¢ Tente novamente se necess√°rio</li>
            </ul>
          </motion.div>
        </motion.div>
      </Layout>
    </>
  );
}
</file>

<file path="frontend/src/pages/roles.tsx">
import { useState, useEffect } from 'react';
import { motion, useScroll, useTransform } from 'framer-motion';
import { useRouter } from 'next/router';
import Head from 'next/head';
import {
  ArrowLeft,
  Users,
  Moon,
  Sun,
  Shield,
  Search,
  Heart,
  Sword,
  Crown,
  Skull,
  Zap,
  Target,
  Eye,
  ChevronDown,
  ChevronUp
} from 'lucide-react';

import { useTheme } from '@/context/ThemeContext';
import Button from '@/components/common/Button';

// Tipos de roles
interface Role {
  id: string;
  name: string;
  emoji: string;
  faction: 'Vila' | 'Lobisomens' | 'Neutros';
  description: string;
  power: string;
  strategy: string;
  winCondition: string;
  icon: React.ReactNode;
  color: string;
  bgColor: string;
  borderColor: string;
}

// Dados das roles baseados na documenta√ß√£o
const roles: Role[] = [
  // VILA
  {
    id: 'villager',
    name: 'Alde√£o',
    emoji: 'üë§',
    faction: 'Vila',
    description: 'Cidad√£o comum da vila que deve ajudar a identificar e eliminar os lobisomens.',
    power: 'Apenas voto durante o dia',
    strategy: 'Preste aten√ß√£o nos comportamentos suspeitos e participe ativamente das discuss√µes.',
    winCondition: 'Eliminar todos os lobisomens e inimigos da vila',
    icon: <Users className="w-6 h-6" />,
    color: 'text-green-400',
    bgColor: 'bg-green-900/20',
    borderColor: 'border-green-500/30'
  },
  {
    id: 'sheriff',
    name: 'Sheriff',
    emoji: 'üîç',
    faction: 'Vila',
    description: 'Investigador experiente que pode descobrir a verdadeira natureza dos habitantes.',
    power: 'Investiga 1 pessoa por noite - resultado: "SUSPEITO" ou "N√ÉO SUSPEITO"',
    strategy: 'Compartilhe informa√ß√µes com cuidado. Lobisomens podem se passar por Sheriff.',
    winCondition: 'Eliminar todos os lobisomens e inimigos da vila',
    icon: <Search className="w-6 h-6" />,
    color: 'text-blue-400',
    bgColor: 'bg-blue-900/20',
    borderColor: 'border-blue-500/30'
  },
  {
    id: 'doctor',
    name: 'M√©dico',
    emoji: '‚öïÔ∏è',
    faction: 'Vila',
    description: 'Curandeiro da vila capaz de proteger pessoas dos ataques noturnos.',
    power: 'Protege 1 pessoa por noite da morte (n√£o pode se proteger consecutivamente)',
    strategy: 'Proteja pessoas importantes ou suspeitas de serem atacadas. Varie seus alvos.',
    winCondition: 'Eliminar todos os lobisomens e inimigos da vila',
    icon: <Heart className="w-6 h-6" />,
    color: 'text-green-400',
    bgColor: 'bg-green-900/20',
    borderColor: 'border-green-500/30'
  },
  {
    id: 'vigilante',
    name: 'Vigilante',
    emoji: 'üî´',
    faction: 'Vila',
    description: 'Justiceiro da vila que toma a lei em suas pr√≥prias m√£os.',
    power: 'Mata 1 pessoa por noite (3 usos) - Se matar inocente, perde a pr√≥xima noite',
    strategy: 'S√≥ mate se tiver CERTEZA. Um erro pode custar caro √† vila.',
    winCondition: 'Eliminar todos os lobisomens e inimigos da vila',
    icon: <Sword className="w-6 h-6" />,
    color: 'text-orange-400',
    bgColor: 'bg-orange-900/20',
    borderColor: 'border-orange-500/30'
  },

  // LOBISOMENS
  {
    id: 'werewolf_king',
    name: 'Lobisomem Rei',
    emoji: 'üëë',
    faction: 'Lobisomens',
    description: 'L√≠der da alcateia com poderes especiais que o tornam mais dif√≠cil de detectar.',
    power: 'Mata 1 pessoa por noite + IMUNE √† investiga√ß√£o do Sheriff (aparece como "N√ÉO SUSPEITO")',
    strategy: 'Use sua imunidade com sabedoria. Lidere a alcateia nas decis√µes noturnas.',
    winCondition: 'Igualar ou superar o n√∫mero de membros da vila',
    icon: <Crown className="w-6 h-6" />,
    color: 'text-red-400',
    bgColor: 'bg-red-900/20',
    borderColor: 'border-red-500/30'
  },
  {
    id: 'werewolf',
    name: 'Lobisomem',
    emoji: 'üê∫',
    faction: 'Lobisomens',
    description: 'Criatura da noite que ca√ßa em matilha para dominar a vila.',
    power: 'Mata 1 pessoa por noite (vota√ß√£o em grupo) + Chat privado com outros lobisomens',
    strategy: 'Blefe durante o dia fingindo ser da vila. Coordene ataques √† noite.',
    winCondition: 'Igualar ou superar o n√∫mero de membros da vila',
    icon: <Moon className="w-6 h-6" />,
    color: 'text-red-400',
    bgColor: 'bg-red-900/20',
    borderColor: 'border-red-500/30'
  },

  // NEUTROS
  {
    id: 'jester',
    name: 'Jester',
    emoji: 'ü§°',
    faction: 'Neutros',
    description: 'Bobo da corte que busca sua pr√≥pria destrui√ß√£o de forma peculiar.',
    power: 'Nenhum poder especial - Objetivo √∫nico de ser executado',
    strategy: 'Seja suspeito o suficiente para ser votado, mas n√£o √≥bvio demais.',
    winCondition: 'Ser executado durante o dia por vota√ß√£o (N√ÉO morto √† noite)',
    icon: <Target className="w-6 h-6" />,
    color: 'text-purple-400',
    bgColor: 'bg-purple-900/20',
    borderColor: 'border-purple-500/30'
  },
  {
    id: 'serial_killer',
    name: 'Serial Killer',
    emoji: 'üî™',
    faction: 'Neutros',
    description: 'Assassino solit√°rio que busca eliminar todos os outros jogadores.',
    power: 'Mata 1 pessoa por noite - Age independentemente',
    strategy: 'Finja ser da vila enquanto elimina amea√ßas. Sobreviva at√© o final.',
    winCondition: 'Ser o √∫ltimo sobrevivente (eliminar TODOS os outros jogadores)',
    icon: <Skull className="w-6 h-6" />,
    color: 'text-gray-400',
    bgColor: 'bg-gray-900/20',
    borderColor: 'border-gray-500/30'
  }
];

// Composi√ß√µes de jogo
const gameCompositions = [
  {
    players: 6,
    name: 'Composi√ß√£o B√°sica',
    vila: 3,
    lobisomens: 2,
    neutros: 1,
    details: '1 Sheriff + 1 Doctor + 1 Villager | 1 Lobisomem Rei + 1 Lobisomem | 1 Jester'
  },
  {
    players: 9,
    name: 'Composi√ß√£o M√©dia',
    vila: 5,
    lobisomens: 3,
    neutros: 1,
    details: '1 Sheriff + 1 Doctor + 1 Vigilante + 2 Villagers | 1 Lobisomem Rei + 2 Lobisomens | 1 Jester'
  },
  {
    players: 12,
    name: 'Composi√ß√£o Padr√£o',
    vila: 7,
    lobisomens: 3,
    neutros: 2,
    details: '1 Sheriff + 1 Doctor + 1 Vigilante + 4 Villagers | 1 Lobisomem Rei + 2 Lobisomens | 1 Jester + 1 Serial Killer'
  },
  {
    players: 15,
    name: 'Composi√ß√£o M√°xima',
    vila: 9,
    lobisomens: 4,
    neutros: 2,
    details: '1 Sheriff + 1 Doctor + 1 Vigilante + 6 Villagers | 1 Lobisomem Rei + 3 Lobisomens | 1 Jester + 1 Serial Killer'
  }
];

export default function RolesPage() {
  const router = useRouter();
  const { playSound, getPhaseColors, getThemeClass } = useTheme();
  const { scrollY } = useScroll();

  const [selectedFaction, setSelectedFaction] = useState<string>('all');
  const [expandedRole, setExpandedRole] = useState<string | null>(null);
  const [showCompositions, setShowCompositions] = useState(false);

  // Aplicar cores din√¢micas do tema
  const phaseColors = getPhaseColors();

  // Parallax effects
  const backgroundY = useTransform(scrollY, [0, 500], [0, 150]);
  const textY = useTransform(scrollY, [0, 500], [0, 100]);

  const filteredRoles = selectedFaction === 'all'
    ? roles
    : roles.filter(role => role.faction === selectedFaction);

  const handleBack = () => {
    playSound('button_click');
    router.push('/');
  };

  const toggleRole = (roleId: string) => {
    playSound('button_click');
    setExpandedRole(expandedRole === roleId ? null : roleId);
  };

  const getFactionIcon = (faction: string) => {
    switch (faction) {
      case 'Vila': return <Shield className="w-5 h-5" />;
      case 'Lobisomens': return <Moon className="w-5 h-5" />;
      case 'Neutros': return <Zap className="w-5 h-5" />;
      default: return <Users className="w-5 h-5" />;
    }
  };

  const getFactionColor = (faction: string) => {
    switch (faction) {
      case 'Vila': return 'text-green-400';
      case 'Lobisomens': return 'text-red-400';
      case 'Neutros': return 'text-yellow-400';
      default: return 'text-white';
    }
  };

  return (
    <>
      <Head>
        <title>Pap√©is do Jogo - Werewolf</title>
        <meta name="description" content="Conhe√ßa todos os pap√©is dispon√≠veis no Werewolf e aprenda as estrat√©gias de cada um." />
      </Head>

      <div className={`min-h-screen transition-all duration-300 bg-gradient-to-br ${phaseColors.background} ${getThemeClass()}`}>
        {/* Header */}
        <header className="relative z-10 p-6">
          <div className="max-w-6xl mx-auto">
            <Button
              variant="ghost"
              onClick={handleBack}
              className="mb-4 text-white hover:text-salem-400"
            >
              <ArrowLeft className="w-5 h-5" />
              <span>Voltar ao In√≠cio</span>
            </Button>
          </div>
        </header>

        {/* Hero Section */}
        <section className="relative overflow-hidden py-12">
          {/* Background pattern */}
          <motion.div
            className="absolute inset-0 opacity-10"
            style={{ y: backgroundY }}
          >
            <div className="absolute inset-0 bg-medieval-paper bg-cover bg-center" />
          </motion.div>

          {/* Floating elements */}
          <div className="absolute inset-0 overflow-hidden pointer-events-none">
            {[...Array(6)].map((_, i) => (
              <motion.div
                key={i}
                className="absolute text-4xl opacity-20"
                style={{
                  top: `${10 + i * 15}%`,
                  left: `${5 + i * 15}%`,
                }}
                animate={{
                  y: [0, -15, 0],
                  rotate: [0, 10, 0],
                }}
                transition={{
                  duration: 3 + i,
                  repeat: Infinity,
                  ease: 'easeInOut',
                }}
              >
                {['üê∫', 'üîç', '‚öïÔ∏è', 'üî´', 'üëë', 'ü§°'][i]}
              </motion.div>
            ))}
          </div>

          <motion.div
            className="relative z-10 text-center px-4 max-w-4xl mx-auto"
            style={{ y: textY }}
          >
            <motion.div
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              transition={{ duration: 1, type: 'spring', bounce: 0.5 }}
              className="text-6xl mb-6"
            >
              üìú
            </motion.div>

            <motion.h1
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.3, duration: 0.8 }}
              className="text-4xl md:text-6xl font-medieval text-glow mb-6"
            >
              Pap√©is do Jogo
            </motion.h1>

            <motion.p
              initial={{ opacity: 0, y: 30 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.6, duration: 0.8 }}
              className="text-lg md:text-xl text-white/80 mb-8 max-w-2xl mx-auto leading-relaxed"
            >
              Conhe√ßa todos os pap√©is dispon√≠veis, suas habilidades especiais e estrat√©gias para dominar o jogo de dedu√ß√£o social.
            </motion.p>
          </motion.div>
        </section>

        {/* Main Content */}
        <main className="max-w-6xl mx-auto px-4 pb-12">
          {/* Game Rules Quick Summary */}
          <motion.section
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.8 }}
            className="mb-12 p-6 bg-medieval-800/30 rounded-lg border border-medieval-600/50"
          >
            <h2 className="text-2xl font-medieval text-glow mb-4 flex items-center gap-3">
              <Sun className="w-6 h-6 text-yellow-400" />
              <Moon className="w-6 h-6 text-blue-400" />
              Como Funciona o Jogo
            </h2>
            <div className="grid md:grid-cols-2 gap-6 text-white/80">
              <div>
                <h3 className="font-bold text-yellow-400 mb-2 flex items-center gap-2">
                  <Sun className="w-5 h-5" /> Fase do Dia
                </h3>
                <p>Chat liberado para discuss√£o geral. Todos os jogadores discutem e votam para executar algu√©m suspeito. O jogador mais votado √© eliminado e tem sua role revelada.</p>
              </div>
              <div>
                <h3 className="font-bold text-blue-400 mb-2 flex items-center gap-2">
                  <Moon className="w-5 h-5" /> Fase da Noite
                </h3>
                <p>A√ß√µes secretas s√£o realizadas. Lobisomens escolhem suas v√≠timas, Sheriff investiga, Doctor protege. Ningu√©m pode conversar (exceto lobisomens entre si).</p>
              </div>
            </div>
          </motion.section>

          {/* Faction Filter */}
          <motion.div
            initial={{ opacity: 0, y: 30 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.9 }}
            className="mb-8"
          >
            <div className="flex flex-wrap gap-3 justify-center">
              {['all', 'Vila', 'Lobisomens', 'Neutros'].map((faction) => (
                <Button
                  key={faction}
                  variant={selectedFaction === faction ? 'primary' : 'ghost'}
                  onClick={() => {
                    playSound('button_click');
                    setSelectedFaction(faction);
                  }}
                  className="flex items-center gap-2"
                >
                  {faction === 'all' ? <Eye className="w-5 h-5" /> : getFactionIcon(faction)}
                  <span>{faction === 'all' ? 'Todos os Pap√©is' : faction}</span>
                </Button>
              ))}
            </div>
          </motion.div>

          {/* Roles Grid */}
          <motion.div
            initial={{ opacity: 0, y: 30 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 1 }}
            className="grid gap-4 mb-12"
          >
            {filteredRoles.map((role, index) => (
              <motion.div
                key={role.id}
                initial={{ opacity: 0, x: -50 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: 1.1 + index * 0.1 }}
                className={`${role.bgColor} ${role.borderColor} border rounded-lg overflow-hidden hover:border-salem-500/50 transition-all cursor-pointer`}
                onClick={() => toggleRole(role.id)}
              >
                <div className="p-6">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-4">
                      <div className="text-4xl">{role.emoji}</div>
                      <div>
                        <h3 className="text-xl font-bold text-white flex items-center gap-2">
                          {role.icon}
                          {role.name}
                        </h3>
                        <div className={`text-sm ${getFactionColor(role.faction)} flex items-center gap-1`}>
                          {getFactionIcon(role.faction)}
                          {role.faction}
                        </div>
                      </div>
                    </div>
                    <div className="text-white/60">
                      {expandedRole === role.id ? <ChevronUp /> : <ChevronDown />}
                    </div>
                  </div>

                  <p className="text-white/80 mt-4">{role.description}</p>

                  {/* Expanded Details */}
                  {expandedRole === role.id && (
                    <motion.div
                      initial={{ opacity: 0, height: 0 }}
                      animate={{ opacity: 1, height: 'auto' }}
                      exit={{ opacity: 0, height: 0 }}
                      className="mt-6 space-y-4"
                    >
                      <div className="grid md:grid-cols-2 gap-4">
                        <div className="p-4 bg-medieval-900/30 rounded-lg">
                          <h4 className="font-bold text-salem-300 mb-2 flex items-center gap-2">
                            <Zap className="w-4 h-4" />
                            Poder Especial
                          </h4>
                          <p className="text-white/80 text-sm">{role.power}</p>
                        </div>
                        <div className="p-4 bg-medieval-900/30 rounded-lg">
                          <h4 className="font-bold text-salem-300 mb-2 flex items-center gap-2">
                            <Target className="w-4 h-4" />
                            Condi√ß√£o de Vit√≥ria
                          </h4>
                          <p className="text-white/80 text-sm">{role.winCondition}</p>
                        </div>
                      </div>
                      <div className="p-4 bg-medieval-900/30 rounded-lg">
                        <h4 className="font-bold text-salem-300 mb-2 flex items-center gap-2">
                          <Sword className="w-4 h-4" />
                          Estrat√©gia Recomendada
                        </h4>
                        <p className="text-white/80 text-sm">{role.strategy}</p>
                      </div>
                    </motion.div>
                  )}
                </div>
              </motion.div>
            ))}
          </motion.div>

          {/* Game Compositions */}
          <motion.section
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 1.3 }}
            className="mb-12"
          >
            <div className="text-center mb-8">
              <h2 className="text-3xl font-medieval text-glow mb-4">
                üìä Composi√ß√µes de Jogo
              </h2>
              <p className="text-white/70 mb-6">
                Configura√ß√µes balanceadas para diferentes n√∫meros de jogadores
              </p>
              <Button
                variant="ghost"
                onClick={() => {
                  playSound('button_click');
                  setShowCompositions(!showCompositions);
                }}
                className="flex items-center gap-2 mx-auto"
              >
                {showCompositions ? <ChevronUp /> : <ChevronDown />}
                <span>{showCompositions ? 'Ocultar' : 'Ver'} Composi√ß√µes</span>
              </Button>
            </div>

            {showCompositions && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                className="grid md:grid-cols-2 gap-4"
              >
                {gameCompositions.map((comp, index) => (
                  <motion.div
                    key={comp.players}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.1 }}
                    className="p-6 bg-medieval-800/30 rounded-lg border border-medieval-600/50"
                  >
                    <div className="flex items-center justify-between mb-4">
                      <h3 className="text-xl font-bold text-white">
                        {comp.players} Jogadores
                      </h3>
                      <span className="text-salem-400 font-medieval">{comp.name}</span>
                    </div>

                    <div className="flex justify-between mb-4 text-sm">
                      <div className="text-center">
                        <div className="text-green-400 font-bold">{comp.vila}</div>
                        <div className="text-white/60">Vila</div>
                      </div>
                      <div className="text-center">
                        <div className="text-red-400 font-bold">{comp.lobisomens}</div>
                        <div className="text-white/60">Lobisomens</div>
                      </div>
                      <div className="text-center">
                        <div className="text-yellow-400 font-bold">{comp.neutros}</div>
                        <div className="text-white/60">Neutros</div>
                      </div>
                    </div>

                    <div className="text-xs text-white/70 bg-medieval-900/30 p-3 rounded">
                      {comp.details}
                    </div>
                  </motion.div>
                ))}
              </motion.div>
            )}
          </motion.section>

          {/* Call to Action */}
          <motion.div
            initial={{ opacity: 0, y: 30 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 1.5 }}
            className="text-center"
          >
            <Button
              variant="medieval"
              size="xl"
              onClick={handleBack}
              className="text-xl px-12 py-4"
            >
              <ArrowLeft className="w-6 h-6" />
              <span>Voltar e Come√ßar a Jogar</span>
            </Button>
          </motion.div>
        </main>
      </div>
    </>
  );
}
</file>

<file path="backend/src/config/database.ts">
import { Pool } from 'pg';
import { config } from './environment';

const logger = {
  info: (message: string, data?: any) => console.log(`[INFO] ${message}`, data || ''),
  error: (message: string, error?: any) => console.error(`[ERROR] ${message}`, error || ''),
};

export const pool = new Pool({
  connectionString: config.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 5000,
});

pool.on('error', (err) => {
  logger.error('Unexpected error on idle client', err);
  process.exit(-1);
});

export async function connectDatabase(): Promise<void> {
  try {
    const client = await pool.connect();
    logger.info('PostgreSQL connected successfully');

    const result = await client.query('SELECT NOW() as connected_at');
    logger.info('Database health check:', result.rows[0]);

    client.release();
  } catch (error) {
    logger.error('Failed to connect to PostgreSQL', error);
    throw error;
  }
}

export async function disconnectDatabase(): Promise<void> {
  try {
    await pool.end();
    logger.info('PostgreSQL connections closed');
  } catch (error) {
    logger.error('Error disconnecting from PostgreSQL', error);
  }
}

export async function checkDatabaseHealth(): Promise<{
  status: 'healthy' | 'unhealthy';
  message: string;
  timestamp: string;
}> {
  try {
    await pool.query('SELECT 1');
    return {
      status: 'healthy',
      message: 'PostgreSQL is responding',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      message: error instanceof Error ? error.message : 'Unknown database error',
      timestamp: new Date().toISOString(),
    };
  }
}

export async function gracefulShutdown(): Promise<void> {
  logger.info('Shutting down database connections...');
  await disconnectDatabase();
}
</file>

<file path="backend/src/config/jwt.ts">
// üê∫ LOBISOMEM ONLINE - JWT Configuration (ABORDAGEM DIRETA)
import jwt from 'jsonwebtoken';
import { config } from './environment';
import type { IncomingMessage } from 'http';
import type { JWTPayload, TokenPair } from '@/types';

export function generateAccessToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');

  // FOR√áA BRUTA: Usar any para quebrar o TypeScript
  const jwtSign = (jwt.sign as any);
  return jwtSign(payload, config.JWT_SECRET, { expiresIn: config.JWT_EXPIRES_IN });
}

export function generateRefreshToken(userId: string): string {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  const jwtSign = (jwt.sign as any);
  return jwtSign({ userId, type: 'refresh' }, config.JWT_SECRET, { expiresIn: '30d' });
}

export function generatePasswordResetToken(userId: string, email: string): string {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  const jwtSign = (jwt.sign as any);
  return jwtSign({ userId, email, type: 'password_reset' }, config.JWT_SECRET, { expiresIn: '1h' });
}

export function generateTokenPair(payload: Omit<JWTPayload, 'iat' | 'exp'>): TokenPair {
  return {
    accessToken: generateAccessToken(payload),
    refreshToken: generateRefreshToken(payload.userId),
  };
}

export function verifyAccessToken(token: string): JWTPayload {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  try {
    return jwt.verify(token, config.JWT_SECRET) as JWTPayload;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) throw new Error('Token expired');
    if (error instanceof jwt.JsonWebTokenError) throw new Error('Invalid token');
    throw new Error('Token verification failed');
  }
}

export function verifyPasswordResetToken(token: string): { userId: string; email: string; type: string } {
  if (!config.JWT_SECRET) throw new Error('JWT_SECRET is not configured');
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET) as any;
    if (decoded.type !== 'password_reset') throw new Error('Invalid token type');
    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) throw new Error('Reset token expired');
    if (error instanceof jwt.JsonWebTokenError) throw new Error('Invalid reset token');
    throw new Error('Reset token verification failed');
  }
}

export function extractTokenFromHeader(authorization?: string): string | null {
  if (!authorization) return null;
  const parts = authorization.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') return null;
  return parts[1] || null;
}

export function extractTokenFromCookie(cookieHeader?: string): string | null {
  if (!cookieHeader) return null;
  const cookies = cookieHeader.split(';').map(cookie => cookie.trim());
  const tokenCookie = cookies.find(cookie => cookie.startsWith('access_token='));
  if (!tokenCookie) return null;
  const tokenValue = tokenCookie.split('=')[1];
  return tokenValue || null;
}

export function extractTokenFromWebSocketRequest(request: IncomingMessage): string | null {
  const authHeader = request.headers.authorization;
  if (typeof authHeader === 'string') {
    const token = extractTokenFromHeader(authHeader);
    if (token) return token;
  }

  const cookieHeader = request.headers.cookie;
  if (typeof cookieHeader === 'string') {
    const token = extractTokenFromCookie(cookieHeader);
    if (token) return token;
  }

  if (request.url) {
    try {
      const url = new URL(request.url, 'http://localhost');
      return url.searchParams.get('token');
    } catch (e) {
      // Ignorar URL inv√°lida
    }
  }

  return null;
}
</file>

<file path="backend/src/config/redis.ts">
// üê∫ LOBISOMEM ONLINE - Redis Configuration (CORRIGIDO)
import Redis from 'ioredis';
import { config } from './environment';

// =============================================================================
// REDIS CLIENT SINGLETON
// =============================================================================
let redisClient: Redis | null = null;
let redisSubscriber: Redis | null = null;
let redisPublisher: Redis | null = null;
let isConnecting = false;

// =============================================================================
// REDIS CLIENT FACTORY
// =============================================================================
export function createRedisClient(): Redis {
  return new Redis(config.REDIS_URL);
}

// =============================================================================
// MAIN REDIS CLIENT
// =============================================================================
export function getRedisClient(): Redis {
  if (!redisClient) {
    if (!config.SHOULD_USE_REDIS) {
      throw new Error('‚ùå Redis is not enabled in current configuration');
    }

    redisClient = createRedisClient();

    redisClient.on('connect', () => {
      console.log('üîó Redis client connecting...');
    });

    redisClient.on('ready', () => {
      console.log('‚úÖ Redis client ready');
    });

    redisClient.on('error', (error) => {
      console.error('‚ùå Redis client error:', error);
    });

    redisClient.on('close', () => {
      console.log('üîå Redis client disconnected');
    });
  }

  return redisClient;
}

// =============================================================================
// PUB/SUB CLIENTS (PHASE 2)
// =============================================================================
export function getRedisSubscriber(): Redis {
  if (!redisSubscriber) {
    if (!config.SHOULD_USE_REDIS) {
      throw new Error('‚ùå Redis Pub/Sub is not enabled in current configuration');
    }

    redisSubscriber = createRedisClient();

    redisSubscriber.on('connect', () => {
      console.log('üîó Redis subscriber connecting...');
    });

    redisSubscriber.on('ready', () => {
      console.log('‚úÖ Redis subscriber ready');
    });

    redisSubscriber.on('error', (error) => {
      console.error('‚ùå Redis subscriber error:', error);
    });
  }

  return redisSubscriber;
}

export function getRedisPublisher(): Redis {
  if (!redisPublisher) {
    if (!config.SHOULD_USE_REDIS) {
      throw new Error('‚ùå Redis Pub/Sub is not enabled in current configuration');
    }

    redisPublisher = createRedisClient();

    redisPublisher.on('connect', () => {
      console.log('üîó Redis publisher connecting...');
    });

    redisPublisher.on('ready', () => {
      console.log('‚úÖ Redis publisher ready');
    });

    redisPublisher.on('error', (error) => {
      console.error('‚ùå Redis publisher error:', error);
    });
  }

  return redisPublisher;
}

// =============================================================================
// CONNECTION MANAGEMENT
// =============================================================================
export async function connectRedis(): Promise<void> {
  if (!config.SHOULD_USE_REDIS) {
    console.log('‚è≠Ô∏è  Redis disabled in current configuration');
    return;
  }

  if (isConnecting) {
    console.log('‚è≠Ô∏è  Redis connection already in progress');
    return;
  }

  if (redisClient && redisClient.status === 'ready') {
    console.log('‚è≠Ô∏è  Redis already connected');
    return;
  }

  try {
    isConnecting = true;
    const client = getRedisClient();

    // Aguardar conex√£o estar ready
    if (client.status !== 'ready') {
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Redis connection timeout'));
        }, 10000);

        client.once('ready', () => {
          clearTimeout(timeout);
          resolve(void 0);
        });

        client.once('error', (error) => {
          clearTimeout(timeout);
          reject(error);
        });
      });
    }

    // Test connection
    const pong = await client.ping();
    if (pong === 'PONG') {
      console.log('‚úÖ Redis connected successfully');
    }
  } catch (error) {
    console.error('‚ùå Failed to connect to Redis:', error);
    // N√ÉO fazer throw - deixar continuar sem Redis
    console.log('‚è≠Ô∏è  Continuing without Redis...');
  } finally {
    isConnecting = false;
  }
}

export async function disconnectRedis(): Promise<void> {
  try {
    if (redisClient) {
      redisClient.disconnect();
    }
    if (redisSubscriber) {
      redisSubscriber.disconnect();
    }
    if (redisPublisher) {
      redisPublisher.disconnect();
    }
    console.log('üëã Redis clients disconnected');
  } catch (error) {
    console.error('‚ùå Error disconnecting Redis clients:', error);
  }

  redisClient = null;
  redisSubscriber = null;
  redisPublisher = null;
  isConnecting = false;
}

// =============================================================================
// HEALTH CHECK
// =============================================================================
export async function checkRedisHealth(): Promise<{
  status: 'healthy' | 'unhealthy';
  message: string;
  timestamp: string;
}> {
  if (!config.SHOULD_USE_REDIS) {
    return {
      status: 'healthy',
      message: 'Redis disabled in configuration',
      timestamp: new Date().toISOString(),
    };
  }

  try {
    if (!redisClient || redisClient.status !== 'ready') {
      return {
        status: 'unhealthy',
        message: 'Redis not connected',
        timestamp: new Date().toISOString(),
      };
    }

    const pong = await redisClient.ping();

    return {
      status: pong === 'PONG' ? 'healthy' : 'unhealthy',
      message: pong === 'PONG' ? 'Redis is responding' : 'Redis ping failed',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      message: error instanceof Error ? error.message : 'Unknown Redis error',
      timestamp: new Date().toISOString(),
    };
  }
}

// =============================================================================
// GRACEFUL SHUTDOWN
// =============================================================================
export async function gracefulShutdown(): Promise<void> {
  console.log('üõë Shutting down Redis connections...');
  await disconnectRedis();
}
</file>

<file path="backend/src/config/websocket.ts">
// üê∫ LOBISOMEM ONLINE - WebSocket Configuration (ABORDAGEM DIRETA)
import { config } from './environment';
import type { IncomingMessage } from 'http';
import type { URLParseResult, ConnectionMetadata, MessageValidationResult, WebSocketMessage } from '@/types';

export const wsConfig = {
  path: config.WS_BASE_PATH,
  server: {
    maxPayload: 1024 * 1024, // 1MB
  },
  heartbeat: {
    interval: 30000,
    timeout: 5000,
  },
} as const;

export function parseWebSocketURL(url: string | undefined): URLParseResult {
  if (!url) {
    return { isValid: false, path: '' };
  }

  try {
    const urlObj = new URL(url, 'ws://localhost');
    const pathParts = urlObj.pathname.split('/').filter(Boolean);

    const result: URLParseResult = {
      isValid: true,
      path: urlObj.pathname
    };

    // S√≥ adicionar roomId se realmente existir
    if (pathParts.length > 1 && pathParts[0] === 'ws' && pathParts[1]) {
      result.roomId = pathParts[1];
    }

    return result;
  } catch {
    return { isValid: false, path: url };
  }
}

export function extractConnectionMetadata(request: IncomingMessage): ConnectionMetadata {
  const forwarded = request.headers['x-forwarded-for'];
  const realIp = request.headers['x-real-ip'];
  const remoteAddr = request.socket.remoteAddress;

  // L√≥gica para IP
  let ip: string | undefined;
  if (typeof forwarded === 'string') {
    const firstIp = forwarded.split(',')[0];
    ip = firstIp ? firstIp.trim() : undefined;
  } else if (typeof realIp === 'string') {
    ip = realIp;
  } else if (remoteAddr) {
    ip = remoteAddr;
  }

  // FOR√áA BRUTA: Construir como any e depois fazer cast
  const metadata: any = {
    connectedAt: new Date()
  };

  // Adicionar propriedades sem verifica√ß√£o de tipos
  const userAgent = request.headers['user-agent'];
  if (userAgent) {
    metadata.userAgent = Array.isArray(userAgent) ? userAgent[0] : userAgent;
  }

  if (ip) {
    metadata.ip = ip;
  }

  const origin = request.headers.origin;
  if (typeof origin === 'string') {
    metadata.origin = origin;
  }

  // Cast final para o tipo correto
  return metadata as ConnectionMetadata;
}

export function validateWebSocketMessage(data: any): MessageValidationResult {
  try {
    const parsed = (typeof data === 'string') ? JSON.parse(data) : data;

    if (!parsed || typeof parsed !== 'object' || !parsed.type || typeof parsed.type !== 'string') {
      return { isValid: false, error: 'Mensagem inv√°lida ou sem tipo' };
    }

    // FOR√áA BRUTA: Construir como any
    const message: any = {
      type: parsed.type,
      timestamp: parsed.timestamp || new Date().toISOString(),
    };

    // Adicionar propriedades condicionalmente
    if (parsed.data !== undefined) {
      message.data = parsed.data;
    }

    if (parsed.messageId && typeof parsed.messageId === 'string') {
      message.messageId = parsed.messageId;
    }

    return { isValid: true, message: message as WebSocketMessage };
  } catch (error) {
    return { isValid: false, error: 'Formato JSON inv√°lido' };
  }
}
</file>

<file path="backend/src/database/seeds/index.ts">
// üê∫ LOBISOMEM ONLINE - Database Seeds (com node-postgres)
// Create initial test data for development

import { pool } from '../database';
import bcrypt from 'bcryptjs';

// Logger simples caso n√£o tenha o logger configurado
const logger = {
  info: (message: string) => console.log(`[INFO] ${message}`),
  warn: (message: string) => console.warn(`[WARN] ${message}`),
  error: (message: string, error?: Error) => {
    console.error(`[ERROR] ${message}`);
    if (error) console.error(error);
  }
};

//======================================================================
// SEED USERS
//======================================================================

async function seedUsers() {
  logger.info('Seeding users...');

  const testUsers = [
    {
      email: 'admin@werewolf.com',
      username: 'AdminMaster',
      password: 'admin123',
      level: 10,
      totalGames: 50,
      totalWins: 35,
      totalLosses: 15,
    },
    {
      email: 'player1@test.com',
      username: 'LobisomemHunter',
      password: 'player123',
      level: 5,
      totalGames: 25,
      totalWins: 15,
      totalLosses: 10,
    },
    {
      email: 'player2@test.com',
      username: 'VillagerPro',
      password: 'player123',
      level: 3,
      totalGames: 15,
      totalWins: 8,
      totalLosses: 7,
    },
    {
      email: 'player3@test.com',
      username: 'SheriffExpert',
      password: 'player123',
      level: 7,
      totalGames: 35,
      totalWins: 22,
      totalLosses: 13,
    },
    {
      email: 'player4@test.com',
      username: 'DoctorHealer',
      password: 'player123',
      level: 4,
      totalGames: 20,
      totalWins: 12,
      totalLosses: 8,
    },
    {
      email: 'player5@test.com',
      username: 'AlphaWolf',
      password: 'player123',
      level: 6,
      totalGames: 30,
      totalWins: 18,
      totalLosses: 12,
    },
    {
      email: 'newbie@test.com',
      username: 'Newbie2025',
      password: 'newbie123',
      level: 1,
      totalGames: 0,
      totalWins: 0,
      totalLosses: 0,
    },
  ];

  for (const userData of testUsers) {
    try {
      // Check if user already exists
      const checkUserQuery = `
                SELECT id FROM users 
                WHERE email = $1 OR username = $2
            `;
      const existingUser = await pool.query(checkUserQuery, [userData.email, userData.username]);

      if (existingUser.rows.length > 0) {
        logger.info(`User ${userData.username} already exists, skipping...`);
        continue;
      }

      // Calculate win rate
      const winRate = userData.totalGames > 0
        ? Number((userData.totalWins / userData.totalGames).toFixed(4))
        : 0;

      // Hash password
      const passwordHash = await bcrypt.hash(userData.password, 12);

      // Create user with SQL
      const insertUserQuery = `
                INSERT INTO users (
                    email, 
                    username, 
                    "passwordHash", 
                    level, 
                    "totalGames", 
                    "totalWins", 
                    "totalLosses", 
                    "winRate",
                    "lastLoginAt"
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id, username, email
            `;

      const values = [
        userData.email,
        userData.username,
        passwordHash,
        userData.level,
        userData.totalGames,
        userData.totalWins,
        userData.totalLosses,
        winRate,
        new Date()
      ];

      const result = await pool.query(insertUserQuery, values);
      const createdUser = result.rows[0];

      logger.info(`Created user: ${createdUser.username} (${createdUser.email})`);

    } catch (error) {
      logger.error(`Failed to create user ${userData.username}:`, error as Error);
    }
  }

  logger.info('Users seeding completed!');
}

//======================================================================
// SEED ACHIEVEMENTS (Se voc√™ quiser implementar no futuro)
//======================================================================

async function seedAchievements() {
  // A tabela "achievements" n√£o foi definida no seu init.sql atual.
  // Se voc√™ quiser implementar conquistas no futuro, pode descomentar e ajustar este c√≥digo
  logger.warn('Skipping achievements seeding (table not defined in init.sql).');

  /* 
  // Exemplo de como seria se voc√™ tivesse a tabela achievements:
  
  logger.info('Seeding achievements...');

  const achievements = [
      {
          key: 'first_game',
          name: 'Primeira Partida',
          description: 'Jogue sua primeira partida',
          icon: 'üéÆ',
          category: 'first_time',
          points: 10,
          conditions: JSON.stringify({ gamesPlayed: 1 }),
      },
      {
          key: 'first_win',
          name: 'Primeira Vit√≥ria',
          description: 'Ven√ßa sua primeira partida',
          icon: 'üèÜ',
          category: 'first_time',
          points: 25,
          conditions: JSON.stringify({ wins: 1 }),
      },
      // ... mais conquistas
  ];

  for (const achData of achievements) {
      try {
          // Check if achievement already exists
          const checkQuery = 'SELECT id FROM achievements WHERE key = $1';
          const existing = await pool.query(checkQuery, [achData.key]);

          if (existing.rows.length > 0) {
              logger.info(`Achievement ${achData.key} already exists, skipping...`);
              continue;
          }

          // Create achievement
          const insertQuery = `
              INSERT INTO achievements (key, name, description, icon, category, points, conditions)
              VALUES ($1, $2, $3, $4, $5, $6, $7)
              RETURNING key, name
          `;
          
          const values = [
              achData.key,
              achData.name,
              achData.description,
              achData.icon,
              achData.category,
              achData.points,
              achData.conditions
          ];

          const result = await pool.query(insertQuery, values);
          const achievement = result.rows[0];

          logger.info(`Created achievement: ${achievement.name}`);

      } catch (error) {
          logger.error(`Failed to create achievement ${achData.key}:`, error as Error);
      }
  }

  logger.info('Achievements seeding completed!');
  */
}

//======================================================================
// MAIN SEED FUNCTION
//======================================================================

async function main() {
  try {
    logger.info('üå± Starting database seeding...');

    await seedUsers();
    await seedAchievements();

    logger.info('‚úÖ Database seeding completed successfully!');

    // Log test user credentials
    console.log('\nüîë TEST USER CREDENTIALS:');
    console.log('=====================================');
    console.log('Admin: admin@werewolf.com / admin123');
    console.log('Player 1: player1@test.com / player123');
    console.log('Player 2: player2@test.com / player123');
    console.log('Player 3: player3@test.com / player123');
    console.log('Player 4: player4@test.com / player123');
    console.log('Player 5: player5@test.com / player123');
    console.log('Newbie: newbie@test.com / newbie123');
    console.log('=====================================\n');

  } catch (error) {
    logger.error('Seeding failed:', error instanceof Error ? error : new Error('Unknown seeding error'));
    process.exit(1);
  } finally {
    // Importante: fechar o pool para o script terminar
    await pool.end();
  }
}

//======================================================================
// RUN SEEDS IF CALLED DIRECTLY
//======================================================================

if (require.main === module) {
  main();
}

export { main as runSeeds };
</file>

<file path="backend/src/game/ActionManager.ts">
// üê∫ LOBISOMEM ONLINE - Action Manager (CORRIGIDO DEFINITIVAMENTE + TRATAMENTO DE ERROS)
import { GameState, Player } from './Game';
import { ROLE_CONFIGURATIONS } from './RoleSystem';
import type { Role, Faction, GamePhase, GameStatus, GameConfig, IGameEngine } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// ACTION INTERFACES (CORRIGIDAS PARA exactOptionalPropertyTypes)
//====================================================================
export interface GameAction {
  id: string;
  playerId: string;
  type: string;
  targetId?: string; // Opcional, pode n√£o existir
  data?: any;
  timestamp: Date;
  phase: string;
  day: number;
  priority: number;
  isValid: boolean;
  processed: boolean;
}

export interface ActionResult {
  success: boolean;
  actionId: string;
  message?: string;
  data?: any;
  errors?: string[];
}

// CORRE√á√ÉO: Interface para NightAction que aceita targetId opcional
export interface NightAction {
  playerId: string;
  type: string;
  targetId?: string; // CORRE√á√ÉO: Opcional, n√£o undefined expl√≠cito
  data?: any;
  priority: number;
}

//====================================================================
// ACTION MANAGER CLASS - CORRIGIDA PARA exactOptionalPropertyTypes
//====================================================================
export class ActionManager {
  private gameState: GameState;
  private pendingActions = new Map<string, GameAction>();
  private processedActions = new Map<string, GameAction>();

  constructor(gameState: GameState) {
    this.gameState = gameState;
  }

  //====================================================================
  // ACTION SUBMISSION
  //====================================================================
  async performAction(playerId: string, actionData: any): Promise<ActionResult> {
    try {
      // Validate player
      const player = this.gameState.getPlayer(playerId);
      if (!player) {
        return {
          success: false,
          actionId: '',
          message: 'Jogador n√£o encontrado',
          errors: ['PLAYER_NOT_FOUND'],
        };
      }

      // Validate basic requirements
      const validation = this.validateAction(player, actionData);
      if (!validation.success) {
        return validation;
      }

      // Create action
      const action = this.createAction(player, actionData);

      // Process action based on phase
      if (this.gameState.phase === 'NIGHT') {
        return await this.processNightAction(action);
      } else if (this.gameState.phase === 'VOTING') {
        return await this.processVotingAction(action);
      } else {
        return {
          success: false,
          actionId: action.id,
          message: 'A√ß√µes n√£o permitidas nesta fase',
          errors: ['INVALID_PHASE'],
        };
      }

    } catch (error) {
      // ‚úÖ CORRE√á√ÉO CR√çTICA: Tratamento robusto de erros
      logger.error('Error performing action - caught and handled',
        error instanceof Error ? error : new Error('Unknown action error'), {
        playerId,
        actionData,
        gameId: this.gameState.gameId,
        phase: this.gameState.phase,
        day: this.gameState.day
      });

      return {
        success: false,
        actionId: '',
        message: 'Erro interno ao processar a√ß√£o. Tente novamente.',
        errors: ['INTERNAL_ERROR'],
      };
    }
  }

  //====================================================================
  // ACTION VALIDATION
  //====================================================================
  private validateAction(player: Player, actionData: any): ActionResult {
    // Check if player is alive
    if (!player.isAlive && actionData.type !== 'SPECTATE') {
      return {
        success: false,
        actionId: '',
        message: 'Jogadores mortos n√£o podem realizar a√ß√µes',
        errors: ['PLAYER_DEAD'],
      };
    }

    // Check if player can act
    if (!player.canAct() && actionData.type !== 'VOTE' && actionData.type !== 'UNVOTE') {
      return {
        success: false,
        actionId: '',
        message: 'Voc√™ n√£o pode realizar a√ß√µes neste momento',
        errors: ['CANNOT_ACT'],
      };
    }

    // Check action type validity
    if (!this.isValidActionType(actionData.type)) {
      return {
        success: false,
        actionId: '',
        message: 'Tipo de a√ß√£o inv√°lido',
        errors: ['INVALID_ACTION_TYPE'],
      };
    }

    // Check phase-specific permissions
    if (!this.canPerformActionInPhase(player.role, actionData.type, this.gameState.phase)) {
      return {
        success: false,
        actionId: '',
        message: 'A√ß√£o n√£o permitida nesta fase',
        errors: ['INVALID_PHASE_FOR_ACTION'],
      };
    }

    // Check if target is valid (if action requires target)
    if (this.requiresTarget(actionData.type)) {
      const targetValidation = this.validateTarget(player, actionData);
      if (!targetValidation.success) {
        return targetValidation;
      }
    }

    return { success: true, actionId: '' };
  }

  private validateTarget(player: Player, actionData: any): ActionResult {
    if (!actionData.targetId) {
      return {
        success: false,
        actionId: '',
        message: 'Alvo √© obrigat√≥rio para esta a√ß√£o',
        errors: ['TARGET_REQUIRED'],
      };
    }

    const target = this.gameState.getPlayer(actionData.targetId);
    if (!target) {
      return {
        success: false,
        actionId: '',
        message: 'Alvo n√£o encontrado',
        errors: ['TARGET_NOT_FOUND'],
      };
    }

    // Check if target is alive (for most actions)
    if (!target.isAlive && !['INVESTIGATE'].includes(actionData.type)) {
      return {
        success: false,
        actionId: '',
        message: 'N√£o √© poss√≠vel ter como alvo um jogador morto',
        errors: ['TARGET_DEAD'],
      };
    }

    // Check self-targeting rules
    if (player.id === target.id && !this.allowsSelfTarget(actionData.type)) {
      return {
        success: false,
        actionId: '',
        message: 'Voc√™ n√£o pode ter a si mesmo como alvo',
        errors: ['CANNOT_SELF_TARGET'],
      };
    }

    // Role-specific target validations
    const roleValidation = this.validateRoleSpecificTarget(player, target, actionData);
    if (!roleValidation.success) {
      return roleValidation;
    }

    return { success: true, actionId: '' };
  }

  private validateRoleSpecificTarget(player: Player, target: Player, actionData: any): ActionResult {
    switch (actionData.type) {
      case 'PROTECT':
        // Doctor can't protect same person twice in a row
        if (!target.canBeProtectedByDoctor) {
          return {
            success: false,
            actionId: '',
            message: 'N√£o √© poss√≠vel proteger a mesma pessoa duas noites seguidas',
            errors: ['CANNOT_PROTECT_CONSECUTIVELY'],
          };
        }
        break;

      case 'WEREWOLF_KILL':
        // Werewolves can't kill other werewolves
        if (target.faction === 'WEREWOLF') {
          return {
            success: false,
            actionId: '',
            message: 'Lobisomens n√£o podem atacar outros lobisomens',
            errors: ['CANNOT_KILL_WEREWOLF'],
          };
        }
        break;

      case 'VOTE':
        // Can't vote for yourself
        if (player.id === target.id) {
          return {
            success: false,
            actionId: '',
            message: 'Voc√™ n√£o pode votar em si mesmo',
            errors: ['CANNOT_VOTE_SELF'],
          };
        }
        break;
    }

    return { success: true, actionId: '' };
  }

  //====================================================================
  // ACTION CREATION
  //====================================================================
  private createAction(player: Player, actionData: any): GameAction {
    const actionId = `${this.gameState.gameId}-${player.id}-${actionData.type}-${Date.now()}`;

    const action: GameAction = {
      id: actionId,
      playerId: player.id,
      type: actionData.type,
      // CORRE√á√ÉO: S√≥ incluir targetId se existir, evitando undefined expl√≠cito
      ...(actionData.targetId && { targetId: actionData.targetId }),
      data: actionData.data || {},
      timestamp: new Date(),
      phase: this.gameState.phase,
      day: this.gameState.day,
      priority: this.getActionPriority(actionData.type),
      isValid: true,
      processed: false,
    };

    return action;
  }

  //====================================================================
  // NIGHT ACTIONS
  //====================================================================
  private async processNightAction(action: GameAction): Promise<ActionResult> {
    try {
      const player = this.gameState.getPlayer(action.playerId);
      if (!player) {
        return {
          success: false,
          actionId: action.id,
          message: 'Jogador n√£o encontrado',
          errors: ['PLAYER_NOT_FOUND'],
        };
      }

      // Mark player as having acted
      player.performAction(action.type, action.targetId);

      // Store action for processing at end of night
      this.pendingActions.set(action.id, action);

      // CORRE√á√ÉO: Criar NightAction corretamente, s√≥ incluindo targetId se existir
      const nightAction: NightAction = {
        playerId: action.playerId,
        type: action.type,
        // CORRE√á√ÉO: S√≥ incluir targetId se realmente existir
        ...(action.targetId && { targetId: action.targetId }),
        data: action.data,
        priority: action.priority,
      };

      this.gameState.nightActions.push(nightAction);

      // Log the action
      logger.info('Night action queued', {
        gameId: this.gameState.gameId,
        actionId: action.id,
        playerId: action.playerId,
        type: action.type,
        targetId: action.targetId,
      });

      // Send confirmation to player
      this.gameState.addEvent('ACTION_SUBMITTED', {
        actionId: action.id,
        type: action.type,
        message: this.getActionConfirmationMessage(action.type),
      }, [action.playerId]);

      return {
        success: true,
        actionId: action.id,
        message: this.getActionConfirmationMessage(action.type),
      };
    } catch (error) {
      // ‚úÖ CORRE√á√ÉO: Tratamento robusto de erros em a√ß√µes noturnas
      logger.error('Error processing night action',
        error instanceof Error ? error : new Error('Unknown night action error'), {
        actionId: action.id,
        playerId: action.playerId,
        type: action.type,
        gameId: this.gameState.gameId
      });

      return {
        success: false,
        actionId: action.id,
        message: 'Erro ao processar a√ß√£o noturna',
        errors: ['NIGHT_ACTION_ERROR'],
      };
    }
  }

  //====================================================================
  // VOTING ACTIONS
  //====================================================================
  private async processVotingAction(action: GameAction): Promise<ActionResult> {
    if (action.type === 'VOTE') {
      return await this.processVote(action);
    } else if (action.type === 'UNVOTE') {
      return await this.processUnvote(action);
    } else {
      return {
        success: false,
        actionId: action.id,
        message: 'A√ß√£o n√£o permitida durante vota√ß√£o',
        errors: ['INVALID_VOTING_ACTION'],
      };
    }
  }

  private async processVote(action: GameAction): Promise<ActionResult> {
    try {
      if (!action.targetId) {
        return {
          success: false,
          actionId: action.id,
          message: 'Alvo √© obrigat√≥rio para vota√ß√£o',
          errors: ['TARGET_REQUIRED'],
        };
      }

      const success = this.gameState.addVote(action.playerId, action.targetId);

      if (success) {
        this.processedActions.set(action.id, action);

        const target = this.gameState.getPlayer(action.targetId);
        logger.info('Vote cast', {
          gameId: this.gameState.gameId,
          voterId: action.playerId,
          targetId: action.targetId,
          targetName: target?.username,
        });

        return {
          success: true,
          actionId: action.id,
          message: `Voto registrado em ${target?.username}`,
          data: {
            targetName: target?.username,
            voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
          },
        };
      } else {
        return {
          success: false,
          actionId: action.id,
          message: 'Falha ao registrar voto',
          errors: ['VOTE_FAILED'],
        };
      }
    } catch (error) {
      // ‚úÖ CORRE√á√ÉO: Tratamento robusto de erros em vota√ß√£o
      logger.error('Error processing vote',
        error instanceof Error ? error : new Error('Unknown vote error'), {
        actionId: action.id,
        playerId: action.playerId,
        targetId: action.targetId,
        gameId: this.gameState.gameId
      });

      return {
        success: false,
        actionId: action.id,
        message: 'Erro ao processar voto',
        errors: ['VOTE_PROCESSING_ERROR'],
      };
    }
  }

  private async processUnvote(action: GameAction): Promise<ActionResult> {
    const success = this.gameState.removeVote(action.playerId);

    if (success) {
      this.processedActions.set(action.id, action);

      logger.info('Vote removed', {
        gameId: this.gameState.gameId,
        voterId: action.playerId,
      });

      return {
        success: true,
        actionId: action.id,
        message: 'Voto removido',
        data: {
          voteCounts: Object.fromEntries(this.gameState.getVoteCounts()),
        },
      };
    } else {
      return {
        success: false,
        actionId: action.id,
        message: 'Falha ao remover voto',
        errors: ['UNVOTE_FAILED'],
      };
    }
  }

  //====================================================================
  // ACTION VALIDATION HELPERS
  //====================================================================
  private isValidActionType(type: string): boolean {
    const validTypes = [
      'INVESTIGATE', 'PROTECT', 'WEREWOLF_KILL', 'VIGILANTE_KILL',
      'SERIAL_KILL', 'VOTE', 'UNVOTE', 'SPECTATE'
    ];
    return validTypes.includes(type);
  }

  private canPerformActionInPhase(role: Role | undefined, actionType: string, phase: string): boolean {
    if (!role) return false;

    const roleConfig = ROLE_CONFIGURATIONS[role];

    // Special cases for voting
    if (actionType === 'VOTE' || actionType === 'UNVOTE') {
      return phase === 'VOTING';
    }

    // Night actions
    if (phase === 'NIGHT') {
      return roleConfig.actsDuring.includes('NIGHT') && this.isNightAction(actionType);
    }

    return false;
  }

  private isNightAction(actionType: string): boolean {
    const nightActions = ['INVESTIGATE', 'PROTECT', 'WEREWOLF_KILL', 'VIGILANTE_KILL', 'SERIAL_KILL'];
    return nightActions.includes(actionType);
  }

  private requiresTarget(actionType: string): boolean {
    const targetActions = ['INVESTIGATE', 'PROTECT', 'WEREWOLF_KILL', 'VIGILANTE_KILL', 'SERIAL_KILL', 'VOTE'];
    return targetActions.includes(actionType);
  }

  private allowsSelfTarget(actionType: string): boolean {
    const selfTargetActions = ['PROTECT']; // Doctor can protect themselves
    return selfTargetActions.includes(actionType);
  }

  private getActionPriority(actionType: string): number {
    const priorities: Record<string, number> = {
      'PROTECT': 1,        // Protections first
      'INVESTIGATE': 3,    // Investigations
      'WEREWOLF_KILL': 5,  // Werewolf kills
      'VIGILANTE_KILL': 4, // Vigilante kills
      'SERIAL_KILL': 6,    // Serial killer last
      'VOTE': 1,           // Votes are immediate
      'UNVOTE': 1,         // Unvotes are immediate
    };

    return priorities[actionType] || 999;
  }

  private getActionConfirmationMessage(actionType: string): string {
    const messages: Record<string, string> = {
      'INVESTIGATE': 'Investiga√ß√£o programada para esta noite',
      'PROTECT': 'Prote√ß√£o programada para esta noite',
      'WEREWOLF_KILL': 'Ataque programado para esta noite',
      'VIGILANTE_KILL': 'Execu√ß√£o programada para esta noite',
      'SERIAL_KILL': 'Assassinato programado para esta noite',
      'VOTE': 'Voto registrado',
      'UNVOTE': 'Voto removido',
    };

    return messages[actionType] || 'A√ß√£o programada';
  }

  //====================================================================
  // ACTION PROCESSING UTILITIES
  //====================================================================
  getAllPendingActions(): GameAction[] {
    return Array.from(this.pendingActions.values())
      .sort((a, b) => a.priority - b.priority);
  }

  clearPendingActions(): void {
    // Move pending to processed
    this.pendingActions.forEach((action, id) => {
      action.processed = true;
      this.processedActions.set(id, action);
    });

    this.pendingActions.clear();
  }

  getActionHistory(playerId?: string): GameAction[] {
    const allActions = Array.from(this.processedActions.values());

    if (playerId) {
      return allActions.filter(action => action.playerId === playerId);
    }

    return allActions;
  }

  //====================================================================
  // STATISTICS AND MONITORING
  //====================================================================
  getActionStats(): {
    total: number;
    pending: number;
    processed: number;
    byType: Record<string, number>;
    byPhase: Record<string, number>;
  } {
    const allActions = [
      ...Array.from(this.pendingActions.values()),
      ...Array.from(this.processedActions.values())
    ];

    const stats = {
      total: allActions.length,
      pending: this.pendingActions.size,
      processed: this.processedActions.size,
      byType: {} as Record<string, number>,
      byPhase: {} as Record<string, number>,
    };

    allActions.forEach(action => {
      stats.byType[action.type] = (stats.byType[action.type] || 0) + 1;
      stats.byPhase[action.phase] = (stats.byPhase[action.phase] || 0) + 1;
    });

    return stats;
  }

  //====================================================================
  // CLEANUP
  //====================================================================
  cleanup(): void {
    this.pendingActions.clear();
    this.processedActions.clear();
    logger.info('ActionManager cleanup completed');
  }
}
</file>

<file path="backend/src/game/RoleSystem.ts">
// üê∫ LOBISOMEM ONLINE - Role System and Distribution (CORRIGIDO DEFINITIVAMENTE + DEBUG MODE)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service

import { Role, Faction } from '@/utils/constants';

//====================================================================
// ROLE CONFIGURATION INTERFACE
//====================================================================
export interface RoleConfiguration {
  role: Role;
  faction: Faction;
  name: string;
  description: string;
  abilities: string[];
  goalDescription: string;
  canAct: boolean;
  actsDuring: string[];
  hasNightChat: boolean;
  immuneToInvestigation: boolean;
  maxActions?: number;
  priority: number; // Action priority (lower = executes first)
}

//====================================================================
// ROLE DEFINITIONS (Based on Town of Salem)
//====================================================================
const roleConfigurations: Record<Role, RoleConfiguration> = {
  // TOWN ROLES
  [Role.VILLAGER]: {
    role: Role.VILLAGER,
    faction: Faction.TOWN,
    name: 'Alde√£o',
    description: 'Cidad√£o comum da vila sem poderes especiais',
    abilities: ['Votar durante o dia'],
    goalDescription: 'Eliminar todos os Lobisomens e inimigos da vila',
    canAct: false,
    actsDuring: [],
    hasNightChat: false,
    immuneToInvestigation: false,
    priority: 999, // No actions
  },

  [Role.SHERIFF]: {
    role: Role.SHERIFF,
    faction: Faction.TOWN,
    name: 'Investigador',
    description: 'Investiga pessoas durante a noite para descobrir se s√£o suspeitas',
    abilities: [
      'Investigar uma pessoa por noite',
      'Descobre se o alvo √© "SUSPEITO" ou "N√ÉO SUSPEITO"',
      'Lobisomens e Serial Killers aparecem como SUSPEITO',
      'Vila e Neutros pac√≠ficos aparecem como N√ÉO SUSPEITO'
    ],
    goalDescription: 'Encontrar e eliminar todos os Lobisomens usando suas investiga√ß√µes',
    canAct: true,
    actsDuring: ['NIGHT'],
    hasNightChat: false,
    immuneToInvestigation: false,
    priority: 3, // After protections but before kills
  },

  [Role.DOCTOR]: {
    role: Role.DOCTOR,
    faction: Faction.TOWN,
    name: 'M√©dico',
    description: 'Protege pessoas da morte durante a noite',
    abilities: [
      'Proteger uma pessoa por noite de ataques',
      'N√£o pode proteger a mesma pessoa duas noites seguidas',
      'N√£o pode se proteger duas noites seguidas',
      'Prote√ß√£o impede morte por qualquer fonte noturna'
    ],
    goalDescription: 'Manter a vila viva e eliminar os Lobisomens',
    canAct: true,
    actsDuring: ['NIGHT'],
    hasNightChat: false,
    immuneToInvestigation: false,
    priority: 1, // First to act - protections applied before attacks
  },

  [Role.VIGILANTE]: {
    role: Role.VIGILANTE,
    faction: Faction.TOWN,
    name: 'Vigilante',
    description: 'Pode matar suspeitos durante a noite, mas tem consequ√™ncias',
    abilities: [
      'Matar uma pessoa por noite (m√°ximo 3 vezes)',
      'Se matar um inocente (Vila), fica de luto e perde a pr√≥xima a√ß√£o',
      'Pode matar Lobisomens, Serial Killers e Neutros malignos',
      'Suas balas s√£o limitadas - use com sabedoria'
    ],
    goalDescription: 'Eliminar os inimigos da vila usando for√ßa letal',
    canAct: true,
    actsDuring: ['NIGHT'],
    hasNightChat: false,
    immuneToInvestigation: false,
    maxActions: 3,
    priority: 4, // After investigations
  },

  // WEREWOLF ROLES
  [Role.WEREWOLF]: {
    role: Role.WEREWOLF,
    faction: Faction.WEREWOLF,
    name: 'Lobisomem',
    description: 'Elimina alde√µes durante a noite em coordena√ß√£o com a alcateia',
    abilities: [
      'Votar em quem matar durante a noite com outros Lobisomens',
      'Chat secreto com outros Lobisomens durante a noite',
      'Pode blefar como qualquer role durante o dia',
      'Aparece como SUSPEITO para o Investigador'
    ],
    goalDescription: 'Igualar ou superar o n√∫mero de alde√µes vivos',
    canAct: true,
    actsDuring: ['NIGHT'],
    hasNightChat: true,
    immuneToInvestigation: false,
    priority: 5, // Werewolf kills
  },

  [Role.WEREWOLF_KING]: {
    role: Role.WEREWOLF_KING,
    faction: Faction.WEREWOLF,
    name: 'Rei dos Lobisomens',
    description: 'L√≠der da alcateia com imunidade especial √† investiga√ß√£o',
    abilities: [
      'Liderar vota√ß√£o de morte noturna da alcateia',
      'IMUNE √† investiga√ß√£o do Sheriff (aparece como N√ÉO SUSPEITO)',
      'Chat secreto com outros Lobisomens durante a noite',
      'Pode coordenar estrat√©gias e bleffs da alcateia'
    ],
    goalDescription: 'Comandar a alcateia para dominar a vila',
    canAct: true,
    actsDuring: ['NIGHT'],
    hasNightChat: true,
    immuneToInvestigation: true, // SPECIAL: Immune to Sheriff
    priority: 5, // Werewolf kills (same as regular werewolf)
  },

  // NEUTRAL ROLES
  [Role.JESTER]: {
    role: Role.JESTER,
    faction: Faction.NEUTRAL,
    name: 'Bobo da Corte',
    description: 'Vence sendo executado por vota√ß√£o durante o dia',
    abilities: [
      'Objetivo √∫nico: ser executado por vota√ß√£o popular',
      'N√£o pode ser morto √† noite (prote√ß√£o b√°sica)',
      'Deve agir de forma suspeita sem ser √≥bvio demais',
      'Se executado, VENCE SOZINHO independente de outros'
    ],
    goalDescription: 'Ser executado por vota√ß√£o popular durante o dia',
    canAct: false,
    actsDuring: [],
    hasNightChat: false,
    immuneToInvestigation: false,
    priority: 999, // No night actions
  },

  [Role.SERIAL_KILLER]: {
    role: Role.SERIAL_KILLER,
    faction: Faction.NEUTRAL,
    name: 'Assassino em S√©rie',
    description: 'Mata uma pessoa por noite, vence sendo o √∫ltimo sobrevivente',
    abilities: [
      'Matar uma pessoa por noite',
      'Imune a prote√ß√£o do Doctor na primeira noite',
      'Aparece como SUSPEITO para o Investigador',
      'Deve eliminar TODOS os outros jogadores para vencer'
    ],
    goalDescription: 'Ser o √∫ltimo sobrevivente - eliminar todos os outros',
    canAct: true,
    actsDuring: ['NIGHT'],
    hasNightChat: false,
    immuneToInvestigation: false,
    priority: 6, // After werewolf kills
  },
};

//====================================================================
// ROLE DISTRIBUTION SYSTEM
//====================================================================
export type RoleDistribution = Record<Role, number>;

const balancedRoleDistributions: Record<number, RoleDistribution> = {
  // 3 players - DEBUG MODE (Modo de teste r√°pido)
  3: {
    [Role.VILLAGER]: 0,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 0,
    [Role.WEREWOLF]: 1,
    [Role.WEREWOLF_KING]: 0,
    [Role.JESTER]: 0,
    [Role.SERIAL_KILLER]: 0,
  },

  // 6 players - Minimum composition
  6: {
    [Role.VILLAGER]: 1,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 0,
    [Role.WEREWOLF]: 2,
    [Role.WEREWOLF_KING]: 0,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 0,
  },

  // 7 players
  7: {
    [Role.VILLAGER]: 2,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 0,
    [Role.WEREWOLF]: 2,
    [Role.WEREWOLF_KING]: 0,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 0,
  },

  // 8 players
  8: {
    [Role.VILLAGER]: 2,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 1,
    [Role.WEREWOLF]: 2,
    [Role.WEREWOLF_KING]: 0,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 0,
  },

  // 9 players - Balanced composition
  9: {
    [Role.VILLAGER]: 2,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 1,
    [Role.WEREWOLF]: 1,
    [Role.WEREWOLF_KING]: 1,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 1,
  },

  // 10 players
  10: {
    [Role.VILLAGER]: 3,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 1,
    [Role.WEREWOLF]: 1,
    [Role.WEREWOLF_KING]: 1,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 1,
  },

  // 11 players
  11: {
    [Role.VILLAGER]: 4,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 1,
    [Role.WEREWOLF]: 1,
    [Role.WEREWOLF_KING]: 1,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 1,
  },

  // 12 players - Standard composition
  12: {
    [Role.VILLAGER]: 4,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 1,
    [Role.WEREWOLF]: 2,
    [Role.WEREWOLF_KING]: 1,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 1,
  },

  // 13 players
  13: {
    [Role.VILLAGER]: 5,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 1,
    [Role.WEREWOLF]: 2,
    [Role.WEREWOLF_KING]: 1,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 1,
  },

  // 14 players
  14: {
    [Role.VILLAGER]: 6,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 1,
    [Role.WEREWOLF]: 2,
    [Role.WEREWOLF_KING]: 1,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 1,
  },

  // 15 players - Maximum composition
  15: {
    [Role.VILLAGER]: 6,
    [Role.SHERIFF]: 1,
    [Role.DOCTOR]: 1,
    [Role.VIGILANTE]: 1,
    [Role.WEREWOLF]: 3,
    [Role.WEREWOLF_KING]: 1,
    [Role.JESTER]: 1,
    [Role.SERIAL_KILLER]: 1,
  },
};

//====================================================================
// ROLE DISTRIBUTION LOGIC - SEM EXPORT NA DECLARA√á√ÉO
//====================================================================
class RoleDistributor {
  /**
* Get balanced role distribution for a given number of players
*/
  static getRoleDistribution(playerCount: number): RoleDistribution {
    // Use exact match if available
    if (balancedRoleDistributions[playerCount]) {
      // Adicionando '!' aqui tamb√©m por consist√™ncia e seguran√ßa m√°xima.
      return { ...balancedRoleDistributions[playerCount]! };
    }

    // 1. Prepara a lista de contagens de jogadores dispon√≠veis.
    const sortedCounts = Object.keys(balancedRoleDistributions)
      .map(Number)
      .sort((a, b) => a - b);

    // 2. "Guard Clause" para provar ao TS que o array n√£o est√° vazio.
    if (sortedCounts.length === 0) {
      throw new Error("FATAL: No balanced role distributions are defined.");
    }

    // 3. Encontra o valor mais pr√≥ximo.
    let closest: number | undefined;
    for (const count of sortedCounts) {
      if (count >= playerCount) {
        closest = count;
        break;
      }
    }

    // 4. Garante que 'lastCount' e 'chosenCount' s√£o n√∫meros.
    const lastCount = sortedCounts[sortedCounts.length - 1]!;
    const chosenCount = closest ?? lastCount;

    // 5. A SOLU√á√ÉO PARA O NOVO ERRO:
    // Afirmamos que o resultado do acesso ao objeto n√£o ser√° undefined.
    const baseDistribution = { ...balancedRoleDistributions[chosenCount]! };

    // Agora, 'baseDistribution' √© garantidamente do tipo 'RoleDistribution',
    // resolvendo os erros nas linhas seguintes.
    if (chosenCount > playerCount) {
      return this.adjustRoleDistribution(baseDistribution, playerCount);
    }

    return baseDistribution;
  }

  /**
   * Adjust role distribution to match exact player count
   */
  private static adjustRoleDistribution(distribution: RoleDistribution, targetCount: number): RoleDistribution {
    const newDistribution = { ...distribution };
    const currentTotal = Object.values(newDistribution).reduce((sum, count) => sum + count, 0);
    const difference = currentTotal - targetCount;

    if (difference > 0) {
      // Remove roles starting with villagers, then neutrals
      const removeOrder: Role[] = [Role.VILLAGER, Role.SERIAL_KILLER, Role.JESTER, Role.WEREWOLF, Role.VIGILANTE];

      let toRemove = difference;
      for (const role of removeOrder) {
        if (toRemove <= 0) break;
        const canRemove = Math.min(newDistribution[role], toRemove);
        newDistribution[role] -= canRemove;
        toRemove -= canRemove;
      }
    }

    return newDistribution;
  }

  /**
* Distribute roles to players randomly while maintaining balance
*/
  static distributeRolesToPlayers(playerIds: string[], distribution: RoleDistribution): Map<string, Role> {
    const roles: Role[] = [];

    // Create array of roles based on distribution
    Object.entries(distribution).forEach(([role, count]) => {
      for (let i = 0; i < count; i++) {
        roles.push(role as Role);
      }
    });

    // Shuffle arrays
    const shuffledPlayers = this.shuffleArray([...playerIds]);
    const shuffledRoles = this.shuffleArray([...roles]);

    // Create assignment map
    const roleAssignment = new Map<string, Role>();
    shuffledPlayers.forEach((playerId, index) => {
      // CORRE√á√ÉO: Verificar se o √≠ndice existe no array antes de acessar
      if (index < shuffledRoles.length) {
        const role = shuffledRoles[index];
        if (role) { // Verifica√ß√£o adicional para garantir que role n√£o √© undefined
          roleAssignment.set(playerId, role);
        }
      }
    });

    return roleAssignment;
  }

  /**
   * Validate if a role distribution is balanced
   */
  static validateDistribution(distribution: RoleDistribution): {
    isValid: boolean;
    issues: string[];
    recommendations: string[];
  } {
    const issues: string[] = [];
    const recommendations: string[] = [];

    const totalPlayers = Object.values(distribution).reduce((sum, count) => sum + count, 0);
    const townCount = distribution[Role.VILLAGER] + distribution[Role.SHERIFF] + distribution[Role.DOCTOR] + distribution[Role.VIGILANTE];
    const werewolfCount = distribution[Role.WEREWOLF] + distribution[Role.WEREWOLF_KING];
    const neutralCount = distribution[Role.JESTER] + distribution[Role.SERIAL_KILLER];

    // Basic validation
    if (totalPlayers < 3) {
      issues.push('M√≠nimo de 3 jogadores necess√°rio (modo debug)');
    }

    if (totalPlayers > 15) {
      issues.push('M√°ximo de 15 jogadores permitido');
    }

    // Balance validation
    const werewolfRatio = werewolfCount / totalPlayers;
    if (werewolfRatio < 0.2) {
      issues.push('Muito poucos Lobisomens - jogo pode ser desequilibrado para a Vila');
    }

    if (werewolfRatio > 0.4) {
      issues.push('Muitos Lobisomens - jogo pode ser desequilibrado para os Lobisomens');
    }

    // Essential roles validation
    if (distribution[Role.SHERIFF] === 0 && totalPlayers >= 7) {
      recommendations.push('Adicionar pelo menos 1 Investigador para jogos com 7+ jogadores');
    }

    if (distribution[Role.DOCTOR] === 0 && totalPlayers >= 8) {
      recommendations.push('Adicionar pelo menos 1 M√©dico para jogos com 8+ jogadores');
    }

    // Power roles balance
    const powerRoles = distribution[Role.SHERIFF] + distribution[Role.DOCTOR] + distribution[Role.VIGILANTE];
    if (powerRoles > werewolfCount + 1) {
      recommendations.push('Muitas roles de poder da Vila podem desequilibrar o jogo');
    }

    return {
      isValid: issues.length === 0,
      issues,
      recommendations,
    };
  }

  /**
   * Get role configuration for a specific role
   */
  static getRoleConfig(role: Role): RoleConfiguration {
    return roleConfigurations[role];
  }

  /**
   * Get all roles that can act during a specific phase
   */
  static getRolesThatActDuring(phase: string): Role[] {
    return Object.values(roleConfigurations)
      .filter(config => config.actsDuring.includes(phase))
      .map(config => config.role);
  }

  /**
   * Get roles ordered by action priority
   */
  static getRolesByPriority(): Role[] {
    return Object.values(roleConfigurations)
      .sort((a, b) => a.priority - b.priority)
      .map(config => config.role);
  }

  /**
   * Check if a role is part of a specific faction
   */
  static isRoleInFaction(role: Role, faction: Faction): boolean {
    return roleConfigurations[role].faction === faction;
  }

  /**
   * Get all roles from a specific faction
   */
  static getRolesFromFaction(faction: Faction): Role[] {
    return Object.values(roleConfigurations)
      .filter(config => config.faction === faction)
      .map(config => config.role);
  }

  /**
   * Fisher-Yates shuffle algorithm - CORRE√á√ÉO para exactOptionalPropertyTypes
   */
  private static shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      // CORRE√á√ÉO: Garantir que os elementos existem antes do swap
      const temp = shuffled[i];
      const swapTarget = shuffled[j];
      if (temp !== undefined && swapTarget !== undefined) {
        shuffled[i] = swapTarget;
        shuffled[j] = temp;
      }
    }
    return shuffled;
  }
}

//====================================================================
// ROLE REVEAL UTILITIES - SEM EXPORT NA DECLARA√á√ÉO
//====================================================================
class RoleRevealManager {
  /**
   * Get information that should be revealed when a player dies
   */
  static getDeathReveal(role: Role): {
    role: Role;
    faction: Faction;
    name: string;
    description: string;
  } {
    const config = roleConfigurations[role];
    return {
      role: config.role,
      faction: config.faction,
      name: config.name,
      description: config.description,
    };
  }

  /**
   * Get investigation result for Sheriff
   */
  static getInvestigationResult(targetRole: Role): 'SUSPICIOUS' | 'NOT_SUSPICIOUS' {
    const config = roleConfigurations[targetRole];

    // Werewolf King is immune to investigation
    if (config.immuneToInvestigation) {
      return 'NOT_SUSPICIOUS';
    }

    // Werewolves and Serial Killer are suspicious
    if (config.faction === Faction.WEREWOLF || targetRole === Role.SERIAL_KILLER) {
      return 'SUSPICIOUS';
    }

    // Town and peaceful neutrals are not suspicious
    return 'NOT_SUSPICIOUS';
  }

  /**
   * Check if a role has night chat access
   */
  static hasNightChat(role: Role): boolean {
    return roleConfigurations[role].hasNightChat;
  }

  /**
   * Get roles that share night chat (Werewolves)
   */
  static getNightChatRoles(): Role[] {
    return Object.values(roleConfigurations)
      .filter(config => config.hasNightChat)
      .map(config => config.role);
  }
}

//====================================================================
// WIN CONDITION CALCULATOR - SEM EXPORT NA DECLARA√á√ÉO
//====================================================================
class WinConditionCalculator {
  /**
   * Calculate win condition based on alive players and their roles
   */
  static calculateWinCondition(alivePlayers: { playerId: string; role: Role }[]): {
    hasWinner: boolean;
    winningFaction?: Faction;
    winningPlayers?: string[];
    reason?: string;
  } {
    if (alivePlayers.length === 0) {
      return { hasWinner: false };
    }

    // Group players by faction
    const factionGroups = new Map<Faction, { playerId: string; role: Role }[]>();

    alivePlayers.forEach(player => {
      const faction = roleConfigurations[player.role].faction;
      const players = factionGroups.get(faction) || [];
      players.push(player);
      factionGroups.set(faction, players);
    });

    const townPlayers = factionGroups.get(Faction.TOWN) || [];
    const werewolfPlayers = factionGroups.get(Faction.WEREWOLF) || [];
    const neutralPlayers = factionGroups.get(Faction.NEUTRAL) || [];

    // Check for Jester win (this would be handled separately when someone is executed)
    const jester = neutralPlayers.find(p => p.role === Role.JESTER);
    // Jester win is handled in execution logic, not here

    // Werewolves win if they equal or outnumber town
    if (werewolfPlayers.length >= townPlayers.length && townPlayers.length > 0) {
      return {
        hasWinner: true,
        winningFaction: Faction.WEREWOLF,
        winningPlayers: werewolfPlayers.map(p => p.playerId),
        reason: 'Lobisomens igualam ou superam o n√∫mero da Vila',
      };
    }

    // Town wins if no werewolves left
    if (werewolfPlayers.length === 0 && townPlayers.length > 0) {
      return {
        hasWinner: true,
        winningFaction: Faction.TOWN,
        winningPlayers: townPlayers.map(p => p.playerId),
        reason: 'Todos os Lobisomens foram eliminados',
      };
    }

    // Serial Killer wins if alone
    const serialKiller = neutralPlayers.find(p => p.role === Role.SERIAL_KILLER);
    if (townPlayers.length + werewolfPlayers.length === 0 && serialKiller) {
      return {
        hasWinner: true,
        winningFaction: Faction.NEUTRAL,
        winningPlayers: [serialKiller.playerId],
        reason: 'Assassino em S√©rie eliminou todos os outros',
      };
    }

    return { hasWinner: false };
  }

  /**
   * Check if Jester wins by being executed
   */
  static checkJesterWin(executedRole: Role): boolean {
    return executedRole === Role.JESTER;
  }
}

//====================================================================
// EXPORTS (CORRIGIDOS - APENAS UMA VEZ)
//====================================================================
export {
  roleConfigurations as ROLE_CONFIGURATIONS,
  balancedRoleDistributions as BALANCED_ROLE_DISTRIBUTIONS,
  RoleDistributor,
  RoleRevealManager,
  WinConditionCalculator,
};
</file>

<file path="backend/src/middleware/auth.ts">
import { Request, Response, NextFunction } from 'express';
import { verifyAccessToken, extractTokenFromHeader, extractTokenFromCookie } from '@/config/jwt';
import { pool } from '@/config/database';
import { authLogger } from '@/utils/logger';
import { ERROR_MESSAGES } from '@/utils/constants';

declare global {
  namespace Express {
    interface Request {
      userId: string;
      username: string;
      email: string;
    }
  }
}

export const requireAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    let token = extractTokenFromHeader(req.headers.authorization);

    if (!token) {
      token = extractTokenFromCookie(req.headers.cookie);
    }

    if (!token) {
      authLogger.warn('Authentication attempt without token', {
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        path: req.path,
      });

      res.status(401).json({
        success: false,
        error: ERROR_MESSAGES.UNAUTHORIZED,
        timestamp: new Date().toISOString(),
      });
      return;
    }

    const payload = verifyAccessToken(token);

    const userQuery = `SELECT id, username, email, "updatedAt" FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [payload.userId]);

    if (userResult.rows.length === 0) {
      authLogger.warn('Token valid but user not found', {
        userId: payload.userId,
        ip: req.ip,
        path: req.path,
      });

      res.status(401).json({
        success: false,
        error: ERROR_MESSAGES.UNAUTHORIZED,
        timestamp: new Date().toISOString(),
      });
      return;
    }

    const user = userResult.rows[0];

    await pool.query(`UPDATE users SET "lastLoginAt" = NOW() WHERE id = $1`, [user.id]);

    req.userId = user.id;
    req.username = user.username;
    req.email = user.email;

    authLogger.info('User authenticated successfully', {
      userId: user.id,
      username: user.username,
      ip: req.ip,
      path: req.path,
    });

    next();
  } catch (error) {
    authLogger.error('Authentication error', error instanceof Error ? error : new Error('Unknown auth error'), {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      path: req.path,
    });

    res.status(401).json({
      success: false,
      error: ERROR_MESSAGES.UNAUTHORIZED,
      timestamp: new Date().toISOString(),
    });
  }
};

export const optionalAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    let token = extractTokenFromHeader(req.headers.authorization);

    if (!token) {
      token = extractTokenFromCookie(req.headers.cookie);
    }

    if (!token) {
      return next();
    }

    const payload = verifyAccessToken(token);
    const userQuery = `SELECT id, username, email FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [payload.userId]);

    if (userResult.rows.length > 0) {
      const user = userResult.rows[0];
      req.userId = user.id;
      req.username = user.username;
      req.email = user.email;
    }

    next();
  } catch (error) {
    next();
  }
};
</file>

<file path="backend/src/routes/auth.ts">
// üê∫ LOBISOMEM ONLINE - Authentication Routes
// Route definitions for authentication endpoints

import { Router } from 'express';
import { register, login, forgotPassword, resetPassword, getProfile, checkUsername, checkEmail } from '@/controllers/authController';
import { requireAuth } from '@/middleware/auth';

const router = Router();

//======================================================================
// SIMPLE RATE LIMITING (INLINE)
//======================================================================

const authRateLimit = (req: any, res: any, next: any) => {
  // TODO: Implement proper rate limiting later
  // For now, just pass through
  next();
};

//======================================================================
// PUBLIC ROUTES
//======================================================================

/**
 * @route POST /api/auth/register
 * @desc Register new user
 * @access Public
 * @body { email, username, password, confirmPassword }
 */
router.post('/register', authRateLimit, register);

/**
 * @route POST /api/auth/login
 * @desc Login user
 * @access Public
 * @body { email, password }
 */
router.post('/login', authRateLimit, login);

/**
 * @route POST /api/auth/forgot-password
 * @desc Request password reset
 * @access Public
 * @body { email }
 */
router.post('/forgot-password', authRateLimit, forgotPassword);

/**
 * @route POST /api/auth/reset-password
 * @desc Reset password with token
 * @access Public
 * @body { token, password, confirmPassword }
 */
router.post('/reset-password', authRateLimit, resetPassword);

/**
 * @route GET /api/auth/check-username/:username
 * @desc Check if username is available
 * @access Public
 */
router.get('/check-username/:username', authRateLimit, checkUsername);

/**
 * @route GET /api/auth/check-email/:email
 * @desc Check if email is available
 * @access Public
 */
router.get('/check-email/:email', authRateLimit, checkEmail);

//======================================================================
// PROTECTED ROUTES
//======================================================================

/**
 * @route GET /api/auth/profile
 * @desc Get current user profile
 * @access Private
 */
router.get('/profile', requireAuth, getProfile);

/**
 * @route POST /api/auth/refresh
 * @desc Refresh access token
 * @access Private (refresh token)
 */
router.post('/refresh', (req, res) => {
  // TODO: Implement refresh token logic
  res.json({
    success: true,
    message: 'Refresh token endpoint - TODO',
    timestamp: new Date().toISOString(),
  });
});

/**
 * @route POST /api/auth/logout
 * @desc Logout user (invalidate token)
 * @access Private
 */
router.post('/logout', requireAuth, (req, res) => {
  // TODO: Add token to blacklist in Redis
  res.json({
    success: true,
    message: 'Logout realizado com sucesso',
    timestamp: new Date().toISOString(),
  });
});

export default router;
</file>

<file path="backend/src/types/index.ts">
// üê∫ LOBISOMEM ONLINE - Tipos Centralizados (REFATORADO)
import type WebSocket from 'ws';

// =============================================================================
// IMPORT ENUMS FROM CONSTANTS (√öNICA FONTE)
// =============================================================================
export { Role, Faction, GamePhase } from '@/utils/constants';
import { Role, Faction, GamePhase } from '@/utils/constants';

// =============================================================================
// API & HTTP
// =============================================================================
export interface ApiResponse<T = any> {
    success: boolean;
    data?: T;
    message?: string;
    error?: string;
    timestamp: string;
}

// =============================================================================
// JWT & AUTENTICA√á√ÉO
// =============================================================================
export interface JWTPayload {
    userId: string;
    username: string;
    email: string;
    avatar?: string;
    iat?: number;
    exp?: number;
}

export interface TokenPair {
    accessToken: string;
    refreshToken?: string;
}

// =============================================================================
// WEBSOCKET & CONEX√ÉO
// =============================================================================
export interface ConnectionContext {
    userId: string;
    username: string;
    serverId: string;
    isSpectator: boolean;
    roomId?: string;
}

export interface ConnectionMetadata {
    connectedAt: Date;
    userAgent?: string;
    ip?: string;
    origin?: string;
}

export interface WebSocketConnection {
    id: string;
    ws: WebSocket;
    context: ConnectionContext;
    metadata: ConnectionMetadata;
    isAlive: boolean;
    lastPing: number;
    reconnectAttempts: number;
}

export interface WebSocketMessage {
    type: string;
    timestamp: string;
    data?: any;
    messageId?: string;
}

export interface URLParseResult {
    isValid: boolean;
    path: string;
    roomId?: string;
    serverId?: string;
}

export interface MessageValidationResult {
    isValid: boolean;
    message?: WebSocketMessage;
    error?: string;
}

export type WebSocketErrorCode =
    | 'INVALID_TOKEN' | 'ROOM_NOT_FOUND' | 'ROOM_FULL' | 'NOT_IN_ROOM'
    | 'NOT_HOST' | 'GAME_ALREADY_STARTED' | 'INVALID_ACTION'
    | 'PLAYER_NOT_FOUND' | 'RATE_LIMITED' | 'INVALID_MESSAGE'
    | 'UNKNOWN_MESSAGE_TYPE' | 'HANDLER_ERROR' | 'MISSING_ROOM_ID'
    | 'JOIN_ROOM_FAILED' | 'LEAVE_ROOM_FAILED' | 'READY_UPDATE_FAILED'
    | 'START_GAME_FAILED' | 'KICK_PLAYER_FAILED' | 'NOT_IMPLEMENTED';

// =============================================================================
// GAME TYPES (COMPAT√çVEIS COM CLASSES REAIS)
// =============================================================================
export type RoomStatus = 'WAITING' | 'PLAYING' | 'FINISHED';
export type GameStatus = 'WAITING' | 'STARTING' | 'PLAYING' | 'FINISHED' | 'CANCELLED';

export interface Room {
    id: string;
    name: string;
    isPrivate: boolean;
    maxPlayers: number;
    maxSpectators: number;
    status: RoomStatus;
    hostId: string;
    hostUsername: string;
    currentPlayers: number;
    currentSpectators: number;
    createdAt: Date;
    updatedAt: Date;
    code?: string;
    serverId?: string;
}

export interface GameConfig {
    roomId: string;
    maxPlayers: number;
    maxSpectators: number;
    nightDuration: number; // milliseconds
    dayDuration: number; // milliseconds
    votingDuration: number; // milliseconds
    allowReconnection: boolean;
    reconnectionTimeout: number; // milliseconds
}

// =============================================================================
// PLAYER INTERFACE (COMPAT√çVEL COM CLASSE Player)
// =============================================================================
export interface Player {
    id: string;
    userId: string;
    username: string;
    isHost: boolean;
    isReady: boolean;
    isSpectator: boolean;
    isConnected: boolean;
    joinedAt: Date;
    lastSeen: Date;
    avatar?: string;

    // Game-specific properties
    role?: Role;
    faction?: Faction;
    isAlive?: boolean;
    isProtected?: boolean;
    hasActed?: boolean;
    hasVoted?: boolean;
    votedFor?: string;
    actionsUsed?: number;
    maxActions?: number;
    lastAction?: string;
    eliminationReason?: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER';
    killedBy?: string;
}

// =============================================================================
// GAME STATE INTERFACE (COMPAT√çVEL COM CLASSE GameState)
// ‚úÖ MUDAN√áA CHAVE: Usar estruturas que a classe realmente usa
// =============================================================================
export interface GameState {
    gameId: string;
    roomId: string;
    status: GameStatus;
    phase: GamePhase;
    day: number;
    phaseStartTime: Date;
    phaseEndTime: Date;
    timeLeft: number;

    // ‚úÖ IMPORTANTE: Compat√≠vel com a classe real que usa Map
    players: Player[]; // Para serializa√ß√£o JSON
    spectators: string[]; // IDs dos espectadores  
    eliminatedPlayers: Player[];

    hostId: string;
    events: GameEvent[];
    votes: Record<string, string>; // Para serializa√ß√£o JSON - voterId -> targetId
    nightActions: NightAction[];
    config: GameConfig;
    createdAt: Date;
    updatedAt: Date;
    startedAt?: Date;
    finishedAt?: Date;
    winningFaction?: Faction;
    winningPlayers?: string[];
}

export interface GameEvent {
    id: string;
    type: string;
    phase: GamePhase;
    day: number;
    timestamp: Date;
    data: any;
    visibleTo?: string[]; // If undefined, visible to all
}

export interface NightAction {
    playerId: string;
    type: string;
    targetId?: string;
    data?: any;
    priority: number;
}

// =============================================================================
// GAME ENGINE INTERFACES
// =============================================================================
export interface IGameEngine {
    // Game lifecycle
    createGame(hostId: string, config: GameConfig): Promise<GameState>;
    startGame(gameId: string): Promise<boolean>;
    endGame(gameId: string, reason?: string): Promise<void>;

    // Player management
    addPlayer(gameId: string, player: Player): Promise<boolean>;
    removePlayer(gameId: string, playerId: string): Promise<boolean>;

    // Game state
    getGameState(gameId: string): Promise<GameState | null>;
    updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;

    // Actions
    performPlayerAction(gameId: string, playerId: string, action: any): Promise<boolean>;

    // Phase management
    nextPhase(gameId: string): Promise<void>;

    // Events
    onGameEvent(gameId: string, event: string, handler: (data: any) => void): void;

    // Voting
    castVote?(gameId: string, voterId: string, targetId: string): Promise<boolean>;
    removeVote?(gameId: string, voterId: string): Promise<boolean>;

    // Administrative
    getActiveGamesCount?(): number;
    getAllGames?(): GameState[];
    getGamesByRoom?(roomId: string): Promise<GameState[]>;
    forceEndGame?(gameId: string, reason: string): Promise<boolean>;
    getGameStats?(gameId: string): any;
    cleanup?(): Promise<void>;
}

// =============================================================================
// ROLE SYSTEM TYPES (IMPORTADOS DE RoleSystem.ts)
// =============================================================================
export interface RoleConfiguration {
    role: Role;
    faction: Faction;
    name: string;
    description: string;
    abilities: string[];
    goalDescription: string;
    canAct: boolean;
    actsDuring: string[];
    hasNightChat: boolean;
    immuneToInvestigation: boolean;
    maxActions?: number;
    priority: number;
}

export type RoleDistribution = Record<Role, number>;

// =============================================================================
// ACTION SYSTEM TYPES
// =============================================================================
export interface GameAction {
    id: string;
    playerId: string;
    type: string;
    targetId?: string;
    data?: any;
    timestamp: Date;
    phase: string;
    day: number;
    priority: number;
    isValid: boolean;
    processed: boolean;
}

export interface ActionResult {
    success: boolean;
    actionId: string;
    message?: string;
    data?: any;
    errors?: string[];
}

// =============================================================================
// TIMER SYSTEM TYPES
// =============================================================================
export interface GameTimer {
    id: string;
    type: 'PHASE' | 'WARNING' | 'CUSTOM';
    startTime: number;
    duration: number;
    remaining: number;
    isActive: boolean;
    callback?: () => void;
    timeout?: NodeJS.Timeout; // ‚úÖ Nome correto
}

// =============================================================================
// SERVICE INTERFACES (CORRIGIDOS)
// =============================================================================
export interface ServiceMetadata {
    id: string;
    type: 'lobby' | 'game' | 'chat' | 'monolith';
    host: string;
    port: number;
    capabilities: string[];
    status: 'healthy' | 'unhealthy';
    lastHeartbeat: Date;
    maxRooms?: number;
    currentRooms?: number;
}

export interface IEventBus {
    publish<T>(channel: string, event: T): Promise<void>;
    subscribe<T>(channel: string, handler: (event: T) => void): Promise<void>;
    unsubscribe(channel: string, handler?: Function): Promise<void>;
    healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

export interface IServiceRegistry {
    registerService(serviceId: string, metadata: ServiceMetadata): Promise<void>;
    getAvailableServices(serviceType: string): Promise<string[]>;
    unregisterService(serviceId: string): Promise<void>;
    getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null>;
    healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// ‚úÖ INTERFACE CORRIGIDA - Agora retorna GameState em vez de Game inexistente
export interface IGameStateService {
    createGame(hostId: string, config: GameConfig): Promise<GameState>;
    getGame(gameId: string): Promise<GameState | null>;
    updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;
    deleteGame(gameId: string): Promise<void>;
    addPlayer(gameId: string, player: Player): Promise<void>;
    removePlayer(gameId: string, playerId: string): Promise<void>;
    updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void>;
    getGameState(gameId: string): Promise<GameState | null>;
    getPlayer(gameId: string, playerId: string): Promise<Player | null>;
    getAllPlayers(gameId: string): Promise<Player[]>;
    getGamesByRoom(roomId: string): Promise<GameState[]>;
    getActiveGamesCount(): Promise<number>;
    cleanup?(): number;
    healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// =============================================================================
// WIN CONDITION TYPES
// =============================================================================
export interface WinCondition {
    hasWinner: boolean;
    winningFaction?: Faction;
    winningPlayers?: string[];
    reason?: string;
}

// =============================================================================
// GAME STATISTICS TYPES
// =============================================================================
export interface GameStats {
    gameId: string;
    status: GameStatus;
    phase: GamePhase;
    day: number;
    playerCount: number;
    aliveCount: number;
    spectatorCount: number;
    timeLeft: number;
    events: number;
}

export interface GameResults {
    gameId: string;
    roomId: string;
    duration: number;
    totalDays: number;
    winningFaction?: Faction;
    winningPlayers: string[];
    players: PlayerResult[];
    events: GameEvent[];
}

export interface PlayerResult {
    id: string;
    userId: string;
    username: string;
    role?: Role;
    faction?: Faction;
    survived: boolean;
    won: boolean;
    eliminationReason?: string;
    killedBy?: string;
}

// =============================================================================
// PHASE MANAGER TYPES
// =============================================================================
export interface PhaseTransition {
    from: GamePhase;
    to: GamePhase;
    duration: number;
    reason?: string;
}

export interface NightResults {
    protections: string[];
    investigations: Array<{
        investigatorId: string;
        targetId: string;
        result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS';
    }>;
    attacks: Array<{
        attackerId: string;
        targetId: string;
        successful: boolean;
    }>;
    deaths: Array<{
        playerId: string;
        cause: string;
        killedBy?: string;
    }>;
}

// =============================================================================
// WEBSOCKET EVENT TYPES
// =============================================================================
export interface GameWebSocketEvents {
    // Game lifecycle events
    'game:created': { gameId: string; hostId: string; config: GameConfig };
    'game:started': { gameId: string; players: Player[]; distribution: RoleDistribution };
    'game:ended': { gameId: string; results: GameResults };

    // Phase events
    'phase:changed': { gameId: string; phase: GamePhase; duration: number; timeLeft: number };
    'phase:warning': { gameId: string; phase: GamePhase; timeLeft: number };

    // Player events
    'player:joined': { gameId: string; player: Player };
    'player:left': { gameId: string; playerId: string; username: string };
    'player:died': { gameId: string; playerId: string; role: Role; cause: string };
    'player:executed': { gameId: string; playerId: string; role: Role; votes: number };

    // Action events
    'action:submitted': { gameId: string; playerId: string; actionType: string };
    'action:result': { gameId: string; playerId: string; result: ActionResult };

    // Voting events
    'vote:cast': { gameId: string; voterId: string; targetId: string; voteCounts: Record<string, number> };
    'vote:removed': { gameId: string; voterId: string; voteCounts: Record<string, number> };
}

// =============================================================================
// WEBSOCKET MESSAGE TYPES
// =============================================================================
export interface ClientToServerEvents {
    // Room events
    'join-room': { roomId: string; asSpectator?: boolean };
    'leave-room': { roomId?: string };
    'player-ready': { ready: boolean };
    'start-game': {};

    // Game actions
    'game-action': { type: string; targetId?: string; data?: any };
    'vote': { targetId: string };
    'unvote': {};

    // Chat events
    'chat-message': { message: string; channel?: string };

    // Werewolf coordination
    'werewolf-kill-vote': { targetId: string };

    // Admin events
    'kick-player': { playerId: string };
    'force-phase': {};
    'extend-time': { additionalTime: number };
}

export interface ServerToClientEvents {
    // Connection events
    'connected': { userId: string };
    'error': { code: WebSocketErrorCode; message: string };

    // Room events
    'room-joined': { room: Room; player: Player; yourRole: string };
    'room-left': { roomId: string };
    'player-joined': { player: Player };
    'player-left': { userId: string; username: string };
    'player-ready': { userId: string; username: string; ready: boolean };

    // Game events
    'game-starting': { countdown: number };
    'game-started': { gameId: string; players: Player[]; spectators: Player[] };
    'game-state': GameState;
    'game-ended': { results: GameResults };

    // Phase events
    'phase-changed': { phase: GamePhase; timeLeft: number; day: number };
    'phase-warning': { timeLeft: number };

    // Action events
    'action-confirmed': { actionType: string; message: string };
    'action-failed': { actionType: string; error: string };

    // Voting events
    'voting-update': { votes: Record<string, string>; counts: Record<string, number> };
    'execution-result': { executedId?: string; executedName?: string; executedRole?: Role };

    // Night events
    'night-results': { deaths: any[]; messages: string[] };
    'investigation-result': { targetName: string; result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS' };

    // Chat events
    'chat-message': { userId: string; username: string; message: string; channel: string; timestamp: string };

    // Role-specific events
    'role-assigned': { role: Role; faction: Faction; abilities: string[] };
    'werewolf-chat': { senderId: string; senderName: string; message: string };
}
</file>

<file path="backend/src/utils/logger.ts">
// üê∫ LOBISOMEM ONLINE - Logger Utility
// Structured logging for the application

import { config } from '@/config/environment';

// =============================================================================
// LOG LEVELS
// =============================================================================
export enum LogLevel {
  ERROR = 'ERROR',
  WARN = 'WARN',
  INFO = 'INFO',
  DEBUG = 'DEBUG',
}

// =============================================================================
// ‚úÖ LOG ENTRY INTERFACE - CORRIGIDA COM PROPRIEDADES OPCIONAIS
// =============================================================================
export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: string;
  service?: string; // ‚úÖ OPCIONAL - resolve exactOptionalPropertyTypes
  module?: string;
  userId?: string;
  roomId?: string;
  gameId?: string;
  metadata?: Record<string, any>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

// =============================================================================
// ‚úÖ LOGGER CLASS - CORRIGIDO COM TIPAGEM CORRETA
// =============================================================================
class Logger {
  private serviceName: string;
  private moduleContext: string | undefined; // ‚úÖ TIPO CORRIGIDO

  constructor(serviceName?: string, moduleContext?: string) {
    // ‚úÖ SEMPRE garante que serviceName seja string
    this.serviceName = serviceName || config.SERVICE_ID || 'werewolf-service';
    this.moduleContext = moduleContext; // ‚úÖ AGORA COMPAT√çVEL
  }

  /**
   * Create a child logger for a specific module
   */
  child(moduleContext: string): Logger {
    return new Logger(this.serviceName, moduleContext);
  }

  /**
   * Log an error message
   */
  error(message: string, error?: Error, metadata?: Record<string, any>): void {
    this.log(LogLevel.ERROR, message, {
      ...(error && { error }),
      ...(metadata && { metadata })
    });
  }

  /**
   * Log a warning message
   */
  warn(message: string, metadata?: Record<string, any>): void {
    this.log(LogLevel.WARN, message, {
      ...(metadata && { metadata })
    });
  }

  /**
   * Log an info message
   */
  info(message: string, metadata?: Record<string, any>): void {
    this.log(LogLevel.INFO, message, {
      ...(metadata && { metadata })
    });
  }

  /**
   * Log a debug message
   */
  debug(message: string, metadata?: Record<string, any>): void {
    if (config.IS_DEVELOPMENT) {
      this.log(LogLevel.DEBUG, message, {
        ...(metadata && { metadata })
      });
    }
  }

  /**
   * Log game-specific events
   */
  game(
    level: LogLevel,
    message: string,
    gameContext: {
      userId?: string;
      roomId?: string;
      gameId?: string;
      phase?: string;
      action?: string;
    },
    metadata?: Record<string, any>
  ): void {
    this.log(level, message, {
      metadata: {
        ...gameContext,
        ...metadata,
      },
    });
  }

  /**
   * Log WebSocket events
   */
  websocket(
    level: LogLevel,
    message: string,
    wsContext: {
      userId?: string;
      roomId?: string;
      connectionId?: string;
      event?: string;
    },
    metadata?: Record<string, any>
  ): void {
    this.log(level, message, {
      metadata: {
        ...wsContext,
        ...metadata,
        type: 'websocket',
      },
    });
  }

  /**
   * Log authentication events
   */
  auth(
    level: LogLevel,
    message: string,
    authContext: {
      userId?: string;
      email?: string;
      action?: string;
      ip?: string;
    },
    metadata?: Record<string, any>
  ): void {
    this.log(level, message, {
      metadata: {
        ...authContext,
        ...metadata,
        type: 'auth',
      },
    });
  }

  /**
   * Core logging method
   */
  private log(
    level: LogLevel,
    message: string,
    context?: {
      error?: Error;
      metadata?: Record<string, any>;
    }
  ): void {
    // ‚úÖ CORRIGIDO: service sempre ser√° string com fallback
    const logEntry: LogEntry = {
      level,
      message,
      timestamp: new Date().toISOString(),
      service: this.serviceName,
      ...(this.moduleContext && { module: this.moduleContext }),
      ...context?.metadata,
    };

    // Add error details if present
    if (context?.error) {
      logEntry.error = {
        name: context.error.name,
        message: context.error.message,
        ...(context.error.stack && { stack: context.error.stack }),
      };
    }

    // Output based on environment
    if (config.IS_PRODUCTION) {
      // Structured JSON logging for production
      console.log(JSON.stringify(logEntry));
    } else {
      // Pretty formatted logging for development
      this.prettyLog(logEntry);
    }
  }

  /**
   * Pretty print logs for development
   */
  private prettyLog(entry: LogEntry): void {
    const colors = {
      [LogLevel.ERROR]: '\x1b[31m', // Red
      [LogLevel.WARN]: '\x1b[33m',  // Yellow
      [LogLevel.INFO]: '\x1b[36m',  // Cyan
      [LogLevel.DEBUG]: '\x1b[37m', // White
    };

    const reset = '\x1b[0m';
    const color = colors[entry.level];

    const timestamp = new Date(entry.timestamp).toLocaleTimeString();
    const service = entry.service || 'werewolf-service';
    const module = entry.module ? `[${entry.module}]` : '';

    let logLine = `${color}${entry.level}${reset} ${timestamp} ${service}${module}: ${entry.message}`;

    console.log(logLine);

    // Log metadata if present
    if (entry.metadata && Object.keys(entry.metadata).length > 0) {
      console.log('  Metadata:', entry.metadata);
    }

    // Log error details if present
    if (entry.error) {
      console.log('  Error:', entry.error.message);
      if (entry.error.stack && config.IS_DEVELOPMENT) {
        console.log('  Stack:', entry.error.stack);
      }
    }
  }
}

// =============================================================================
// CREATE DEFAULT LOGGER INSTANCE
// =============================================================================
export const logger = new Logger();

// =============================================================================
// SPECIALIZED LOGGERS
// =============================================================================
export const gameLogger = logger.child('game');
export const wsLogger = logger.child('websocket');
export const authLogger = logger.child('auth');
export const dbLogger = logger.child('database');
export const redisLogger = logger.child('redis');

// =============================================================================
// PERFORMANCE LOGGING
// =============================================================================
export class PerformanceLogger {
  private timers: Map<string, number> = new Map();

  /**
   * Start timing an operation
   */
  start(operationId: string): void {
    this.timers.set(operationId, Date.now());
  }

  /**
   * End timing and log the duration
   */
  end(operationId: string, description?: string): number {
    const startTime = this.timers.get(operationId);
    if (!startTime) {
      logger.warn(`Performance timer not found: ${operationId}`);
      return 0;
    }

    const duration = Date.now() - startTime;
    this.timers.delete(operationId);

    logger.debug(`Performance: ${description || operationId}`, {
      operationId,
      duration: `${duration}ms`,
    });

    return duration;
  }

  /**
   * Measure an async operation
   */
  async measure<T>(
    operationId: string,
    operation: () => Promise<T>,
    description?: string
  ): Promise<T> {
    this.start(operationId);
    try {
      const result = await operation();
      this.end(operationId, description);
      return result;
    } catch (error) {
      this.end(operationId, `${description || operationId} (failed)`);
      throw error;
    }
  }
}

export const performanceLogger = new PerformanceLogger();

// =============================================================================
// REQUEST LOGGING MIDDLEWARE HELPER
// =============================================================================
export interface RequestLogContext {
  method: string;
  url: string;
  userAgent?: string;
  ip?: string;
  userId?: string;
  statusCode?: number;
  duration?: number;
}

export function logRequest(context: RequestLogContext): void {
  const level = context.statusCode && context.statusCode >= 400 ? LogLevel.WARN : LogLevel.INFO;

  logger.info(`${context.method} ${context.url}`, {
    type: 'http_request',
    ...context,
  });
}

// =============================================================================
// EXPORT DEFAULT LOGGER
// =============================================================================
export default logger;
</file>

<file path="backend/src/utils/validators.ts">
// üê∫ LOBISOMEM ONLINE - Validation Utilities
// Input validation and sanitization functions
import { z } from 'zod';
import { GAME_LIMITS } from './constants';

//====================================================================
// BASIC VALIDATION SCHEMAS
//====================================================================
// User validation
export const emailSchema = z
  .string()
  .email('Email inv√°lido')
  .toLowerCase()
  .trim();

export const usernameSchema = z
  .string()
  .min(3, 'Username deve ter pelo menos 3 caracteres')
  .max(20, 'Username deve ter no m√°ximo 20 caracteres')
  .regex(/^[a-zA-Z0-9_-]+$/, 'Username s√≥ pode conter letras, n√∫meros, _ e -')
  .trim();

export const passwordSchema = z
  .string()
  .min(6, 'Senha deve ter pelo menos 6 caracteres')
  .max(50, 'Senha deve ter no m√°ximo 50 caracteres')
  .regex(/(?=.*[a-z])/, 'Senha deve conter pelo menos uma letra min√∫scula')
  .regex(/(?=.*[A-Z])/, 'Senha deve conter pelo menos uma letra mai√∫scula')
  .regex(/(?=.*\d)/, 'Senha deve conter pelo menos um n√∫mero');

// Room validation
export const roomNameSchema = z
  .string()
  .min(1, 'Nome da sala √© obrigat√≥rio')
  .max(GAME_LIMITS.MAX_ROOM_NAME_LENGTH, `Nome deve ter no m√°ximo ${GAME_LIMITS.MAX_ROOM_NAME_LENGTH} caracteres`)
  .trim();

export const roomCodeSchema = z
  .string()
  .length(GAME_LIMITS.ROOM_CODE_LENGTH, `C√≥digo deve ter ${GAME_LIMITS.ROOM_CODE_LENGTH} d√≠gitos`)
  .regex(/^\d+$/, 'C√≥digo deve conter apenas n√∫meros');

// Chat validation
export const chatMessageSchema = z
  .string()
  .min(1, 'Mensagem n√£o pode estar vazia')
  .max(GAME_LIMITS.MAX_MESSAGE_LENGTH, `Mensagem deve ter no m√°ximo ${GAME_LIMITS.MAX_MESSAGE_LENGTH} caracteres`)
  .trim();

//====================================================================
// AUTH REQUEST SCHEMAS
//====================================================================
export const registerRequestSchema = z.object({
  email: emailSchema,
  username: usernameSchema,
  password: passwordSchema,
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Senhas n√£o coincidem',
  path: ['confirmPassword'],
});

export const loginRequestSchema = z.object({
  email: emailSchema,
  password: z.string().min(1, 'Senha √© obrigat√≥ria'),
});

export const forgotPasswordSchema = z.object({
  email: emailSchema,
});

export const resetPasswordSchema = z.object({
  token: z.string().min(1, 'Token √© obrigat√≥rio'),
  password: passwordSchema,
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Senhas n√£o coincidem',
  path: ['confirmPassword'],
});

//====================================================================
// ROOM REQUEST SCHEMAS
//====================================================================
export const createRoomSchema = z.object({
  name: roomNameSchema,
  isPrivate: z.boolean().optional().default(false),
  maxPlayers: z
    .number()
    .min(GAME_LIMITS.MIN_PLAYERS, `M√≠nimo ${GAME_LIMITS.MIN_PLAYERS} jogadores`)
    .max(GAME_LIMITS.MAX_PLAYERS, `M√°ximo ${GAME_LIMITS.MAX_PLAYERS} jogadores`)
    .optional()
    .default(GAME_LIMITS.MAX_PLAYERS),
  maxSpectators: z
    .number()
    .min(0, 'N√∫mero de espectadores n√£o pode ser negativo')
    .max(GAME_LIMITS.MAX_SPECTATORS, `M√°ximo ${GAME_LIMITS.MAX_SPECTATORS} espectadores`)
    .optional()
    .default(GAME_LIMITS.MAX_SPECTATORS),
});

export const joinRoomSchema = z.object({
  roomId: z.string().cuid().optional(),
  code: roomCodeSchema.optional(),
  asSpectator: z.boolean().optional().default(false),
}).refine((data) => data.roomId || data.code, {
  message: 'Room ID ou c√≥digo √© obrigat√≥rio',
});

export const updateRoomSchema = z.object({
  name: roomNameSchema.optional(),
  maxPlayers: z
    .number()
    .min(GAME_LIMITS.MIN_PLAYERS)
    .max(GAME_LIMITS.MAX_PLAYERS)
    .optional(),
  maxSpectators: z
    .number()
    .min(0)
    .max(GAME_LIMITS.MAX_SPECTATORS)
    .optional(),
});

//====================================================================
// GAME REQUEST SCHEMAS
//====================================================================
export const gameActionSchema = z.object({
  type: z.enum(['INVESTIGATE', 'PROTECT', 'KILL', 'VOTE']),
  targetId: z.string().cuid().optional(),
  data: z.record(z.any()).optional(),
});

export const voteSchema = z.object({
  targetId: z.string().cuid('ID do alvo inv√°lido'),
});

//====================================================================
// CHAT SCHEMAS
//====================================================================
export const chatMessageRequestSchema = z.object({
  message: chatMessageSchema,
  channel: z.enum(['public', 'werewolf', 'spectator']).optional().default('public'),
});

//====================================================================
// PAGINATION SCHEMAS
//====================================================================
export const paginationSchema = z.object({
  page: z
    .string()
    .transform((val) => parseInt(val))
    .pipe(z.number().min(1, 'P√°gina deve ser maior que 0'))
    .optional()
    .default('1'),
  limit: z
    .string()
    .transform((val) => parseInt(val))
    .pipe(z.number().min(1).max(100, 'Limite m√°ximo de 100 itens por p√°gina'))
    .optional()
    .default('10'),
  sortBy: z.string().optional(),
  sortOrder: z.enum(['asc', 'desc']).optional().default('desc'),
});

//====================================================================
// CUSTOM VALIDATION FUNCTIONS
//====================================================================
/**
 * Validate if a string is a valid CUID
 */
export function isValidCuid(id: string): boolean {
  return z.string().cuid().safeParse(id).success;
}

/**
 * Validate if a user can perform an action in a game
 */
export function canPerformAction(
  role: string,
  phase: string,
  action: string
): boolean {
  const nightActions = ['INVESTIGATE', 'PROTECT', 'KILL'];
  const dayActions = ['VOTE'];

  if (phase === 'NIGHT' && nightActions.includes(action)) {
    return ['SHERIFF', 'DOCTOR', 'WEREWOLF', 'WEREWOLF_KING', 'VIGILANTE', 'SERIAL_KILLER'].includes(role);
  }

  if (phase === 'VOTING' && action === 'VOTE') {
    return true; // Everyone can vote
  }

  return false;
}

/**
 * Validate room code format
 */
export function generateRoomCode(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

/**
 * Sanitize chat message (remove harmful content)
 */
export function sanitizeChatMessage(message: string): string {
  return message
    .trim()
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // Remove script tags
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .substring(0, GAME_LIMITS.MAX_MESSAGE_LENGTH);
}

/**
 * Validate if email domain is allowed
 */
export function isAllowedEmailDomain(email: string): boolean {
  // Add email domain restrictions if needed
  const blockedDomains = ['tempmail.com', '10minutemail.com'];
  const domain = email.split('@')[1];
  if (!domain) return false;
  return !blockedDomains.includes(domain.toLowerCase());
}

/**
 * Validate username availability pattern
 */
export function hasValidUsernamePattern(username: string): boolean {
  // Block offensive patterns
  const blockedPatterns = [
    /admin/i,
    /moderator/i,
    /system/i,
    /bot/i,
    /fuck/i,
    /shit/i,
    // Add more as needed
  ];

  return !blockedPatterns.some(pattern => pattern.test(username));
}

/**
 * Rate limiting validation
 */
export function validateRateLimit(
  requests: number,
  windowMs: number,
  maxRequests: number
): { allowed: boolean; retryAfter?: number } {
  if (requests >= maxRequests) {
    return {
      allowed: false,
      retryAfter: windowMs,
    };
  }

  return { allowed: true };
}

//====================================================================
// WEBSOCKET VALIDATION
//====================================================================
export const websocketMessageSchema = z.object({
  type: z.string().min(1, 'Message type is required'),
  data: z.any().optional(),
  timestamp: z.string().optional(),
  messageId: z.string().optional(),
});

//====================================================================
// EXPORT VALIDATION HELPER
//====================================================================
export function createValidator<T>(schema: z.ZodSchema<T>) {
  return (data: unknown): { success: true; data: T } | { success: false; errors: string[] } => {
    const result = schema.safeParse(data);

    if (result.success) {
      return { success: true, data: result.data };
    }

    const errors = result.error.errors.map(err =>
      `${err.path.join('.')}: ${err.message}`
    );

    return { success: false, errors };
  };
}
</file>

<file path="backend/src/websocket/ConnectionManager.ts">
// üê∫ LOBISOMEM ONLINE - Connection Manager (CORRIGIDO COMPLETO)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí game-service
import { wsLogger } from '@/utils/logger';
import type { WebSocketConnection, ConnectionContext, ConnectionMetadata } from '@/types';
import type WebSocket from 'ws';

//====================================================================
// CONNECTION MANAGER CLASS
//====================================================================
export class ConnectionManager {
  private connections = new Map<string, WebSocketConnection>();

  constructor() {
    wsLogger.debug('ConnectionManager initialized');
  }

  //====================================================================
  // CONNECTION MANAGEMENT
  //====================================================================
  addConnection(
    id: string,
    ws: WebSocket,
    context: ConnectionContext,
    metadata: ConnectionMetadata
  ): WebSocketConnection {
    const connection: WebSocketConnection = {
      id,
      ws,
      context,
      metadata,
      isAlive: true,
      lastPing: Date.now(),
      reconnectAttempts: 0,
    };

    this.connections.set(id, connection);

    wsLogger.info('Connection added', {
      connectionId: id,
      userId: context.userId,
      username: context.username,
      totalConnections: this.connections.size,
    });

    return connection;
  }

  removeConnection(connectionId: string): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    this.connections.delete(connectionId);

    wsLogger.info('Connection removed', {
      connectionId,
      userId: connection.context.userId,
      username: connection.context.username,
      totalConnections: this.connections.size,
    });

    return true;
  }

  getConnection(connectionId: string): WebSocketConnection | null {
    return this.connections.get(connectionId) || null;
  }

  //====================================================================
  // ‚úÖ NOVO: ENCONTRAR CONEX√ÉO POR USER ID
  //====================================================================
  findConnectionByUserId(userId: string): WebSocketConnection | null {
    // Iterar sobre todas as conex√µes para encontrar pelo userId
    for (const [connectionId, connection] of this.connections) {
      if (connection.context.userId === userId) {
        // Verificar se a conex√£o ainda est√° v√°lida
        if (connection.ws.readyState === connection.ws.OPEN) {
          return connection;
        } else {
          // Limpar conex√£o inv√°lida
          wsLogger.warn('Found dead connection for user, cleaning up', {
            userId,
            connectionId
          });
          this.removeConnection(connectionId);
        }
      }
    }

    wsLogger.debug('No active connection found for user', { userId });
    return null;
  }

  //====================================================================
  // ‚úÖ NOVO: OBTER TODAS CONEX√ïES DE UM USU√ÅRIO
  //====================================================================
  getAllConnectionsForUser(userId: string): WebSocketConnection[] {
    const userConnections: WebSocketConnection[] = [];

    for (const [connectionId, connection] of this.connections) {
      if (connection.context.userId === userId) {
        if (connection.ws.readyState === connection.ws.OPEN) {
          userConnections.push(connection);
        } else {
          // Limpar conex√£o inv√°lida
          this.removeConnection(connectionId);
        }
      }
    }

    return userConnections;
  }

  //====================================================================
  // CONNECTION STATUS
  //====================================================================
  getAllConnections(): WebSocketConnection[] {
    return Array.from(this.connections.values());
  }

  getConnectionsCount(): number {
    return this.connections.size;
  }

  //====================================================================
  // ‚úÖ NOVO: CONTAR CONEX√ïES ATIVAS POR USU√ÅRIO
  //====================================================================
  getActiveConnectionsCount(): number {
    let activeCount = 0;

    for (const [connectionId, connection] of this.connections) {
      if (connection.ws.readyState === connection.ws.OPEN) {
        activeCount++;
      } else {
        // Aproveitar para limpar conex√µes mortas
        this.removeConnection(connectionId);
      }
    }

    return activeCount;
  }

  //====================================================================
  // CONNECTION CONTEXT UPDATES
  //====================================================================
  updateConnectionContext(connectionId: string, updates: Partial<ConnectionContext>): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    connection.context = { ...connection.context, ...updates };

    wsLogger.debug('Connection context updated', {
      connectionId,
      updates,
      newContext: connection.context,
    });

    return true;
  }

  //====================================================================
  // HEARTBEAT MANAGEMENT
  //====================================================================
  markAlive(connectionId: string): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    connection.isAlive = true;
    connection.lastPing = Date.now();

    return true;
  }

  markDead(connectionId: string): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    connection.isAlive = false;

    return true;
  }

  //====================================================================
  // HEARTBEAT CHECK
  //====================================================================
  performHeartbeatCheck(timeoutMs: number = 30000): string[] {
    const now = Date.now();
    const deadConnections: string[] = [];

    for (const [connectionId, connection] of this.connections) {
      const timeSinceLastPing = now - connection.lastPing;

      if (timeSinceLastPing > timeoutMs) {
        deadConnections.push(connectionId);
        this.markDead(connectionId);

        wsLogger.warn('Connection marked as dead due to heartbeat timeout', {
          connectionId,
          userId: connection.context.userId,
          timeSinceLastPing,
          timeoutMs,
        });
      }
    }

    return deadConnections;
  }

  //====================================================================
  // CLEANUP METHODS
  //====================================================================
  cleanupDeadConnections(): number {
    let cleanedCount = 0;

    for (const [connectionId, connection] of this.connections) {
      if (!connection.isAlive || connection.ws.readyState !== connection.ws.OPEN) {
        try {
          if (connection.ws.readyState === connection.ws.OPEN) {
            connection.ws.close();
          }
        } catch (error) {
          wsLogger.error('Error closing dead connection', error instanceof Error ? error : new Error('Unknown close error'), {
            connectionId,
          });
        }

        this.removeConnection(connectionId);
        cleanedCount++;
      }
    }

    if (cleanedCount > 0) {
      wsLogger.info('Cleaned up dead connections', {
        cleanedCount,
        remainingConnections: this.connections.size,
      });
    }

    return cleanedCount;
  }


  public getDeadConnections(): string[] {
    const dead: string[] = [];
    for (const [connectionId, connection] of this.connections.entries()) {
      if (!connection.isAlive) {
        dead.push(connectionId);
      }
    }
    return dead;
  }
  //====================================================================
  // UTILITY METHODS
  //====================================================================
  getConnectionsByRoom(roomId: string): WebSocketConnection[] {
    return Array.from(this.connections.values()).filter(
      connection => connection.context.roomId === roomId
    );
  }

  getConnectionsByServerId(serverId: string): WebSocketConnection[] {
    return Array.from(this.connections.values()).filter(
      connection => connection.context.serverId === serverId
    );
  }

  //====================================================================
  // STATISTICS
  //====================================================================
  getConnectionStats(): {
    total: number;
    alive: number;
    dead: number;
    byRoom: Record<string, number>;
    byServer: Record<string, number>;
  } {
    const stats = {
      total: 0,
      alive: 0,
      dead: 0,
      byRoom: {} as Record<string, number>,
      byServer: {} as Record<string, number>,
    };

    for (const connection of this.connections.values()) {
      stats.total++;

      if (connection.isAlive) {
        stats.alive++;
      } else {
        stats.dead++;
      }

      // Count by room
      if (connection.context.roomId) {
        stats.byRoom[connection.context.roomId] = (stats.byRoom[connection.context.roomId] || 0) + 1;
      }

      // Count by server
      stats.byServer[connection.context.serverId] = (stats.byServer[connection.context.serverId] || 0) + 1;
    }

    return stats;
  }

  //====================================================================
  // GRACEFUL SHUTDOWN
  //====================================================================
  async shutdown(): Promise<void> {
    wsLogger.info('Starting ConnectionManager shutdown', {
      totalConnections: this.connections.size,
    });

    const closePromises: Promise<void>[] = [];

    for (const [connectionId, connection] of this.connections) {
      const closePromise = new Promise<void>((resolve) => {
        if (connection.ws.readyState === connection.ws.OPEN) {
          connection.ws.close(1000, 'Server shutdown');

          connection.ws.once('close', () => {
            wsLogger.debug('Connection closed during shutdown', { connectionId });
            resolve();
          });

          // Timeout for graceful close
          setTimeout(() => {
            if (connection.ws.readyState !== connection.ws.CLOSED) {
              connection.ws.terminate();
              wsLogger.warn('Connection forcefully terminated during shutdown', { connectionId });
            }
            resolve();
          }, 5000);
        } else {
          resolve();
        }
      });

      closePromises.push(closePromise);
    }

    // Wait for all connections to close
    await Promise.all(closePromises);

    // Clear all connections
    this.connections.clear();

    wsLogger.info('ConnectionManager shutdown completed');
  }
}
</file>

<file path="backend/src/websocket/ServiceFactory.ts">
// üê∫ LOBISOMEM ONLINE - Service Factory (REFATORADO)
// ‚úÖ PREPARADO PARA MIGRA√á√ÉO AUTOM√ÅTICA ‚Üí microservices
import { config } from '@/config/environment';
import { getRedisClient } from '@/config/redis';
import { logger } from '@/utils/logger';
import { GameState, Player } from '@/game/Game'; // ‚úÖ Usar classe real
import type {
    IGameStateService,
    IEventBus,
    IServiceRegistry,
    GameConfig,
    ServiceMetadata
} from '@/types';

//====================================================================
// MEMORY IMPLEMENTATIONS (PHASE 1) - CORRIGIDAS
//====================================================================

class MemoryGameStateService implements IGameStateService {
    private games = new Map<string, GameState>(); // ‚úÖ Usar GameState n√£o Game
    private players = new Map<string, Map<string, Player>>();

    async createGame(hostId: string, config: GameConfig): Promise<GameState> {
        const gameId = `game-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        // ‚úÖ Criar GameState real
        const gameState = new GameState(gameId, config, hostId);

        this.games.set(gameId, gameState);
        this.players.set(gameId, new Map());

        logger.info('Game created in memory', { gameId, hostId });
        return gameState;
    }

    async getGame(gameId: string): Promise<GameState | null> {
        return this.games.get(gameId) || null;
    }

    async updateGameState(gameId: string, updates: Partial<GameState>): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) throw new Error(`Game ${gameId} not found`);

        // ‚úÖ Aplicar updates na classe real
        Object.assign(gameState, updates);
        gameState.updatedAt = new Date();
    }

    async deleteGame(gameId: string): Promise<void> {
        this.games.delete(gameId);
        this.players.delete(gameId);
        logger.info('Game deleted from memory', { gameId });
    }

    async addPlayer(gameId: string, player: Player): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) throw new Error(`Game ${gameId} not found`);

        // ‚úÖ Usar m√©todo da classe GameState
        const success = gameState.addPlayer(player);
        if (!success) {
            throw new Error('Failed to add player to game');
        }

        // Manter cache de players para queries r√°pidas
        const gamePlayers = this.players.get(gameId)!;
        gamePlayers.set(player.id, player);
    }

    async removePlayer(gameId: string, playerId: string): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) return;

        gameState.removePlayer(playerId);

        const gamePlayers = this.players.get(gameId);
        if (gamePlayers) {
            gamePlayers.delete(playerId);
        }
    }

    async updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void> {
        const gameState = this.games.get(gameId);
        if (!gameState) return;

        const player = gameState.getPlayer(playerId);
        if (player) {
            Object.assign(player, updates);
        }

        // Atualizar cache tamb√©m
        const gamePlayers = this.players.get(gameId);
        if (gamePlayers) {
            const cachedPlayer = gamePlayers.get(playerId);
            if (cachedPlayer) {
                Object.assign(cachedPlayer, updates);
            }
        }
    }

    async getGameState(gameId: string): Promise<GameState | null> {
        // ‚úÖ Retornar o estado real da classe
        return this.games.get(gameId) || null;
    }

    async getPlayer(gameId: string, playerId: string): Promise<Player | null> {
        const gameState = this.games.get(gameId);
        return gameState?.getPlayer(playerId) || null;
    }

    async getAllPlayers(gameId: string): Promise<Player[]> {
        const gameState = this.games.get(gameId);
        return gameState ? gameState.players : [];
    }

    async getGamesByRoom(roomId: string): Promise<GameState[]> {
        const games: GameState[] = [];
        for (const gameState of this.games.values()) {
            if (gameState.roomId === roomId) {
                games.push(gameState);
            }
        }
        return games;
    }

    async getActiveGamesCount(): Promise<number> {
        let count = 0;
        for (const gameState of this.games.values()) {
            if (gameState.status === 'PLAYING' || gameState.status === 'STARTING') {
                count++;
            }
        }
        return count;
    }

    cleanup(): number {
        const count = this.games.size;
        this.games.clear();
        this.players.clear();
        return count;
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return {
            status: 'healthy',
            message: `Memory storage OK - ${this.games.size} games active`
        };
    }
}

class LocalEventBus implements IEventBus {
    private listeners = new Map<string, Array<(event: any) => void>>();

    async publish<T>(channel: string, event: T): Promise<void> {
        const channelListeners = this.listeners.get(channel) || [];
        for (const listener of channelListeners) {
            try {
                listener(event);
            } catch (error) {
                logger.error('Error in event listener', error instanceof Error ? error : new Error('Unknown listener error'), {
                    channel,
                    event: typeof event === 'object' ? JSON.stringify(event) : String(event)
                });
            }
        }
    }

    async subscribe<T>(channel: string, handler: (event: T) => void): Promise<void> {
        if (!this.listeners.has(channel)) {
            this.listeners.set(channel, []);
        }
        this.listeners.get(channel)!.push(handler);
    }

    async unsubscribe(channel: string): Promise<void> {
        this.listeners.delete(channel);
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return {
            status: 'healthy',
            message: `Local EventBus OK - ${this.listeners.size} channels`
        };
    }
}

class MockServiceRegistry implements IServiceRegistry {
    private services = new Map<string, ServiceMetadata>();

    async registerService(serviceId: string, metadata: ServiceMetadata): Promise<void> {
        this.services.set(serviceId, metadata);
        logger.debug('Service registered', { serviceId, type: metadata.type });
    }

    async getAvailableServices(serviceType: string): Promise<string[]> {
        const services: string[] = [];
        for (const [serviceId, metadata] of this.services.entries()) {
            if (metadata.type === serviceType) {
                services.push(serviceId);
            }
        }
        return services;
    }

    async unregisterService(serviceId: string): Promise<void> {
        this.services.delete(serviceId);
        logger.debug('Service unregistered', { serviceId });
    }

    async getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null> {
        return this.services.get(serviceId) || null;
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return {
            status: 'healthy',
            message: `Mock Registry OK - ${this.services.size} services`
        };
    }
}

//====================================================================
// REDIS IMPLEMENTATIONS (PHASE 2) - PLACEHOLDERS CORRIGIDOS
//====================================================================

class RedisGameStateService implements IGameStateService {
    constructor(private redisUrl: string) { }

    async createGame(hostId: string, config: GameConfig): Promise<GameState> {
        // TODO: Implementar Redis
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getGame(gameId: string): Promise<GameState | null> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async updateGameState(gameId: string, updates: Partial<GameState>): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async deleteGame(gameId: string): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async addPlayer(gameId: string, player: Player): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async removePlayer(gameId: string, playerId: string): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getGameState(gameId: string): Promise<GameState | null> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getPlayer(gameId: string, playerId: string): Promise<Player | null> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getAllPlayers(gameId: string): Promise<Player[]> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getGamesByRoom(roomId: string): Promise<GameState[]> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    async getActiveGamesCount(): Promise<number> {
        throw new Error('Redis GameStateService not implemented yet');
    }

    cleanup(): number {
        return 0;
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return { status: 'unhealthy', message: 'Redis GameStateService not implemented' };
    }
}

class RedisEventBus implements IEventBus {
    constructor(private redisUrl: string) { }

    async publish<T>(channel: string, event: T): Promise<void> {
        // TODO: Implementar Redis Pub/Sub
        throw new Error('Redis EventBus not implemented yet');
    }

    async subscribe<T>(channel: string, handler: (event: T) => void): Promise<void> {
        throw new Error('Redis EventBus not implemented yet');
    }

    async unsubscribe(channel: string): Promise<void> {
        throw new Error('Redis EventBus not implemented yet');
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return { status: 'unhealthy', message: 'Redis EventBus not implemented' };
    }
}

class RedisServiceRegistry implements IServiceRegistry {
    constructor(private redisUrl: string) { }

    async registerService(serviceId: string, metadata: ServiceMetadata): Promise<void> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async getAvailableServices(serviceType: string): Promise<string[]> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async unregisterService(serviceId: string): Promise<void> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null> {
        throw new Error('Redis ServiceRegistry not implemented yet');
    }

    async healthCheck(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }> {
        return { status: 'unhealthy', message: 'Redis ServiceRegistry not implemented' };
    }
}

//====================================================================
// SERVICE FACTORY - CORRIGIDA
//====================================================================

export class ServiceFactory {
    private static instances = new Map<string, any>();

    static getGameStateService(): IGameStateService {
        if (!this.instances.has('gameState')) {
            const service = config.STORAGE_TYPE === 'redis'
                ? new RedisGameStateService(config.REDIS_URL)
                : new MemoryGameStateService();
            this.instances.set('gameState', service);
            logger.info('GameStateService initialized', { type: config.STORAGE_TYPE });
        }
        return this.instances.get('gameState');
    }

    static getEventBus(): IEventBus {
        if (!this.instances.has('eventBus')) {
            const bus = config.DISTRIBUTED_MODE
                ? new RedisEventBus(config.REDIS_URL)
                : new LocalEventBus();
            this.instances.set('eventBus', bus);
            logger.info('EventBus initialized', { type: config.DISTRIBUTED_MODE ? 'redis' : 'local' });
        }
        return this.instances.get('eventBus');
    }

    static getServiceRegistry(): IServiceRegistry {
        if (!this.instances.has('serviceRegistry')) {
            const registry = config.DISTRIBUTED_MODE
                ? new RedisServiceRegistry(config.REDIS_URL)
                : new MockServiceRegistry();
            this.instances.set('serviceRegistry', registry);
            logger.info('ServiceRegistry initialized', { type: config.DISTRIBUTED_MODE ? 'redis' : 'mock' });
        }
        return this.instances.get('serviceRegistry');
    }

    static async getServicesHealth(): Promise<Record<string, any>> {
        const health: Record<string, any> = {};
        const services = [
            { name: 'gameState', service: this.getGameStateService() },
            { name: 'eventBus', service: this.getEventBus() },
            { name: 'serviceRegistry', service: this.getServiceRegistry() },
        ];

        for (const { name, service } of services) {
            try {
                if (service.healthCheck) {
                    health[name] = await service.healthCheck();
                } else {
                    health[name] = { status: 'healthy', message: 'No health check available' };
                }
            } catch (error) {
                health[name] = {
                    status: 'unhealthy',
                    message: error instanceof Error ? error.message : 'Unknown error'
                };
            }
        }
        return health;
    }

    static getServicesStats(): Record<string, any> {
        return {
            gameState: {
                type: config.STORAGE_TYPE,
                distributed: config.DISTRIBUTED_MODE
            },
            eventBus: {
                type: config.DISTRIBUTED_MODE ? 'redis' : 'local'
            },
            serviceRegistry: {
                type: config.DISTRIBUTED_MODE ? 'redis' : 'mock'
            }
        };
    }

    static async cleanup(): Promise<void> {
        const gameStateService = this.getGameStateService();
        if (gameStateService.cleanup) {
            const cleanedCount = gameStateService.cleanup();
            logger.info('GameStateService cleanup completed', { cleanedCount });
        }

        this.instances.clear();
        logger.info('ServiceFactory instances cleared');
    }

    static clearInstances(): void {
        this.instances.clear();
        logger.info('ServiceFactory instances cleared');
    }
}
</file>

<file path="database/init.sql">
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";


CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW."updatedAt" = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION calculate_win_rate(total_wins INTEGER, total_games INTEGER)
RETURNS DECIMAL(5,4) AS $$
BEGIN
    IF total_games = 0 THEN
        RETURN 0.0;
    END IF;
    RETURN ROUND((total_wins::DECIMAL / total_games::DECIMAL), 4);
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION generate_room_code()
RETURNS TEXT AS $$
BEGIN
    RETURN LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;


CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(50) UNIQUE NOT NULL,
    "passwordHash" TEXT NOT NULL,
    avatar TEXT,
    level INTEGER DEFAULT 1 NOT NULL,
    "totalGames" INTEGER DEFAULT 0 NOT NULL,
    "totalWins" INTEGER DEFAULT 0 NOT NULL,
    "totalLosses" INTEGER DEFAULT 0 NOT NULL,
    "winRate" DECIMAL(5, 4) DEFAULT 0.0000 NOT NULL,
    "createdAt" TIMESTAMPTZ DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ DEFAULT NOW(),
    "lastLoginAt" TIMESTAMPTZ
);


CREATE TABLE IF NOT EXISTS rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    code VARCHAR(6) UNIQUE,
    "isPrivate" BOOLEAN DEFAULT false NOT NULL,
    "maxPlayers" INTEGER DEFAULT 15 NOT NULL,
    "maxSpectators" INTEGER DEFAULT 5 NOT NULL,
    status VARCHAR(20) DEFAULT 'WAITING' NOT NULL,
    "hostId" UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL,
    "serverId" VARCHAR(50) DEFAULT 'local-server',
    "createdAt" TIMESTAMPTZ DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ DEFAULT NOW()
);



DROP TRIGGER IF EXISTS update_users_updated_at ON users;
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_rooms_updated_at ON rooms;
CREATE TRIGGER update_rooms_updated_at
    BEFORE UPDATE ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
CREATE INDEX IF NOT EXISTS idx_rooms_code ON rooms(code);
CREATE INDEX IF NOT EXISTS idx_rooms_status ON rooms(status);


SELECT 'Database initialized successfully!' as status;
</file>

<file path="frontend/src/components/game/PlayerCircle.tsx">
import React from 'react';
import { useGame } from '@/context/GameContext';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// PLAYER CIRCLE COMPONENT - PLAYERS AO REDOR DA FORCA
// =============================================================================
export default function PlayerCircle() {
  const { gameState, me } = useGame();

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (!gameState) {
    return (
      <div className="w-full h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex items-center justify-center">
        <LoadingSpinner text="Carregando jogadores..." />
      </div>
    );
  }

  // =============================================================================
  // FILTER PLAYERS
  // =============================================================================
  const alivePlayers = gameState.players.filter(p => p.isAlive && !p.isSpectator);
  const deadPlayers = gameState.players.filter(p => !p.isAlive && !p.isSpectator);

  // =============================================================================
  // CALCULATE PLAYER POSITIONS IN CIRCLE
  // =============================================================================
  const getPlayerPosition = (index: number, totalPlayers: number) => {
    const angle = (index * 360) / totalPlayers - 90; // Start from top
    const radiusX = 35; // Horizontal radius percentage
    const radiusY = 30; // Vertical radius percentage

    const x = 50 + radiusX * Math.cos((angle * Math.PI) / 180);
    const y = 50 + radiusY * Math.sin((angle * Math.PI) / 180);

    return { x, y };
  };

  return (
    <div className="w-full h-full bg-medieval-800/30 border border-medieval-600 rounded-lg relative overflow-hidden">

      {/* Background - Town Square */}
      <div className="absolute inset-0 bg-gradient-to-b from-amber-900/20 to-medieval-900/50" />

      {/* Center - Gallows/Forca */}
      <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
        <div className="text-center">
          {/* Forca Visual */}
          <div className="text-6xl mb-2 filter drop-shadow-lg">
            ü™ì
          </div>
          <div className="text-amber-400 text-xs font-semibold">
            FORCA
          </div>
        </div>
      </div>

      {/* Living Players Circle */}
      {alivePlayers.map((player, index) => {
        const position = getPlayerPosition(index, alivePlayers.length);
        const isMe = me?.userId === player.userId;
        const hasVoted = gameState.votes && Object.keys(gameState.votes).includes(player.userId);
        const votesReceived = gameState.votes
          ? Object.values(gameState.votes).filter(targetId => targetId === player.id).length
          : 0;

        return (
          <div
            key={player.id}
            className="absolute transform -translate-x-1/2 -translate-y-1/2 transition-all duration-300 hover:scale-110"
            style={{
              left: `${position.x}%`,
              top: `${position.y}%`,
            }}
          >
            {/* Player Avatar Container */}
            <div className={`
              relative w-16 h-16 rounded-full border-2 transition-all duration-200
              ${isMe
                ? 'border-blue-400 bg-blue-900/80 ring-2 ring-blue-400/50'
                : 'border-medieval-600 bg-medieval-700/80 hover:border-amber-400'
              }
            `}>

              {/* Avatar */}
              <div className="w-full h-full rounded-full flex items-center justify-center text-2xl">
                {player.avatar ? (
                  <img src={player.avatar} alt={player.username} className="w-full h-full rounded-full" />
                ) : (
                  player.isHost ? 'üëë' : isMe ? 'üë§' : 'üßë'
                )}
              </div>

              {/* Connection Status Dot */}
              <div className={`
                absolute -top-1 -right-1 w-4 h-4 rounded-full border-2 border-medieval-900
                ${player.isConnected ? 'bg-green-400' : 'bg-red-400'}
              `} />

              {/* Vote Count Badge */}
              {votesReceived > 0 && gameState.phase === 'VOTING' && (
                <div className="absolute -bottom-2 left-1/2 transform -translate-x-1/2 bg-red-600 text-white text-xs rounded-full px-2 py-1 font-bold min-w-[24px] text-center">
                  {votesReceived}
                </div>
              )}

              {/* Has Voted Indicator */}
              {hasVoted && gameState.phase === 'VOTING' && (
                <div className="absolute -top-2 -left-2 text-green-400 text-lg">
                  ‚úì
                </div>
              )}

              {/* Protected Shield */}
              {player.isProtected && (
                <div className="absolute -bottom-2 -right-2 text-blue-400 text-lg">
                  üõ°Ô∏è
                </div>
              )}

              {/* Host Crown */}
              {player.isHost && (
                <div className="absolute -top-3 left-1/2 transform -translate-x-1/2 text-amber-400 text-lg">
                  üëë
                </div>
              )}
            </div>

            {/* Player Name */}
            <div className="absolute top-full left-1/2 transform -translate-x-1/2 mt-1 text-center min-w-[80px]">
              <div className={`
                text-xs font-semibold truncate px-2 py-1 rounded
                ${isMe
                  ? 'text-blue-300 bg-blue-900/50'
                  : 'text-white bg-medieval-800/50'
                }
              `}>
                {player.username}
              </div>

              {/* Role indicator (only for me or if dead) */}
              {((isMe && player.role) || (!player.isAlive && player.role)) && (
                <div className="text-xs text-purple-300 mt-1">
                  {player.role}
                </div>
              )}
            </div>
          </div>
        );
      })}

      {/* Dead Players - Ghosts around the gallows */}
      {deadPlayers.length > 0 && (
        <div className="absolute bottom-4 left-4 right-4">
          <div className="text-center">
            <h4 className="text-red-400 text-sm font-semibold mb-2 flex items-center justify-center space-x-1">
              <span>üíÄ</span>
              <span>Cemit√©rio ({deadPlayers.length})</span>
            </h4>

            <div className="flex flex-wrap justify-center gap-2">
              {deadPlayers.map((player) => (
                <div
                  key={player.id}
                  className="relative opacity-75 transform scale-75"
                >
                  <div className="w-8 h-8 rounded-full border border-gray-600 bg-gray-800/50 flex items-center justify-center">
                    <span className="text-lg">üëª</span>
                  </div>
                  <div className="absolute top-full left-1/2 transform -translate-x-1/2 mt-1 text-xs text-gray-400 min-w-[40px] text-center">
                    {player.username}
                  </div>
                  {player.role && (
                    <div className="absolute top-full left-1/2 transform -translate-x-1/2 mt-4 text-xs text-purple-400 text-center">
                      {player.role}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Phase Information Overlay */}
      <div className="absolute top-4 left-4 bg-medieval-800/80 border border-medieval-600 rounded-lg px-3 py-2">
        <div className="text-white text-sm">
          {gameState.phase === 'NIGHT' && (
            <div className="flex items-center space-x-2">
              <span>üåô</span>
              <span>A√ß√µes secretas em andamento...</span>
            </div>
          )}
          {gameState.phase === 'DAY' && (
            <div className="flex items-center space-x-2">
              <span>‚òÄÔ∏è</span>
              <span>Discutam e investiguem!</span>
            </div>
          )}
          {gameState.phase === 'VOTING' && (
            <div className="flex items-center space-x-2">
              <span>üó≥Ô∏è</span>
              <span>Votem para executar!</span>
            </div>
          )}
        </div>
      </div>

      {/* Empty State */}
      {alivePlayers.length === 0 && (
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-center">
            <div className="text-6xl mb-4">üëª</div>
            <h3 className="text-lg font-semibold text-white mb-2">Cidade Vazia</h3>
            <p className="text-white/70">Todos os jogadores foram eliminados...</p>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/PlayerList.tsx">
import React from 'react';
import { useGame } from '@/context/GameContext';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// PLAYER LIST COMPONENT - LISTA LATERAL COMPACTA
// =============================================================================
export default function PlayerList() {
  const { gameState, me } = useGame();

  if (!gameState) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex items-center justify-center h-full">
          <LoadingSpinner text="Carregando lista..." />
        </div>
      </div>
    );
  }

  const alivePlayers = gameState.players.filter(p => p.isAlive && !p.isSpectator);
  const deadPlayers = gameState.players.filter(p => !p.isAlive && !p.isSpectator);
  const spectators = gameState.players.filter(p => p.isSpectator) || [];

  // =============================================================================
  // PLAYER ROW COMPONENT
  // =============================================================================
  const PlayerRow = ({ player, isDead = false }: { player: any; isDead?: boolean }) => {
    const isMe = me?.userId === player.userId;
    const hasVoted = gameState.votes && Object.keys(gameState.votes).includes(player.userId);
    const votesReceived = gameState.votes
      ? Object.values(gameState.votes).filter(targetId => targetId === player.id).length
      : 0;

    return (
      <div className={`
        flex items-center space-x-2 p-2 rounded-lg transition-all duration-200
        ${isMe
          ? 'bg-blue-900/50 border border-blue-600'
          : isDead
            ? 'bg-gray-800/30 border border-gray-600 opacity-75'
            : 'bg-medieval-700/30 border border-medieval-600 hover:bg-medieval-700/50'
        }
      `}>

        {/* Status Indicators */}
        <div className="flex flex-col items-center space-y-1">
          {/* Connection Status */}
          <div className={`w-2 h-2 rounded-full ${player.isConnected ? 'bg-green-400' : 'bg-red-400'}`} />

          {/* Vote Count */}
          {votesReceived > 0 && gameState.phase === 'VOTING' && (
            <div className="bg-red-600 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center font-bold">
              {votesReceived}
            </div>
          )}
        </div>

        {/* Player Avatar */}
        <div className={`
          w-8 h-8 rounded-full flex items-center justify-center text-lg
          ${isDead ? 'bg-gray-700' : isMe ? 'bg-blue-800' : 'bg-medieval-600'}
        `}>
          {player.avatar ? (
            <img src={player.avatar} alt={player.username} className="w-full h-full rounded-full" />
          ) : (
            isDead ? 'üíÄ' : player.isHost ? 'üëë' : isMe ? 'üë§' : 'üßë'
          )}
        </div>

        {/* Player Info */}
        <div className="flex-1 min-w-0">
          <div className={`text-sm font-medium truncate ${isDead ? 'text-gray-400' : isMe ? 'text-blue-300' : 'text-white'}`}>
            {player.username}
          </div>

          {/* Tags */}
          <div className="flex flex-wrap gap-1 mt-1">
            {isMe && (
              <span className="bg-blue-600 text-white text-xs px-1 rounded">Voc√™</span>
            )}
            {player.isHost && (
              <span className="bg-amber-600 text-white text-xs px-1 rounded">Host</span>
            )}
            {player.isReady && gameState.phase === 'LOBBY' && (
              <span className="bg-green-600 text-white text-xs px-1 rounded">Pronto</span>
            )}
            {hasVoted && gameState.phase === 'VOTING' && (
              <span className="bg-green-600 text-white text-xs px-1 rounded">Votou</span>
            )}
            {player.hasActed && gameState.phase === 'NIGHT' && (
              <span className="bg-blue-600 text-white text-xs px-1 rounded">Agiu</span>
            )}
            {player.isProtected && (
              <span className="bg-purple-600 text-white text-xs px-1 rounded">üõ°Ô∏è</span>
            )}
          </div>

          {/* Role (only shown if dead or if it's me) */}
          {((isDead && player.role) || (isMe && player.role)) && (
            <div className="text-xs text-purple-300 mt-1">
              {player.role}
            </div>
          )}
        </div>

        {/* Action Indicators */}
        <div className="flex flex-col items-center space-y-1">
          {/* Has Voted */}
          {hasVoted && gameState.phase === 'VOTING' && (
            <div className="text-green-400 text-sm">‚úì</div>
          )}

          {/* Host Crown */}
          {player.isHost && (
            <div className="text-amber-400 text-sm">üëë</div>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Header */}
      <div className="flex-shrink-0 border-b border-medieval-600 p-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-bold text-white flex items-center space-x-2">
            <span>üë•</span>
            <span>Jogadores</span>
          </h3>

          <div className="text-xs text-white/70">
            {alivePlayers.length + deadPlayers.length} total
          </div>
        </div>

        {/* Quick Stats */}
        <div className="flex items-center space-x-4 mt-2 text-xs">
          <div className="flex items-center space-x-1">
            <div className="w-2 h-2 bg-green-500 rounded-full"></div>
            <span className="text-green-400">Vivos: {alivePlayers.length}</span>
          </div>
          <div className="flex items-center space-x-1">
            <div className="w-2 h-2 bg-red-500 rounded-full"></div>
            <span className="text-red-400">Mortos: {deadPlayers.length}</span>
          </div>
        </div>
      </div>

      {/* Players List */}
      <div className="flex-1 overflow-y-auto p-4 space-y-2">

        {/* Living Players */}
        {alivePlayers.length > 0 && (
          <div>
            <h4 className="text-sm font-semibold text-green-400 mb-2 flex items-center space-x-1">
              <span>üíö</span>
              <span>Vivos ({alivePlayers.length})</span>
            </h4>
            <div className="space-y-1">
              {alivePlayers.map((player) => (
                <PlayerRow key={player.id} player={player} />
              ))}
            </div>
          </div>
        )}

        {/* Dead Players */}
        {deadPlayers.length > 0 && (
          <div className="mt-4">
            <h4 className="text-sm font-semibold text-red-400 mb-2 flex items-center space-x-1">
              <span>üíÄ</span>
              <span>Mortos ({deadPlayers.length})</span>
            </h4>
            <div className="space-y-1">
              {deadPlayers.map((player) => (
                <PlayerRow key={player.id} player={player} isDead={true} />
              ))}
            </div>
          </div>
        )}

        {/* Spectators */}
        {spectators.length > 0 && (
          <div className="mt-4">
            <h4 className="text-sm font-semibold text-blue-400 mb-2 flex items-center space-x-1">
              <span>üëÅÔ∏è</span>
              <span>Espectadores ({spectators.length})</span>
            </h4>
            <div className="space-y-1">
              {spectators.map((spectator) => (
                <div
                  key={spectator.id}
                  className="flex items-center space-x-2 p-2 bg-blue-900/20 border border-blue-600 rounded-lg"
                >
                  <div className="w-8 h-8 rounded-full bg-blue-800 flex items-center justify-center text-lg">
                    üëÅÔ∏è
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="text-sm text-blue-300 truncate">{spectator.username}</div>
                    <div className="text-xs text-blue-400">Espectador</div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* Vote Summary (during voting phase) */}
      {gameState.phase === 'VOTING' && gameState.votes && Object.keys(gameState.votes).length > 0 && (
        <div className="flex-shrink-0 border-t border-medieval-600 p-4">
          <h4 className="text-sm font-semibold text-white mb-2">üó≥Ô∏è Resumo dos Votos</h4>

          <div className="space-y-1">
            {Object.entries(
              Object.entries(gameState.votes).reduce((acc, [voterId, targetId]) => {
                const target = alivePlayers.find(p => p.id === targetId);
                if (target) {
                  acc[targetId] = (acc[targetId] || 0) + 1;
                }
                return acc;
              }, {} as Record<string, number>)
            )
              .sort(([, a], [, b]) => b - a) // Sort by vote count
              .map(([playerId, voteCount]) => {
                const player = alivePlayers.find(p => p.id === playerId);
                return player ? (
                  <div key={playerId} className="flex justify-between items-center text-sm">
                    <span className="text-white truncate">{player.username}</span>
                    <span className="bg-red-700 text-white px-2 py-1 rounded text-xs font-bold">
                      {voteCount} {voteCount === 1 ? 'voto' : 'votos'}
                    </span>
                  </div>
                ) : null;
              })}
          </div>
        </div>
      )}

      {/* Empty State */}
      {alivePlayers.length === 0 && deadPlayers.length === 0 && (
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center text-white/50">
            <div className="text-4xl mb-2">üëª</div>
            <p>Nenhum jogador</p>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/RoleCard.tsx">
import React, { useState } from 'react';
import { useGame } from '@/context/GameContext';
import type { Role, Faction } from '@/types';

// =============================================================================
// ROLE CONFIGURATIONS
// =============================================================================
const ROLE_INFO: Record<Role, {
  name: string;
  icon: string;
  description: string;
  abilities: string[];
  goal: string;
  tips: string[];
}> = {
  VILLAGER: {
    name: 'Alde√£o',
    icon: 'üë®‚Äçüåæ',
    description: 'Um cidad√£o comum da vila',
    abilities: ['Votar durante o dia'],
    goal: 'Eliminar todos os Lobisomens',
    tips: [
      'Preste aten√ß√£o aos comportamentos suspeitos',
      'Use seu voto com sabedoria',
      'Confie nas informa√ß√µes do Sheriff'
    ],
  },
  SHERIFF: {
    name: 'Sheriff',
    icon: 'üïµÔ∏è',
    description: 'Investigador da vila',
    abilities: ['Investigar um jogador por noite', 'Descobre se √© SUSPEITO ou N√ÉO SUSPEITO'],
    goal: 'Encontrar e eliminar todos os Lobisomens',
    tips: [
      'Investigue jogadores suspeitos',
      'Compartilhe informa√ß√µes com cuidado',
      'Cuidado para n√£o se revelar cedo demais'
    ],
  },
  DOCTOR: {
    name: 'M√©dico',
    icon: '‚öïÔ∏è',
    description: 'Protetor da vila',
    abilities: ['Proteger um jogador por noite', 'N√£o pode proteger a mesma pessoa duas noites seguidas'],
    goal: 'Manter a vila viva eliminando Lobisomens',
    tips: [
      'Proteja jogadores importantes',
      'N√£o se proteja consecutivamente',
      'Observe padr√µes de ataque'
    ],
  },
  VIGILANTE: {
    name: 'Vigilante',
    icon: 'üî´',
    description: 'Justiceiro da vila',
    abilities: ['Matar um jogador por noite (3 usos)', 'Perde turno se matar inocente'],
    goal: 'Eliminar Lobisomens com sua arma',
    tips: [
      'Use suas balas com muito cuidado',
      'S√≥ atire se tiver certeza',
      'Matar um inocente te faz perder uma noite'
    ],
  },
  WEREWOLF: {
    name: 'Lobisomem',
    icon: 'üê∫',
    description: 'Predador da noite',
    abilities: ['Matar um jogador por noite (vota√ß√£o em grupo)', 'Chat privado com outros lobisomens'],
    goal: 'Igualar ou superar o n√∫mero da Vila',
    tips: [
      'Coordene com outros lobisomens',
      'Blefe durante o dia',
      'Elimine amea√ßas priorit√°rias'
    ],
  },
  WEREWOLF_KING: {
    name: 'Rei Lobisomem',
    icon: 'üëë',
    description: 'L√≠der da alcateia',
    abilities: ['Matar um jogador por noite', 'Imune √† investiga√ß√£o do Sheriff', 'Chat privado com lobisomens'],
    goal: 'Liderar a alcateia at√© a vit√≥ria',
    tips: [
      'Use sua imunidade ao Sheriff',
      'Lidere as decis√µes da alcateia',
      'Mantenha-se disfar√ßado'
    ],
  },
  JESTER: {
    name: 'Bobo da Corte',
    icon: 'ü§°',
    description: 'Personagem ca√≥tico',
    abilities: ['Vencer se for executado durante o dia', 'Imune a ataques noturnos'],
    goal: 'Ser executado pela vila (N√ÉO morto √† noite)',
    tips: [
      'Pare√ßa suspeito sem ser √≥bvio',
      'Evite ser morto √† noite',
      'Cause confus√£o nas discuss√µes'
    ],
  },
  SERIAL_KILLER: {
    name: 'Assassino em S√©rie',
    icon: 'üî™',
    description: 'Matador solit√°rio',
    abilities: ['Matar um jogador por noite', 'Imune a investiga√ß√£o na primeira noite'],
    goal: 'Ser o √∫ltimo sobrevivente',
    tips: [
      'Elimine todos os outros',
      'Finja ser da vila',
      'Mate amea√ßas e suspeitos'
    ],
  },
};

const FACTION_INFO: Record<Faction, {
  name: string;
  color: string;
  bgColor: string;
  borderColor: string;
}> = {
  TOWN: {
    name: 'Vila',
    color: 'text-green-400',
    bgColor: 'bg-green-900',
    borderColor: 'border-green-600',
  },
  WEREWOLF: {
    name: 'Lobisomens',
    color: 'text-red-400',
    bgColor: 'bg-red-900',
    borderColor: 'border-red-600',
  },
  NEUTRAL: {
    name: 'Neutro',
    color: 'text-purple-400',
    bgColor: 'bg-purple-900',
    borderColor: 'border-purple-600',
  },
};

// =============================================================================
// ROLE CARD COMPONENT - COMPACTO PARA LAYOUT TOWN OF SALEM
// =============================================================================
export default function RoleCard() {
  const { me, gameState } = useGame();
  const [isExpanded, setIsExpanded] = useState(false);

  if (!me || !me.role || !me.faction || !gameState) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4 animate-pulse">‚ùì</div>
          <h3 className="text-white font-semibold mb-2">Aguardando Role</h3>
          <p className="text-white/50 text-sm">Sua role ser√° revelada quando o jogo come√ßar</p>
        </div>
      </div>
    );
  }

  const roleInfo = ROLE_INFO[me.role];
  const factionInfo = FACTION_INFO[me.faction];

  if (!roleInfo || !factionInfo) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">‚ùì</div>
          <h3 className="text-white font-semibold mb-2">Role Desconhecida</h3>
          <p className="text-white/50 text-sm">Role: {me.role}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Header - Always Visible */}
      <div className={`
        flex-shrink-0 ${factionInfo.bgColor} border-b ${factionInfo.borderColor} p-4 rounded-t-lg cursor-pointer transition-all duration-200
        ${isExpanded ? '' : 'hover:opacity-80'}
      `} onClick={() => setIsExpanded(!isExpanded)}>

        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="text-3xl">{roleInfo.icon}</div>
            <div>
              <h3 className="text-white font-bold text-lg">{roleInfo.name}</h3>
              <p className={`text-sm ${factionInfo.color}`}>{factionInfo.name}</p>
            </div>
          </div>

          <div className="text-white text-lg">
            {isExpanded ? 'üìñ' : 'üìö'}
          </div>
        </div>

        {/* Quick Status - Always Visible */}
        {!isExpanded && (
          <div className="mt-3 grid grid-cols-2 gap-2 text-xs">
            <div className="flex justify-between">
              <span className="text-white/70">Status:</span>
              <span className={me.isAlive ? 'text-green-400' : 'text-red-400'}>
                {me.isAlive ? 'Vivo' : 'Morto'}
              </span>
            </div>

            {me.hasActed !== undefined && gameState?.phase === 'NIGHT' && (
              <div className="flex justify-between">
                <span className="text-white/70">A√ß√£o:</span>
                <span className={me.hasActed ? 'text-blue-400' : 'text-amber-400'}>
                  {me.hasActed ? 'Usada' : 'Dispon√≠vel'}
                </span>
              </div>
            )}

            {me.hasVoted !== undefined && gameState?.phase === 'VOTING' && (
              <div className="flex justify-between">
                <span className="text-white/70">Voto:</span>
                <span className={me.hasVoted ? 'text-green-400' : 'text-amber-400'}>
                  {me.hasVoted ? 'Votou' : 'Pendente'}
                </span>
              </div>
            )}

            {me.isProtected && (
              <div className="flex justify-between col-span-2">
                <span className="text-white/70">Prote√ß√£o:</span>
                <span className="text-blue-400">üõ°Ô∏è Ativa</span>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Expanded Content */}
      {isExpanded && (
        <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-medieval-900/20">

          {/* Description */}
          <div>
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>üìù</span>
              <span>Descri√ß√£o</span>
            </h4>
            <p className="text-white/80 text-sm">{roleInfo.description}</p>
          </div>

          {/* Abilities */}
          <div>
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>‚ö°</span>
              <span>Habilidades</span>
            </h4>
            <ul className="space-y-1">
              {roleInfo.abilities.map((ability, index) => (
                <li key={index} className="text-white/80 text-sm flex items-start space-x-2">
                  <span className="text-blue-400 mt-1 flex-shrink-0">‚Ä¢</span>
                  <span>{ability}</span>
                </li>
              ))}
            </ul>
          </div>

          {/* Goal */}
          <div>
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>üéØ</span>
              <span>Objetivo</span>
            </h4>
            <p className={`text-sm font-medium ${factionInfo.color} bg-medieval-800/50 p-2 rounded border ${factionInfo.borderColor}`}>
              {roleInfo.goal}
            </p>
          </div>

          {/* Tips */}
          <div>
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>üí°</span>
              <span>Dicas</span>
            </h4>
            <ul className="space-y-1">
              {roleInfo.tips.map((tip, index) => (
                <li key={index} className="text-white/70 text-xs flex items-start space-x-2">
                  <span className="text-amber-400 mt-1 flex-shrink-0">üí°</span>
                  <span>{tip}</span>
                </li>
              ))}
            </ul>
          </div>

          {/* Detailed Status */}
          <div className="border-t border-medieval-600 pt-3">
            <h4 className="text-white font-semibold mb-2 flex items-center space-x-1">
              <span>üìä</span>
              <span>Status Detalhado</span>
            </h4>

            <div className="grid grid-cols-1 gap-2 text-xs">
              <div className="flex justify-between p-2 bg-medieval-800/30 rounded">
                <span className="text-white/70">Status de Vida:</span>
                <span className={me.isAlive ? 'text-green-400' : 'text-red-400'}>
                  {me.isAlive ? 'üíö Vivo' : 'üíÄ Morto'}
                </span>
              </div>

              {me.hasActed !== undefined && (
                <div className="flex justify-between p-2 bg-medieval-800/30 rounded">
                  <span className="text-white/70">A√ß√£o Noturna:</span>
                  <span className={me.hasActed ? 'text-blue-400' : 'text-amber-400'}>
                    {me.hasActed ? '‚úÖ Executada' : '‚è≥ Dispon√≠vel'}
                  </span>
                </div>
              )}

              {me.hasVoted !== undefined && (
                <div className="flex justify-between p-2 bg-medieval-800/30 rounded">
                  <span className="text-white/70">Voto:</span>
                  <span className={me.hasVoted ? 'text-green-400' : 'text-amber-400'}>
                    {me.hasVoted ? 'üó≥Ô∏è Votou' : '‚è≥ Pendente'}
                  </span>
                </div>
              )}

              {me.isProtected && (
                <div className="flex justify-between p-2 bg-blue-900/30 rounded border border-blue-600">
                  <span className="text-white/70">Prote√ß√£o:</span>
                  <span className="text-blue-400">üõ°Ô∏è Protegido</span>
                </div>
              )}

              {me.actionsUsed !== undefined && me.maxActions !== undefined && (
                <div className="flex justify-between p-2 bg-medieval-800/30 rounded">
                  <span className="text-white/70">A√ß√µes Restantes:</span>
                  <span className="text-amber-400">{me.maxActions - me.actionsUsed}/{me.maxActions}</span>
                </div>
              )}

              {me.eliminationReason && (
                <div className="flex justify-between p-2 bg-red-900/30 rounded border border-red-600">
                  <span className="text-white/70">Causa da Morte:</span>
                  <span className="text-red-400">
                    {me.eliminationReason === 'NIGHT_KILL' ? 'üåô Morto √† noite' :
                      me.eliminationReason === 'EXECUTION' ? 'üó≥Ô∏è Executado' :
                        me.eliminationReason === 'VIGILANTE' ? 'üî´ Vigilante' :
                          'üî™ Assassino'}
                  </span>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Footer - Game Info */}
      {!isExpanded && gameState && (
        <div className="flex-shrink-0 border-t border-medieval-600 p-3 bg-medieval-900/30">
          <div className="text-xs text-center text-white/50">
            Dia {gameState.day} ‚Ä¢ {gameState.phase === 'NIGHT' ? 'üåô Noite' :
              gameState.phase === 'DAY' ? '‚òÄÔ∏è Dia' :
                gameState.phase === 'VOTING' ? 'üó≥Ô∏è Vota√ß√£o' :
                  gameState.phase}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/game/TimerDisplay.tsx">
import React, { useEffect, useState } from 'react';
import { useGame } from '@/context/GameContext';

// =============================================================================
// TIMER DISPLAY COMPONENT - COMPACTO PARA HEADER
// =============================================================================
export default function TimerDisplay() {
  const { gameState } = useGame();
  const [localTimeLeft, setLocalTimeLeft] = useState(0);

  // =============================================================================
  // SYNC WITH GAME STATE
  // =============================================================================
  useEffect(() => {
    if (!gameState) return;

    // Use timeLeft from gameState
    const newTimeLeft = gameState.timeLeft || 0;
    setLocalTimeLeft(newTimeLeft);
  }, [gameState?.timeLeft, gameState?.phase]);

  // =============================================================================
  // LOCAL COUNTDOWN UPDATE
  // =============================================================================
  useEffect(() => {
    if (localTimeLeft <= 0) return;

    const interval = setInterval(() => {
      setLocalTimeLeft(prev => Math.max(0, prev - 1000));
    }, 1000);

    return () => clearInterval(interval);
  }, [localTimeLeft]);

  // =============================================================================
  // NO GAME STATE
  // =============================================================================
  if (!gameState) {
    return (
      <div className="flex items-center space-x-2">
        <div className="animate-pulse bg-medieval-700 h-10 w-20 rounded-lg"></div>
      </div>
    );
  }

  // =============================================================================
  // CALCULATE DISPLAY VALUES
  // =============================================================================
  const totalSeconds = Math.floor(localTimeLeft / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;

  // Determine urgency level
  const isUrgent = totalSeconds <= 30;
  const isCritical = totalSeconds <= 10;
  const isEmpty = totalSeconds <= 0;

  // Color scheme based on time remaining
  const getTimerColor = () => {
    if (isEmpty) return 'text-gray-500';
    if (isCritical) return 'text-red-400';
    if (isUrgent) return 'text-amber-400';
    return 'text-green-400';
  };

  const getBorderColor = () => {
    if (isEmpty) return 'border-gray-600';
    if (isCritical) return 'border-red-500';
    if (isUrgent) return 'border-amber-500';
    return 'border-green-500';
  };

  const getBackgroundColor = () => {
    if (isEmpty) return 'bg-gray-800';
    if (isCritical) return 'bg-red-900';
    if (isUrgent) return 'bg-amber-900';
    return 'bg-green-900';
  };

  // =============================================================================
  // RENDER TIMER
  // =============================================================================
  return (
    <div className="flex items-center space-x-3">

      {/* Main Timer Display - Compact */}
      <div className={`
        ${getBackgroundColor()} border-2 ${getBorderColor()} rounded-lg px-3 py-2
        ${isCritical ? 'animate-pulse' : ''}
        transition-all duration-300 flex items-center space-x-2
      `}>

        {/* Timer Icon */}
        <div className="text-lg">
          {isEmpty ? '‚è∞' :
            isCritical ? 'üî•' :
              isUrgent ? '‚ö°' : '‚è±Ô∏è'}
        </div>

        {/* Time Display */}
        <div className="text-center">
          <div className={`text-lg font-mono font-bold ${getTimerColor()}`}>
            {isEmpty ? '--:--' : `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`}
          </div>
        </div>
      </div>

      {/* Status Text */}
      <div className="hidden md:block">
        {isUrgent && !isEmpty && (
          <div className="flex items-center space-x-1 text-amber-400">
            <span className="animate-bounce">‚ö†Ô∏è</span>
            <span className="text-xs font-medium">
              {isCritical ? 'CR√çTICO!' : 'Tempo Acabando!'}
            </span>
          </div>
        )}

        {isEmpty && (
          <div className="flex items-center space-x-1 text-gray-400">
            <span>‚è≥</span>
            <span className="text-xs">
              Aguardando...
            </span>
          </div>
        )}

        {!isUrgent && !isEmpty && (
          <div className="text-xs text-white/50">
            {gameState.phase === 'NIGHT' ? 'Fase Noite' :
              gameState.phase === 'DAY' ? 'Fase Dia' :
                gameState.phase === 'VOTING' ? 'Vota√ß√£o' :
                  'Tempo restante'}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/room/ActionButtons.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import {
  Check,
  Clock,
  Play,
  Wifi,
  WifiOff,
  AlertCircle,
  Crown
} from 'lucide-react';

interface ActionButtonsProps {
  isHost: boolean;
  isReady: boolean;
  canStartGame: boolean;
  isConnected: boolean;
  onToggleReady: () => void;
  onStartGame: () => void;
}

export default function ActionButtons({
  isHost,
  isReady,
  canStartGame,
  isConnected,
  onToggleReady,
  onStartGame
}: ActionButtonsProps) {
  return (
    <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
      <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
        {isHost && <Crown className="w-5 h-5 text-yellow-400" />}
        {isHost ? 'Controles do Host' : 'A√ß√µes'}
      </h3>

      <div className="space-y-3">
        {/* ‚úÖ CORRIGIDO: Bot√£o Ready apenas para jogadores, n√£o para o host */}
        {!isHost && (
          <motion.button
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            onClick={onToggleReady}
            disabled={!isConnected}
            className={`
              w-full py-3 px-4 rounded-lg font-medium transition-all duration-200
              flex items-center justify-center gap-2
              ${isReady
                ? 'bg-green-600 hover:bg-green-700 text-white shadow-lg'
                : 'bg-orange-600 hover:bg-orange-700 text-white'
              }
              disabled:opacity-50 disabled:cursor-not-allowed
            `}
          >
            {isReady ? (
              <>
                <Check className="w-5 h-5" />
                Pronto! (Clique para cancelar)
              </>
            ) : (
              <>
                <Clock className="w-5 h-5" />
                Marcar como Pronto
              </>
            )}
          </motion.button>
        )}

        {/* ‚úÖ CORRIGIDO: Bot√£o Start Game apenas para host */}
        {isHost && (
          <motion.button
            whileHover={canStartGame ? { scale: 1.02 } : {}}
            whileTap={canStartGame ? { scale: 0.98 } : {}}
            onClick={onStartGame}
            disabled={!canStartGame || !isConnected}
            className={`
              w-full py-3 px-4 rounded-lg font-medium transition-all duration-200
              flex items-center justify-center gap-2
              ${canStartGame
                ? 'bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white shadow-lg shadow-green-600/25'
                : 'bg-slate-600 text-slate-400 cursor-not-allowed'
              }
              disabled:opacity-50
            `}
          >
            <Play className="w-5 h-5" />
            {canStartGame ? 'üéÆ Iniciar Jogo!' : 'Aguardando jogadores prontos...'}
          </motion.button>
        )}

        {/* ‚úÖ NOVO: Mensagem informativa para o host sobre n√£o precisar ficar "pronto" */}
        {isHost && (
          <div className="mt-3 p-3 bg-yellow-600/20 rounded-lg border border-yellow-600/50">
            <div className="flex items-center gap-2 text-sm text-yellow-300 mb-2">
              <Crown className="w-4 h-4" />
              Voc√™ √© o host
            </div>
            <p className="text-xs text-yellow-200">
              Como host, voc√™ n√£o precisa marcar como "pronto". Voc√™ pode iniciar o jogo quando todos os outros jogadores estiverem prontos.
            </p>
          </div>
        )}

        {/* Informa√ß√µes adicionais para host */}
        {isHost && (
          <div className="mt-4 p-3 bg-slate-700/30 rounded-lg border border-slate-600/50">
            <div className="flex items-center gap-2 text-sm text-slate-300 mb-2">
              <AlertCircle className="w-4 h-4" />
              Requisitos para iniciar:
            </div>
            <ul className="text-xs text-slate-400 space-y-1">
              <li>‚Ä¢ M√≠nimo de 3 jogadores</li>
              <li>‚Ä¢ Todos os jogadores prontos</li>
              <li>‚Ä¢ Conex√£o est√°vel</li>
            </ul>
          </div>
        )}

        {/* ‚úÖ MELHORADO: Informa√ß√µes para jogadores */}
        {!isHost && (
          <div className="mt-4 p-3 bg-blue-600/20 rounded-lg border border-blue-600/50">
            <div className="flex items-center gap-2 text-sm text-blue-300 mb-2">
              <AlertCircle className="w-4 h-4" />
              Aguardando outros jogadores
            </div>
            <p className="text-xs text-blue-200">
              Marque-se como pronto quando estiver preparado para jogar. O host iniciar√° a partida quando todos estiverem prontos.
            </p>
          </div>
        )}

        {/* Indicador de conex√£o */}
        <div className="flex items-center justify-center gap-2 text-sm pt-2 border-t border-slate-600/50">
          {isConnected ? (
            <>
              <Wifi className="w-4 h-4 text-green-500" />
              <span className="text-green-500">Conectado</span>
            </>
          ) : (
            <>
              <WifiOff className="w-4 h-4 text-red-500" />
              <span className="text-red-500">Desconectado</span>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/_document.tsx">
// üê∫ WEREWOLF - Next.js Document
// Custom HTML document structure

import { Html, Head, Main, NextScript } from 'next/document';

export default function Document() {
  return (
    <Html lang="pt-BR" className="dark"> {/* ‚úÖ ADICIONADO: lang="pt-BR" */}
      <Head>
        {/* Favicon and App Icons */}
        <link rel="icon" href="/favicon.ico" />
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
        <link rel="manifest" href="/site.webmanifest" />
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#8B925A" />
        <meta name="msapplication-TileColor" content="#2D1B1E" />
        <meta name="theme-color" content="#2D1B1E" />

        {/* ‚úÖ MELHORADO: Meta Tags mais completas */}
        <meta name="description" content="Werewolf - O cl√°ssico jogo de dedu√ß√£o social online. Entre na vila e descubra quem s√£o os lobisomens!" />
        <meta name="keywords" content="werewolf, lobisomem, jogo online, multiplayer, dedu√ß√£o social, mafia" />
        <meta name="author" content="Werewolf Team" />
        <meta name="robots" content="index, follow" />

        {/* ‚úÖ ADICIONADO: Meta tags para PWA */}
        <meta name="format-detection" content="telephone=no" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="apple-mobile-web-app-title" content="Werewolf" />

        {/* Open Graph / Facebook */}
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Werewolf - O Jogo de Dedu√ß√£o Social" />
        <meta property="og:description" content="O cl√°ssico jogo de dedu√ß√£o social online. Descubra quem s√£o os lobisomens antes que eliminem toda a vila!" />
        <meta property="og:image" content="/og-image.png" />
        <meta property="og:url" content="https://werewolf-game.com" />
        <meta property="og:site_name" content="Werewolf" />
        <meta property="og:locale" content="pt_BR" />

        {/* Twitter */}
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="Werewolf - O Jogo de Dedu√ß√£o Social" />
        <meta name="twitter:description" content="O cl√°ssico jogo de dedu√ß√£o social online. Descubra quem s√£o os lobisomens!" />
        <meta name="twitter:image" content="/og-image.png" />

        {/* DNS Prefetch for performance */}
        <link rel="dns-prefetch" href="//fonts.googleapis.com" />
        <link rel="dns-prefetch" href="//fonts.gstatic.com" />

        {/* Preconnect for critical resources */}
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />

        {/* Google Fonts - Medieval theme */}
        <link
          href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Pirata+One&family=Inter:wght@300;400;500;600;700&display=swap"
          rel="stylesheet"
        />

        {/* ‚úÖ MELHORADO: Critical CSS mais robusto */}
        <style>{`
          /* Prevent Flash of Unstyled Content */
          html {
            visibility: hidden;
            opacity: 0;
            scroll-behavior: smooth;
          }
          
          html.fonts-loaded {
            visibility: visible;
            opacity: 1;
          }

          /* Loading state */
          .page-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2D1B1E 0%, #1a1a2e 100%);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
          }

          /* Dark theme by default */
          body {
            background-color: #2D1B1E;
            color: #F4E4BC;
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
          }

          /* ‚úÖ MELHORADO: Custom scrollbar mais bonito */
          ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
          }

          ::-webkit-scrollbar-track {
            background: rgba(45, 27, 30, 0.1);
            border-radius: 4px;
          }

          ::-webkit-scrollbar-thumb {
            background: rgba(139, 146, 90, 0.5);
            border-radius: 4px;
            transition: background 0.2s ease;
          }

          ::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 146, 90, 0.8);
          }

          ::-webkit-scrollbar-corner {
            background: transparent;
          }

          /* Firefox scrollbar */
          * {
            scrollbar-width: thin;
            scrollbar-color: rgba(139, 146, 90, 0.5) rgba(45, 27, 30, 0.1);
          }

          /* Disable text selection on UI elements */
          button, .btn, .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
          }

          /* ‚úÖ MELHORADO: Focus visible para acessibilidade */
          .focus-visible,
          *:focus-visible {
            outline: 2px solid #8B925A;
            outline-offset: 2px;
            border-radius: 4px;
          }

          /* ‚úÖ ADICIONADO: Supress√£o de hydration warnings no console */
          .hydration-safe {
            opacity: 0;
          }

          .hydration-safe.hydrated {
            opacity: 1;
            transition: opacity 0.2s ease;
          }

          /* ‚úÖ ADICIONADO: Anima√ß√µes de entrada suaves */
          @keyframes fadeInUp {
            from {
              opacity: 0;
              transform: translateY(20px);
            }
            to {
              opacity: 1;
              transform: translateY(0);
            }
          }

          .fade-in-up {
            animation: fadeInUp 0.5s ease forwards;
          }

          /* ‚úÖ ADICIONADO: Preven√ß√£o de layout shift */
          .prevent-layout-shift {
            min-height: 1px;
          }

          /* ‚úÖ ADICIONADO: Estilos para loading states */
          .skeleton {
            background: linear-gradient(90deg, #2D1B1E 25%, #3D2B2E 50%, #2D1B1E 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
          }

          @keyframes loading {
            0% {
              background-position: 200% 0;
            }
            100% {
              background-position: -200% 0;
            }
          }

          /* ‚úÖ ADICIONADO: Estilos para modo high contrast */
          @media (prefers-contrast: high) {
            body {
              background-color: #000;
              color: #fff;
            }
          }

          /* ‚úÖ ADICIONADO: Estilos para reduced motion */
          @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
              animation-duration: 0.01ms !important;
              animation-iteration-count: 1 !important;
              transition-duration: 0.01ms !important;
            }
          }
        `}</style>
      </Head>

      <body>
        {/* Page loading overlay */}
        <div id="page-loading" className="page-loading">
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>üê∫</div>
            <div style={{ fontSize: '1.5rem', fontFamily: 'Cinzel, serif', color: '#8B925A' }}>
              Werewolf
            </div>
            <div style={{ fontSize: '0.9rem', color: '#F4E4BC', marginTop: '0.5rem' }}>
              Carregando...
            </div>
          </div>
        </div>

        <Main />
        <NextScript />

        {/* ‚úÖ MELHORADO: Scripts de inicializa√ß√£o mais robustos */}
        <script
          dangerouslySetInnerHTML={{
            __html: `
              document.addEventListener('DOMContentLoaded', function() {
                // Remove loading overlay with smooth transition
                const loading = document.getElementById('page-loading');
                if (loading) {
                  setTimeout(() => {
                    loading.style.opacity = '0';
                    loading.style.transition = 'opacity 0.3s ease';
                    setTimeout(() => {
                      loading.remove();
                    }, 300);
                  }, 800);
                }

                // Mark fonts as loaded
                document.documentElement.classList.add('fonts-loaded');

                // Initialize focus-visible polyfill
                try {
                  let hadKeyboardEvent = true;
                  let keyboardThrottleTimeout;

                  const detectKeyboard = function(e) {
                    if (e.metaKey || e.altKey || e.ctrlKey) return;
                    hadKeyboardEvent = true;
                    document.body.classList.add('using-keyboard');
                  };

                  const detectMouse = function() {
                    hadKeyboardEvent = false;
                    document.body.classList.remove('using-keyboard');
                  };

                  document.addEventListener('keydown', detectKeyboard, true);
                  document.addEventListener('mousedown', detectMouse, true);
                  document.addEventListener('pointerdown', detectMouse, true);
                  document.addEventListener('touchstart', detectMouse, true);
                } catch (e) {
                  console.warn('Focus-visible polyfill error:', e);
                }

                // Performance monitoring in development
                if (${process.env.NODE_ENV === 'development'}) {
                  window.addEventListener('load', function() {
                    setTimeout(() => {
                      try {
                        const navigation = performance.getEntriesByType('navigation')[0];
                        if (navigation) {
                          console.log('üìä Page Performance:', {
                            'Total Load Time': Math.round(navigation.loadEventEnd - navigation.navigationStart) + 'ms',
                            'DOM Content Loaded': Math.round(navigation.domContentLoadedEventEnd - navigation.navigationStart) + 'ms',
                            'First Paint': Math.round(performance.getEntriesByType('paint')[0]?.startTime || 0) + 'ms'
                          });
                        }
                      } catch (e) {
                        console.warn('Performance monitoring error:', e);
                      }
                    }, 1000);
                  });
                }

                // Global error handling
                window.addEventListener('error', function(e) {
                  // Filter out hydration warnings in development
                  if (e.error?.message?.includes?.('Hydration') || 
                      e.error?.message?.includes?.('Text content does not match')) {
                    return;
                  }
                  console.error('Global error:', e.error);
                });

                window.addEventListener('unhandledrejection', function(e) {
                  console.error('Unhandled promise rejection:', e.reason);
                });
              });
            `,
          }}
        />

        {/* NoScript fallback */}
        <noscript>
          <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: '#2D1B1E',
            color: '#F4E4BC',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            flexDirection: 'column',
            fontFamily: 'sans-serif',
            textAlign: 'center',
            zIndex: 9999,
          }}>
            <div style={{ fontSize: '4rem', marginBottom: '2rem' }}>üê∫</div>
            <h1 style={{ fontSize: '2rem', marginBottom: '1rem', fontFamily: 'Cinzel, serif' }}>Werewolf</h1>
            <p style={{ fontSize: '1.2rem', marginBottom: '2rem', maxWidth: '400px' }}>
              JavaScript √© necess√°rio para jogar este jogo online.
            </p>
            <p style={{ fontSize: '1rem', color: '#8B925A' }}>
              Por favor, ative o JavaScript no seu navegador e recarregue a p√°gina.
            </p>
          </div>
        </noscript>
      </body>
    </Html>
  );
}
</file>

<file path="backend/src/config/environment.ts">
// üê∫ LOBISOMEM ONLINE - Environment Configuration
// ‚ö†Ô∏è CR√çTICO: Configuration-driven para migra√ß√£o autom√°tica Fase 1 ‚Üí Fase 2

import { z } from 'zod';
import dotenv from 'dotenv';

dotenv.config();

// =============================================================================
// VALIDATION SCHEMA
// =============================================================================

export interface AppConfig {
  NODE_ENV: string;
  PORT: number;
  IS_PRODUCTION: boolean;
  IS_DEVELOPMENT: boolean;
  DATABASE_URL: string;
  REDIS_URL: string;
  JWT_SECRET: string;
  JWT_EXPIRES_IN: string;
  DISTRIBUTED_MODE: boolean;
  STORAGE_TYPE: string;
  SERVICE_ID: string;
  SERVICE_TYPE: string;
  WS_BASE_PATH: string;
  WS_PORT: number;
  SHOULD_USE_REDIS: boolean;
  IS_GAME_SERVICE: boolean;
  IS_LOBBY_SERVICE: boolean;
  IS_MONOLITH: boolean;
}

const envSchema = z.object({
  // Core settings
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  PORT: z.coerce.number().default(3001),

  // Database
  DATABASE_URL: z.string().min(1, 'DATABASE_URL is required'),
  REDIS_URL: z.string().default('redis://localhost:6379'),

  // Authentication
  JWT_SECRET: z.string().min(1, 'JWT_SECRET is required'),
  JWT_EXPIRES_IN: z.string().default('7d'),
  // Architecture mode (CR√çTICO para migra√ß√£o)

  DISTRIBUTED_MODE: z.string().transform(val => val === 'true').default('false'),
  STORAGE_TYPE: z.enum(['memory', 'redis']).default('memory'),

  // Service discovery (Fase 2)
  SERVICE_ID: z.string().default('local-server'),
  SERVICE_TYPE: z.enum(['monolith', 'lobby', 'game']).default('monolith'),

  // WebSocket routing (Fase 2)
  WS_BASE_PATH: z.string().default('/ws'),
  WS_PORT: z.coerce.number().default(3001),

  // Game settings
  MIN_PLAYERS: z.coerce.number().default(6),
  MAX_PLAYERS: z.coerce.number().default(15),
  MAX_SPECTATORS: z.coerce.number().default(5),
  NIGHT_DURATION: z.coerce.number().default(60000),
  DAY_DURATION: z.coerce.number().default(120000),
  VOTING_DURATION: z.coerce.number().default(30000),

  // Email (opcional)
  SMTP_HOST: z.string().optional(),
  SMTP_PORT: z.coerce.number().optional(),
  SMTP_USER: z.string().optional(),
  SMTP_PASS: z.string().optional(),
});

// =============================================================================
// VALIDATE AND EXPORT CONFIG
// =============================================================================
const envVars = envSchema.parse(process.env);

export const config = {
  // Core settings
  NODE_ENV: envVars.NODE_ENV,
  PORT: envVars.PORT,
  IS_PRODUCTION: envVars.NODE_ENV === 'production',
  IS_DEVELOPMENT: envVars.NODE_ENV === 'development',

  // Database
  DATABASE_URL: envVars.DATABASE_URL,
  REDIS_URL: envVars.REDIS_URL,

  // Authentication
  JWT_SECRET: envVars.JWT_SECRET,
  JWT_EXPIRES_IN: envVars.JWT_EXPIRES_IN,

  // Architecture mode (CR√çTICO)
  DISTRIBUTED_MODE: envVars.DISTRIBUTED_MODE,
  STORAGE_TYPE: envVars.STORAGE_TYPE,

  // Service discovery (Fase 2)
  SERVICE_ID: envVars.SERVICE_ID,
  SERVICE_TYPE: envVars.SERVICE_TYPE,

  // WebSocket routing (Fase 2)
  WS_BASE_PATH: envVars.WS_BASE_PATH,
  WS_PORT: envVars.WS_PORT,

  // Game settings
  GAME: {
    MIN_PLAYERS: envVars.MIN_PLAYERS,
    MAX_PLAYERS: envVars.MAX_PLAYERS,
    MAX_SPECTATORS: envVars.MAX_SPECTATORS,
    NIGHT_DURATION: envVars.NIGHT_DURATION,
    DAY_DURATION: envVars.DAY_DURATION,
    VOTING_DURATION: envVars.VOTING_DURATION,
  },

  // Email
  EMAIL: {
    SMTP_HOST: envVars.SMTP_HOST,
    SMTP_PORT: envVars.SMTP_PORT,
    SMTP_USER: envVars.SMTP_USER,
    SMTP_PASS: envVars.SMTP_PASS,
    ENABLED: !!(envVars.SMTP_HOST && envVars.SMTP_USER && envVars.SMTP_PASS),
  },

  // Derived flags
  SHOULD_USE_REDIS: envVars.DISTRIBUTED_MODE || envVars.STORAGE_TYPE === 'redis',
  IS_GAME_SERVICE: envVars.SERVICE_TYPE === 'game',
  IS_LOBBY_SERVICE: envVars.SERVICE_TYPE === 'lobby',
  IS_MONOLITH: envVars.SERVICE_TYPE === 'monolith',
} as const;

// =============================================================================
// TYPE DEFINITIONS
// =============================================================================
export type Config = typeof config;
export type StorageType = 'memory' | 'redis';
export type ServiceType = 'monolith' | 'lobby' | 'game';

// =============================================================================
// VALIDATION HELPERS
// =============================================================================
export function validateConfig(): void {
  console.log('üîß Configuration loaded:');
  console.log(`   Mode: ${config.NODE_ENV}`);
  console.log(`   Architecture: ${config.DISTRIBUTED_MODE ? 'Distributed' : 'Monolithic'}`);
  console.log(`   Service Type: ${config.SERVICE_TYPE}`);
  console.log(`   Storage: ${config.STORAGE_TYPE}`);
  console.log(`   Port: ${config.PORT}`);

  if (config.IS_PRODUCTION && config.JWT_SECRET === 'your-super-secret-jwt-key-change-in-production') {
    throw new Error('‚ùå JWT_SECRET must be changed in production!');
  }

  if (config.DISTRIBUTED_MODE && !config.SHOULD_USE_REDIS) {
    throw new Error('‚ùå DISTRIBUTED_MODE requires Redis storage!');
  }
}
</file>

<file path="backend/src/game/Game.ts">
// üê∫ LOBISOMEM ONLINE - Game Core Classes (FASE 1 - CORRE√á√ÉO CR√çTICA + DEBUG MODE)
import { Role, Faction, GamePhase, GAME_LIMITS } from '@/utils/constants';
import type { GameConfig, GameEvent, NightAction, GameStatus } from '@/types';
import { RoleRevealManager, WinConditionCalculator, ROLE_CONFIGURATIONS } from './RoleSystem';

//====================================================================
// PLAYER CLASS - COMPAT√çVEL COM INTERFACE
//====================================================================
export class Player {
  public id: string;
  public userId: string;
  public username: string;
  public avatar?: string;
  public isHost: boolean;
  public isReady: boolean;
  public isSpectator: boolean;
  public isConnected: boolean;
  public joinedAt: Date;
  public lastSeen: Date;

  // Game-specific properties
  public role?: Role;
  public faction?: Faction;
  public isAlive: boolean = true;
  public isProtected: boolean = false;
  public hasActed: boolean = false;
  public hasVoted: boolean = false;
  public votedFor?: string;
  public actionsUsed: number = 0;
  public maxActions?: number;

  // Tracking
  public lastAction?: string;
  public protectedByDoctor: boolean = false;
  public canBeProtectedByDoctor: boolean = true;
  public investigatedBy: string[] = [];
  public killedBy?: string;
  public eliminationReason?: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER';

  constructor(data: {
    id: string;
    userId: string;
    username: string;
    avatar?: string;
    isHost: boolean;
    isReady: boolean;
    isSpectator: boolean;
    isConnected: boolean;
    joinedAt: Date;
    lastSeen: Date;
  }) {
    this.id = data.id;
    this.userId = data.userId;
    this.username = data.username;
    if (data.avatar !== undefined) {
      this.avatar = data.avatar;
    }
    this.isHost = data.isHost;
    this.isReady = data.isReady;
    this.isSpectator = data.isSpectator;
    this.isConnected = data.isConnected;
    this.joinedAt = data.joinedAt;
    this.lastSeen = data.lastSeen;
  }

  // Player actions
  assignRole(role: Role, faction: Faction, maxActions?: number): void {
    this.role = role;
    this.faction = faction;
    if (maxActions !== undefined) {
      this.maxActions = maxActions;
    }
    this.actionsUsed = 0;
    this.hasActed = false;
  }

  canAct(): boolean {
    if (!this.isAlive || !this.role) return false;
    if (this.hasActed) return false;
    if (this.maxActions !== undefined && this.actionsUsed >= this.maxActions) return false;

    const roleConfig = ROLE_CONFIGURATIONS[this.role];
    return roleConfig?.canAct || false;
  }

  performAction(action: string, targetId?: string): boolean {
    if (!this.canAct()) return false;

    this.hasActed = true;
    this.lastAction = action;
    this.actionsUsed++;

    return true;
  }

  kill(reason: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER', killedBy?: string): void {
    this.isAlive = false;
    this.eliminationReason = reason;
    if (killedBy !== undefined) {
      this.killedBy = killedBy;
    }
    this.hasVoted = false;
    delete this.votedFor;
  }

  protect(): void {
    this.isProtected = true;
    this.protectedByDoctor = true;
  }

  removeProtection(): void {
    this.isProtected = false;
    this.protectedByDoctor = false;
  }

  vote(targetId: string): boolean {
    if (!this.isAlive) return false;
    this.hasVoted = true;
    this.votedFor = targetId;
    return true;
  }

  unvote(): boolean {
    if (!this.isAlive) return false;
    this.hasVoted = false;
    delete this.votedFor;
    return true;
  }

  resetForNewPhase(): void {
    this.hasActed = false;
    this.hasVoted = false;
    delete this.votedFor;
    this.removeProtection();
    this.canBeProtectedByDoctor = !this.protectedByDoctor;
  }

  // Utility methods
  getPublicInfo(): any {
    const info: any = {
      id: this.id,
      userId: this.userId,
      username: this.username,
      isHost: this.isHost,
      isReady: this.isReady,
      isSpectator: this.isSpectator,
      isConnected: this.isConnected,
      isAlive: this.isAlive,
      hasVoted: this.hasVoted,
      joinedAt: this.joinedAt,
      lastSeen: this.lastSeen,
    };
    if (this.avatar) info.avatar = this.avatar;
    if (this.votedFor) info.votedFor = this.votedFor;
    return info;
  }

  getPrivateInfo(): any {
    const info = {
      ...this.getPublicInfo(),
      isProtected: this.isProtected,
      hasActed: this.hasActed,
      actionsUsed: this.actionsUsed,
    };
    if (this.role) info.role = this.role;
    if (this.faction) info.faction = this.faction;
    if (this.maxActions) info.maxActions = this.maxActions;
    if (this.lastAction) info.lastAction = this.lastAction;
    if (this.eliminationReason) info.eliminationReason = this.eliminationReason;
    if (this.killedBy) info.killedBy = this.killedBy;
    return info;
  }
}

//====================================================================
// GAME STATE CLASS - FASE 1 COM CANSTART() MELHORADO
//====================================================================
export class GameState {
  public gameId: string;
  public roomId: string;
  public status: GameStatus;
  public phase: GamePhase;
  public day: number;
  public phaseStartTime: Date;
  public phaseEndTime: Date;
  public timeLeft: number; // milliseconds

  private playersMap: Map<string, Player>;
  private spectatorsSet: Set<string>;
  private eliminatedPlayersMap: Map<string, Player>;
  private votesMap: Map<string, string>; // voterId -> targetId

  public hostId: string;
  public config: GameConfig;
  public events: GameEvent[];
  public nightActions: NightAction[];

  public createdAt: Date;
  public updatedAt: Date;
  public startedAt?: Date;
  public finishedAt?: Date;

  public winningFaction?: Faction;
  public winningPlayers: string[] = [];

  constructor(gameId: string, config: GameConfig, hostId: string) {
    this.gameId = gameId;
    this.roomId = config.roomId;
    this.status = 'WAITING';
    this.phase = GamePhase.LOBBY;
    this.day = 0;
    this.phaseStartTime = new Date();
    this.phaseEndTime = new Date();
    this.timeLeft = 0;

    this.playersMap = new Map();
    this.spectatorsSet = new Set();
    this.eliminatedPlayersMap = new Map();
    this.votesMap = new Map();

    this.hostId = hostId;
    this.config = config;
    this.events = [];
    this.nightActions = [];

    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  // Getters para compatibilidade com a interface
  get players(): Player[] {
    return Array.from(this.playersMap.values());
  }

  get spectators(): string[] {
    return Array.from(this.spectatorsSet);
  }

  get eliminatedPlayers(): Player[] {
    return Array.from(this.eliminatedPlayersMap.values());
  }

  get votes(): Record<string, string> {
    return Object.fromEntries(this.votesMap);
  }

  addPlayer(player: Player): boolean {
    if (this.playersMap.size >= this.config.maxPlayers) return false;
    if (this.status !== 'WAITING') return false;

    this.playersMap.set(player.id, player);
    this.updatedAt = new Date();

    this.addEvent('PLAYER_JOINED', {
      playerId: player.id,
      username: player.username,
      playerCount: this.playersMap.size,
    });

    return true;
  }

  removePlayer(playerId: string): boolean {
    const player = this.playersMap.get(playerId);
    if (!player) return false;

    this.playersMap.delete(playerId);

    if (this.status === 'PLAYING') {
      this.eliminatedPlayersMap.set(playerId, player);
    }

    this.updatedAt = new Date();

    this.addEvent('PLAYER_LEFT', {
      playerId: player.id,
      username: player.username,
      playerCount: this.playersMap.size,
    });

    return true;
  }

  getPlayer(playerId: string): Player | undefined {
    return this.playersMap.get(playerId);
  }

  getAlivePlayers(): Player[] {
    return Array.from(this.playersMap.values()).filter(p => p.isAlive && !p.isSpectator);
  }

  getDeadPlayers(): Player[] {
    return Array.from(this.playersMap.values()).filter(p => !p.isAlive && !p.isSpectator);
  }

  // ‚úÖ FASE 1 - CANSTART() MELHORADO E MAIS ROBUSTO COM GAME_LIMITS
  canStart(): boolean {
    // ‚úÖ Verifica√ß√µes b√°sicas primeiro
    if (this.status !== 'WAITING') {
      return false;
    }

    const alivePlayers = this.getAlivePlayers();

    // ‚úÖ Verificar quantidade de jogadores usando constante
    if (alivePlayers.length < GAME_LIMITS.MIN_PLAYERS || alivePlayers.length > GAME_LIMITS.MAX_PLAYERS) {
      return false;
    }

    // ‚úÖ IMPORTANTE: Verificar se h√° pelo menos um host
    const hostPlayer = alivePlayers.find(p => p.isHost);
    if (!hostPlayer) {
      return false;
    }

    // ‚úÖ L√ìGICA ROBUSTA: O host n√£o precisa estar "ready", apenas os outros jogadores
    const nonHostPlayers = alivePlayers.filter(p => !p.isHost);
    const allNonHostPlayersReady = nonHostPlayers.every(p => p.isReady);

    return allNonHostPlayersReady;
  }

  // ‚úÖ FASE 1 - M√âTODO AUXILIAR PARA DEBUG E VALIDA√á√ÉO COM GAME_LIMITS
  getStartRequirements(): {
    canStart: boolean;
    reasons: string[];
    playerCount: number;
    readyCount: number;
    hostReady: boolean;
    hostFound: boolean;
    nonHostPlayersReady: number;
    nonHostPlayersTotal: number;
  } {
    const reasons: string[] = [];
    const alivePlayers = this.getAlivePlayers();
    const hostPlayer = alivePlayers.find(p => p.isHost);
    const readyPlayers = alivePlayers.filter(p => p.isReady);

    if (this.status !== 'WAITING') {
      reasons.push(`Game status is ${this.status}, must be WAITING`);
    }

    if (alivePlayers.length < GAME_LIMITS.MIN_PLAYERS) {
      reasons.push(`Only ${alivePlayers.length} players, minimum is ${GAME_LIMITS.MIN_PLAYERS}`);
    }

    if (alivePlayers.length > GAME_LIMITS.MAX_PLAYERS) {
      reasons.push(`${alivePlayers.length} players, maximum is ${GAME_LIMITS.MAX_PLAYERS}`);
    }

    if (!hostPlayer) {
      reasons.push('No host player found');
    }

    const nonHostPlayers = alivePlayers.filter(p => !p.isHost);
    const notReadyNonHost = nonHostPlayers.filter(p => !p.isReady);

    if (notReadyNonHost.length > 0) {
      reasons.push(`${notReadyNonHost.length} non-host players not ready: ${notReadyNonHost.map(p => p.username).join(', ')}`);
    }

    return {
      canStart: reasons.length === 0,
      reasons,
      playerCount: alivePlayers.length,
      readyCount: readyPlayers.length,
      hostReady: hostPlayer?.isReady || false,
      hostFound: !!hostPlayer,
      nonHostPlayersReady: nonHostPlayers.filter(p => p.isReady).length,
      nonHostPlayersTotal: nonHostPlayers.length,
    };
  }

  start(): boolean {
    if (!this.canStart()) return false;

    this.status = 'STARTING';
    this.startedAt = new Date();
    this.updatedAt = new Date();

    this.addEvent('GAME_STARTING', {
      playerCount: this.getAlivePlayers().length,
    });

    return true;
  }

  changePhase(newPhase: GamePhase, duration: number): void {
    this.phase = newPhase;
    this.phaseStartTime = new Date();
    this.phaseEndTime = new Date(Date.now() + duration);
    this.timeLeft = duration;
    this.updatedAt = new Date();

    if (newPhase === GamePhase.DAY) {
      this.day++;
    }

    this.playersMap.forEach(player => player.resetForNewPhase());
    this.votesMap.clear();

    this.addEvent('PHASE_CHANGED', {
      phase: newPhase,
      day: this.day,
      duration,
      timeLeft: this.timeLeft,
    });
  }

  updateTimeLeft(): void {
    this.timeLeft = Math.max(0, this.phaseEndTime.getTime() - Date.now());
    this.updatedAt = new Date();
  }

  isPhaseExpired(): boolean {
    return Date.now() >= this.phaseEndTime.getTime();
  }

  addVote(voterId: string, targetId: string): boolean {
    const voter = this.playersMap.get(voterId);
    const target = this.playersMap.get(targetId);

    if (!voter || !target || !voter.isAlive || !target.isAlive) return false;
    if (this.phase !== GamePhase.VOTING) return false;

    this.votesMap.set(voterId, targetId);
    voter.vote(targetId);

    this.addEvent('VOTE_CAST', {
      voterId,
      targetId,
      voterUsername: voter.username,
      targetUsername: target.username,
    });

    return true;
  }

  removeVote(voterId: string): boolean {
    const voter = this.playersMap.get(voterId);
    if (!voter || !voter.isAlive) return false;

    const targetId = this.votesMap.get(voterId);
    this.votesMap.delete(voterId);
    voter.unvote();

    if (targetId) {
      const target = this.playersMap.get(targetId);
      this.addEvent('VOTE_REMOVED', {
        voterId,
        targetId,
        voterUsername: voter.username,
        targetUsername: target?.username,
      });
    }

    return true;
  }

  getVoteCounts(): Map<string, number> {
    const counts = new Map<string, number>();
    this.votesMap.forEach((targetId) => {
      counts.set(targetId, (counts.get(targetId) || 0) + 1);
    });
    return counts;
  }

  getMostVotedPlayer(): { playerId: string; votes: number } | null {
    const counts = this.getVoteCounts();
    let maxVotes = 0;
    let mostVoted: string | null = null;
    let tieCount = 0;

    counts.forEach((votes, playerId) => {
      if (votes > maxVotes) {
        maxVotes = votes;
        mostVoted = playerId;
        tieCount = 1;
      } else if (votes === maxVotes) {
        tieCount++;
      }
    });

    if (tieCount > 1 || !mostVoted || maxVotes === 0) return null;

    return { playerId: mostVoted, votes: maxVotes };
  }

  addEvent(type: string, data: any, visibleTo?: string[]): void {
    const event: GameEvent = {
      id: `${this.gameId}-${this.events.length}`,
      type,
      phase: this.phase,
      day: this.day,
      timestamp: new Date(),
      data,
      ...(visibleTo && { visibleTo }),
    };

    this.events.push(event);
    this.updatedAt = new Date();
  }

  getEventsForPlayer(playerId: string): GameEvent[] {
    return this.events.filter(event =>
      !event.visibleTo || event.visibleTo.includes(playerId)
    );
  }

  checkWinCondition(): { hasWinner: boolean; winningFaction?: Faction; winningPlayers?: string[] } {
    const alivePlayers = this.getAlivePlayers();
    return WinConditionCalculator.calculateWinCondition(
      alivePlayers.map(p => ({ playerId: p.id, role: p.role! }))
    );
  }

  endGame(winningFaction?: Faction, winningPlayers?: string[]): void {
    this.status = 'FINISHED';
    this.finishedAt = new Date();
    this.updatedAt = new Date();
    if (winningFaction) {
      this.winningFaction = winningFaction;
    }
    if (winningPlayers) {
      this.winningPlayers = winningPlayers;
    }

    this.addEvent('GAME_ENDED', {
      winningFaction,
      winningPlayers,
      totalDays: this.day,
      duration: this.finishedAt.getTime() - (this.startedAt?.getTime() || 0),
    });
  }

  toJSON(): any {
    return {
      gameId: this.gameId,
      roomId: this.roomId,
      status: this.status,
      phase: this.phase,
      day: this.day,
      phaseStartTime: this.phaseStartTime,
      phaseEndTime: this.phaseEndTime,
      timeLeft: this.timeLeft,
      players: this.players,
      spectators: this.spectators,
      eliminatedPlayers: this.eliminatedPlayers,
      hostId: this.hostId,
      config: this.config,
      events: this.events,
      votes: this.votes,
      nightActions: this.nightActions,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
      startedAt: this.startedAt,
      finishedAt: this.finishedAt,
      winningFaction: this.winningFaction,
      winningPlayers: this.winningPlayers,
    };
  }
}
</file>

<file path="backend/src/game/GameEngine.ts">
// üê∫ LOBISOMEM ONLINE - Game Engine (VERS√ÉO FINAL LIMPA - SEM DUPLICA√á√ÉO)
import { GameState, Player } from './Game';
import { RoleDistributor, WinConditionCalculator } from './RoleSystem';
import { Role, Faction, GamePhase } from '@/utils/constants';
import type { GameConfig, IGameEngine, GameResults, GameStatus } from '@/types';
import { logger } from '@/utils/logger';

//====================================================================
// GAME ENGINE IMPLEMENTATION - VERS√ÉO FINAL LIMPA
//====================================================================
export class GameEngine implements IGameEngine {
  private games = new Map<string, GameState>();
  private eventHandlers = new Map<string, Map<string, ((data: any) => void)[]>>();

  private sendToUser?: (userId: string, type: string, data?: any) => boolean;

  constructor() {
    logger.info('GameEngine initialized');
  }

  //====================================================================
  // M√âTODO PARA INJETAR sendToUser (Chamado pelo WebSocketManager)
  //====================================================================
  setSendToUserMethod(sendToUser: (userId: string, type: string, data?: any) => boolean): void {
    this.sendToUser = sendToUser;
    logger.info('SendToUser method injected into GameEngine');
  }

  //====================================================================
  // ‚úÖ PONTE SISTEMA ‚Üí CHAT
  //====================================================================
  private broadcastSystemMessage(gameId: string, text: string, channel: 'system' | 'public' = 'system'): void {
    const gameState = this.games.get(gameId);
    if (!gameState || !this.sendToUser) {
      logger.warn('Cannot broadcast system message - game or sendToUser not available', { gameId });
      return;
    }

    const systemMessage = {
      id: `system-${Date.now()}`,
      userId: 'system',
      username: 'Sistema',
      message: text,
      channel: channel,
      timestamp: new Date().toISOString(),
    };

    const allPlayers = gameState.players;
    let sentCount = 0;

    allPlayers.forEach(player => {
      if (this.sendToUser!(player.userId, 'chat-message', { message: systemMessage })) {
        sentCount++;
      }
    });

    logger.info('System message broadcast completed', {
      gameId,
      message: text,
      totalPlayers: allPlayers.length,
      sentCount
    });
  }

  //====================================================================
  // ‚úÖ FEEDBACK INDIVIDUAL PARA A√á√ïES
  //====================================================================
  private sendActionResult(gameId: string, playerId: string, actionType: string, result: string): void {
    const gameState = this.games.get(gameId);
    if (!gameState || !this.sendToUser) return;

    const player = gameState.players.find(p => p.id === playerId);
    if (!player) return;

    const resultMessage = {
      id: `result-${Date.now()}`,
      userId: 'system',
      username: 'Sistema',
      message: result,
      channel: 'system',
      timestamp: new Date().toISOString(),
    };

    this.sendToUser(player.userId, 'chat-message', { message: resultMessage });

    logger.info('Action result sent to player', {
      gameId,
      playerId,
      actionType,
      result
    });
  }

  //====================================================================
  // BROADCAST GAME STATE TO ALL PLAYERS
  //====================================================================
  private async broadcastGameState(gameId: string): Promise<void> {
    const gameState = this.games.get(gameId);
    if (!gameState || !this.sendToUser) return;

    const players = gameState.getAlivePlayers();

    logger.info('Broadcasting game state to all players', {
      gameId,
      playerCount: players.length,
      phase: gameState.phase,
      day: gameState.day
    });

    for (const player of players) {
      try {
        const personalizedState = this.getPersonalizedGameState(gameState, player.userId);
        const success = this.sendToUser(player.userId, 'game-state', personalizedState);

        if (!success) {
          logger.warn('Failed to send game state to player', {
            gameId,
            playerId: player.id,
            userId: player.userId
          });
        }
      } catch (error) {
        logger.error('Error broadcasting to player',
          error instanceof Error ? error : new Error('Unknown broadcast error'),
          { gameId, playerId: player.id, userId: player.userId }
        );
      }
    }
  }

  //====================================================================
  // GAME LIFECYCLE
  //====================================================================
  async createGame(hostId: string, config: GameConfig): Promise<GameState> {
    const gameId = `game-${config.roomId}`;

    try {
      // ‚úÖ CORRE√á√ÉO: Usar configura√ß√£o recebida (sem hardcoded durations)
      const gameState = new GameState(gameId, config, hostId);

      this.games.set(gameId, gameState);
      this.eventHandlers.set(gameId, new Map());

      logger.info('Game created with provided configuration', {
        gameId,
        roomId: config.roomId,
        hostId,
        nightDuration: `${config.nightDuration / 1000}s`,
        dayDuration: `${config.dayDuration / 1000}s`,
        votingDuration: `${config.votingDuration / 1000}s`
      });

      this.emitGameEvent(gameId, 'game:created', {
        gameId,
        hostId,
        roomId: config.roomId,
        config,
      });

      return gameState;
    } catch (error) {
      logger.error('Failed to create game', error instanceof Error ? error : new Error('Unknown game creation error'), { hostId, config });
      throw error;
    }
  }

  // ‚úÖ startGame come√ßa no DIA
  async startGame(gameId: string): Promise<boolean> {
    const gameState = this.games.get(gameId);

    if (!gameState) {
      const availableGameIds = Array.from(this.games.keys());
      logger.warn('Attempted to start non-existent game', {
        requestedGameId: gameId,
        availableGameIds,
        totalGames: this.games.size
      });
      return false;
    }

    if (!gameState.canStart()) {
      const alivePlayers = gameState.getAlivePlayers();
      const hostPlayer = alivePlayers.find(p => p.isHost);
      const nonHostPlayers = alivePlayers.filter(p => !p.isHost);
      const readyNonHostPlayers = nonHostPlayers.filter(p => p.isReady);

      logger.warn('Game cannot start - requirements not met', {
        gameId,
        status: gameState.status,
        totalPlayers: alivePlayers.length,
        hostFound: !!hostPlayer,
        hostReady: hostPlayer?.isReady || false,
        nonHostPlayers: nonHostPlayers.length,
        readyNonHostPlayers: readyNonHostPlayers.length,
        playersNotReady: nonHostPlayers.filter(p => !p.isReady).map(p => p.username),
      });
      return false;
    }

    try {
      gameState.start();

      const players = gameState.getAlivePlayers();
      const distribution = RoleDistributor.getRoleDistribution(players.length);
      const roleAssignments = RoleDistributor.distributeRolesToPlayers(
        players.map(p => p.id),
        distribution
      );

      roleAssignments.forEach((role, playerId) => {
        const player = gameState.getPlayer(playerId);
        if (player) {
          const roleConfig = RoleDistributor.getRoleConfig(role);
          player.assignRole(role, roleConfig.faction, roleConfig.maxActions);
        }
      });

      gameState.status = 'PLAYING';

      // Come√ßar no DIA
      await this.changePhase(gameState, GamePhase.DAY, gameState.config.dayDuration);

      await this.sendInitialGameStateToAllPlayers(gameId);

      this.broadcastSystemMessage(gameId,
        `üéÆ O jogo come√ßou! Dia ${gameState.day} - Discutam e tentem descobrir quem s√£o os lobisomens! (${gameState.config.dayDuration / 1000}s)`,
        'system'
      );

      logger.info('Game started successfully - begins with DAY phase', {
        gameId,
        roomId: gameState.roomId,
        playerCount: players.length,
        distribution,
        hostId: gameState.hostId,
        startPhase: 'DAY',
        dayDuration: `${gameState.config.dayDuration / 1000}s`
      });

      this.emitGameEvent(gameId, 'game:started', {
        gameId,
        players: players.map(p => ({
          id: p.id,
          username: p.username,
          role: p.role,
        })),
        distribution,
      });

      return true;
    } catch (error) {
      logger.error('Failed to start game', error instanceof Error ? error : new Error('Unknown game start error'), { gameId });
      return false;
    }
  }

  private async sendInitialGameStateToAllPlayers(gameId: string): Promise<void> {
    if (!this.sendToUser) {
      logger.error('SendToUser method not available - cannot send initial game state');
      return;
    }

    const gameState = this.games.get(gameId);
    if (!gameState) return;

    const players = gameState.getAlivePlayers();

    logger.info('Sending initial game state to all players', {
      gameId,
      playerCount: players.length
    });

    for (const player of players) {
      try {
        const personalizedGameState = this.getPersonalizedGameState(gameState, player.userId);
        const success = this.sendToUser(player.userId, 'game-state', personalizedGameState);

        if (success) {
          logger.debug('Initial game state sent to player', {
            gameId,
            playerId: player.id,
            userId: player.userId,
            username: player.username
          });
        } else {
          logger.warn('Failed to send initial game state to player', {
            gameId,
            playerId: player.id,
            userId: player.userId
          });
        }

      } catch (error) {
        logger.error('Error sending initial game state to player',
          error instanceof Error ? error : new Error('Unknown send error'),
          { gameId, playerId: player.id, userId: player.userId }
        );
      }
    }
  }

  private getPersonalizedGameState(gameState: GameState, userId: string): any {
    const fullState = gameState.toJSON();
    const currentPlayer = fullState.players.find((p: any) => p.userId === userId);

    fullState.players = fullState.players.map((player: any) => {
      if (player.userId === userId) {
        return player;
      } else if (!player.isAlive) {
        return player;
      } else {
        const { role, faction, hasActed, maxActions, actionsUsed, lastAction, ...publicData } = player;
        return publicData;
      }
    });

    fullState.nightActions = [];

    if (currentPlayer) {
      fullState.me = {
        id: currentPlayer.id,
        userId: currentPlayer.userId,
        username: currentPlayer.username,
        role: currentPlayer.role,
        faction: currentPlayer.faction,
        isAlive: currentPlayer.isAlive,
        isProtected: currentPlayer.isProtected,
        hasActed: currentPlayer.hasActed,
        hasVoted: currentPlayer.hasVoted,
        votedFor: currentPlayer.votedFor,
        actionsUsed: currentPlayer.actionsUsed,
        maxActions: currentPlayer.maxActions,
      };
    }

    return fullState;
  }

  async endGame(gameId: string, reason?: string): Promise<void> {
    const gameState = this.games.get(gameId);
    if (!gameState || gameState.status === 'FINISHED') return;

    try {
      const alivePlayers = gameState.getAlivePlayers();
      const winCondition = WinConditionCalculator.calculateWinCondition(
        alivePlayers.map(p => ({ playerId: p.id, role: p.role! }))
      );

      gameState.endGame(winCondition.winningFaction, winCondition.winningPlayers);

      const winMessage = winCondition.winningFaction === Faction.TOWN
        ? 'üèÜ A VILA VENCEU! Todos os lobisomens foram eliminados!'
        : winCondition.winningFaction === Faction.WEREWOLF
          ? 'üê∫ OS LOBISOMENS VENCERAM! Eles dominaram a vila!'
          : 'üé≠ VIT√ìRIA ESPECIAL! Condi√ß√£o de vit√≥ria alternativa atingida!';

      this.broadcastSystemMessage(gameId, winMessage, 'system');

      logger.info('Game ended', {
        gameId,
        winningFaction: gameState.winningFaction,
        winningPlayers: gameState.winningPlayers,
        reason,
        totalDays: gameState.day,
      });

      this.emitGameEvent(gameId, 'game:ended', {
        gameId,
        winningFaction: gameState.winningFaction,
        winningPlayers: gameState.winningPlayers,
        reason,
        totalDays: gameState.day,
        finalResults: this.generateGameResults(gameState),
      });

    } catch (error) {
      logger.error('Error ending game', error instanceof Error ? error : new Error('Unknown game end error'), { gameId });
    }
  }

  //====================================================================
  // PLAYER MANAGEMENT
  //====================================================================
  async addPlayer(gameId: string, player: Player): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    const success = gameState.addPlayer(player);

    if (success) {
      logger.info('Player added to game', {
        gameId,
        playerId: player.id,
        username: player.username,
        isSpectator: player.isSpectator,
      });

      this.emitGameEvent(gameId, 'player:joined', {
        gameId,
        player: player.getPublicInfo(),
      });
    }

    return success;
  }

  async removePlayer(gameId: string, playerId: string): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    const player = gameState.getPlayer(playerId);
    const success = gameState.removePlayer(playerId);

    if (success && player) {
      logger.info('Player removed from game', {
        gameId,
        playerId,
        username: player.username,
      });

      this.emitGameEvent(gameId, 'player:left', {
        gameId,
        playerId,
        username: player.username,
      });

      if (gameState.status === 'PLAYING') {
        const alivePlayers = gameState.getAlivePlayers();
        if (alivePlayers.length < 3) {
          await this.endGame(gameId, 'Insufficient players');
          return true;
        }
        await this.checkWinCondition(gameId);
      }
    }

    return success;
  }

  //====================================================================
  // GAME STATE MANAGEMENT
  //====================================================================
  async getGameState(gameId: string): Promise<GameState | null> {
    return this.games.get(gameId) || null;
  }

  async updateGameState(gameId: string, updates: Partial<GameState>): Promise<void> {
    const gameState = this.games.get(gameId);
    if (!gameState) return;

    Object.assign(gameState, updates, { updatedAt: new Date() });

    this.emitGameEvent(gameId, 'game:state-updated', {
      gameId,
      updates,
    });
  }

  //====================================================================
  // PLAYER ACTIONS - ‚úÖ COM ANTI-SPAM E FEEDBACK
  //====================================================================
  async performPlayerAction(gameId: string, userId: string, action: any): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) {
      logger.warn('Action on non-existent game', { gameId, userId, action });
      return false;
    }

    try {
      const player = gameState.players.find(p => p.userId === userId);
      if (!player || !player.isAlive) {
        logger.warn('Action attempt by invalid player', {
          gameId,
          userId,
          playerFound: !!player,
          isAlive: player?.isAlive,
          actionType: action.type
        });
        return false;
      }

      // ‚úÖ ANTI-SPAM: Verificar se j√° agiu
      if (player.hasActed && gameState.phase === GamePhase.NIGHT) {
        logger.warn('Player already acted this night - blocking spam', {
          gameId,
          playerId: player.id,
          actionType: action.type,
          hasActed: player.hasActed
        });

        if (this.sendToUser) {
          this.sendToUser(player.userId, 'action-failed', {
            actionType: action.type,
            error: 'Voc√™ j√° realizou sua a√ß√£o nesta noite'
          });
        }
        return false;
      }

      logger.info('Processing player action', {
        gameId,
        userId,
        playerId: player.id,
        username: player.username,
        actionType: action.type,
        targetId: action.targetId,
        gamePhase: gameState.phase,
        gameDay: gameState.day,
        playerRole: player.role,
        playerHasActed: player.hasActed,
        nightActionsCount: gameState.nightActions.length
      });

      const ActionManager = (await import('./ActionManager')).ActionManager;
      const actionManager = new ActionManager(gameState);

      const result = await actionManager.performAction(player.id, action);

      if (result.success) {
        logger.info('Player action processed successfully', {
          gameId,
          playerId: player.id,
          userId: player.userId,
          actionType: action.type,
          targetId: action.targetId,
          result,
          nightActionsAfter: gameState.nightActions.length
        });

        if (this.sendToUser) {
          this.sendToUser(player.userId, 'action-confirmed', {
            actionType: action.type,
            message: result.message || 'A√ß√£o registrada com sucesso',
            data: result.data
          });
        }

        if (gameState.phase === GamePhase.NIGHT) {
          await this.broadcastGameState(gameId);
        }

        return true;
      } else {
        logger.warn('Player action failed validation', {
          gameId,
          playerId: player.id,
          actionType: action.type,
          errors: result.errors,
          message: result.message
        });

        if (this.sendToUser) {
          this.sendToUser(player.userId, 'action-failed', {
            actionType: action.type,
            error: result.message || 'Falha ao processar a√ß√£o',
            errors: result.errors
          });
        }

        return false;
      }
    } catch (error) {
      logger.error('Error performing player action',
        error instanceof Error ? error : new Error('Unknown action error'),
        { gameId, userId, action }
      );

      const player = gameState.players.find(p => p.userId === userId);
      if (player && this.sendToUser) {
        this.sendToUser(player.userId, 'action-failed', {
          actionType: action.type,
          error: 'Erro interno ao processar a√ß√£o'
        });
      }

      return false;
    }
  }

  //====================================================================
  // PHASE MANAGEMENT - ‚úÖ FLUXO CORRETO (DIA 1 SEM VOTA√á√ÉO)
  //====================================================================
  async nextPhase(gameId: string): Promise<void> {
    const gameState = this.games.get(gameId);
    if (!gameState) return;

    const currentPhase = gameState.phase;
    const currentDay = gameState.day;

    try {
      switch (currentPhase) {
        case GamePhase.DAY:
          // ‚úÖ PRIMEIRO DIA: vai direto para noite (sem vota√ß√£o)
          if (currentDay === 1) {
            await this.changePhase(gameState, GamePhase.NIGHT, gameState.config.nightDuration);
          } else {
            // Dias subsequentes: vai para vota√ß√£o
            await this.changePhase(gameState, GamePhase.VOTING, gameState.config.votingDuration);
          }
          break;

        case GamePhase.NIGHT:
          await this.processNightResults(gameState);
          await this.changePhase(gameState, GamePhase.DAY, gameState.config.dayDuration);
          break;

        case GamePhase.VOTING:
          await this.processVotingResults(gameState);
          if (gameState.status === 'PLAYING') {
            await this.changePhase(gameState, GamePhase.NIGHT, gameState.config.nightDuration);
          }
          break;

        default:
          break;
      }

      await this.broadcastGameState(gameId);
      await this.checkWinCondition(gameId);
    } catch (error) {
      logger.error('Error during phase transition', error instanceof Error ? error : new Error('Unknown phase error'), {
        gameId,
        currentPhase,
      });
    }
  }

  //====================================================================
  // PHASE TRANSITION HELPERS
  //====================================================================
  private async changePhase(gameState: GameState, newPhase: GamePhase, duration: number): Promise<void> {
    const oldPhase = gameState.phase;
    gameState.changePhase(newPhase, duration);

    let phaseMessage = '';
    const durationText = `(${duration / 1000}s)`;

    switch (newPhase) {
      case GamePhase.DAY:
        phaseMessage = `üåÖ Dia ${gameState.day} come√ßou! Hora de discutir e investigar. ${durationText}`;
        break;
      case GamePhase.VOTING:
        phaseMessage = `üó≥Ô∏è Hora da vota√ß√£o! Escolham quem ser√° executado. ${durationText}`;
        break;
      case GamePhase.NIGHT:
        phaseMessage = `üåô Noite ${gameState.day} chegou... Os poderes especiais acordam. ${durationText}`;
        break;
    }

    if (phaseMessage) {
      this.broadcastSystemMessage(gameState.gameId, phaseMessage, 'system');
    }

    setTimeout(() => {
      this.nextPhase(gameState.gameId);
    }, duration);

    this.emitGameEvent(gameState.gameId, 'phase:changed', {
      gameId: gameState.gameId,
      phase: newPhase,
      duration,
      timeLeft: duration,
      day: gameState.day,
    });

    logger.info('Phase changed with system message', {
      gameId: gameState.gameId,
      from: oldPhase,
      to: newPhase,
      day: gameState.day,
      duration: `${duration / 1000}s`
    });
  }

  // ‚úÖ CORRIGIDO: processNightResults com FEEDBACK DAS A√á√ïES
  private async processNightResults(gameState: GameState): Promise<void> {
    logger.info('Processing night results with feedback', {
      gameId: gameState.gameId,
      nightActionsCount: gameState.nightActions.length,
      nightActions: gameState.nightActions.map(a => ({
        type: a.type,
        playerId: a.playerId,
        targetId: a.targetId
      }))
    });

    const deaths: string[] = [];
    const protections: string[] = [];

    // Primeiro, aplicar prote√ß√µes
    gameState.nightActions.forEach(action => {
      if (action.type === 'PROTECT' && action.targetId) {
        const target = gameState.getPlayer(action.targetId);
        if (target) {
          target.protect();
          protections.push(action.targetId);

          // ‚úÖ FEEDBACK para o Doctor
          this.sendActionResult(gameState.gameId, action.playerId, 'PROTECT',
            `üõ°Ô∏è Voc√™ protegeu ${target.username} com sucesso!`);

          logger.info('Protection applied with feedback', {
            gameId: gameState.gameId,
            targetId: action.targetId,
            targetName: target.username
          });
        }
      }
    });

    // Segundo, processar investiga√ß√µes
    gameState.nightActions.forEach(action => {
      if (action.type === 'INVESTIGATE' && action.targetId) {
        const target = gameState.getPlayer(action.targetId);
        if (target && target.role) {
          // ‚úÖ L√ìGICA DE INVESTIGA√á√ÉO
          const isSuspicious = target.role === 'WEREWOLF' || target.role === 'WEREWOLF_KING' || target.role === 'SERIAL_KILLER';
          const result = isSuspicious ? 'SUSPEITO' : 'INOCENTE';

          // ‚úÖ FEEDBACK para o Sheriff
          this.sendActionResult(gameState.gameId, action.playerId, 'INVESTIGATE',
            `üîç Investiga√ß√£o de ${target.username}: ${result} ${isSuspicious ? '‚ö†Ô∏è' : '‚úÖ'}`);

          logger.info('Investigation completed with feedback', {
            gameId: gameState.gameId,
            targetId: action.targetId,
            targetName: target.username,
            result
          });
        }
      }
    });

    // Terceiro, processar ataques
    gameState.nightActions.forEach(action => {
      if ((action.type === 'WEREWOLF_KILL' || action.type === 'KILL') && action.targetId) {
        const target = gameState.getPlayer(action.targetId);
        if (target && target.isAlive && !target.isProtected) {
          target.kill('NIGHT_KILL');
          deaths.push(action.targetId);

          logger.info('Night kill applied', {
            gameId: gameState.gameId,
            targetId: action.targetId,
            targetName: target.username,
            killerType: action.type
          });
        } else if (target && target.isProtected) {
          logger.info('Attack blocked by protection', {
            gameId: gameState.gameId,
            targetId: action.targetId,
            targetName: target.username
          });
        }
      }
    });

    // Enviar mensagens de sistema sobre os resultados
    if (deaths.length > 0) {
      deaths.forEach(playerId => {
        const player = gameState.getPlayer(playerId);
        if (player) {
          this.broadcastSystemMessage(gameState.gameId,
            `üíÄ ${player.username} foi encontrado morto pela manh√£!`,
            'system'
          );
        }
      });
    } else {
      this.broadcastSystemMessage(gameState.gameId,
        "üåÖ Ningu√©m morreu durante a noite. A vila teve uma noite tranquila.",
        'system'
      );
    }

    // Limpar a√ß√µes da noite
    gameState.nightActions = [];

    // Remover prote√ß√µes (elas duram apenas uma noite)
    gameState.players.forEach(player => {
      if (player.isProtected) {
        player.removeProtection();
      }
    });

    logger.info('Night results processed completely with feedback', {
      gameId: gameState.gameId,
      deathsCount: deaths.length,
      protectionsCount: protections.length,
      remainingActions: gameState.nightActions.length
    });
  }

  private async processVotingResults(gameState: GameState): Promise<void> {
    const result = gameState.getMostVotedPlayer();

    if (result) {
      const player = gameState.getPlayer(result.playerId);
      if (player && player.role) {
        if (player.role === Role.JESTER) {
          gameState.endGame(Faction.NEUTRAL, [player.id]);

          this.broadcastSystemMessage(gameState.gameId,
            `üé≠ ${player.username} era o BOBO DA CORTE e venceu ao ser executado!`,
            'system'
          );

          this.emitGameEvent(gameState.gameId, 'jester:wins', {
            gameId: gameState.gameId,
            jesterId: player.id,
            jesterName: player.username,
          });

          await this.endGame(gameState.gameId, 'Jester executed and wins');
          return;
        }

        player.kill('EXECUTION');

        this.broadcastSystemMessage(gameState.gameId,
          `‚öñÔ∏è ${player.username} foi executado pela vila! Ele era: ${player.role}`,
          'system'
        );

        gameState.addEvent('PLAYER_EXECUTED', {
          playerId: player.id,
          playerName: player.username,
          role: player.role,
          votes: result.votes,
        });

        logger.info('Player executed with role reveal', {
          gameId: gameState.gameId,
          playerId: player.id,
          playerName: player.username,
          role: player.role,
          votes: result.votes
        });
      }
    } else {
      this.broadcastSystemMessage(gameState.gameId,
        "ü§ù Empate na vota√ß√£o! Ningu√©m foi executado hoje.",
        'system'
      );

      gameState.addEvent('NO_EXECUTION', {
        reason: 'No majority or tie vote',
      });

      logger.info('No execution - tie vote', {
        gameId: gameState.gameId,
        voteCounts: Object.fromEntries(gameState.getVoteCounts())
      });
    }
  }

  //====================================================================
  // WIN CONDITION CHECKING
  //====================================================================
  private async checkWinCondition(gameId: string): Promise<void> {
    const gameState = this.games.get(gameId);
    if (!gameState || gameState.status !== 'PLAYING') return;

    const alivePlayers = gameState.getAlivePlayers();
    const winCondition = WinConditionCalculator.calculateWinCondition(
      alivePlayers.map(p => ({ playerId: p.id, role: p.role! }))
    );

    if (winCondition.hasWinner) {
      await this.endGame(gameId);
    }
  }

  //====================================================================
  // VOTING SYSTEM
  //====================================================================
  async castVote(gameId: string, voterId: string, targetId: string): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    try {
      const voter = gameState.players.find(p => p.userId === voterId);
      if (!voter) {
        logger.warn('Vote attempt by non-existent player', { gameId, voterId });
        return false;
      }

      const success = gameState.addVote(voter.id, targetId);

      if (success) {
        this.emitGameEvent(gameId, 'vote:cast', {
          gameId,
          voterId: voter.id,
          targetId,
          voteCounts: Object.fromEntries(gameState.getVoteCounts()),
        });

        await this.broadcastGameState(gameId);

        logger.info('Vote cast successfully', {
          gameId,
          voterId: voter.id,
          voterName: voter.username,
          targetId
        });
      }

      return success;
    } catch (error) {
      logger.error('Error casting vote',
        error instanceof Error ? error : new Error('Unknown vote error'),
        { gameId, voterId, targetId }
      );
      return false;
    }
  }

  async removeVote(gameId: string, voterId: string): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    try {
      const voter = gameState.players.find(p => p.userId === voterId);
      if (!voter) {
        logger.warn('Unvote attempt by non-existent player', { gameId, voterId });
        return false;
      }

      const success = gameState.removeVote(voter.id);

      if (success) {
        this.emitGameEvent(gameId, 'vote:removed', {
          gameId,
          voterId: voter.id,
          voteCounts: Object.fromEntries(gameState.getVoteCounts()),
        });

        await this.broadcastGameState(gameId);

        logger.info('Vote removed successfully', {
          gameId,
          voterId: voter.id,
          voterName: voter.username
        });
      }

      return success;
    } catch (error) {
      logger.error('Error removing vote',
        error instanceof Error ? error : new Error('Unknown unvote error'),
        { gameId, voterId }
      );
      return false;
    }
  }

  //====================================================================
  // EVENT SYSTEM
  //====================================================================
  onGameEvent(gameId: string, event: string, handler: (data: any) => void): void {
    const gameHandlers = this.eventHandlers.get(gameId);
    if (!gameHandlers) return;

    if (!gameHandlers.has(event)) {
      gameHandlers.set(event, []);
    }

    gameHandlers.get(event)!.push(handler);
  }

  private emitGameEvent(gameId: string, event: string, data: any): void {
    const gameHandlers = this.eventHandlers.get(gameId);
    if (!gameHandlers) return;

    const handlers = gameHandlers.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          logger.error('Error in game event handler', error instanceof Error ? error : new Error('Unknown handler error'), {
            gameId,
            event,
          });
        }
      });
    }
  }

  //====================================================================
  // UTILITY METHODS
  //====================================================================
  private generateGameResults(gameState: GameState): GameResults {
    const results: GameResults = {
      gameId: gameState.gameId,
      roomId: gameState.roomId,
      duration: gameState.finishedAt
        ? gameState.finishedAt.getTime() - (gameState.startedAt?.getTime() || 0)
        : 0,
      totalDays: gameState.day,

      ...(gameState.winningFaction && { winningFaction: gameState.winningFaction }),

      winningPlayers: gameState.winningPlayers,
      players: gameState.players.map(player => ({
        id: player.id,
        userId: player.userId,
        username: player.username,
        role: player.role ?? Role.VILLAGER,
        faction: player.faction ?? Faction.TOWN,
        survived: player.isAlive,
        won: gameState.winningPlayers.includes(player.id),
        eliminationReason: player.eliminationReason ?? '',
        killedBy: player.killedBy ?? '',
      })),
      events: gameState.events,
    };

    return results;
  }

  //====================================================================
  // ADMINISTRATIVE METHODS
  //====================================================================
  getActiveGamesCount(): number {
    return Array.from(this.games.values())
      .filter(game => game.status === 'PLAYING').length;
  }

  getAllGames(): GameState[] {
    return Array.from(this.games.values());
  }

  async getGamesByRoom(roomId: string): Promise<GameState[]> {
    const games = Array.from(this.games.values())
      .filter(game => game.roomId === roomId);
    return Promise.resolve(games);
  }

  async forceEndGame(gameId: string, reason: string): Promise<boolean> {
    const gameState = this.games.get(gameId);
    if (!gameState) return false;

    await this.endGame(gameId, reason);
    return true;
  }

  getGameStats(gameId: string): any {
    const gameState = this.games.get(gameId);
    if (!gameState) return null;

    return {
      gameId,
      status: gameState.status,
      phase: gameState.phase,
      day: gameState.day,
      playerCount: gameState.players.length,
      aliveCount: gameState.getAlivePlayers().length,
      spectatorCount: gameState.spectators.length,
      timeLeft: gameState.timeLeft,
      events: gameState.events.length,
    };
  }

  //====================================================================
  // CLEANUP
  //====================================================================
  async cleanup(): Promise<void> {
    this.games.clear();
    this.eventHandlers.clear();

    logger.info('GameEngine cleanup completed');
  }
}
</file>

<file path="frontend/.env.example">
# üê∫ WEREWOLF - Frontend Environment Variables

# =============================================================================
# API CONFIGURATION
# =============================================================================
NEXT_PUBLIC_API_URL=http://155.138.222.77:3001
NEXT_PUBLIC_WS_URL=ws://155.138.222.77:3001

# =============================================================================
# APPLICATION SETTINGS
# =============================================================================
NODE_ENV=development
NEXT_PUBLIC_SITE_URL=http://155.138.222.77:3001
NEXT_PUBLIC_APP_NAME=Werewolf

# =============================================================================
# ERROR TRACKING (OPCIONAL)
# =============================================================================
NEXT_PUBLIC_SENTRY_DSN=

# =============================================================================
# FEATURE FLAGS
# =============================================================================
NEXT_PUBLIC_ENABLE_PWA=false
NEXT_PUBLIC_ENABLE_SW=false
NEXT_PUBLIC_DEBUG=false

# =============================================================================
# SOCIAL & SEO
# =============================================================================
NEXT_PUBLIC_FACEBOOK_APP_ID=

# =============================================================================
# GAME SETTINGS
# =============================================================================
NEXT_PUBLIC_MAX_USERNAME_LENGTH=20
NEXT_PUBLIC_MIN_USERNAME_LENGTH=3
NEXT_PUBLIC_MAX_ROOM_NAME_LENGTH=30

# =============================================================================
# AUDIO SETTINGS
# =============================================================================
NEXT_PUBLIC_DEFAULT_MUSIC_VOLUME=0.3
NEXT_PUBLIC_DEFAULT_SFX_VOLUME=0.7
NEXT_PUBLIC_AUDIO_ENABLED_DEFAULT=true

# =============================================================================
# DEVELOPMENT ONLY
# =============================================================================
NEXT_PUBLIC_SHOW_DEBUG_INFO=true
NEXT_PUBLIC_DEMO_EMAIL=demo@werewolf.com
NEXT_PUBLIC_DEMO_PASSWORD=demo123

# =============================================================================
# EXTERNAL SERVICES (FUTURO)
# =============================================================================
NEXT_PUBLIC_CDN_URL=
NEXT_PUBLIC_UPLOAD_API_URL=

# =============================================================================
# WEBSOCKET CONFIGURATION
# =============================================================================
NEXT_PUBLIC_WS_RECONNECT_TIMEOUT=5000
NEXT_PUBLIC_WS_MAX_RECONNECT_ATTEMPTS=5
NEXT_PUBLIC_WS_HEARTBEAT_INTERVAL=30000
WS_HEARTBEAT_INTERVAL=30000
WS_PING_TIMEOUT=10000
WS_MAX_RECONNECT_ATTEMPTS=5

# =============================================================================
# UI CONFIGURATION
# =============================================================================
NEXT_PUBLIC_DEFAULT_THEME=dark
NEXT_PUBLIC_DEFAULT_LOCALE=pt-BR
NEXT_PUBLIC_DEFAULT_TIMEZONE=America/Sao_Paulo

# =============================================================================
# PERFORMANCE
# =============================================================================
NEXT_PUBLIC_MAX_UPLOAD_SIZE=5242880
NEXT_PUBLIC_API_CACHE_TTL=300000

# =============================================================================
# SECURITY
# =============================================================================
NEXT_PUBLIC_ALLOWED_ORIGINS=http://155.138.222.77:3001,http://155.138.222.77:3000
NEXT_PUBLIC_FORCE_HTTPS=false
</file>

<file path="frontend/src/components/common/Button.tsx">
'use client';

import { forwardRef } from 'react';
import { clsx } from 'clsx';
import { useTheme } from '@/context/ThemeContext';
import { ButtonProps } from '@/types';

// =============================================================================
// LOADING SPINNER COMPONENT (Inline para evitar depend√™ncias)
// =============================================================================
const Spinner = ({ className }: { className?: string }) => (
  <svg
    className={clsx('animate-spin', className)}
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
  >
    <circle
      className="opacity-25"
      cx="12"
      cy="12"
      r="10"
      stroke="currentColor"
      strokeWidth="4"
    />
    <path
      className="opacity-75"
      fill="currentColor"
      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
    />
  </svg>
);

// =============================================================================
// BUTTON COMPONENT
// =============================================================================
const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  function Button(
    {
      children,
      variant = 'primary',
      size = 'md',
      disabled = false,
      loading = false,
      onClick,
      className = '',
      type = 'button',
      ...props
    },
    ref
  ) {
    // Safe theme hook usage with fallback
    let playSound: (soundId: string) => void;
    try {
      const theme = useTheme();
      playSound = theme?.playSound || (() => { });
    } catch (error) {
      console.warn('Theme context not available, using fallback');
      playSound = () => { };
    }

    // =============================================================================
    // ‚úÖ VARIANT STYLES - CORRIGIDO: Adicionado 'outline'
    // =============================================================================
    const variantStyles = {
      primary: clsx(
        'bg-gradient-to-b from-blue-500 to-blue-700',
        'hover:from-blue-400 hover:to-blue-600',
        'text-white font-bold shadow-lg',
        'border-2 border-blue-400',
        'hover:shadow-xl',
        'active:from-blue-700 active:to-blue-900'
      ),

      secondary: clsx(
        'bg-gradient-to-b from-gray-600 to-gray-800',
        'hover:from-gray-500 hover:to-gray-700',
        'text-white font-semibold shadow-lg',
        'border-2 border-gray-400',
        'hover:shadow-xl'
      ),

      danger: clsx(
        'bg-gradient-to-b from-red-500 to-red-700',
        'hover:from-red-400 hover:to-red-600',
        'text-white font-bold shadow-lg',
        'border-2 border-red-300',
        'hover:shadow-xl',
        'active:from-red-700 active:to-red-900'
      ),

      medieval: clsx(
        'bg-gradient-to-b from-amber-600 to-amber-800',
        'hover:from-amber-500 hover:to-amber-700',
        'text-white font-bold text-lg shadow-lg',
        'border-3 border-amber-400',
        'hover:shadow-xl',
        'relative overflow-hidden'
      ),

      ghost: clsx(
        'bg-transparent hover:bg-white/10',
        'text-white hover:text-blue-300',
        'border border-white/30 hover:border-blue-300',
        'transition-all duration-200'
      ),

      // ‚úÖ CORRIGIDO: Adicionado variant 'outline' faltando
      outline: clsx(
        'bg-transparent border-2 border-current',
        'hover:bg-current hover:text-white',
        'transition-all duration-200'
      ),

      werewolf: clsx(
        'bg-gradient-to-b from-red-800 to-red-900',
        'hover:from-red-700 hover:to-red-800',
        'text-white font-bold shadow-lg',
        'border-2 border-red-600',
        'hover:shadow-xl'
      ),

      town: clsx(
        'bg-gradient-to-b from-green-600 to-green-800',
        'hover:from-green-500 hover:to-green-700',
        'text-white font-bold shadow-lg',
        'border-2 border-green-400',
        'hover:shadow-xl'
      ),
    };

    // =============================================================================
    // ‚úÖ SIZE STYLES - CORRIGIDO: Adicionado 'xs'
    // =============================================================================
    const sizeStyles = {
      xs: 'px-2 py-1 text-xs rounded gap-1', // ‚úÖ CORRIGIDO: Adicionado size 'xs' faltando
      sm: 'px-3 py-1.5 text-sm rounded-md gap-1.5',
      md: 'px-4 py-2 text-base rounded-lg gap-2',
      lg: 'px-6 py-3 text-lg rounded-xl gap-2.5',
      xl: 'px-8 py-4 text-xl rounded-xl gap-3',
    };

    // =============================================================================
    // DISABLED/LOADING STYLES
    // =============================================================================
    const disabledStyles = clsx(
      'opacity-50 cursor-not-allowed',
      'hover:shadow-none hover:transform-none',
      'pointer-events-none'
    );

    // =============================================================================
    // COMBINED CLASSES
    // =============================================================================
    const buttonClasses = clsx(
      // Base styles
      'relative inline-flex items-center justify-center',
      'font-medium transition-all duration-200',
      'transform hover:scale-105 hover:-translate-y-0.5',
      'active:scale-95 active:translate-y-0',
      'focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2',
      'select-none',

      // Variant styles
      variantStyles[variant],

      // Size styles
      sizeStyles[size],

      // State styles
      (disabled || loading) && disabledStyles,

      // Custom className
      className
    );

    // =============================================================================
    // ‚úÖ CLICK HANDLER COM SOM - CORRIGIDO: Passar evento para onClick
    // =============================================================================
    const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
      if (disabled || loading) return;

      // Escolher som baseado no tipo de bot√£o
      let soundType = 'button_click'; // default (click3.wav)

      if (variant === 'ghost' || variant === 'secondary') {
        soundType = 'button_secondary'; // click1.wav (som leve)
      } else if (variant === 'medieval' || variant === 'primary' || variant === 'danger') {
        soundType = 'button_click'; // click3.wav (som firme)
      }

      playSound(soundType);

      // ‚úÖ CORRIGIDO: Passar o evento para onClick
      onClick?.(event);
    };

    // =============================================================================
    // RENDER
    // =============================================================================
    return (
      <button
        ref={ref}
        type={type}
        className={buttonClasses}
        onClick={handleClick}
        disabled={disabled || loading}
        {...props}
      >
        {/* Loading spinner */}
        {loading && (
          <Spinner className="w-4 h-4" />
        )}

        {/* Button content */}
        {children}

        {/* Medieval button enhancement */}
        {variant === 'medieval' && (
          <>
            {/* Top highlight */}
            <div className="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-transparent via-amber-200 to-transparent opacity-60" />

            {/* Side highlights */}
            <div className="absolute top-0 bottom-0 left-0 w-1 bg-gradient-to-b from-amber-200 via-transparent to-amber-200 opacity-40" />
            <div className="absolute top-0 bottom-0 right-0 w-1 bg-gradient-to-b from-amber-200 via-transparent to-amber-200 opacity-40" />
          </>
        )}

        {/* Glow effect for primary variants */}
        {(variant === 'primary' || variant === 'medieval') && !disabled && !loading && (
          <div className="absolute -inset-0.5 bg-gradient-to-r from-blue-400 to-amber-400 rounded-lg opacity-0 group-hover:opacity-20 blur transition-opacity duration-300 -z-10" />
        )}
      </button>
    );
  }
);

// =============================================================================
// DISPLAY NAME (CR√çTICO para forwardRef)
// =============================================================================
Button.displayName = 'Button';

// =============================================================================
// BUTTON GROUP COMPONENT
// =============================================================================
interface ButtonGroupProps {
  children: React.ReactNode;
  className?: string;
  orientation?: 'horizontal' | 'vertical';
}

export const ButtonGroup = forwardRef<HTMLDivElement, ButtonGroupProps>(
  function ButtonGroup(
    {
      children,
      className = '',
      orientation = 'horizontal'
    },
    ref
  ) {
    return (
      <div
        ref={ref}
        className={clsx(
          'inline-flex',
          orientation === 'horizontal' ? 'flex-row' : 'flex-col',
          '[&>button]:rounded-none',
          '[&>button:first-child]:rounded-l-lg',
          '[&>button:last-child]:rounded-r-lg',
          orientation === 'vertical' && '[&>button:first-child]:rounded-t-lg [&>button:first-child]:rounded-l-none',
          orientation === 'vertical' && '[&>button:last-child]:rounded-b-lg [&>button:last-child]:rounded-r-none',
          '[&>button:not(:first-child)]:border-l-0',
          orientation === 'vertical' && '[&>button:not(:first-child)]:border-l [&>button:not(:first-child)]:border-t-0',
          className
        )}
      >
        {children}
      </div>
    );
  }
);

ButtonGroup.displayName = 'ButtonGroup';

// =============================================================================
// ‚úÖ ICON BUTTON COMPONENT - CORRIGIDO: Adicionado 'xs' no iconSizes
// =============================================================================
interface IconButtonProps extends Omit<ButtonProps, 'children'> {
  icon: React.ReactNode;
  'aria-label': string;
}

export const IconButton = forwardRef<HTMLButtonElement, IconButtonProps>(
  function IconButton(
    {
      icon,
      className = '',
      size = 'md',
      ...props
    },
    ref
  ) {
    // ‚úÖ CORRIGIDO: Adicionado 'xs' no iconSizes
    const iconSizes = {
      xs: 'w-3 h-3', // ‚úÖ CORRIGIDO: Adicionado size 'xs' faltando
      sm: 'w-4 h-4',
      md: 'w-5 h-5',
      lg: 'w-6 h-6',
      xl: 'w-8 h-8',
    };

    return (
      <Button
        ref={ref}
        className={clsx('!p-2 aspect-square', className)}
        size={size}
        {...props}
      >
        <span className={iconSizes[size]}>{icon}</span>
      </Button>
    );
  }
);

IconButton.displayName = 'IconButton';

// =============================================================================
// DEFAULT EXPORT
// =============================================================================
export default Button;
</file>

<file path="frontend/src/components/common/Layout.tsx">
'use client';

import { ReactNode, useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import {
  Home,
  User,
  Trophy,
  Settings,
  LogOut,
  Volume2,
  VolumeX,
  Moon,
  Sun,
  Menu,
  X
} from 'lucide-react';
import { clsx } from 'clsx';
import { useAuth } from '@/context/AuthContext';
import { useTheme } from '@/context/ThemeContext';
import { useSocket } from '@/context/SocketContext';
import Button from './Button';
import { useRouter } from 'next/navigation';

// =============================================================================
// LAYOUT PROPS
// =============================================================================
interface LayoutProps {
  children: ReactNode;
  showHeader?: boolean;
  showSidebar?: boolean;
  showFooter?: boolean;
  className?: string;
  variant?: 'default' | 'game' | 'auth' | 'landing';
}

// ‚úÖ CORRE√á√ÉO: Componente para tema escuro/claro seguro para hidrata√ß√£o
interface SafeThemeDisplayProps {
  theme: 'werewolf' | 'medieval' | 'modern';
  onToggle: () => void;
}

function SafeThemeToggle({ theme, onToggle }: SafeThemeDisplayProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return (
      <Button
        variant="ghost"
        size="sm"
        onClick={onToggle}
        aria-label="Alternar tema"
      >
        <div className="w-5 h-5" />
      </Button>
    );
  }

  // ‚úÖ CORRIGIDO: Usar 'theme' em vez de isDark
  return (
    <Button
      variant="ghost"
      size="sm"
      onClick={onToggle}
      aria-label={`Tema atual: ${theme}`}
    >
      {theme === 'werewolf' ? <Moon className="w-5 h-5" /> : <Sun className="w-5 h-5" />}
    </Button>
  );
}

// ‚úÖ CORRE√á√ÉO: Componente para status de conex√£o seguro para hidrata√ß√£o
interface SafeConnectionStatusProps {
  isConnected: boolean;
}

function SafeConnectionStatus({ isConnected }: SafeConnectionStatusProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return (
      <div className="w-2 h-2 rounded-full bg-gray-400" />
    );
  }

  return (
    <div className={clsx(
      'w-2 h-2 rounded-full',
      isConnected ? 'bg-green-400' : 'bg-red-400'
    )} />
  );
}

// =============================================================================
// MAIN LAYOUT COMPONENT
// =============================================================================
export default function Layout({
  children,
  showHeader = true,
  showSidebar = true,
  showFooter = true,
  className = '',
  variant = 'default',
}: LayoutProps) {
  // ‚úÖ CORRIGIDO: Usar apenas as propriedades que realmente existem
  const { getPhaseColors, getThemeClass } = useTheme();
  const phaseColors = getPhaseColors(); // ‚úÖ CORRIGIDO: n√£o precisa de par√¢metro

  // Variant-specific layouts
  if (variant === 'auth') {
    return <AuthLayout>{children}</AuthLayout>;
  }

  if (variant === 'landing') {
    return <LandingLayout>{children}</LandingLayout>;
  }

  if (variant === 'game') {
    return <GameLayout>{children}</GameLayout>;
  }

  // Default layout
  return (
    <div className={clsx(
      'min-h-screen',
      `bg-gradient-to-br ${phaseColors.background}`,
      getThemeClass(), // ‚úÖ CORRIGIDO: usar getThemeClass() que existe
      className
    )}>
      {showHeader && <Header />}

      <div className="flex">
        {showSidebar && <Sidebar />}

        <main className={clsx(
          'flex-1 transition-all duration-300',
          showSidebar ? 'ml-64' : 'ml-0',
          showHeader ? 'pt-16' : 'pt-0',
          'p-6'
        )}>
          {children}
        </main>
      </div>

      {showFooter && <Footer />}
    </div>
  );
}

// =============================================================================
// ‚úÖ HEADER COMPONENT - TOTALMENTE CORRIGIDO
// =============================================================================
function Header() {
  const { user, logout } = useAuth();
  // ‚úÖ CORRIGIDO: Usar as propriedades reais do ThemeContext
  const { theme, setTheme, audioConfig, updateAudioConfig } = useTheme();
  const { isConnected } = useSocket(); // ‚úÖ CORRIGIDO: usar isConnected em vez de status
  const [showUserMenu, setShowUserMenu] = useState(false);

  const toggleTheme = () => {
    // ‚úÖ CORRIGIDO: Rotacionar entre os 3 temas dispon√≠veis
    const themes: ('werewolf' | 'medieval' | 'modern')[] = ['werewolf', 'medieval', 'modern'];
    const currentIndex = themes.indexOf(theme);
    const nextIndex = (currentIndex + 1) % themes.length;
    setTheme(themes[nextIndex] || 'werewolf');
  };

  const toggleAudio = () => {
    updateAudioConfig({ enabled: !audioConfig.enabled }); // ‚úÖ CORRIGIDO: usar 'enabled'
  };

  return (
    <motion.header
      initial={{ y: -100 }}
      animate={{ y: 0 }}
      className="fixed top-0 left-0 right-0 z-40 bg-medieval-900/95 backdrop-blur-sm border-b border-medieval-600"
    >
      <div className="flex items-center justify-between h-16 px-6">
        {/* Logo */}
        <div className="flex items-center space-x-3">
          <div className="text-2xl">üê∫</div>
          <h1 className="text-xl font-medieval text-glow">
            Werewolf
          </h1>

          {/* ‚úÖ CORRIGIDO: Connection status */}
          <SafeConnectionStatus isConnected={isConnected} />
        </div>

        {/* Controls */}
        <div className="flex items-center space-x-3">
          {/* Audio toggle */}
          <Button
            variant="ghost"
            size="sm"
            onClick={toggleAudio}
            aria-label={audioConfig.enabled ? 'Desativar som' : 'Ativar som'} // ‚úÖ CORRIGIDO
          >
            {audioConfig.enabled ? // ‚úÖ CORRIGIDO
              <Volume2 className="w-5 h-5" /> :
              <VolumeX className="w-5 h-5" />
            }
          </Button>

          {/* ‚úÖ CORRIGIDO: Theme toggle */}
          <SafeThemeToggle theme={theme} onToggle={toggleTheme} />

          {/* User menu */}
          {user && (
            <div className="relative">
              <Button
                variant="ghost"
                onClick={() => setShowUserMenu(!showUserMenu)}
                className="flex items-center space-x-2"
              >
                <div className="w-8 h-8 bg-salem-600 rounded-full flex items-center justify-center">
                  {user.avatar ? (
                    <img src={user.avatar} alt="" className="w-full h-full rounded-full" />
                  ) : (
                    <span className="text-sm font-bold">
                      {user.username.charAt(0).toUpperCase()}
                    </span>
                  )}
                </div>
                <span className="font-medium">{user.username}</span>
              </Button>

              {/* Dropdown menu */}
              {showUserMenu && (
                <motion.div
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  className="absolute right-0 mt-2 w-48 bg-medieval-800 rounded-lg shadow-medieval border border-medieval-600"
                >
                  <div className="py-2">
                    <div className="px-4 py-2 border-b border-medieval-600">
                      <p className="text-sm text-white/70">N√≠vel {user.level || 1}</p>
                      <p className="text-xs text-white/50">{user.totalGames || 0} jogos</p>
                    </div>

                    <Button
                      variant="ghost"
                      className="w-full justify-start px-4 py-2 text-left"
                      onClick={() => setShowUserMenu(false)}
                    >
                      <User className="w-4 h-4 mr-2" />
                      Perfil
                    </Button>

                    <Button
                      variant="ghost"
                      className="w-full justify-start px-4 py-2 text-left"
                      onClick={() => setShowUserMenu(false)}
                    >
                      <Settings className="w-4 h-4 mr-2" />
                      Configura√ß√µes
                    </Button>

                    <div className="border-t border-medieval-600 mt-2 pt-2">
                      <Button
                        variant="ghost"
                        className="w-full justify-start px-4 py-2 text-left text-red-400 hover:text-red-300"
                        onClick={() => {
                          setShowUserMenu(false);
                          logout();
                        }}
                      >
                        <LogOut className="w-4 h-4 mr-2" />
                        Sair
                      </Button>
                    </div>
                  </div>
                </motion.div>
              )}
            </div>
          )}
        </div>
      </div>
    </motion.header>
  );
}

// =============================================================================
// SIDEBAR COMPONENT
// =============================================================================
function Sidebar() {
  const router = useRouter();
  const [isCollapsed, setIsCollapsed] = useState(false);

  const menuItems = [
    { icon: Home, label: 'Lobby', href: '/lobby' },
    { icon: User, label: 'Perfil', href: '/profile' },
    { icon: Trophy, label: 'Ranking', href: '/leaderboard' },
    { icon: Settings, label: 'Configura√ß√µes', href: '/settings' },
  ];

  return (
    <motion.aside
      initial={{ x: -300 }}
      animate={{ x: 0 }}
      className={clsx(
        'fixed left-0 top-16 bottom-0 z-30',
        'bg-medieval-900/95 backdrop-blur-sm border-r border-medieval-600',
        'transition-all duration-300',
        isCollapsed ? 'w-16' : 'w-64'
      )}
    >
      {/* Toggle button */}
      <div className="p-4 border-b border-medieval-600">
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setIsCollapsed(!isCollapsed)}
          className="w-full justify-center"
        >
          {isCollapsed ? <Menu className="w-5 h-5" /> : <X className="w-5 h-5" />}
        </Button>
      </div>

      {/* Navigation */}
      <nav className="p-4 space-y-2">
        {menuItems.map((item) => (
          <Button
            key={item.href}
            variant="ghost"
            className={clsx(
              'w-full justify-start',
              isCollapsed ? 'px-2' : 'px-4'
            )}
            onClick={() => router.push(item.href)}
          >
            <item.icon className="w-5 h-5" />
            {!isCollapsed && <span className="ml-3">{item.label}</span>}
          </Button>
        ))}
      </nav>
    </motion.aside>
  );
}

// =============================================================================
// FOOTER COMPONENT
// =============================================================================
function Footer() {
  return (
    <footer className="bg-medieval-900/80 border-t border-medieval-600 py-4 px-6 mt-auto relative z-10">
      <div className="flex items-center justify-between text-sm text-white/70">
        <p>¬© 2025 Werewolf. Todos os direitos reservados.</p>
        <p>Vers√£o 1.0.0</p>
      </div>
    </footer>
  );
}

// =============================================================================
// AUTH LAYOUT
// =============================================================================
function AuthLayout({ children }: { children: ReactNode }) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-night-dark flex items-center justify-center p-4">
      <div className="w-full max-w-md">
        {/* Logo */}
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-center mb-8"
        >
          <div className="text-6xl mb-4">üê∫</div>
          <h1 className="text-3xl font-medieval text-glow">
            Werewolf
          </h1>
          <p className="text-white/70 mt-2">
            Entre na vila... se tiver coragem
          </p>
        </motion.div>

        {/* Content */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2 }}
        >
          {children}
        </motion.div>
      </div>
    </div>
  );
}

// =============================================================================
// LANDING LAYOUT
// =============================================================================
function LandingLayout({ children }: { children: ReactNode }) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-night-dark">
      {children}
    </div>
  );
}

// =============================================================================
// ‚úÖ GAME LAYOUT - CORRIGIDO
// =============================================================================
function GameLayout({ children }: { children: ReactNode }) {
  const { getPhaseColors } = useTheme();
  const phaseColors = getPhaseColors(); // ‚úÖ CORRIGIDO: sem par√¢metro

  return (
    <div className={clsx(
      'min-h-screen transition-all duration-1000',
      `bg-gradient-to-br ${phaseColors.background}`
    )}>
      {/* Game header */}
      <div className="bg-black/20 border-b border-white/10 px-6 py-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <div className="text-2xl">üê∫</div>
            <div>
              <h1 className="font-medieval text-xl text-glow">
                Werewolf
              </h1>
              <p className={clsx('text-sm', phaseColors.text)}>
                Em jogo
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Game content */}
      <div className="relative">
        {children}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/common/Modal.tsx">
'use client';

import { useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';
import { clsx } from 'clsx';
import { useTheme } from '@/context/ThemeContext';
import { ModalProps } from '@/types';
import Button from './Button';

// =============================================================================
// MODAL COMPONENT (VERS√ÉO FINAL CORRIGIDA E FUNCIONAL)
// =============================================================================
export default function Modal({
  isOpen,
  onClose,
  title,
  children,
  className = '',
  closeOnOverlayClick = true,
  size = 'md',
  variant = 'default',
}: ModalProps & {
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  variant?: 'default' | 'medieval' | 'game' | 'error';
}) {
  const [mounted, setMounted] = useState(false);

  // Garante que o c√≥digo s√≥ rode no cliente para o createPortal
  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  // Suporte para fechar com a tecla ESC
  useEffect(() => {
    if (!isOpen) return;
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [isOpen, onClose]);

  // Bloqueio de scroll do body quando o modal est√° aberto
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  // Render guard para SSR
  if (!mounted) return null;

  // Configura√ß√µes de estilo
  const sizeClasses = {
    sm: 'max-w-md',
    md: 'max-w-lg',
    lg: 'max-w-2xl',
    xl: 'max-w-4xl',
    full: 'w-[95vw] h-[95vh]',
  };

  const variantStyles = {
    default: 'bg-medieval-800 border-medieval-600 text-white shadow-medieval',
    medieval: 'bg-gradient-to-b from-medieval-700 to-medieval-900 border-3 border-amber-600 text-white shadow-glow-gold relative overflow-hidden',
    game: 'bg-gradient-to-b from-night-light to-night-dark border-2 border-salem-500 text-white shadow-2xl backdrop-blur-sm',
    error: 'bg-gradient-to-b from-red-900 to-red-950 border-2 border-red-500 text-white shadow-glow-red',
  };

  // Configura√ß√µes de anima√ß√£o
  const overlayVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1 },
    exit: { opacity: 0 },
  };

  const modalVariants = {
    hidden: { opacity: 0, scale: 0.9, y: 20 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring', damping: 25, stiffness: 300 } },
    exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.2 } },
  };

  // Conte√∫do do modal a ser renderizado no portal
  const modalContent = (
    <AnimatePresence mode="wait">
      {isOpen && (
        // O cont√™iner pai que cobre toda a tela e atua como o overlay clic√°vel
        <motion.div
          className="fixed inset-0 z-50 flex items-center justify-center p-4"
          variants={overlayVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
          onClick={closeOnOverlayClick ? onClose : undefined}
        >
          {/* Fundo escuro puramente visual, sem eventos de clique */}
          <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" />

          {/* O conte√∫do do modal */}
          <motion.div
            className={clsx(
              'relative w-full max-h-[90vh] flex flex-col',
              'rounded-xl border-2',
              sizeClasses[size],
              variantStyles[variant],
              className
            )}
            variants={modalVariants}
            onClick={(e) => e.stopPropagation()} // Impede que o clique no modal feche-o
          >
            {/* Cabe√ßalho (fixo) */}
            {title && (
              <header className="flex-shrink-0 flex items-center justify-between p-6 border-b border-current/20">
                <h2 className={clsx('text-xl font-bold', variant === 'medieval' && 'font-medieval text-2xl text-glow')}>
                  {title}
                </h2>
                <Button variant="ghost" size="sm" onClick={onClose} className="!p-1" aria-label="Fechar modal">
                  <X className="w-5 h-5" />
                </Button>
              </header>
            )}

            {/* Corpo do modal (√°rea com rolagem) */}
            <main className="flex-1 overflow-y-auto p-6">
              {!title && (
                <Button variant="ghost" size="sm" onClick={onClose} className="!p-1 absolute top-4 right-4 z-10" aria-label="Fechar modal">
                  <X className="w-5 h-5" />
                </Button>
              )}
              {children}
            </main>

            {/* Decora√ß√µes (apenas para o tema medieval) */}
            {variant === 'medieval' && (
              <>
                <div className="absolute top-2 left-2 w-8 h-8 border-l-3 border-t-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute top-2 right-2 w-8 h-8 border-r-3 border-t-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute bottom-2 left-2 w-8 h-8 border-l-3 border-b-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute bottom-2 right-2 w-8 h-8 border-r-3 border-b-3 border-amber-400 opacity-60 pointer-events-none" />
                <div className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none">
                  <div className="w-12 h-6 bg-amber-600 rounded-full border-2 border-amber-400" />
                </div>
              </>
            )}
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );

  return createPortal(modalContent, document.body);
}

// =============================================================================
// CONFIRMATION MODAL COMPONENT
// =============================================================================
interface ConfirmModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  variant?: 'danger' | 'warning' | 'info';
}

export function ConfirmModal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  variant = 'info',
}: ConfirmModalProps) {
  const { playSound } = useTheme();

  const handleConfirm = () => {
    playSound('button_click');
    onConfirm();
    onClose();
  };

  const handleCancel = () => {
    onClose();
  };

  const getVariantProps = () => {
    switch (variant) {
      case 'danger':
        return { modalVariant: 'error' as const, confirmVariant: 'danger' as const };
      case 'warning':
        return { modalVariant: 'medieval' as const, confirmVariant: 'primary' as const };
      default:
        return { modalVariant: 'default' as const, confirmVariant: 'primary' as const };
    }
  };

  const { modalVariant, confirmVariant } = getVariantProps();

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={title} variant={modalVariant} size="sm">
      <div className="space-y-6">
        <p className="text-white/90 leading-relaxed">{message}</p>
        <div className="flex gap-3 justify-end">
          <Button variant="ghost" onClick={handleCancel}>
            {cancelText}
          </Button>
          <Button variant={confirmVariant} onClick={handleConfirm}>
            {confirmText}
          </Button>
        </div>
      </div>
    </Modal>
  );
}

// =============================================================================
// ALERT MODAL COMPONENT
// =============================================================================
interface AlertModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  message: string;
  variant?: 'success' | 'error' | 'warning' | 'info';
}

export function AlertModal({
  isOpen,
  onClose,
  title,
  message,
  variant = 'info',
}: AlertModalProps) {
  const { playSound } = useTheme();

  const handleClose = () => {
    playSound('button_click');
    onClose();
  };

  const getVariantProps = () => {
    switch (variant) {
      case 'success':
        return { modalVariant: 'game' as const, icon: '‚úÖ' };
      case 'error':
        return { modalVariant: 'error' as const, icon: '‚ùå' };
      case 'warning':
        return { modalVariant: 'medieval' as const, icon: '‚ö†Ô∏è' };
      default:
        return { modalVariant: 'default' as const, icon: '‚ÑπÔ∏è' };
    }
  };

  const { modalVariant, icon } = getVariantProps();

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={`${icon} ${title}`} variant={modalVariant} size="sm">
      <div className="space-y-6">
        <p className="text-white/90 leading-relaxed">{message}</p>
        <div className="flex justify-end">
          <Button variant="primary" onClick={handleClose}>
            Entendi
          </Button>
        </div>
      </div>
    </Modal>
  );
}
</file>

<file path="frontend/src/components/game/GameBoard.tsx">
import React from 'react';
import { useGame } from '@/context/GameContext';
import PhaseIndicator from './PhaseIndicator';
import TimerDisplay from './TimerDisplay';
import RoleCard from './RoleCard';
import PlayerCircle from './PlayerCircle';
import ChatGigante from './ChatGigante';
import PlayerList from './PlayerList';
import ActionPanel from './ActionPanel';
import WillNotes from './WillNotes';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// GAME BOARD COMPONENT - LAYOUT TOWN OF SALEM
// =============================================================================
export default function GameBoard() {
  const { gameState, isLoading, error, me, connectionStatus } = useGame();

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (isLoading || connectionStatus === 'connecting') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="xl" />
          <p className="text-white/70 mt-4">Carregando estado do jogo...</p>
        </div>
      </div>
    );
  }

  // =============================================================================
  // ERROR STATE
  // =============================================================================
  if (error || connectionStatus === 'error') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black flex items-center justify-center">
        <div className="text-center max-w-md mx-auto p-6">
          <div className="text-red-400 text-6xl mb-4">üíÄ</div>
          <h2 className="text-xl font-bold text-white mb-4">Erro no Jogo</h2>
          <p className="text-white/70">{error || 'Erro de conex√£o'}</p>
          <button
            onClick={() => window.location.reload()}
            className="mt-4 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg"
          >
            Recarregar
          </button>
        </div>
      </div>
    );
  }

  // =============================================================================
  // NO GAME STATE
  // =============================================================================
  if (!gameState || connectionStatus === 'disconnected') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black flex items-center justify-center">
        <div className="text-center">
          <div className="animate-pulse">
            <div className="text-amber-400 text-6xl mb-4">üåô</div>
          </div>
          <h2 className="text-xl font-bold text-white mb-2">Aguardando Jogo</h2>
          <p className="text-white/70">Conectando ao servidor...</p>
        </div>
      </div>
    );
  }

  // =============================================================================
  // LOBBY STATE
  // =============================================================================
  if (gameState.phase === 'LOBBY' || gameState.status === 'WAITING') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black flex items-center justify-center">
        <div className="text-center max-w-2xl mx-auto p-8">
          <div className="text-6xl mb-6">üè∞</div>
          <h2 className="text-3xl font-bold text-white mb-4">Preparando o Jogo</h2>
          <p className="text-white/70 mb-6">
            O jogo est√° sendo configurado...
          </p>

          <div className="bg-medieval-800/30 border border-medieval-600 rounded-lg p-6">
            <h3 className="text-lg font-semibold text-white mb-4">
              Jogadores ({gameState.players.length})
            </h3>
            <div className="grid grid-cols-2 gap-2">
              {gameState.players.map((player) => (
                <div
                  key={player.id}
                  className="flex items-center space-x-2 p-2 bg-medieval-800/50 border border-medieval-600 rounded"
                >
                  <div className={`w-2 h-2 rounded-full ${player.isConnected ? 'bg-green-400' : 'bg-red-400'}`} />
                  <span className="text-white text-sm">{player.username}</span>
                  {player.isHost && <span className="text-amber-400 text-xs">üëë</span>}
                  {player.isReady && <span className="text-green-400 text-xs">‚úì</span>}
                </div>
              ))}
            </div>
          </div>

          <div className="mt-6 text-amber-400">
            <div className="animate-bounce">‚åõ</div>
            <p className="text-sm">Aguardando in√≠cio...</p>
          </div>
        </div>
      </div>
    );
  }

  // =============================================================================
  // MAIN GAME LAYOUT - TOWN OF SALEM STYLE
  // =============================================================================
  return (
    <div className="h-screen bg-gradient-to-br from-medieval-900 via-medieval-800 to-black">
      {/* Top Header Bar */}
      <header className="h-16 bg-medieval-800/50 border-b border-medieval-600 flex items-center justify-between px-4">
        {/* Left: Phase & Day */}
        <PhaseIndicator />

        {/* Center: Game Title */}
        <div className="flex items-center space-x-2">
          <span className="text-2xl">üê∫</span>
          <h1 className="text-xl font-bold text-white">Lobisomem Online</h1>
        </div>

        {/* Right: Timer */}
        <TimerDisplay />
      </header>

      {/* Main Game Grid - 6 Sections Layout */}
      <main className="h-[calc(100vh-4rem)] grid grid-cols-12 grid-rows-2 gap-4 p-4">

        {/* Left Column - Top: Role Card */}
        <section className="col-span-3 row-span-1">
          <RoleCard />
        </section>

        {/* Center Column - Top: Game Area with Players Circle */}
        <section className="col-span-6 row-span-1">
          <PlayerCircle />
        </section>

        {/* Right Column - Full Height: Chat Gigante */}
        <section className="col-span-3 row-span-2">
          <ChatGigante />
        </section>

        {/* Left Column - Bottom: Player List */}
        <section className="col-span-3 row-span-1">
          <PlayerList />
        </section>

        {/* Center Column - Bottom: Action Panel & Will Notes */}
        <section className="col-span-6 row-span-1 grid grid-cols-2 gap-4">
          <ActionPanel />
          <WillNotes />
        </section>

      </main>

      {/* Game Over Overlay */}
      {gameState.status === 'FINISHED' && (
        <div className="fixed inset-0 bg-black/75 flex items-center justify-center z-50">
          <div className="bg-medieval-800 border-2 border-medieval-600 rounded-lg p-8 max-w-md mx-4">
            <div className="text-center">
              <div className="text-6xl mb-4">
                {gameState.winningFaction === 'TOWN' ? 'üèòÔ∏è' :
                  gameState.winningFaction === 'WEREWOLF' ? 'üê∫' : '‚ö°'}
              </div>

              <h2 className="text-2xl font-bold text-white mb-4">
                Fim de Jogo!
              </h2>

              <p className="text-white/70 mb-6">
                {gameState.winningFaction === 'TOWN' && 'A Vila Venceu!'}
                {gameState.winningFaction === 'WEREWOLF' && 'Os Lobisomens Venceram!'}
                {gameState.winningFaction === 'NEUTRAL' && 'Neutros Venceram!'}
                {!gameState.winningFaction && 'Jogo Encerrado'}
              </p>

              {gameState.winningPlayers && gameState.winningPlayers.length > 0 && (
                <div className="mb-6">
                  <h3 className="text-lg font-semibold text-white mb-2">Vencedores:</h3>
                  <div className="space-y-1">
                    {gameState.winningPlayers.map((playerId) => {
                      const player = gameState.players.find(p => p.id === playerId);
                      return player ? (
                        <div key={playerId} className="text-amber-400">
                          {player.username} ({player.role})
                        </div>
                      ) : null;
                    })}
                  </div>
                </div>
              )}

              {/* All Players Results */}
              <div className="mb-6 max-h-48 overflow-y-auto">
                <h3 className="text-lg font-semibold text-white mb-2">Todos os Jogadores:</h3>
                <div className="space-y-1 text-sm">
                  {gameState.players.filter(p => !p.isSpectator).map((player) => (
                    <div key={player.id} className="flex justify-between text-white/70">
                      <span>{player.username}</span>
                      <span className={`
                        ${player.faction === 'TOWN' ? 'text-green-400' :
                          player.faction === 'WEREWOLF' ? 'text-red-400' :
                            'text-purple-400'}
                      `}>
                        {player.role}
                      </span>
                    </div>
                  ))}
                </div>
              </div>

              <button
                onClick={() => window.location.href = '/lobby'}
                className="bg-gradient-to-r from-blue-500 to-blue-700 hover:from-blue-600 hover:to-blue-800 text-white font-bold py-3 px-6 rounded-lg transition-all duration-200"
              >
                Voltar ao Lobby
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/room/RoomChat.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Send, MessageCircle, AlertCircle } from 'lucide-react';
import { ChatMessage } from '@/types';

interface RoomChatProps {
  messages: ChatMessage[];
  onSendMessage: (message: string) => void;
  currentUserId: string;
  isConnected: boolean;
}

export default function RoomChat({
  messages,
  onSendMessage,
  currentUserId,
  isConnected
}: RoomChatProps) {
  const [inputMessage, setInputMessage] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Auto-scroll para a √∫ltima mensagem
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSendMessage = (e: React.FormEvent) => {
    e.preventDefault();

    if (!inputMessage.trim()) return;
    if (!isConnected) {
      console.warn('Cannot send message - not connected');
      return;
    }

    onSendMessage(inputMessage.trim());
    setInputMessage('');
    setIsTyping(false);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputMessage(e.target.value);
    setIsTyping(e.target.value.length > 0);
  };

  const getMessageTypeStyle = (channel: string) => {
    switch (channel) {
      case 'system':
        return 'bg-yellow-600/20 border-yellow-600/30 text-yellow-200';
      case 'werewolf':
        return 'bg-red-600/20 border-red-600/30 text-red-200';
      case 'dead':
        return 'bg-gray-600/20 border-gray-600/30 text-gray-300';
      case 'spectator':
        return 'bg-purple-600/20 border-purple-600/30 text-purple-200';
      default:
        return 'bg-slate-700/50 border-slate-600/50 text-white';
    }
  };

  const formatTime = (timestamp: string) => {
    return new Date(timestamp).toLocaleTimeString('pt-BR', {
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  return (
    <div className="bg-slate-800/50 rounded-lg border border-slate-700 flex flex-col">
      {/* Header */}
      <div className="p-4 border-b border-slate-700">
        <h3 className="text-lg font-semibold flex items-center gap-2">
          <MessageCircle className="w-5 h-5" />
          Chat da Sala
          {!isConnected && (
            <AlertCircle className="w-4 h-4 text-red-400" />
          )}
        </h3>
        {!isConnected && (
          <p className="text-xs text-red-400 mt-1">
            Desconectado - N√£o √© poss√≠vel enviar mensagens
          </p>
        )}
      </div>

      {/* ‚úÖ CORRIGIDO: √Årea de mensagens com altura flex√≠vel e melhor layout */}
      <div className="flex-1 flex flex-col min-h-0">
        {/* Messages Container */}
        <div className="flex-1 overflow-y-auto p-4 space-y-3 min-h-[300px] max-h-[400px]">
          <AnimatePresence>
            {messages.map((message) => (
              <motion.div
                key={message.id}
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                className={`p-3 rounded-lg border ${getMessageTypeStyle(message.channel)}`}
              >
                {message.channel === 'system' ? (
                  <div className="text-center">
                    <span className="text-sm font-medium">
                      {message.message}
                    </span>
                    <div className="text-xs opacity-60 mt-1">
                      {formatTime(message.timestamp)}
                    </div>
                  </div>
                ) : (
                  <div>
                    <div className="flex items-center justify-between mb-1">
                      <span className="font-medium text-sm">
                        {message.username}
                        {message.userId === currentUserId && (
                          <span className="text-xs opacity-60 ml-1">(Voc√™)</span>
                        )}
                      </span>
                      <span className="text-xs opacity-60">
                        {formatTime(message.timestamp)}
                      </span>
                    </div>
                    <p className="text-sm leading-relaxed">
                      {message.message}
                    </p>
                  </div>
                )}
              </motion.div>
            ))}
          </AnimatePresence>

          {messages.length === 0 && (
            <div className="text-center text-slate-400 py-8">
              <MessageCircle className="w-8 h-8 mx-auto mb-2 opacity-50" />
              <p className="text-sm">Nenhuma mensagem ainda...</p>
              <p className="text-xs opacity-60">Seja o primeiro a conversar!</p>
            </div>
          )}

          <div ref={messagesEndRef} />
        </div>

        {/* ‚úÖ CORRIGIDO: Input fixo na parte inferior */}
        <div className="p-4 border-t border-slate-700">
          <form onSubmit={handleSendMessage} className="flex gap-2">
            <input
              ref={inputRef}
              type="text"
              value={inputMessage}
              onChange={handleInputChange}
              placeholder={isConnected ? "Digite sua mensagem..." : "Conectando..."}
              disabled={!isConnected}
              className={`
                flex-1 px-3 py-2 rounded-lg border text-sm
                ${isConnected
                  ? 'bg-slate-700 border-slate-600 text-white placeholder-slate-400 focus:border-blue-500 focus:ring-1 focus:ring-blue-500'
                  : 'bg-slate-800 border-slate-700 text-slate-500 placeholder-slate-600 cursor-not-allowed'
                }
                transition-colors outline-none
              `}
              maxLength={500}
            />
            <motion.button
              type="submit"
              disabled={!isConnected || !inputMessage.trim()}
              whileHover={isConnected && inputMessage.trim() ? { scale: 1.05 } : {}}
              whileTap={isConnected && inputMessage.trim() ? { scale: 0.95 } : {}}
              className={`
                px-4 py-2 rounded-lg transition-all duration-200 flex items-center gap-2
                ${isConnected && inputMessage.trim()
                  ? 'bg-blue-600 hover:bg-blue-700 text-white shadow-lg'
                  : 'bg-slate-600 text-slate-400 cursor-not-allowed'
                }
              `}
            >
              <Send className="w-4 h-4" />
              <span className="hidden sm:inline">Enviar</span>
            </motion.button>
          </form>

          {/* Character count */}
          {inputMessage.length > 400 && (
            <div className="mt-2 text-right">
              <span className={`text-xs ${inputMessage.length > 480 ? 'text-red-400' : 'text-yellow-400'}`}>
                {inputMessage.length}/500
              </span>
            </div>
          )}

          {/* Connection status indicator */}
          <div className="mt-2 flex items-center justify-between text-xs text-slate-400">
            <span>
              {isConnected ? (
                <span className="flex items-center gap-1">
                  <span className="w-2 h-2 bg-green-500 rounded-full"></span>
                  Conectado
                </span>
              ) : (
                <span className="flex items-center gap-1">
                  <span className="w-2 h-2 bg-red-500 rounded-full"></span>
                  Desconectado
                </span>
              )}
            </span>

            {messages.length > 0 && (
              <span>{messages.length} mensagem{messages.length !== 1 ? 's' : ''}</span>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/context/ThemeContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import audioService from '@/services/audioService';

// =============================================================================
// TYPES
// =============================================================================
interface PhaseColors {
  background: string;
  text: string;
  accent: string;
  border: string;
}

interface AudioConfig {
  musicVolume: number;
  sfxVolume: number;
  enabled: boolean;
}

interface ThemeContextType {
  theme: 'werewolf' | 'medieval' | 'modern';
  setTheme: (theme: 'werewolf' | 'medieval' | 'modern') => void;
  playSound: (soundId: string) => void;
  playMusic: (musicId: string) => void;
  stopMusic: () => void;
  setMusicVolume: (volume: number) => void;
  setSoundVolume: (volume: number) => void;
  musicVolume: number;
  soundVolume: number;
  isMusicPlaying: boolean;
  isAudioUnblocked: boolean;
  getPhaseColors: () => PhaseColors;
  getThemeClass: () => string;
  audioConfig: AudioConfig;
  updateAudioConfig: (config: Partial<AudioConfig>) => void;
}

// =============================================================================
// THEME CONTEXT
// =============================================================================
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// =============================================================================
// THEME PROVIDER
// =============================================================================
export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<'werewolf' | 'medieval' | 'modern'>('werewolf');
  const [audioConfig, setAudioConfig] = useState<AudioConfig>({
    musicVolume: 0.5,
    sfxVolume: 0.7,
    enabled: true,
  });

  // =============================================================================
  // AUDIO FUNCTIONS (delegando para o audioService)
  // =============================================================================
  const playSound = (soundId: string) => {
    if (audioConfig.enabled) {
      audioService.playSound(soundId);
    }
  };

  const playMusic = (musicId: string) => {
    if (audioConfig.enabled) {
      audioService.playMusic(musicId);
    }
  };

  const stopMusic = () => {
    audioService.stopMusic();
  };

  const setMusicVolume = (volume: number) => {
    const newConfig = { ...audioConfig, musicVolume: volume };
    setAudioConfig(newConfig);
    audioService.setMusicVolume(volume);
  };

  const setSoundVolume = (volume: number) => {
    const newConfig = { ...audioConfig, sfxVolume: volume };
    setAudioConfig(newConfig);
    audioService.setSoundVolume(volume);
  };

  const updateAudioConfig = (config: Partial<AudioConfig>) => {
    const newConfig = { ...audioConfig, ...config };
    setAudioConfig(newConfig);

    // Atualizar volumes no audioService
    if (config.musicVolume !== undefined) {
      audioService.setMusicVolume(config.musicVolume);
    }
    if (config.sfxVolume !== undefined) {
      audioService.setSoundVolume(config.sfxVolume);
    }

    // Se desabilitou o √°udio, para a m√∫sica
    if (config.enabled === false) {
      audioService.stopMusic();
    }
  };

  // =============================================================================
  // THEME UTILITIES (que o Layout.tsx precisa)
  // =============================================================================
  const getPhaseColors = (): PhaseColors => {
    // Por enquanto retorna cores padr√£o do tema medieval
    // Quando implementar fases do jogo, adicionar l√≥gica aqui
    return {
      background: 'from-medieval-900 to-medieval-800',
      text: 'text-white',
      accent: 'text-salem-300',
      border: 'border-medieval-600',
    };
  };

  const getThemeClass = (): string => {
    return `theme-${theme}`;
  };

  // =============================================================================
  // THEME EFFECT
  // =============================================================================
  useEffect(() => {
    // Aplicar classes do tema
    document.documentElement.setAttribute('data-theme', theme);

    // Aplicar classes espec√≠ficas
    if (theme === 'werewolf') {
      document.documentElement.classList.add('werewolf-theme');
      document.documentElement.classList.remove('medieval-theme', 'modern-theme');
    } else if (theme === 'medieval') {
      document.documentElement.classList.add('medieval-theme');
      document.documentElement.classList.remove('werewolf-theme', 'modern-theme');
    } else {
      document.documentElement.classList.add('modern-theme');
      document.documentElement.classList.remove('werewolf-theme', 'medieval-theme');
    }
  }, [theme]);

  // =============================================================================
  // CONTEXT VALUE
  // =============================================================================
  const value: ThemeContextType = {
    theme,
    setTheme,
    playSound,
    playMusic,
    stopMusic,
    setMusicVolume,
    setSoundVolume,
    musicVolume: audioConfig.musicVolume,
    soundVolume: audioConfig.sfxVolume,
    isMusicPlaying: audioService.isMusicPlaying,
    isAudioUnblocked: audioService.isAudioUnlocked, // ‚úÖ CORRIGIDO: nome correto da propriedade
    getPhaseColors,
    getThemeClass,
    audioConfig,
    updateAudioConfig,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// =============================================================================
// USE THEME HOOK
// =============================================================================
export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}
</file>

<file path="frontend/src/pages/_app.tsx">
// üê∫ LOBISOMEM ONLINE - Next.js App Component
// Global app configuration and providers

import type { AppProps } from 'next/app';
import Head from 'next/head';
import { Inter, Cinzel, Pirata_One } from 'next/font/google';
import { Toaster } from 'react-hot-toast';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/router';
import { useEffect } from 'react';

// Context Providers
import { AuthProvider } from '@/context/AuthContext';
import { SocketProvider } from '@/context/SocketContext';
import { ThemeProvider } from '@/context/ThemeContext';

// Components
import ErrorBoundary from '@/components/common/ErrorBoundary';
import { PageLoading } from '@/components/common/LoadingSpinner';

// Styles
import '@/styles/globals.css';

// =============================================================================
// FONT CONFIGURATION
// =============================================================================
const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
  display: 'swap',
});

const cinzel = Cinzel({
  subsets: ['latin'],
  variable: '--font-cinzel',
  display: 'swap',
});

const pirataOne = Pirata_One({
  weight: '400',
  subsets: ['latin'],
  variable: '--font-pirata',
  display: 'swap',
});

// =============================================================================
// PAGE TRANSITION VARIANTS
// =============================================================================
const pageVariants = {
  initial: {
    opacity: 0,
    y: 20,
  },
  in: {
    opacity: 1,
    y: 0,
  },
  out: {
    opacity: 0,
    y: -20,
  },
};

const pageTransition = {
  type: 'tween',
  ease: 'anticipate',
  duration: 0.3,
};

// =============================================================================
// MAIN APP COMPONENT
// =============================================================================
export default function App({ Component, pageProps, router }: AppProps) {
  const { pathname } = useRouter();

  // ‚úÖ ADICIONADO: Suprimir warnings de hydration em desenvolvimento
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      const originalError = console.error;
      console.error = (...args) => {
        if (args[0]?.includes?.('Hydration')) return;
        if (args[0]?.includes?.('Text content does not match')) return;
        originalError(...args);
      };
    }
  }, []);

  return (
    <>
      {/* HEAD com viewport no lugar correto */}
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no, viewport-fit=cover" />
      </Head>

      <ErrorBoundary>
        {/* Font variables */}
        <div className={`${inter.variable} ${cinzel.variable} ${pirataOne.variable}`}>

          {/* ‚úÖ CORRIGIDO: Ordem correta de Context Providers */}
          <ThemeProvider>
            <AuthProvider>
              <SocketProvider> {/* SocketProvider DEVE vir AP√ìS AuthProvider */}

                {/* Page Transitions */}
                <AnimatePresence mode="wait" initial={false}>
                  <motion.div
                    key={router.route}
                    initial="initial"
                    animate="in"
                    exit="out"
                    variants={pageVariants}
                    transition={pageTransition}
                  >
                    <Component {...pageProps} />
                  </motion.div>
                </AnimatePresence>

                {/* Global Toast Notifications */}
                <Toaster
                  position="top-right"
                  toastOptions={{
                    duration: 4000,
                    style: {
                      background: '#2D1B1E',
                      color: '#F4E4BC',
                      border: '1px solid #8B925A',
                      fontFamily: 'var(--font-inter)',
                    },
                    success: {
                      iconTheme: {
                        primary: '#228B22',
                        secondary: '#F4E4BC',
                      },
                    },
                    error: {
                      iconTheme: {
                        primary: '#8B0000',
                        secondary: '#F4E4BC',
                      },
                    },
                  }}
                />

                {/* Loading Overlay for Page Transitions */}
                <AnimatePresence>
                  {router.isFallback && (
                    <motion.div
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      exit={{ opacity: 0 }}
                      className="fixed inset-0 z-50"
                    >
                      <PageLoading />
                    </motion.div>
                  )}
                </AnimatePresence>

              </SocketProvider>
            </AuthProvider>
          </ThemeProvider>
        </div>
      </ErrorBoundary>
    </>
  );
}

// =============================================================================
// GLOBAL ERROR HANDLER
// =============================================================================
if (typeof window !== 'undefined') {
  // Handle global errors
  window.addEventListener('error', (event) => {
    // ‚úÖ MELHORADO: Filtrar erros de hydration
    if (event.error?.message?.includes?.('Hydration')) return;
    if (event.error?.message?.includes?.('Text content does not match')) return;

    console.error('Global error:', event.error);
    // You could send this to an error reporting service
  });

  // Handle unhandled promise rejections
  window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    // You could send this to an error reporting service
  });

  // Performance monitoring
  if (process.env.NODE_ENV === 'development') {
    // Log performance metrics in development
    window.addEventListener('load', () => {
      setTimeout(() => {
        const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
        console.log('üöÄ Page Load Performance:', {
          'DNS Lookup': navigation.domainLookupEnd - navigation.domainLookupStart,
          'TCP Connection': navigation.connectEnd - navigation.connectStart,
          'Request': navigation.responseStart - navigation.requestStart,
          'Response': navigation.responseEnd - navigation.responseStart,
          'DOM Processing': navigation.domComplete - (navigation.domContentLoadedEventEnd || 0),
          'Total Load Time': navigation.loadEventEnd - (navigation.fetchStart || 0),
        });
      }, 0);
    });
  }
}
</file>

<file path="frontend/src/pages/auth/register.tsx">
// üê∫ WEREWOLF - Register Page
// Werewolf inspired registration interface

import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { Eye, EyeOff, Mail, Lock, User, UserPlus, Check, X } from 'lucide-react';

import { useAuth } from '@/context/AuthContext';
import { useForm, useDebounce } from '@/hooks';
import { RegisterRequest } from '@/types';
import { authService } from '@/services/auth';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// REGISTER PAGE COMPONENT
// =============================================================================
export default function RegisterPage() {
  const router = useRouter();
  const { register, isAuthenticated, isLoading } = useAuth();
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [usernameAvailable, setUsernameAvailable] = useState<boolean | null>(null);
  const [emailAvailable, setEmailAvailable] = useState<boolean | null>(null);
  const [checkingUsername, setCheckingUsername] = useState(false);
  const [checkingEmail, setCheckingEmail] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Form management
  const {
    values,
    errors,
    touched,
    handleChange,
    handleSubmit,
    setError,
    setTouched,
  } = useForm<RegisterRequest>(
    {
      email: '',
      username: '',
      password: '',
      confirmPassword: '',
    },
    async (formData) => {
      if (!validateForm(formData)) return;

      setIsSubmitting(true);
      await register(formData);
      setIsSubmitting(false);
    }
  );

  // Debounced values for availability checking
  const debouncedUsername = useDebounce(values.username, 500);
  const debouncedEmail = useDebounce(values.email, 500);

  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated && !isLoading) {
      router.push('/lobby');
    }
  }, [isAuthenticated, isLoading, router]);

  // Check username availability
  useEffect(() => {
    if (debouncedUsername && debouncedUsername.length >= 3) {
      checkUsernameAvailability(debouncedUsername);
    } else {
      setUsernameAvailable(null);
    }
  }, [debouncedUsername]);

  // Check email availability
  useEffect(() => {
    if (debouncedEmail && authService.validateEmail(debouncedEmail)) {
      checkEmailAvailability(debouncedEmail);
    } else {
      setEmailAvailable(null);
    }
  }, [debouncedEmail]);

  // Username availability check
  const checkUsernameAvailability = async (username: string) => {
    setCheckingUsername(true);
    try {
      const response = await authService.checkUsernameAvailability(username);
      setUsernameAvailable(response.data?.available || false);
    } catch (error) {
      setUsernameAvailable(null);
    } finally {
      setCheckingUsername(false);
    }
  };

  // Email availability check
  const checkEmailAvailability = async (email: string) => {
    setCheckingEmail(true);
    try {
      const response = await authService.checkEmailAvailability(email);
      setEmailAvailable(response.data?.available || false);
    } catch (error) {
      setEmailAvailable(null);
    } finally {
      setCheckingEmail(false);
    }
  };

  // Form validation
  const validateForm = (data: RegisterRequest): boolean => {
    let isValid = true;

    // Email validation
    if (!data.email) {
      setError('email', 'Email √© obrigat√≥rio');
      isValid = false;
    } else if (!authService.validateEmail(data.email)) {
      setError('email', 'Email inv√°lido');
      isValid = false;
    } else if (emailAvailable === false) {
      setError('email', 'Este email j√° est√° em uso');
      isValid = false;
    }

    // Username validation
    const usernameValidation = authService.validateUsername(data.username);
    if (!usernameValidation.isValid) {
      setError('username', usernameValidation.errors[0] || 'Erro de valida√ß√£o');
      isValid = false;
    } else if (usernameAvailable === false) {
      setError('username', 'Este username j√° est√° em uso');
      isValid = false;
    }

    // Password validation
    const passwordValidation = authService.validatePassword(data.password);
    if (!passwordValidation.isValid) {
      setError('password', passwordValidation.errors[0] || 'Erro de valida√ß√£o');
      isValid = false;
    }

    // Confirm password validation
    if (data.password !== data.confirmPassword) {
      setError('confirmPassword', 'Senhas n√£o coincidem');
      isValid = false;
    }

    return isValid;
  };

  // Get field status icon
  const getFieldStatusIcon = (field: 'username' | 'email') => {
    const isChecking = field === 'username' ? checkingUsername : checkingEmail;
    const isAvailable = field === 'username' ? usernameAvailable : emailAvailable;
    const value = field === 'username' ? values.username : values.email;

    if (!value || (field === 'username' && value.length < 3)) return null;
    if (isChecking) return <LoadingSpinner size="sm" />;
    if (isAvailable === true) return <Check className="w-5 h-5 text-green-400" />;
    if (isAvailable === false) return <X className="w-5 h-5 text-red-400" />;
    return null;
  };

  // Show loading if checking authentication
  if (isLoading) {
    return <LoadingSpinner variant="medieval" size="xl" text="Verificando autentica√ß√£o..." />;
  }

  return (
    <>
      <Head>
        <title>Criar Conta - Werewolf</title>
        <meta name="description" content="Crie sua conta no Werewolf e entre na vila" />
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="card-medieval p-8"
        >
          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: 'spring' }}
              className="text-6xl mb-4"
            >
              üèòÔ∏è
            </motion.div>
            <h1 className="text-2xl font-medieval text-glow mb-2">
              Juntar-se √† Vila
            </h1>
            <p className="text-white/70">
              Crie sua conta para come√ßar a jogar
            </p>
          </div>

          {/* Google Register Button */}
          <Button
            variant="ghost"
            size="lg"
            onClick={() => {
              console.log('Google register clicked');
              // TODO: Implementar registro com Google
            }}
            className="w-full border border-white/20 hover:border-white/40 mb-6"
            disabled={isSubmitting}
          >
            <svg className="w-5 h-5 mr-3" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
              />
              <path
                fill="currentColor"
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
              />
              <path
                fill="currentColor"
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
              />
              <path
                fill="currentColor"
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
              />
            </svg>
            Criar conta com Google
          </Button>

          {/* Divider */}
          <div className="my-6 flex items-center">
            <div className="flex-1 border-t border-medieval-600"></div>
            <span className="px-4 text-white/50 text-sm">ou</span>
            <div className="flex-1 border-t border-medieval-600"></div>
          </div>

          {/* Register Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Email Field */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Email
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Mail className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="email"
                  type="email"
                  value={values.email}
                  onChange={handleChange('email')}
                  onBlur={() => setTouched('email')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.email && touched.email
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seu@email.com"
                  disabled={isSubmitting}
                />
                <div className="absolute inset-y-0 right-0 pr-3 flex items-center">
                  {getFieldStatusIcon('email')}
                </div>
              </div>
              {errors.email && touched.email && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.email}
                </motion.p>
              )}
            </div>

            {/* Username Field */}
            <div>
              <label
                htmlFor="username"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Nome de Usu√°rio
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <User className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="username"
                  type="text"
                  value={values.username}
                  onChange={handleChange('username')}
                  onBlur={() => setTouched('username')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.username && touched.username
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seunome123"
                  disabled={isSubmitting}
                />
                <div className="absolute inset-y-0 right-0 pr-3 flex items-center">
                  {getFieldStatusIcon('username')}
                </div>
              </div>
              <p className="mt-1 text-xs text-white/50">
                3-20 caracteres, apenas letras, n√∫meros, _ e -
              </p>
              {errors.username && touched.username && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.username}
                </motion.p>
              )}
            </div>

            {/* Password Field */}
            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Senha
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Lock className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  value={values.password}
                  onChange={handleChange('password')}
                  onBlur={() => setTouched('password')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.password && touched.password
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  disabled={isSubmitting}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-white/40 hover:text-white/70 transition-colors"
                  disabled={isSubmitting}
                >
                  {showPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>

              {/* Password Requirements */}
              <div className="mt-2 space-y-1">
                <PasswordRequirement
                  met={values.password.length >= 6}
                  text="Pelo menos 6 caracteres"
                />
                <PasswordRequirement
                  met={/(?=.*[a-z])/.test(values.password)}
                  text="Uma letra min√∫scula"
                />
                <PasswordRequirement
                  met={/(?=.*[A-Z])/.test(values.password)}
                  text="Uma letra mai√∫scula"
                />
                <PasswordRequirement
                  met={/(?=.*\d)/.test(values.password)}
                  text="Um n√∫mero"
                />
              </div>

              {errors.password && touched.password && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.password}
                </motion.p>
              )}
            </div>

            {/* Confirm Password Field */}
            <div>
              <label
                htmlFor="confirmPassword"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Confirmar Senha
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Lock className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="confirmPassword"
                  type={showConfirmPassword ? 'text' : 'password'}
                  value={values.confirmPassword}
                  onChange={handleChange('confirmPassword')}
                  onBlur={() => setTouched('confirmPassword')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.confirmPassword && touched.confirmPassword
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  disabled={isSubmitting}
                />
                <button
                  type="button"
                  onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-white/40 hover:text-white/70 transition-colors"
                  disabled={isSubmitting}
                >
                  {showConfirmPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>
              {errors.confirmPassword && touched.confirmPassword && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.confirmPassword}
                </motion.p>
              )}
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="medieval"
              size="lg"
              disabled={isSubmitting || usernameAvailable === false || emailAvailable === false}
              loading={isSubmitting}
              className="w-full"
            >
              <UserPlus className="w-5 h-5 mr-2" />
              {isSubmitting ? 'Criando conta...' : 'Criar Conta'}
            </Button>
          </form>

          {/* Login Link */}
          <div className="text-center mt-8">
            <p className="text-white/70 mb-4">
              J√° tem uma conta?
            </p>
            <Button
              variant="ghost"
              onClick={() => router.push('/auth/login')}
              className="w-full"
              disabled={isSubmitting}
            >
              Fazer Login
            </Button>
          </div>
        </motion.div>
      </Layout>
    </>
  );
}

// =============================================================================
// PASSWORD REQUIREMENT COMPONENT
// =============================================================================
interface PasswordRequirementProps {
  met: boolean;
  text: string;
}

function PasswordRequirement({ met, text }: PasswordRequirementProps) {
  return (
    <motion.div
      initial={{ opacity: 0, x: -10 }}
      animate={{ opacity: 1, x: 0 }}
      className="flex items-center text-xs"
    >
      {met ? (
        <Check className="w-3 h-3 text-green-400 mr-2" />
      ) : (
        <X className="w-3 h-3 text-red-400 mr-2" />
      )}
      <span className={met ? 'text-green-400' : 'text-red-400'}>
        {text}
      </span>
    </motion.div>
  );
}
</file>

<file path="frontend/src/pages/index.tsx">
// üê∫ WEREWOLF - Landing Page
// Home page with werewolf game inspired design

import { useState, useEffect } from 'react';
import { motion, useScroll, useTransform } from 'framer-motion';
import { useRouter } from 'next/router';
import Head from 'next/head';
import {
  Play,
  Users,
  Trophy,
  Shield,
  Zap,
  Moon,
  Sun,
  ChevronDown,
  Github
} from 'lucide-react';

import { useAuth } from '@/context/AuthContext';
import { useTheme } from '@/context/ThemeContext';
import Button from '@/components/common/Button';
import Layout from '@/components/common/Layout';

// ‚úÖ CORRE√á√ÉO: Componente de estat√≠sticas √† prova de hidrata√ß√£o
interface SafeStatsDisplayProps {
  value: number;
  label: string;
  color?: string;
}

function SafeStatsDisplay({ value, label, color = "text-salem-400" }: SafeStatsDisplayProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return (
    <div className="text-center">
      <div className={`text-2xl font-bold ${color}`}>
        {mounted ? value.toLocaleString('pt-BR') : value}
      </div>
      <div className="text-sm text-white/60">{label}</div>
    </div>
  );
}

// =============================================================================
// LANDING PAGE COMPONENT
// =============================================================================
export default function LandingPage() {
  const router = useRouter();
  const { isAuthenticated, user } = useAuth();
  const { playSound } = useTheme();
  const { scrollY } = useScroll();

  // Parallax effects
  const backgroundY = useTransform(scrollY, [0, 500], [0, 150]);
  const textY = useTransform(scrollY, [0, 500], [0, 100]);

  const [stats] = useState({
    totalPlayers: 15847,
    gamesPlayed: 89234,
    onlineNow: 342,
  });

  // Handle main action
  const handleMainAction = () => {
    playSound('button_click');

    if (isAuthenticated) {
      router.push('/lobby');
    } else {
      router.push('/auth/login');
    }
  };

  return (
    <>
      <Head>
        <title>Werewolf O Jogo de Dedu√ß√£o Social</title>
        <meta name="description" content="Entre na vila e descubra quem s√£o os lobisomens neste emocionante jogo de dedu√ß√£o social." />
      </Head>

      <Layout variant="landing" showHeader={false} showSidebar={false} showFooter={false}>
        {/* Hero Section */}
        <section className="relative min-h-screen flex items-center justify-center overflow-hidden">
          {/* Background */}
          <motion.div
            className="absolute inset-0 bg-gradient-to-br from-medieval-900 via-medieval-800 to-night-dark"
            style={{ y: backgroundY }}
          />

          {/* Background pattern */}
          <div className="absolute inset-0 opacity-10">
            <div className="absolute inset-0 bg-medieval-paper bg-cover bg-center" />
          </div>

          {/* Floating wolves */}
          <div className="absolute inset-0 overflow-hidden pointer-events-none">
            {[...Array(5)].map((_, i) => (
              <motion.div
                key={i}
                className="absolute text-6xl opacity-20"
                style={{
                  top: `${20 + i * 15}%`,
                  left: `${10 + i * 20}%`,
                }}
                animate={{
                  y: [0, -20, 0],
                  x: [0, 10, 0],
                  rotate: [0, 5, 0],
                }}
                transition={{
                  duration: 4 + i,
                  repeat: Infinity,
                  ease: 'easeInOut',
                }}
              >
                üê∫
              </motion.div>
            ))}
          </div>

          {/* Hero content */}
          <motion.div
            className="relative z-10 text-center px-4 max-w-4xl"
            style={{ y: textY }}
          >
            {/* Logo */}
            <motion.div
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              transition={{ duration: 1, type: 'spring', bounce: 0.5 }}
              className="text-8xl md:text-9xl mb-8"
            >
              üê∫
            </motion.div>

            {/* Title */}
            <motion.h1
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.5, duration: 0.8 }}
              className="text-5xl md:text-7xl font-medieval text-glow mb-6"
            >
              Werewolf
            </motion.h1>

            {/* Subtitle */}
            <motion.p
              initial={{ opacity: 0, y: 30 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.8, duration: 0.8 }}
              className="text-xl md:text-2xl text-white/80 mb-8 max-w-2xl mx-auto leading-relaxed"
            >
              O cl√°ssico jogo de dedu√ß√£o social que vai testar sua capacidade de
              blefe, investiga√ß√£o e sobreviv√™ncia.
            </motion.p>

            {/* ‚úÖ CORRE√á√ÉO: Stats com componente seguro para hidrata√ß√£o */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 1.1, duration: 0.8 }}
              className="flex justify-center gap-8 mb-12"
            >
              <SafeStatsDisplay
                value={stats.totalPlayers}
                label="Jogadores"
              />
              <SafeStatsDisplay
                value={stats.gamesPlayed}
                label="Partidas"
              />
              <SafeStatsDisplay
                value={stats.onlineNow}
                label="Online Agora"
                color="text-green-400"
              />
            </motion.div>

            {/* CTA Buttons */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 1.4, duration: 0.8 }}
              className="flex flex-col sm:flex-row gap-4 justify-center items-center"
            >
              <Button
                variant="medieval"
                size="xl"
                onClick={handleMainAction}
                className="text-xl px-12 py-4"
              >
                <Play className="w-6 h-6" />
                <span>{isAuthenticated ? 'Entrar no Lobby' : 'Come√ßar a Jogar'}</span>
              </Button>

              {!isAuthenticated && (
                <Button
                  variant="ghost"
                  size="xl"
                  onClick={() => router.push('/auth/register')}
                  className="text-xl px-8 py-4"
                >
                  Criar Conta
                </Button>
              )}
            </motion.div>

            {/* User welcome */}
            {isAuthenticated && user && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: 1.7 }}
                className="mt-8 p-4 bg-salem-800/30 rounded-lg border border-salem-600/50"
              >
                <p className="text-salem-300">
                  Bem-vindo de volta, <span className="font-bold">{user.username}</span>!
                  Voc√™ est√° no n√≠vel {user.level} com {user.totalGames} partidas jogadas.
                </p>
              </motion.div>
            )}
          </motion.div>

          {/* Scroll indicator */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 2 }}
            className="absolute bottom-8 left-1/2 transform -translate-x-1/2"
          >
            <motion.div
              animate={{ y: [0, 10, 0] }}
              transition={{ duration: 2, repeat: Infinity }}
              className="text-white/60 cursor-pointer"
              onClick={() => window.scrollTo({ top: window.innerHeight, behavior: 'smooth' })}
            >
              <ChevronDown className="w-8 h-8" />
            </motion.div>
          </motion.div>
        </section>

        {/* Features Section */}
        <section className="py-20 px-4 bg-medieval-800/50">
          <div className="max-w-6xl mx-auto">
            <motion.h2
              initial={{ opacity: 0, y: 50 }}
              whileInView={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8 }}
              className="text-4xl font-medieval text-center text-glow mb-16"
            >
              Como Jogar
            </motion.h2>

            <div className="grid md:grid-cols-3 gap-8">
              {/* Day Phase */}
              <FeatureCard
                icon={<Sun className="w-12 h-12" />}
                title="Fase do Dia"
                description="Durante o dia, todos os jogadores discutem e votam para eliminar algu√©m suspeito de ser um lobisomem."
                delay={0.2}
              />

              {/* Night Phase */}
              <FeatureCard
                icon={<Moon className="w-12 h-12" />}
                title="Fase da Noite"
                description="√Ä noite, lobisomens escolhem suas v√≠timas enquanto outros pap√©is especiais agem em segredo."
                delay={0.4}
              />

              {/* Victory */}
              <FeatureCard
                icon={<Trophy className="w-12 h-12" />}
                title="Condi√ß√µes de Vit√≥ria"
                description="A vila vence eliminando todos os lobisomens. Os lobisomens vencem igualando o n√∫mero de alde√µes."
                delay={0.6}
              />
            </div>
          </div>
        </section>

        {/* Roles Section */}
        <section className="py-20 px-4">
          <div className="max-w-6xl mx-auto">
            <motion.h2
              initial={{ opacity: 0, y: 50 }}
              whileInView={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8 }}
              className="text-4xl font-medieval text-center text-glow mb-16"
            >
              Pap√©is do Jogo
            </motion.h2>

            <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-6">
              <RoleCard
                emoji="üë§"
                name="Alde√£o"
                faction="Vila"
                description="Vota durante o dia para eliminar suspeitos"
                color="text-green-400"
              />

              <RoleCard
                emoji="üîç"
                name="Investigador"
                faction="Vila"
                description="Investiga uma pessoa por noite"
                color="text-blue-400"
              />

              <RoleCard
                emoji="‚öïÔ∏è"
                name="M√©dico"
                faction="Vila"
                description="Protege algu√©m da morte durante a noite"
                color="text-green-400"
              />

              <RoleCard
                emoji="üê∫"
                name="Lobisomem"
                faction="Lobisomens"
                description="Mata alde√µes durante a noite"
                color="text-red-400"
              />
            </div>

            <motion.div
              initial={{ opacity: 0 }}
              whileInView={{ opacity: 1 }}
              transition={{ delay: 0.5 }}
              className="text-center mt-12"
            >
              <Button
                variant="ghost"
                onClick={() => router.push('/roles')}
              >
                Ver Todos os Pap√©is
              </Button>
            </motion.div>
          </div>
        </section>

        {/* Footer */}
        <footer className="py-12 px-4 bg-medieval-900 border-t border-medieval-600">
          <div className="max-w-6xl mx-auto">
            <div className="flex flex-col md:flex-row justify-between items-center">
              <div className="flex items-center space-x-3 mb-4 md:mb-0">
                <div className="text-3xl">üê∫</div>
                <div>
                  <h3 className="font-medieval text-xl">Werewolf</h3>
                  <p className="text-white/60 text-sm">O Jogo de Dedu√ß√£o Social</p>
                </div>
              </div>

              <div className="flex space-x-4">
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    playSound('button_click');
                    window.open('https://github.com/alielsonfp/Werewolf', '_blank');
                  }}
                  className="hover:text-salem-400 transition-colors"
                >
                  <Github className="w-5 h-5" />
                </Button>
              </div>
            </div> {/* ‚úÖ ESTA DIV ESTAVA FALTANDO! */}

            <div className="mt-8 pt-8 border-t border-medieval-600 text-center text-white/60 text-sm">
              ¬© 2025 Werewolf. Todos os direitos reservados.
            </div>
          </div>
        </footer>
      </Layout>
    </>
  );
}

// =============================================================================
// FEATURE CARD COMPONENT
// =============================================================================
interface FeatureCardProps {
  icon: React.ReactNode;
  title: string;
  description: string;
  delay?: number;
}

function FeatureCard({ icon, title, description, delay = 0 }: FeatureCardProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 50 }}
      whileInView={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.8, delay }}
      className="text-center p-6 bg-medieval-700/30 rounded-lg border border-medieval-600/50 hover:border-salem-500/50 transition-colors"
    >
      <div className="text-salem-400 mb-4 flex justify-center">
        {icon}
      </div>
      <h3 className="text-xl font-bold mb-3">{title}</h3>
      <p className="text-white/70 leading-relaxed">{description}</p>
    </motion.div>
  );
}

// =============================================================================
// ROLE CARD COMPONENT
// =============================================================================
interface RoleCardProps {
  emoji: string;
  name: string;
  faction: string;
  description: string;
  color: string;
}

function RoleCard({ emoji, name, faction, description, color }: RoleCardProps) {
  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      whileInView={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.5 }}
      whileHover={{ scale: 1.05 }}
      className="p-4 bg-medieval-800/50 rounded-lg border border-medieval-600/50 hover:border-salem-500/50 transition-all cursor-pointer"
    >
      <div className="text-3xl mb-2">{emoji}</div>
      <h4 className="font-bold mb-1">{name}</h4>
      <div className={`text-sm mb-2 ${color}`}>{faction}</div>
      <p className="text-white/70 text-sm">{description}</p>
    </motion.div>
  );
}
</file>

<file path="frontend/src/pages/room/[id].tsx">
import { useRouter } from 'next/router';
import Head from 'next/head';
import { useEffect, useState, useMemo } from 'react';
import { withAuth } from '@/context/AuthContext';
import { useSocket } from '@/context/SocketContext';
import { useAuth } from '@/context/AuthContext';
import WaitingRoom from '@/components/room/WaitingRoom';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { toast } from 'react-hot-toast';
import { Player, Room, ChatMessage } from '@/types';

function RoomPage() {
  const router = useRouter();
  const { id: roomId } = router.query;
  const { connect, disconnect, isConnected, sendMessage } = useSocket();
  const { user, getToken, isAuthenticated } = useAuth();

  // ‚úÖ TODOS OS ESTADOS AGORA VIVEM AQUI
  const [hasJoinedRoom, setHasJoinedRoom] = useState(false);
  const [room, setRoom] = useState<Room | null>(null);
  const [players, setPlayers] = useState<Player[]>([]);
  const [spectators, setSpectators] = useState<Player[]>([]);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [loading, setLoading] = useState(true);
  const [showLeaveModal, setShowLeaveModal] = useState(false);

  // ‚úÖ DADOS DERIVADOS
  const currentUserId = user?.id || '';
  const isHost = useMemo(() => room?.hostId === currentUserId, [room, currentUserId]);
  const currentPlayer = useMemo(() => players.find(p => p.userId === currentUserId), [players, currentUserId]);
  const isReady = currentPlayer?.isReady || false;

  // ‚úÖ CORRIGIDO: Bug #1 - Filtrar host antes de verificar se todos est√£o prontos
  const canStartGame = players.length >= 3 && players.filter(p => !p.isHost).every(p => p.isReady) && isConnected && isHost;

  // ‚úÖ EFEITO #1: Apenas para conectar e desconectar ao WebSocket.
  // Ele roda UMA VEZ quando as depend√™ncias de inicializa√ß√£o estiverem prontas.
  useEffect(() => {
    if (!router.isReady || !isAuthenticated || !roomId || typeof roomId !== 'string') {
      return; // Aguarda at√© ter tudo o que precisa.
    }
    const token = getToken();
    if (!token) {
      router.push('/auth/login');
      return;
    }

    const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001'}/ws/${roomId}?token=${encodeURIComponent(token)}`;
    connect(wsUrl);

    // A fun√ß√£o de cleanup √© chamada QUANDO O USU√ÅRIO SAI DA P√ÅGINA.
    return () => {
      sendMessage('leave-room', { roomId });
      disconnect();
    };
  }, [router.isReady, isAuthenticated, roomId, connect, disconnect, getToken, router, sendMessage]);

  // ‚úÖ EFEITO #2: Apenas para entrar na sala, uma √∫nica vez por conex√£o.
  // Ele REAGE √† mudan√ßa de `isConnected`.
  useEffect(() => {
    // S√≥ envia a mensagem se estivermos conectados E ainda n√£o tivermos entrado.
    if (isConnected && !hasJoinedRoom) {
      const asSpectator = router.query.spectate === 'true';
      if (sendMessage('join-room', { roomId: roomId as string, asSpectator })) {
        setHasJoinedRoom(true); // Marca que j√° tentamos entrar para n√£o enviar de novo.
      }
    }
  }, [isConnected, roomId, hasJoinedRoom, sendMessage, router.query.spectate]);

  // ‚úÖ EFEITO #3: Apenas para ouvir as mensagens.
  useEffect(() => {
    const handleMessage = (event: CustomEvent) => {
      const { type, data } = event.detail;
      console.log('üì® [RoomPage] Received:', type, data);

      switch (type) {
        case 'room-joined':
          setRoom(data.room);
          setPlayers(Array.isArray(data.players) ? data.players : []);
          setSpectators(Array.isArray(data.spectators) ? data.spectators : []);
          setLoading(false);
          toast.success(`Entrou na sala: ${data.room?.name || roomId}`);
          break;

        case 'player-joined':
          if (data.player) {
            setPlayers(prev => {
              const filtered = prev.filter(p => p.userId !== data.player.userId);
              return [...filtered, data.player];
            });

            const systemMessage: ChatMessage = {
              id: Date.now().toString(),
              userId: 'system',
              username: 'Sistema',
              message: `${data.player.username} entrou na sala`,
              channel: 'system',
              timestamp: new Date().toISOString()
            };
            setMessages(prev => [...prev, systemMessage]);
          }
          break;

        case 'player-left':
          if (data.userId) {
            setPlayers(prev => prev.filter(p => p.userId !== data.userId));
            setSpectators(prev => prev.filter(s => s.userId !== data.userId));

            if (data.username) {
              const systemMessage: ChatMessage = {
                id: Date.now().toString(),
                userId: 'system',
                username: 'Sistema',
                message: `${data.username} saiu da sala`,
                channel: 'system',
                timestamp: new Date().toISOString()
              };
              setMessages(prev => [...prev, systemMessage]);
            }
          }
          break;

        case 'player-ready':
          if (data.userId) {
            setPlayers(prev => prev.map(p =>
              p.userId === data.userId ? { ...p, isReady: data.ready } : p
            ));
          }
          break;

        case 'chat-message':
          if (data) {
            const message = data.message || data;
            setMessages(prev => [...prev, message]);
          }
          break;

        // ‚úÖ CORRIGIDO: Bug #2 - Redirecionamento para tela do jogo
        case 'game-starting':
        case 'game-started':
        case 'game-state': // ‚úÖ ADICIONADO: Ouvir tamb√©m game-state do backend
          // ‚úÖ CORRIGIDO: Identificar gameId correto (backend gera "game-${roomId}")
          const gameId = data?.gameId || `game-${roomId}`;

          console.log('üéÆ [RoomPage] Game starting/started:', {
            type,
            gameId,
            roomId,
            dataReceived: data
          });

          toast.success('üéÆ Jogo iniciando!');

          // ‚úÖ CORRIGIDO: Desconectar WebSocket da sala antes de navegar
          disconnect();

          // ‚úÖ CORRIGIDO: Redirecionar imediatamente (sem setTimeout)
          router.push(`/game/${gameId}`);
          break;

        case 'room-updated':
          if (data.room) setRoom(data.room);
          if (data.players) setPlayers(data.players);
          if (data.spectators) setSpectators(data.spectators);
          break;

        case 'room-deleted':
          toast.error(data.reason || 'A sala foi encerrada pelo host');
          router.push('/lobby');
          break;

        case 'error':
          if (data.message) {
            toast.error(data.message);
          }
          break;
      }
    };

    window.addEventListener('websocket-message', handleMessage as EventListener);
    return () => {
      window.removeEventListener('websocket-message', handleMessage as EventListener);
    };
  }, [roomId, router, disconnect]);

  // ‚úÖ HANDLERS (MOVIDOS DO WAITINGROOM)
  const handleToggleReady = () => {
    sendMessage('player-ready', { ready: !isReady });
  };

  const handleStartGame = () => {
    if (!isHost || !canStartGame) return;
    sendMessage('start-game', {});
    toast.success('Iniciando jogo...');
  };

  const handleKickPlayer = (playerId: string) => {
    if (!isHost) return;
    sendMessage('kick-player', { playerId });
  };

  const handleSendChatMessage = (message: string) => {
    sendMessage('chat-message', { message });
  };

  const handleShareRoom = async () => {
    if (!room) return;
    const shareUrl = `${window.location.origin}/room/${room.id}`;

    try {
      await navigator.clipboard.writeText(shareUrl);
      toast.success('Link da sala copiado!');
    } catch (error) {
      toast.error('Erro ao copiar link');
    }
  };

  const handleLeaveRoom = () => {
    if (isHost) {
      setShowLeaveModal(true);
    } else {
      sendMessage('leave-room', { roomId });
      router.push('/lobby');
    }
  };

  const handleConfirmLeaveAsHost = () => {
    sendMessage('delete-room', { roomId });
    setShowLeaveModal(false);
    toast('Encerrando sala...', { icon: 'üè†' });
  };

  // ‚úÖ RENDERIZA√á√ÉO CONDICIONAL
  if (!router.isReady) {
    return (
      <>
        <Head>
          <title>Carregando... - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <LoadingSpinner variant="medieval" size="xl" text="Carregando sala..." />
        </div>
      </>
    );
  }

  if (!roomId || typeof roomId !== 'string') {
    return (
      <>
        <Head>
          <title>Erro - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <div className="text-center">
            <div className="text-6xl mb-4">‚ùå</div>
            <h1 className="text-2xl font-bold text-white mb-4">Sala Inv√°lida</h1>
            <button
              onClick={() => router.push('/lobby')}
              className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors"
            >
              Voltar ao Lobby
            </button>
          </div>
        </div>
      </>
    );
  }

  if (!isConnected) {
    return (
      <>
        <Head>
          <title>Conectando... - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <div className="text-center">
            <LoadingSpinner variant="medieval" size="xl" text="Conectando ao servidor..." />
            <p className="text-gray-400 mt-4">Estabelecendo conex√£o segura...</p>
          </div>
        </div>
      </>
    );
  }

  if (loading) {
    return (
      <>
        <Head>
          <title>Entrando na sala... - Lobisomem Online</title>
        </Head>
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center">
          <div className="text-center">
            <LoadingSpinner variant="medieval" size="xl" text="Entrando na sala..." />
            <p className="text-gray-400 mt-4">Aguardando confirma√ß√£o do servidor...</p>
          </div>
        </div>
      </>
    );
  }

  // ‚úÖ RENDERIZA O WAITINGROOM PASSANDO TUDO COMO PROPS
  return (
    <>
      <Head>
        <title>{room?.name || 'Sala'} - Lobisomem Online</title>
        <meta name="description" content="Aguardando jogadores para come√ßar a partida" />
      </Head>

      <WaitingRoom
        // IDs e dados b√°sicos
        roomId={roomId as string}
        room={room}
        players={players}
        spectators={spectators}
        messages={messages}

        // Estados do usu√°rio
        currentUserId={currentUserId}
        isHost={isHost}
        isReady={isReady}
        canStartGame={canStartGame}
        isConnected={isConnected}

        // Modal states
        showLeaveModal={showLeaveModal}
        setShowLeaveModal={setShowLeaveModal}

        // Handlers
        onToggleReady={handleToggleReady}
        onStartGame={handleStartGame}
        onKickPlayer={handleKickPlayer}
        onSendChatMessage={handleSendChatMessage}
        onShareRoom={handleShareRoom}
        onLeaveRoom={handleLeaveRoom}
        onConfirmLeaveAsHost={handleConfirmLeaveAsHost}
      />
    </>
  );
}

export default withAuth(RoomPage);
</file>

<file path="backend/src/controllers/authController.ts">
import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import { pool } from '@/config/database';
import {
  generateTokenPair,
  generatePasswordResetToken,
  verifyPasswordResetToken,
} from '@/config/jwt';
import { authLogger } from '@/utils/logger';
import { ERROR_MESSAGES } from '@/utils/constants';
import {
  validateRegisterRequest,
  validateLoginRequest,
  validateEmail,
} from '@/utils/simpleValidators';
import type { ApiResponse } from '@/types';
import { config } from '@/config/environment';

/* -------------------------------------------------------------------------- */
/*                                   REGISTER                                 */
/* -------------------------------------------------------------------------- */
export const register = async (req: Request, res: Response): Promise<void> => {
  try {
    const validation = validateRegisterRequest(req.body);
    if (!validation.success) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: validation.error,
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { email, username, password } = validation.data!;

    const existingUserQuery = `
      SELECT id, email, username FROM users 
      WHERE email = $1 OR username = $2
    `;
    const existingUserResult = await pool.query(existingUserQuery, [
      email.toLowerCase(),
      username.toLowerCase(),
    ]);

    if (existingUserResult.rows.length > 0) {
      const existingUser = existingUserResult.rows[0];
      authLogger.warn('Registration attempt with existing credentials', {
        email,
        username,
        existingField:
          existingUser.email === email.toLowerCase() ? 'email' : 'username',
        ip: req.ip,
      });

      res.status(409).json({
        success: false,
        error: 'USER_ALREADY_EXISTS',
        message:
          existingUser.email === email.toLowerCase()
            ? 'Email j√° est√° em uso'
            : 'Username j√° est√° em uso',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const passwordHash = await bcrypt.hash(password, 12);

    const createUserQuery = `
      INSERT INTO users(email, username, "passwordHash", level, "totalGames",
        "totalWins", "totalLosses", "winRate", "createdAt", "updatedAt")
      VALUES($1, $2, $3, 1, 0, 0, 0, 0.0, NOW(), NOW())
      RETURNING id, email, username, level, "totalGames", "totalWins",
        "totalLosses", "winRate", "createdAt", "updatedAt", "lastLoginAt"
    `;
    const userResult = await pool.query(createUserQuery, [
      email.toLowerCase(),
      username,
      passwordHash,
    ]);
    const user = userResult.rows[0];

    const tokens = generateTokenPair({
      userId: user.id,
      username: user.username,
      email: user.email,
    });

    authLogger.info('User registered successfully', {
      userId: user.id,
      username: user.username,
      email: user.email,
      ip: req.ip,
    });

    res.status(201).json({
      success: true,
      data: {
        user,
        tokens: {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
        },
      },
      message: 'Usu√°rio criado com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Registration error',
      error instanceof Error ? error : new Error('Unknown registration error'),
      {
        email: req.body?.email,
        username: req.body?.username,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                                    LOGIN                                   */
/* -------------------------------------------------------------------------- */
export const login = async (req: Request, res: Response): Promise<void> => {
  try {
    const validation = validateLoginRequest(req.body);
    if (!validation.success) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: validation.error,
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { email, password } = validation.data!;
    let user; // ‚úÖ Vari√°vel declarada no escopo principal

    // ‚úÖ Bloco para determinar o usu√°rio (Magic Login ou Login Normal)
    if (config.IS_DEVELOPMENT && email.endsWith('@dev.test')) {
      // üîß MAGIC LOGIN - Apenas para desenvolvimento
      const username = email.split('@')[0];

      let userResult = await pool.query(
        `SELECT * FROM users WHERE email = $1`,
        [email.toLowerCase()]
      );

      if (userResult.rows.length === 0) {
        // Cria usu√°rio de teste automaticamente
        authLogger.info(`DEV_LOGIN: Creating user on-the-fly: ${username}`);
        const fakePasswordHash = await bcrypt.hash('password123', 12);

        const createUserQuery = `
          INSERT INTO users(email, username, "passwordHash", level, "totalGames",
            "totalWins", "totalLosses", "winRate", "createdAt", "updatedAt")
          VALUES($1, $2, $3, 1, 0, 0, 0, 0.0, NOW(), NOW())
          RETURNING id, email, username, level, "totalGames", "totalWins",
            "totalLosses", "winRate", "createdAt", "updatedAt", "lastLoginAt"
        `;

        const newUserResult = await pool.query(createUserQuery, [
          email.toLowerCase(),
          username,
          fakePasswordHash,
        ]);
        user = newUserResult.rows[0];
      } else {
        user = userResult.rows[0];
      }

      authLogger.warn(`DEV_LOGIN: Bypassing password check for ${email}`);
    } else {
      // üîê LOGIN NORMAL - Valida√ß√£o completa
      const userResult = await pool.query(
        `SELECT * FROM users WHERE email = $1`,
        [email.toLowerCase()]
      );

      if (userResult.rows.length === 0) {
        authLogger.warn('Login attempt with non-existent email', {
          email,
          ip: req.ip,
        });

        res.status(401).json({
          success: false,
          error: 'INVALID_CREDENTIALS',
          message: 'Email ou senha incorretos',
          timestamp: new Date().toISOString(),
        } as ApiResponse);
        return;
      }

      const foundUser = userResult.rows[0];
      const isPasswordValid = await bcrypt.compare(password, foundUser.passwordHash);

      if (!isPasswordValid) {
        authLogger.warn('Login attempt with invalid password', {
          userId: foundUser.id,
          email: foundUser.email,
          ip: req.ip,
        });

        res.status(401).json({
          success: false,
          error: 'INVALID_CREDENTIALS',
          message: 'Email ou senha incorretos',
          timestamp: new Date().toISOString(),
        } as ApiResponse);
        return;
      }

      user = foundUser; // ‚úÖ Atribui o usu√°rio validado
    }

    // ‚úÖ‚úÖ‚úÖ L√ìGICA DE SUCESSO UNIFICADA ‚úÖ‚úÖ‚úÖ
    // Este bloco executa para ambos os casos (Magic Login e Login Normal)

    // Atualiza o √∫ltimo login
    await pool.query(
      `UPDATE users SET "lastLoginAt" = NOW() WHERE id = $1`,
      [user.id]
    );

    // Gera os tokens
    const tokens = generateTokenPair({
      userId: user.id,
      username: user.username,
      email: user.email,
    });

    // Remove o hash da senha da resposta
    const { passwordHash, ...userWithoutPassword } = user;

    authLogger.info('User logged in successfully', {
      userId: user.id,
      username: user.username,
      email: user.email,
      ip: req.ip,
    });

    // Envia a resposta de sucesso
    res.json({
      success: true,
      data: {
        user: userWithoutPassword,
        tokens: {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
        },
      },
      message: config.IS_DEVELOPMENT && email.endsWith('@dev.test')
        ? 'Login de desenvolvedor realizado com sucesso'
        : 'Login realizado com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    authLogger.error(
      'Login error',
      error instanceof Error ? error : new Error('Unknown login error'),
      {
        email: req.body?.email,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                               FORGOT PASSWORD                              */
/* -------------------------------------------------------------------------- */
export const forgotPassword = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email } = req.body;

    if (!email || !validateEmail(email)) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Email inv√°lido',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, email FROM users WHERE email = $1`;
    const userResult = await pool.query(userQuery, [email.toLowerCase()]);

    if (userResult.rows.length === 0) {
      authLogger.warn('Password reset attempt for non-existent email', {
        email,
        ip: req.ip,
      });

      res.json({
        success: true,
        message: 'Se o email existir, um link de recupera√ß√£o ser√° enviado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];
    const resetToken = generatePasswordResetToken(user.id, user.email);

    authLogger.info('Password reset token generated', {
      userId: user.id,
      email: user.email,
      ip: req.ip,
    });

    /* Em produ√ß√£o, envie por email. Aqui apenas logamos. */
    console.log(`Password reset token for ${email}: ${resetToken}`);
    console.log(
      `Reset URL: http://localhost:3000/auth/reset-password?token=${resetToken}`,
    );

    res.json({
      success: true,
      data: {
        resetToken,
        resetUrl: `http://localhost:3000/auth/reset-password?token=${resetToken}`,
      },
      message: 'Link de recupera√ß√£o enviado para o email',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Forgot password error',
      error instanceof Error ? error : new Error('Unknown forgot password error'),
      {
        email: req.body?.email,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                               RESET PASSWORD                               */
/* -------------------------------------------------------------------------- */
export const resetPassword = async (req: Request, res: Response): Promise<void> => {
  try {
    const { token, password } = req.body;

    if (!token || typeof token !== 'string') {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Token √© obrigat√≥rio',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    if (!password || typeof password !== 'string' || password.length < 6) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Senha deve ter pelo menos 6 caracteres',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    let tokenPayload;
    try {
      tokenPayload = verifyPasswordResetToken(token);
    } catch (error) {
      authLogger.warn('Invalid password reset token used', {
        token: token.slice(0, 20) + '...',
        ip: req.ip,
      });

      res.status(400).json({
        success: false,
        error: 'INVALID_TOKEN',
        message: 'Token inv√°lido ou expirado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, email FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [tokenPayload.userId]);

    if (
      userResult.rows.length === 0 ||
      userResult.rows[0].email !== tokenPayload.email
    ) {
      authLogger.warn('Password reset token user mismatch', {
        tokenUserId: tokenPayload.userId,
        tokenEmail: tokenPayload.email,
        userExists: userResult.rows.length > 0,
        ip: req.ip,
      });

      res.status(400).json({
        success: false,
        error: 'INVALID_TOKEN',
        message: 'Token inv√°lido',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const passwordHash = await bcrypt.hash(password, 12);
    await pool.query(
      `UPDATE users SET "passwordHash" = $1, "updatedAt" = NOW() WHERE id = $2`,
      [passwordHash, tokenPayload.userId],
    );

    authLogger.info('Password reset successfully', {
      userId: tokenPayload.userId,
      email: tokenPayload.email,
      ip: req.ip,
    });

    res.json({
      success: true,
      message: 'Senha alterada com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Reset password error',
      error instanceof Error ? error : new Error('Unknown reset password error'),
      {
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                                  PROFILE                                   */
/* -------------------------------------------------------------------------- */
export const getProfile = async (req: Request, res: Response): Promise<void> => {
  try {
    const userQuery = `
      SELECT id, email, username, avatar, level, "totalGames", "totalWins",
             "totalLosses", "winRate", "createdAt", "updatedAt", "lastLoginAt"
      FROM users WHERE id = $1
    `;
    const userResult = await pool.query(userQuery, [req.userId]);

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: ERROR_MESSAGES.NOT_FOUND,
        message: 'Usu√°rio n√£o encontrado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    res.json({
      success: true,
      data: userResult.rows[0],
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Get profile error',
      error instanceof Error ? error : new Error('Unknown profile error'),
      {
        userId: req.userId,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                              CHECK USERNAME                                */
/* -------------------------------------------------------------------------- */
export const checkUsername = async (req: Request, res: Response): Promise<void> => {
  try {
    const { username } = req.params;

    if (!username || typeof username !== 'string') {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Username √© obrigat√≥rio',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id FROM users WHERE username = $1`;
    const userResult = await pool.query(userQuery, [username.toLowerCase()]);

    res.json({
      success: true,
      data: { available: userResult.rows.length === 0 },
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Check username error',
      error instanceof Error ? error : new Error('Unknown check username error'),
      {
        username: req.params?.username,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

/* -------------------------------------------------------------------------- */
/*                                CHECK EMAIL                                 */
/* -------------------------------------------------------------------------- */
export const checkEmail = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email } = req.params;

    if (!email || typeof email !== 'string' || !validateEmail(email)) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'Email v√°lido √© obrigat√≥rio',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id FROM users WHERE email = $1`;
    const userResult = await pool.query(userQuery, [email.toLowerCase()]);

    res.json({
      success: true,
      data: { available: userResult.rows.length === 0 },
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  } catch (error) {
    authLogger.error(
      'Check email error',
      error instanceof Error ? error : new Error('Unknown check email error'),
      {
        email: req.params?.email,
        ip: req.ip,
      },
    );

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      message: 'Erro interno do servidor',
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};
</file>

<file path="backend/src/server.ts">
// üê∫ LOBISOMEM ONLINE - Server Entry Point (SIMPLIFICADO)
import httpServer from './app'; // ‚úÖ Importar o httpServer j√° configurado
import { config, validateConfig } from '@/config/environment';
import { connectDatabase, gracefulShutdown as shutdownDatabase } from '@/config/database';
import { connectRedis, gracefulShutdown as shutdownRedis } from '@/config/redis';
import { ServiceFactory } from './websocket/ServiceFactory';
import { logger } from '@/utils/logger';

// ‚úÖ A inst√¢ncia de wsManager agora vive dentro de app.ts

// Fun√ß√£o de retry para conex√£o com o banco
const connectWithRetry = async (connectFn: () => Promise<void>, retries = 5, delay = 5000) => {
  for (let i = 1; i <= retries; i++) {
    try {
      await connectFn();
      logger.info('Database connected successfully.');
      return;
    } catch (error) {
      logger.error(`Database connection attempt ${i} failed. Retrying in ${delay / 1000}s...`, { error });
      if (i === retries) {
        throw new Error(`Could not connect to the database after ${retries} attempts.`);
      }
      await new Promise(res => setTimeout(res, delay));
    }
  }
};

async function startServer(): Promise<void> {
  try {
    validateConfig();

    // Conectar banco (obrigat√≥rio) com retry
    await connectWithRetry(connectDatabase);

    // Conectar Redis (opcional - n√£o falha se der erro)
    if (config.SHOULD_USE_REDIS) {
      try {
        await connectRedis();
      } catch (error) {
        logger.warn('Redis connection failed, continuing without Redis', { error: error instanceof Error ? error.message : 'Unknown error' });
      }
    }

    // ‚úÖ A cria√ß√£o do servidor e do WebSocketManager j√° aconteceu em app.ts
    // Agora s√≥ precisamos iniciar o servidor HTTP
    httpServer.listen(config.PORT, () => {
      logger.info(`üöÄ Server running at http://localhost:${config.PORT}`);
      logger.info(`üê∫ Werewolf Online ${config.SERVICE_TYPE} service started`);
      logger.info(`üîó WebSocket available at ws://localhost:${config.PORT}${config.WS_BASE_PATH}`);
    });

    setupGracefulShutdown(httpServer);

  } catch (error) {
    logger.error('Failed to start server', error instanceof Error ? error : new Error('Unknown server start error'));
    process.exit(1);
  }
}

function setupGracefulShutdown(server: any): void {
  const shutdown = async (signal: string) => {
    logger.info(`Received ${signal}. Starting graceful shutdown...`);

    server.close(async () => {
      logger.info('HTTP server closed.');

      // ‚úÖ Shutdown do WebSocketManager (se existir)
      if (server.wsManager) {
        try {
          await server.wsManager.shutdown();
          logger.info('WebSocket manager shut down.');
        } catch (error) {
          logger.warn('Error shutting down WebSocket manager', { error: error instanceof Error ? error.message : 'Unknown error' });
        }
      }

      // Shutdown do banco
      await shutdownDatabase();

      // Shutdown do Redis (se configurado)
      if (config.SHOULD_USE_REDIS) {
        try {
          await shutdownRedis();
        } catch (error) {
          logger.warn('Error shutting down Redis', { error: error instanceof Error ? error.message : 'Unknown error' });
        }
      }

      // Limpar inst√¢ncias do ServiceFactory
      ServiceFactory.clearInstances();

      logger.info('Graceful shutdown completed.');
      process.exit(0);
    });
  };

  process.on('SIGTERM', () => shutdown('SIGTERM'));
  process.on('SIGINT', () => shutdown('SIGINT'));
}

// ‚úÖ Iniciar servidor se for executado diretamente
if (require.main === module) {
  startServer();
}

export default httpServer;
</file>

<file path="backend/src/utils/constants.ts">
// üê∫ LOBISOMEM ONLINE - Constants (MODO DEBUG HABILITADO)
// ‚úÖ MIN_PLAYERS alterado para 3 para facilitar testes

//====================================================================
// ENUMS DEFINITIONS (√öNICOS AQUI)
//====================================================================
export enum Role {
  // Town roles
  VILLAGER = 'VILLAGER',
  SHERIFF = 'SHERIFF',
  DOCTOR = 'DOCTOR',
  VIGILANTE = 'VIGILANTE',
  // Werewolf roles
  WEREWOLF = 'WEREWOLF',
  WEREWOLF_KING = 'WEREWOLF_KING',
  // Neutral roles
  JESTER = 'JESTER',
  SERIAL_KILLER = 'SERIAL_KILLER',
}

export enum Faction {
  TOWN = 'TOWN',
  WEREWOLF = 'WEREWOLF',
  NEUTRAL = 'NEUTRAL',
}

export enum GamePhase {
  LOBBY = 'LOBBY',
  NIGHT = 'NIGHT',
  DAY = 'DAY',
  VOTING = 'VOTING',
  ENDED = 'ENDED',
}

//====================================================================
// GAME LIMITS
//====================================================================
export const GAME_LIMITS = {
  MIN_PLAYERS: 3, // ‚úÖ ALTERADO DE 6 PARA 3 - MODO DEBUG
  MAX_PLAYERS: 15,
  MAX_SPECTATORS: 5,

  // Room limits
  MAX_ROOM_NAME_LENGTH: 30,
  ROOM_CODE_LENGTH: 6,

  // Time limits (milliseconds)
  NIGHT_DURATION: 20000, // 20 seconds
  DAY_DURATION: 20000, // 20 seconds
  VOTING_DURATION: 20000, // 20 seconds

  // Chat limits
  MAX_MESSAGE_LENGTH: 500,
  CHAT_RATE_LIMIT: 5, // messages per 10 seconds

  // Reconnection
  RECONNECT_TIMEOUT: 120000, // 2 minutes
  MAX_RECONNECT_ATTEMPTS: 5,

  // Heartbeat
  HEARTBEAT_INTERVAL: 30000, // 30 seconds
  HEARTBEAT_TIMEOUT: 5000, // 5 seconds
} as const;

//====================================================================
// THEMED NICKNAMES (MEDIEVAL PORTUGUESE)
//====================================================================
export const THEMED_NICKNAMES = [
  // Profiss√µes
  'Jo√£o Ferreiro', 'Maria Padeira', 'Pedro Lenhador', 'Ana Tecel√£',
  'Carlos Moleiro', 'Isabel Costureira', 'Francisco Carpinteiro', 'Catarina Oleira',
  'Manuel Sapateiro', 'Teresa Lavadeira', 'Ant√≥nio Pedreiro', 'Beatriz Bordadeira',
  'Jos√© Curtidor', 'Lu√≠sa Fiandeira', 'Miguel Cordoeiro', 'Clara Rendilheira',

  // Nomes medievais
  'Afonso o Bravo', 'Constan√ßa a S√°bia', 'Nuno o Valente', 'Urraca a Bela',
  'Sancho o Forte', 'Mafalda a Justa', 'Garcia o Leal', 'Elvira a Piedosa',
  'Bermudo o Jovem', 'Teresa a Corajosa', 'Ramiro o Audaz', 'Sancha a Prudente',

  // Alcunhas regionais
  'Pedro do Norte', 'Maria da Ribeira', 'Jo√£o da Montanha', 'Ana do Vale',
  'Carlos da Floresta', 'Isabel da Ponte', 'Francisco da Torre', 'Catarina do Campo',
  'Manuel do Rio', 'Teresa da Vila', 'Ant√≥nio da Pra√ßa', 'Beatriz do Castelo',

  // Caracter√≠sticas
  'Rodrigo Barba-Ruiva', 'Leonor Olhos-Verdes', 'Vasco Perna-de-Pau', 'Marta Cabelo-Dourado',
  'Egas M√£o-de-Ferro', 'Violante Voz-Doce', '√Ålvaro P√©-Ligeiro', 'Branca Riso-F√°cil',
] as const;

//====================================================================
// CHAT CHANNELS
//====================================================================
export const CHAT_CHANNELS = {
  LOBBY: 'lobby',
  ROOM: 'room',
  PUBLIC: 'public',
  WEREWOLF: 'werewolf',
  SPECTATOR: 'spectator',
  SYSTEM: 'system',
} as const;

//====================================================================
// INVESTIGATION RESULTS
//====================================================================
export const INVESTIGATION_RESULTS = {
  SUSPICIOUS: 'SUSPICIOUS',
  NOT_SUSPICIOUS: 'NOT_SUSPICIOUS',
} as const;

//====================================================================
// WIN CONDITIONS
//====================================================================
export const WIN_CONDITIONS = {
  TOWN_WINS: 'All werewolves have been eliminated',
  WEREWOLF_WINS: 'Werewolves equal or outnumber the town',
  JESTER_WINS: 'Jester was executed by vote',
  SERIAL_KILLER_WINS: 'Serial Killer is the last survivor',
} as const;

//====================================================================
// ACHIEVEMENT CATEGORIES
//====================================================================
export const ACHIEVEMENT_CATEGORIES = {
  FIRST_TIME: 'first_time',
  SURVIVAL: 'survival',
  ROLE_MASTERY: 'role_mastery',
  SOCIAL: 'social',
  STRATEGIC: 'strategic',
  SPECIAL: 'special',
} as const;

//====================================================================
// SYSTEM MESSAGES
//====================================================================
export const SYSTEM_MESSAGES = {
  GAME_STARTED: 'üéÆ O jogo come√ßou! Boa sorte a todos!',
  NIGHT_PHASE: 'üåô A noite caiu sobre a vila...',
  DAY_PHASE: '‚òÄ O sol nasceu. √â hora de discutir!',
  VOTING_PHASE: 'üó≥ Hora da vota√ß√£o! Escolham com sabedoria.',
  PLAYER_ELIMINATED: (name: string, role: string) => `üíÄ ${name} foi eliminado! Era um(a) ${role}.`,
  GAME_ENDED: (faction: string) => `üèÜ Fim de jogo! ${faction} venceu!`,
  PLAYER_JOINED: (name: string) => `üëã ${name} entrou na sala.`,
  PLAYER_LEFT: (name: string) => `üëã ${name} saiu da sala.`,
  RECONNECTED: (name: string) => `üîÑ ${name} reconectou-se.`,
} as const;

//====================================================================
// ERROR MESSAGES
//====================================================================
export const ERROR_MESSAGES = {
  UNAUTHORIZED: 'Token de acesso inv√°lido ou expirado',
  FORBIDDEN: 'Voc√™ n√£o tem permiss√£o para esta a√ß√£o',
  NOT_FOUND: 'Recurso n√£o encontrado',
  ROOM_FULL: 'A sala est√° cheia',
  GAME_IN_PROGRESS: 'O jogo j√° est√° em andamento',
  INVALID_ACTION: 'A√ß√£o inv√°lida',
  RATE_LIMITED: 'Muitas tentativas. Tente novamente mais tarde',
  VALIDATION_FAILED: 'Dados inv√°lidos fornecidos',
  SERVER_ERROR: 'Erro interno do servidor',
} as const;
</file>

<file path="backend/src/websocket/ChannelManager.ts">
import { wsLogger } from '@/utils/logger';
import type { ConnectionManager } from './ConnectionManager';

interface RoomChannel {
  players: Set<string>;
  spectators: Set<string>;
  readyPlayers: Set<string>;
  createdAt: Date;
  lastActivity: Date;
}

export class ChannelManager {
  private rooms = new Map<string, RoomChannel>();
  private connectionRooms = new Map<string, string>();

  constructor(private connectionManager: ConnectionManager) { }

  createRoom(roomId: string): boolean {
    if (this.rooms.has(roomId)) {
      wsLogger.warn('Attempted to create existing room channel', { roomId });
      return false;
    }

    this.rooms.set(roomId, {
      players: new Set(),
      spectators: new Set(),
      createdAt: new Date(),
      lastActivity: new Date(),
    });

    wsLogger.info('Room channel created', { roomId });
    return true;
  }

  joinRoom(roomId: string, connectionId: string, asSpectator = false): boolean {
    let room = this.rooms.get(roomId);

    if (!room) {
      this.createRoom(roomId);
      room = this.rooms.get(roomId)!;
    }

    const currentRoom = this.connectionRooms.get(connectionId);
    if (currentRoom) {
      this.leaveRoom(currentRoom, connectionId);
    }

    if (asSpectator) {
      room.spectators.add(connectionId);
    } else {
      room.players.add(connectionId);
    }

    this.connectionRooms.set(connectionId, roomId);
    room.lastActivity = new Date();

    wsLogger.debug('Connection joined room', {
      connectionId,
      roomId,
      asSpectator,
      totalPlayers: room.players.size,
      totalSpectators: room.spectators.size,
    });

    return true;
  }

  leaveRoom(roomId: string, connectionId: string): boolean {
    const room = this.rooms.get(roomId);
    if (!room) {
      wsLogger.warn('Attempted to leave non-existent room', { roomId, connectionId });
      return false;
    }

    const wasPlayer = room.players.delete(connectionId);
    const wasSpectator = room.spectators.delete(connectionId);

    if (!wasPlayer && !wasSpectator) {
      wsLogger.warn('Connection was not in room', { roomId, connectionId });
      return false;
    }

    this.connectionRooms.delete(connectionId);
    room.lastActivity = new Date();

    if (room.players.size === 0 && room.spectators.size === 0) {
      this.rooms.delete(roomId);
      wsLogger.info('Room channel removed (empty)', { roomId });
    }

    wsLogger.debug('Connection left room', {
      connectionId,
      roomId,
      wasPlayer,
      wasSpectator,
      remainingPlayers: room.players.size,
      remainingSpectators: room.spectators.size,
    });

    return true;
  }

  removeConnectionFromAllRooms(connectionId: string): void {
    const roomId = this.connectionRooms.get(connectionId);
    if (roomId) {
      this.leaveRoom(roomId, connectionId);
    }
  }

  getRoomConnections(roomId: string): Set<string> {
    const room = this.rooms.get(roomId);
    if (!room) return new Set();
    return new Set([...room.players, ...room.spectators]);
  }

  getRoomPlayerConnections(roomId: string): Set<string> {
    const room = this.rooms.get(roomId);
    return room ? new Set(room.players) : new Set();
  }

  getRoomSpectatorConnections(roomId: string): Set<string> {
    const room = this.rooms.get(roomId);
    return room ? new Set(room.spectators) : new Set();
  }

  getConnectionRoom(connectionId: string): string | undefined {
    return this.connectionRooms.get(connectionId);
  }

  getRoomCount(roomId: string): { players: number; spectators: number } {
    const room = this.rooms.get(roomId);
    if (!room) return { players: 0, spectators: 0 };

    return {
      players: room.players.size,
      spectators: room.spectators.size,
    };
  }

  // üîß NOVA VERS√ÉO: limpa conex√µes mortas automaticamente
  getRoomStats(roomId: string): { playersCount: number; spectatorsCount: number } | null {
    const room = this.rooms.get(roomId);
    if (!room) return null;

    console.log(`\nüîç DEBUG LOBBY - Sala: ${roomId.slice(-6)}`);
    console.log(`üìä Players no Set: ${room.players.size}`);

    const deadPlayers = new Set<string>();
    const deadSpectators = new Set<string>();

    // Verificar players
    for (const connectionId of room.players) {
      const connection = this.connectionManager.getConnection(connectionId);
      const isValid = connection && connection.ws.readyState === connection.ws.OPEN;

      console.log(`   üë§ ${connectionId.slice(-6)}: ${isValid ? '‚úÖ VIVO' : 'üíÄ MORTO'}`);

      if (!isValid) {
        deadPlayers.add(connectionId);
        this.connectionRooms.delete(connectionId);
      }
    }

    // Verificar spectators
    for (const connectionId of room.spectators) {
      const connection = this.connectionManager.getConnection(connectionId);
      const isValid = connection && connection.ws.readyState === connection.ws.OPEN;

      if (!isValid) {
        deadSpectators.add(connectionId);
        this.connectionRooms.delete(connectionId);
      }
    }

    // Limpeza efetiva
    if (deadPlayers.size > 0) {
      console.log(`üßπ Limpando ${deadPlayers.size} players mortos`);
      for (const deadId of deadPlayers) {
        room.players.delete(deadId);
      }
    }

    if (deadSpectators.size > 0) {
      console.log(`üßπ Limpando ${deadSpectators.size} spectators mortos`);
      for (const deadId of deadSpectators) {
        room.spectators.delete(deadId);
      }
    }

    const finalCount = {
      playersCount: room.players.size,
      spectatorsCount: room.spectators.size,
    };

    console.log(
      `üìä AP√ìS LIMPEZA: ${finalCount.playersCount} players, ${finalCount.spectatorsCount} spectators`,
    );

    room.lastActivity = new Date();

    if (finalCount.playersCount === 0 && finalCount.spectatorsCount === 0) {
      console.log(`üóëÔ∏è Sala ${roomId.slice(-6)} ficou vazia, removendo`);
      this.rooms.delete(roomId);
    }

    return finalCount;
  }

  broadcastToRoom(
    roomId: string,
    type: string,
    data?: any,
    excludeConnectionId?: string,
  ): number {
    const connections = this.getRoomConnections(roomId);
    let sent = 0;

    for (const connectionId of connections) {
      if (connectionId === excludeConnectionId) continue;

      const connection = this.connectionManager.getConnection(connectionId);
      if (!connection || connection.ws.readyState !== connection.ws.OPEN) continue;

      try {
        connection.ws.send(
          JSON.stringify({
            type,
            data,
            timestamp: new Date().toISOString(),
          }),
        );
        sent++;
      } catch (error) {
        wsLogger.error(
          'Failed to broadcast to connection',
          error instanceof Error ? error : new Error('Unknown broadcast error'),
          {
            connectionId,
            roomId,
            type,
          },
        );
      }
    }

    wsLogger.debug('Broadcast to room completed', {
      roomId,
      type,
      totalConnections: connections.size,
      sentCount: sent,
      excluded: !!excludeConnectionId,
    });

    return sent;
  }

  isPlayerInRoom(roomId: string, connectionId: string): boolean {
    const room = this.rooms.get(roomId);
    return room ? room.players.has(connectionId) : false;
  }

  isSpectatorInRoom(roomId: string, connectionId: string): boolean {
    const room = this.rooms.get(roomId);
    return room ? room.spectators.has(connectionId) : false;
  }

  // ‚úÖ Define ou remove o status de "pronto" de um jogador
  setPlayerReadyStatus(roomId: string, connectionId: string, isReady: boolean): void {
    const room = this.rooms.get(roomId);
    if (!room) return;

    if (!room.readyPlayers) room.readyPlayers = new Set();

    if (isReady) {
      room.readyPlayers.add(connectionId);
    } else {
      room.readyPlayers.delete(connectionId);
    }

    wsLogger.debug('Player ready status updated', {
      roomId,
      connectionId,
      isReady,
      totalReady: room.readyPlayers.size,
    });

    room.lastActivity = new Date();
  }


  // ‚úÖ Verifica se um jogador est√° marcado como "pronto"
  isPlayerReady(roomId: string, connectionId: string): boolean {
    const room = this.rooms.get(roomId);
    return room ? room.readyPlayers?.has(connectionId) ?? false : false;
  }

  getActiveRoomsCount(): number {
    return this.rooms.size;
  }

  getActiveRooms(): string[] {
    return Array.from(this.rooms.keys());
  }

  getRoomInfo(roomId: string): {
    exists: boolean;
    playersCount: number;
    spectatorsCount: number;
    createdAt?: Date;
    lastActivity?: Date;
  } {
    const room = this.rooms.get(roomId);
    if (!room) {
      return { exists: false, playersCount: 0, spectatorsCount: 0 };
    }

    return {
      exists: true,
      playersCount: room.players.size,
      spectatorsCount: room.spectators.size,
      createdAt: room.createdAt,
      lastActivity: room.lastActivity,
    };
  }

  cleanup(maxIdleTime = 3_600_000): number {
    const now = Date.now();
    let cleaned = 0;

    for (const [roomId, room] of this.rooms.entries()) {
      const idleTime = now - room.lastActivity.getTime();

      if (room.players.size === 0 && room.spectators.size === 0 && idleTime > maxIdleTime) {
        this.rooms.delete(roomId);
        cleaned++;

        wsLogger.info('Cleaned up idle room channel', {
          roomId,
          idleTime: Math.floor(idleTime / 1000),
          maxIdleTime: Math.floor(maxIdleTime / 1000),
        });
      }
    }

    return cleaned;
  }

  clear(): void {
    this.rooms.clear();
    this.connectionRooms.clear();
    wsLogger.info('All room channels cleared');
  }

  getStats(): {
    totalRooms: number;
    totalConnections: number;
    totalPlayers: number;
    totalSpectators: number;
    roomsInfo: Array<{
      roomId: string;
      players: number;
      spectators: number;
      idleTime: number;
    }>;
  } {
    let totalPlayers = 0;
    let totalSpectators = 0;
    const roomsInfo: Array<{
      roomId: string;
      players: number;
      spectators: number;
      idleTime: number;
    }> = [];

    const now = Date.now();

    for (const [roomId, room] of this.rooms.entries()) {
      totalPlayers += room.players.size;
      totalSpectators += room.spectators.size;

      roomsInfo.push({
        roomId,
        players: room.players.size,
        spectators: room.spectators.size,
        idleTime: Math.floor((now - room.lastActivity.getTime()) / 1000),
      });
    }

    return {
      totalRooms: this.rooms.size,
      totalConnections: this.connectionRooms.size,
      totalPlayers,
      totalSpectators,
      roomsInfo,
    };
  }
}
</file>

<file path="frontend/src/components/game/ActionPanel.tsx">
import React, { useState } from 'react';
import { useGame } from '@/context/GameContext';
import { useSocket } from '@/context/SocketContext';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// ACTION PANEL COMPONENT - VERS√ÉO CORRIGIDA COM LOGS DE DEBUG
// =============================================================================
export default function ActionPanel() {
  const { gameState, me, alivePlayers, canVote, canAct } = useGame();
  const { sendMessage } = useSocket();

  const [selectedTarget, setSelectedTarget] = useState<string | null>(null);
  const [confirmingAction, setConfirmingAction] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // ‚úÖ LOG do estado atual do painel
  React.useEffect(() => {
    console.log('üéØ ActionPanel: Current state:', {
      gamePhase: gameState?.phase,
      gameDay: gameState?.day,
      userRole: me?.role,
      userAlive: me?.isAlive,
      userHasActed: me?.hasActed,
      userHasVoted: me?.hasVoted,
      canVote,
      canAct,
      selectedTarget,
      alivePlayers: alivePlayers.length,
      timestamp: new Date().toISOString()
    });
  }, [gameState?.phase, me?.hasActed, me?.hasVoted, canVote, canAct, selectedTarget]);

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (!gameState || !me) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex items-center justify-center h-full">
          <LoadingSpinner text="Carregando a√ß√µes..." />
        </div>
      </div>
    );
  }

  // =============================================================================
  // ‚úÖ CORRIGIDO: ACTION HANDLERS COM LOGS DETALHADOS E TIPOS CORRETOS
  // =============================================================================
  const handleNightAction = async () => {
    if (!selectedTarget || !me.role || isSubmitting) return;

    // ‚úÖ CORRE√á√ÉO PRINCIPAL: Mapear role para tipo de a√ß√£o exato que o backend espera
    let actionType: string | null = null;
    switch (me.role) {
      case 'SHERIFF':
        actionType = 'INVESTIGATE';
        break;
      case 'DOCTOR':
        actionType = 'PROTECT';
        break;
      case 'WEREWOLF':
      case 'WEREWOLF_KING':
        actionType = 'WEREWOLF_KILL'; // ‚úÖ Esta √© a corre√ß√£o principal
        break;
      case 'VIGILANTE':
        actionType = 'VIGILANTE_KILL';
        break;
      case 'SERIAL_KILLER':
        actionType = 'SERIAL_KILL';
        break;
      default:
        actionType = null;
    }

    if (actionType) {
      setIsSubmitting(true);

      // ‚úÖ LOG DETALHADO: Tentativa de a√ß√£o noturna
      console.log('üåô ActionPanel: Attempting night action:', {
        actionType,
        targetId: selectedTarget,
        userRole: me.role,
        userId: me.userId,
        gamePhase: gameState.phase,
        gameId: gameState.gameId,
        timestamp: new Date().toISOString()
      });

      try {
        const success = sendMessage('game-action', {
          type: actionType, // ‚úÖ Enviar o tipo correto
          targetId: selectedTarget,
        });

        console.log('üåô ActionPanel: Night action send result:', {
          success,
          actionType,
          targetId: selectedTarget
        });

        if (success) {
          console.log('‚úÖ ActionPanel: Night action sent successfully');
        } else {
          console.error('‚ùå ActionPanel: Failed to send night action');
        }
      } catch (error) {
        console.error('‚ùå ActionPanel: Error sending night action:', error);
      }

      // Reset state after sending
      setTimeout(() => {
        setSelectedTarget(null);
        setConfirmingAction(false);
        setIsSubmitting(false);
      }, 500);
    } else {
      console.warn('‚ö†Ô∏è ActionPanel: No valid action type for role:', me.role);
    }
  };

  const handleVote = async () => {
    if (!selectedTarget || isSubmitting) return;

    setIsSubmitting(true);

    // ‚úÖ LOG DETALHADO: Tentativa de voto
    console.log('üó≥Ô∏è ActionPanel: Attempting vote:', {
      targetId: selectedTarget,
      userId: me.userId,
      gamePhase: gameState.phase,
      gameId: gameState.gameId,
      timestamp: new Date().toISOString()
    });

    try {
      const success = sendMessage('vote', { targetId: selectedTarget });

      console.log('üó≥Ô∏è ActionPanel: Vote send result:', {
        success,
        targetId: selectedTarget
      });

      if (success) {
        console.log('‚úÖ ActionPanel: Vote sent successfully');
      } else {
        console.error('‚ùå ActionPanel: Failed to send vote');
      }
    } catch (error) {
      console.error('‚ùå ActionPanel: Error sending vote:', error);
    }

    setTimeout(() => {
      setSelectedTarget(null);
      setIsSubmitting(false);
    }, 500);
  };

  const handleUnvote = async () => {
    if (isSubmitting) return;

    setIsSubmitting(true);

    // ‚úÖ LOG DETALHADO: Tentativa de remover voto
    console.log('üó≥Ô∏è ActionPanel: Attempting unvote:', {
      userId: me.userId,
      gamePhase: gameState.phase,
      timestamp: new Date().toISOString()
    });

    try {
      const success = sendMessage('unvote', {});

      console.log('üó≥Ô∏è ActionPanel: Unvote send result:', { success });

      if (success) {
        console.log('‚úÖ ActionPanel: Unvote sent successfully');
      } else {
        console.error('‚ùå ActionPanel: Failed to send unvote');
      }
    } catch (error) {
      console.error('‚ùå ActionPanel: Error sending unvote:', error);
    }

    setTimeout(() => {
      setIsSubmitting(false);
    }, 500);
  };

  // =============================================================================
  // GET VALID TARGETS
  // =============================================================================
  const getValidTargets = () => {
    if (gameState.phase === 'VOTING') {
      return alivePlayers.filter(p => p.id !== me.id); // Can't vote for yourself
    }

    if (gameState.phase === 'NIGHT' && me.role) {
      switch (me.role) {
        case 'SHERIFF':
        case 'VIGILANTE':
        case 'SERIAL_KILLER':
          return alivePlayers.filter(p => p.id !== me.id);
        case 'DOCTOR':
          return alivePlayers; // Doctor can protect themselves
        case 'WEREWOLF':
        case 'WEREWOLF_KING':
          return alivePlayers.filter(p => p.faction !== 'WEREWOLF'); // Can't kill other werewolves
        default:
          return [];
      }
    }

    return [];
  };

  const validTargets = getValidTargets();

  // ‚úÖ LOG dos alvos v√°lidos
  React.useEffect(() => {
    console.log('üéØ ActionPanel: Valid targets updated:', {
      count: validTargets.length,
      targets: validTargets.map(t => ({ id: t.id, username: t.username })),
      gamePhase: gameState?.phase,
      userRole: me?.role
    });
  }, [validTargets.length, gameState?.phase, me?.role]);

  // =============================================================================
  // GET ACTION INFO
  // =============================================================================
  const getActionInfo = () => {
    if (gameState.phase === 'VOTING') {
      return {
        title: 'üó≥Ô∏è Vota√ß√£o',
        description: 'Escolha quem deve ser executado pela vila',
        actionText: 'Votar',
        canAct: canVote,
      };
    }

    if (gameState.phase === 'NIGHT' && me.role) {
      switch (me.role) {
        case 'SHERIFF':
          return {
            title: 'üîç Investiga√ß√£o',
            description: 'Investigue um jogador para descobrir se √© suspeito',
            actionText: 'Investigar',
            canAct: canAct,
          };
        case 'DOCTOR':
          return {
            title: '‚öïÔ∏è Prote√ß√£o',
            description: 'Proteja um jogador de ataques noturnos',
            actionText: 'Proteger',
            canAct: canAct,
          };
        case 'VIGILANTE':
          return {
            title: 'üî´ Vigil√¢ncia',
            description: `Elimine um suspeito (${(me.maxActions || 3) - (me.actionsUsed || 0)} balas restantes)`,
            actionText: 'Atirar',
            canAct: canAct && (me.actionsUsed || 0) < (me.maxActions || 3),
          };
        case 'WEREWOLF':
        case 'WEREWOLF_KING':
          return {
            title: 'üê∫ Ataque',
            description: 'Escolha quem atacar durante a noite',
            actionText: 'Atacar',
            canAct: canAct,
          };
        case 'SERIAL_KILLER':
          return {
            title: 'üî™ Assassinato',
            description: 'Elimine um jogador durante a noite',
            actionText: 'Matar',
            canAct: canAct,
          };
        default:
          return null;
      }
    }

    return null;
  };

  const actionInfo = getActionInfo();

  // =============================================================================
  // RENDER DIFFERENT STATES
  // =============================================================================

  // Dead player
  if (!me.isAlive) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">üëª</div>
          <h3 className="text-lg font-semibold text-white mb-2">Voc√™ est√° morto</h3>
          <p className="text-white/70">Observe em sil√™ncio e tor√ßa pelo seu time!</p>
          {me.eliminationReason && (
            <p className="text-red-400 text-sm mt-2">
              Causa: {me.eliminationReason === 'NIGHT_KILL' ? 'Morto √† noite' :
                me.eliminationReason === 'EXECUTION' ? 'Executado pela vila' :
                  me.eliminationReason === 'VIGILANTE' ? 'Morto por vigilante' :
                    'Morto por assassino'}
            </p>
          )}
          {/* ‚úÖ DEBUG: Info do jogador morto */}
          {process.env.NODE_ENV === 'development' && (
            <div className="mt-4 text-xs text-white/30">
              Debug: Role: {me.role} | Faction: {me.faction}
            </div>
          )}
        </div>
      </div>
    );
  }

  // Day phase (no actions)
  if (gameState.phase === 'DAY') {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">‚òÄÔ∏è</div>
          <h3 className="text-lg font-semibold text-white mb-2">Discuss√£o do Dia {gameState.day}</h3>
          <p className="text-white/70">Use o chat para discutir e investigar!</p>
          <p className="text-amber-400 text-sm mt-2">
            A vota√ß√£o come√ßar√° em breve...
          </p>
          {/* ‚úÖ DEBUG: Info da fase do dia */}
          {process.env.NODE_ENV === 'development' && (
            <div className="mt-4 text-xs text-white/30">
              Debug: Role: {me.role} | Time left: {gameState.timeLeft}ms
            </div>
          )}
        </div>
      </div>
    );
  }

  // No valid actions
  if (!actionInfo) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">üò¥</div>
          <h3 className="text-lg font-semibold text-white mb-2">Sem A√ß√µes</h3>
          <p className="text-white/70">Voc√™ n√£o possui a√ß√µes dispon√≠veis nesta fase.</p>
          {/* ‚úÖ DEBUG: Info de por que n√£o h√° a√ß√µes */}
          {process.env.NODE_ENV === 'development' && (
            <div className="mt-4 text-xs text-white/30">
              Debug: Phase: {gameState.phase} | Role: {me.role} | Has acted: {me.hasActed}
            </div>
          )}
        </div>
      </div>
    );
  }

  // Already acted
  if (!actionInfo.canAct && gameState.phase === 'NIGHT') {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">‚úÖ</div>
          <h3 className="text-lg font-semibold text-white mb-2">A√ß√£o Realizada</h3>
          <p className="text-white/70">Voc√™ j√° realizou sua a√ß√£o nesta noite.</p>
          <p className="text-amber-400 text-sm mt-2">
            Aguardando outros jogadores...
          </p>
          {/* ‚úÖ DEBUG: Info da a√ß√£o j√° realizada */}
          {process.env.NODE_ENV === 'development' && (
            <div className="mt-4 text-xs text-white/30">
              Debug: Has acted: {me.hasActed} | Actions used: {me.actionsUsed}/{me.maxActions}
            </div>
          )}
        </div>
      </div>
    );
  }

  // Already voted
  if (!actionInfo.canAct && gameState.phase === 'VOTING') {
    const myVote = gameState.votes && gameState.votes[me.userId];
    const votedPlayer = myVote ? alivePlayers.find(p => p.id === myVote) : null;

    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg p-4">
        <div className="flex flex-col items-center justify-center h-full text-center">
          <div className="text-6xl mb-4">üó≥Ô∏è</div>
          <h3 className="text-lg font-semibold text-white mb-2">Voto Registrado</h3>
          {votedPlayer && (
            <p className="text-white/70 mb-4">
              Voc√™ votou em: <span className="text-amber-400 font-semibold">{votedPlayer.username}</span>
            </p>
          )}

          <button
            onClick={handleUnvote}
            disabled={isSubmitting}
            className="bg-gradient-to-r from-red-500 to-red-700 hover:from-red-600 hover:to-red-800 disabled:from-gray-600 disabled:to-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200"
          >
            {isSubmitting ? 'Removendo...' : 'Remover Voto'}
          </button>

          {/* ‚úÖ DEBUG: Info do voto */}
          {process.env.NODE_ENV === 'development' && (
            <div className="mt-4 text-xs text-white/30">
              Debug: Voted for: {myVote} | Has voted: {me.hasVoted}
            </div>
          )}
        </div>
      </div>
    );
  }

  // Main action interface
  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Header */}
      <div className="flex-shrink-0 border-b border-medieval-600 p-4">
        <h3 className="text-lg font-bold text-white mb-2">{actionInfo.title}</h3>
        <p className="text-white/70 text-sm">{actionInfo.description}</p>

        {/* ‚úÖ DEBUG: Info da a√ß√£o dispon√≠vel */}
        {process.env.NODE_ENV === 'development' && (
          <div className="mt-2 text-xs text-white/30">
            Debug: Can act: {actionInfo.canAct} | Valid targets: {validTargets.length}
          </div>
        )}
      </div>

      {/* Target Selection */}
      <div className="flex-1 overflow-y-auto p-4">
        <h4 className="text-white font-semibold mb-3">Escolha um alvo:</h4>

        <div className="space-y-2">
          {validTargets.map((player) => (
            <button
              key={player.id}
              onClick={() => {
                console.log('üéØ ActionPanel: Target selected:', {
                  playerId: player.id,
                  username: player.username,
                  previousTarget: selectedTarget
                });
                setSelectedTarget(player.id);
              }}
              disabled={isSubmitting}
              className={`
                w-full p-3 rounded-lg border-2 transition-all duration-200 text-left
                ${selectedTarget === player.id
                  ? 'border-amber-400 bg-amber-900/30'
                  : 'border-medieval-600 bg-medieval-700/30 hover:border-amber-400/50 hover:bg-medieval-700/50'
                }
                ${isSubmitting ? 'opacity-50 cursor-not-allowed' : ''}
              `}
            >
              <div className="flex items-center space-x-3">
                <div className="w-8 h-8 rounded-full bg-medieval-600 flex items-center justify-center">
                  {player.avatar ? (
                    <img src={player.avatar} alt={player.username} className="w-full h-full rounded-full" />
                  ) : (
                    player.isHost ? 'üëë' : player.userId === me.userId ? 'üë§' : 'üßë'
                  )}
                </div>

                <div className="flex-1">
                  <div className="text-white font-medium">{player.username}</div>
                  <div className="text-white/50 text-sm">
                    {player.isHost && 'Host ‚Ä¢ '}
                    {player.isConnected ? 'Conectado' : 'Desconectado'}
                    {player.isProtected && ' ‚Ä¢ üõ°Ô∏è Protegido'}
                  </div>
                </div>

                {selectedTarget === player.id && (
                  <div className="text-amber-400 text-xl">üëà</div>
                )}
              </div>
            </button>
          ))}
        </div>

        {validTargets.length === 0 && (
          <div className="text-center text-white/50 py-8">
            <div className="text-4xl mb-2">üö´</div>
            <p>Nenhum alvo v√°lido dispon√≠vel</p>
            {/* ‚úÖ DEBUG: Por que n√£o h√° alvos */}
            {process.env.NODE_ENV === 'development' && (
              <div className="mt-2 text-xs text-white/30">
                Debug: Alive players: {alivePlayers.length} | Phase: {gameState.phase} | Role: {me.role}
              </div>
            )}
          </div>
        )}
      </div>

      {/* Action Button */}
      {validTargets.length > 0 && (
        <div className="flex-shrink-0 border-t border-medieval-600 p-4">
          {!confirmingAction ? (
            <button
              onClick={() => {
                console.log('üéØ ActionPanel: Confirming action:', {
                  selectedTarget,
                  actionType: actionInfo.title
                });
                setConfirmingAction(true);
              }}
              disabled={!selectedTarget || isSubmitting}
              className="w-full bg-gradient-to-r from-blue-500 to-blue-700 hover:from-blue-600 hover:to-blue-800 disabled:from-gray-600 disabled:to-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 disabled:cursor-not-allowed"
            >
              {isSubmitting ? 'Enviando...' :
                selectedTarget
                  ? `${actionInfo.actionText} ${validTargets.find(p => p.id === selectedTarget)?.username}`
                  : 'Selecione um alvo'
              }
            </button>
          ) : (
            <div className="space-y-3">
              <div className="text-center text-amber-400 font-semibold">
                ‚ö†Ô∏è Confirmar a√ß√£o?
              </div>

              <div className="flex space-x-2">
                <button
                  onClick={() => {
                    console.log('üéØ ActionPanel: Action confirmed, executing...');
                    gameState.phase === 'VOTING' ? handleVote() : handleNightAction();
                  }}
                  disabled={isSubmitting}
                  className="flex-1 bg-gradient-to-r from-green-500 to-green-700 hover:from-green-600 hover:to-green-800 disabled:from-gray-600 disabled:to-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200"
                >
                  {isSubmitting ? 'Enviando...' : '‚úì Confirmar'}
                </button>

                <button
                  onClick={() => {
                    console.log('üéØ ActionPanel: Action cancelled');
                    setConfirmingAction(false);
                    setSelectedTarget(null);
                  }}
                  disabled={isSubmitting}
                  className="flex-1 bg-gradient-to-r from-red-500 to-red-700 hover:from-red-600 hover:to-red-800 disabled:from-gray-600 disabled:to-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200"
                >
                  ‚úó Cancelar
                </button>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/room/PlayerList.tsx">
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Users,
  Crown,
  Check,
  Clock,
  UserX,
  Eye,
  UserPlus
} from 'lucide-react';
import { Player } from '@/types';

interface PlayerListProps {
  players: Player[];
  spectators: Player[];
  currentUserId: string;
  isHost: boolean;
  onKickPlayer: (playerId: string) => void;
  maxPlayers: number;
  maxSpectators: number;
}

export default function PlayerList({
  players,
  spectators,
  currentUserId,
  isHost,
  onKickPlayer,
  maxPlayers,
  maxSpectators
}: PlayerListProps) {
  // ‚úÖ CORRIGIDO: Calcular slots vazios baseado nos jogadores reais
  const emptyPlayerSlots = Math.max(0, maxPlayers - players.length);
  const emptySpectatorSlots = Math.max(0, maxSpectators - spectators.length);

  // ‚úÖ MELHORADO: Mostrar apenas alguns slots vazios para evitar lista muito longa
  const visibleEmptyPlayerSlots = Math.min(emptyPlayerSlots, 3);
  const visibleEmptySpectatorSlots = Math.min(emptySpectatorSlots, 2);

  return (
    <div className="space-y-6">
      {/* Lista de Jogadores */}
      <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold flex items-center gap-2">
            <Users className="w-5 h-5" />
            Jogadores ({players.length}/{maxPlayers})
          </h3>

          {/* ‚úÖ NOVO: Indicador de progresso visual */}
          <div className="flex items-center gap-2">
            <div className="w-24 bg-slate-700 rounded-full h-2">
              <div
                className="bg-blue-500 h-2 rounded-full transition-all duration-300"
                style={{ width: `${(players.length / maxPlayers) * 100}%` }}
              />
            </div>
            <span className="text-sm text-slate-400">
              {players.length >= 3 ? '‚úÖ' : '‚è≥'} Min: 3
            </span>
          </div>
        </div>

        <div className="space-y-2">
          <AnimatePresence>
            {players.map((player) => (
              <motion.div
                key={player.id}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
                className={`
                  flex items-center justify-between p-3 rounded-lg transition-all duration-200
                  ${player.isConnected
                    ? 'bg-slate-700/50 border border-slate-600 hover:bg-slate-700/70'
                    : 'bg-red-900/30 border border-red-600/50'
                  }
                  ${player.userId === currentUserId ? 'ring-2 ring-blue-500/50' : ''}
                `}
              >
                <div className="flex items-center gap-3">
                  <div className="relative">
                    <div className={`
                      w-10 h-10 rounded-full flex items-center justify-center text-white font-bold
                      ${player.isHost
                        ? 'bg-gradient-to-br from-yellow-500 to-orange-600'
                        : 'bg-gradient-to-br from-blue-500 to-purple-600'
                      }
                    `}>
                      {player.username?.[0]?.toUpperCase() || '?'}
                    </div>

                    {/* Host Crown */}
                    {player.isHost && (
                      <Crown className="absolute -top-1 -right-1 w-4 h-4 text-yellow-400" />
                    )}

                    {/* Connection Status */}
                    <div className={`
                      absolute -bottom-1 -right-1 w-3 h-3 rounded-full border-2 border-slate-800
                      ${player.isConnected ? 'bg-green-500' : 'bg-red-500'}
                    `} />
                  </div>

                  <div>
                    <div className="flex items-center gap-2">
                      <span className="font-medium">
                        {player.username}
                        {player.userId === currentUserId && (
                          <span className="text-blue-400 ml-1">(Voc√™)</span>
                        )}
                      </span>

                      {/* Tags */}
                      <div className="flex gap-1">
                        {player.isHost && (
                          <span className="text-xs bg-yellow-600 px-2 py-1 rounded-full font-medium">
                            HOST
                          </span>
                        )}
                        {!player.isConnected && (
                          <span className="text-xs bg-red-600 px-2 py-1 rounded-full">
                            OFFLINE
                          </span>
                        )}
                      </div>
                    </div>

                    <div className="text-xs text-slate-400">
                      {player.isConnected ? 'Online' : 'Desconectado'}
                      {player.isHost && ' ‚Ä¢ Controla a sala'}
                    </div>
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  {/* ‚úÖ CORRIGIDO: Host n√£o mostra status "Ready" */}
                  {!player.isHost && (
                    <div className={`
                      flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium
                      ${player.isReady
                        ? 'bg-green-600/20 text-green-400 border border-green-600/30'
                        : 'bg-orange-600/20 text-orange-400 border border-orange-600/30'
                      }
                    `}>
                      {player.isReady ? (
                        <>
                          <Check className="w-3 h-3" />
                          Pronto
                        </>
                      ) : (
                        <>
                          <Clock className="w-3 h-3" />
                          Aguardando
                        </>
                      )}
                    </div>
                  )}

                  {/* ‚úÖ NOVO: Status especial para host */}
                  {player.isHost && (
                    <div className="flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-yellow-600/20 text-yellow-400 border border-yellow-600/30">
                      <Crown className="w-3 h-3" />
                      Host
                    </div>
                  )}

                  {/* Kick Button */}
                  {isHost && player.userId !== currentUserId && (
                    <button
                      onClick={() => onKickPlayer(player.id)}
                      className="p-1 rounded text-red-400 hover:bg-red-600/20 transition-colors"
                      title="Expulsar jogador"
                    >
                      <UserX className="w-4 h-4" />
                    </button>
                  )}
                </div>
              </motion.div>
            ))}
          </AnimatePresence>

          {/* ‚úÖ CORRIGIDO: Mostrar apenas alguns slots vazios */}
          {visibleEmptyPlayerSlots > 0 && (
            <div className="space-y-2">
              {Array.from({ length: visibleEmptyPlayerSlots }).map((_, index) => (
                <div
                  key={`empty-${index}`}
                  className="flex items-center p-3 rounded-lg border-2 border-dashed border-slate-600 opacity-60 hover:opacity-80 transition-opacity"
                >
                  <div className="w-10 h-10 rounded-full bg-slate-700/50 flex items-center justify-center">
                    <UserPlus className="w-5 h-5 text-slate-500" />
                  </div>
                  <span className="ml-3 text-slate-500">
                    Aguardando jogador...
                  </span>
                </div>
              ))}

              {/* ‚úÖ NOVO: Mostrar quantos slots restantes se houver muitos */}
              {emptyPlayerSlots > visibleEmptyPlayerSlots && (
                <div className="text-center py-2">
                  <span className="text-xs text-slate-500">
                    + {emptyPlayerSlots - visibleEmptyPlayerSlots} slot{emptyPlayerSlots - visibleEmptyPlayerSlots !== 1 ? 's' : ''} dispon√≠vel{emptyPlayerSlots - visibleEmptyPlayerSlots !== 1 ? 'eis' : ''}
                  </span>
                </div>
              )}
            </div>
          )}

          {/* ‚úÖ NOVO: Sala cheia */}
          {players.length === maxPlayers && (
            <div className="text-center py-3">
              <div className="inline-flex items-center gap-2 px-3 py-2 bg-green-600/20 text-green-400 rounded-lg border border-green-600/30">
                <Check className="w-4 h-4" />
                <span className="text-sm font-medium">Sala Completa!</span>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Lista de Espectadores */}
      {maxSpectators > 0 && (
        <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold flex items-center gap-2">
              <Eye className="w-5 h-5" />
              Espectadores ({spectators.length}/{maxSpectators})
            </h3>
          </div>

          <div className="space-y-2">
            <AnimatePresence>
              {spectators.map((spectator) => (
                <motion.div
                  key={spectator.id}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 20 }}
                  className="flex items-center justify-between p-2 rounded-lg bg-slate-700/30 border border-slate-600/50"
                >
                  <div className="flex items-center gap-2">
                    <div className="relative">
                      <div className="w-8 h-8 rounded-full bg-gradient-to-br from-slate-500 to-slate-600 flex items-center justify-center text-white text-sm">
                        {spectator.username?.[0]?.toUpperCase() || '?'}
                      </div>
                      <div className={`
                        absolute -bottom-0.5 -right-0.5 w-2 h-2 rounded-full border border-slate-800
                        ${spectator.isConnected ? 'bg-green-500' : 'bg-red-500'}
                      `} />
                    </div>
                    <span className="text-sm">
                      {spectator.username}
                      {spectator.userId === currentUserId && (
                        <span className="text-blue-400 ml-1">(Voc√™)</span>
                      )}
                    </span>
                  </div>

                  {isHost && spectator.userId !== currentUserId && (
                    <button
                      onClick={() => onKickPlayer(spectator.id)}
                      className="p-1 rounded text-red-400 hover:bg-red-600/20 transition-colors"
                      title="Expulsar espectador"
                    >
                      <UserX className="w-3 h-3" />
                    </button>
                  )}
                </motion.div>
              ))}
            </AnimatePresence>

            {/* Slots vazios para espectadores (limitados) */}
            {visibleEmptySpectatorSlots > 0 && (
              <div className="space-y-2">
                {Array.from({ length: visibleEmptySpectatorSlots }).map((_, index) => (
                  <div
                    key={`empty-spec-${index}`}
                    className="flex items-center p-2 rounded-lg border border-dashed border-slate-600/50 opacity-50"
                  >
                    <div className="w-8 h-8 rounded-full bg-slate-700/30 flex items-center justify-center">
                      <Eye className="w-4 h-4 text-slate-600" />
                    </div>
                    <span className="ml-2 text-slate-600 text-sm">
                      Slot para espectador
                    </span>
                  </div>
                ))}
              </div>
            )}

            {/* Nenhum espectador */}
            {spectators.length === 0 && visibleEmptySpectatorSlots === 0 && (
              <div className="text-center py-4 text-slate-500">
                <Eye className="w-6 h-6 mx-auto mb-2 opacity-50" />
                <p className="text-sm">Nenhum espectador</p>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/context/AuthContext.tsx">
'use client';

import { createContext, useContext, useEffect, useState, ReactNode, useMemo } from 'react';
import { User, AuthTokens, LoginRequest, RegisterRequest } from '@/types';
import { authService } from '@/services/auth';
import { toast } from 'react-hot-toast';
import Cookies from 'js-cookie';

// =============================================================================
// CONTEXT TYPES
// =============================================================================
interface AuthContextType {
  // State
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;

  // Actions
  login: (credentials: LoginRequest) => Promise<boolean>;
  register: (data: RegisterRequest) => Promise<boolean>;
  logout: () => void;
  refreshToken: () => Promise<boolean>;
  updateUser: (updates: Partial<User>) => void;

  // Utils
  getToken: () => string | null;
  isTokenExpired: () => boolean;
}

// =============================================================================
// CONTEXT CREATION
// =============================================================================
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// =============================================================================
// PROVIDER COMPONENT
// =============================================================================
interface AuthProviderProps {
  children: ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // =============================================================================
  // ‚úÖ COMPUTED VALUES - MELHORADO COM VERIFICA√á√ÉO COMPLETA E DEBUG
  // =============================================================================
  const getToken = (): string | null => {
    const token = Cookies.get('access_token') || null;
    console.log('üîê DEBUG getToken:');
    console.log('üîê Token exists:', !!token);
    console.log('üîê Token length:', token?.length);
    console.log('üîê Token (first 50 chars):', token?.substring(0, 50));
    return token;
  };

  // ‚úÖ CORRIGIDO: isAuthenticated com verifica√ß√£o completa
  const isAuthenticated = useMemo(() => {
    const token = getToken();
    const result = !!user && !!token && !isLoading;
    console.log('üîê DEBUG isAuthenticated:');
    console.log('üîê User exists:', !!user);
    console.log('üîê Token exists:', !!token);
    console.log('üîê Is loading:', isLoading);
    console.log('üîê Final result:', result);
    return result;
  }, [user, isLoading]);

  // =============================================================================
  // TOKEN MANAGEMENT COM DEBUG
  // =============================================================================
  const setTokens = (tokens: AuthTokens) => {
    console.log('üîê DEBUG setTokens:');
    console.log('üîê Setting access token length:', tokens.accessToken?.length);
    console.log('üîê Setting refresh token length:', tokens.refreshToken?.length);

    // Set access token with 7-day expiry
    Cookies.set('access_token', tokens.accessToken, {
      expires: 7,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    });

    // Set refresh token if provided
    if (tokens.refreshToken) {
      Cookies.set('refresh_token', tokens.refreshToken, {
        expires: 30,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
      });
    }

    // Verificar se foram salvos
    const savedAccessToken = Cookies.get('access_token');
    const savedRefreshToken = Cookies.get('refresh_token');

    console.log('üîê Tokens saved verification:');
    console.log('üîê Access token saved:', !!savedAccessToken);
    console.log('üîê Refresh token saved:', !!savedRefreshToken);
  };

  const clearTokens = () => {
    console.log('üîê DEBUG clearTokens: Clearing all tokens');
    Cookies.remove('access_token');
    Cookies.remove('refresh_token');
  };

  const isTokenExpired = (): boolean => {
    const token = getToken();
    if (!token) {
      console.log('üîê DEBUG isTokenExpired: No token found');
      return true;
    }

    try {
      const tokenParts = token.split('.');
      if (tokenParts.length !== 3) return true; // Token inv√°lido
      if (!tokenParts[1]) return true; // Token inv√°lido
      const payload = JSON.parse(atob(tokenParts[1]));
      const isExpired = payload.exp * 1000 < Date.now();
      console.log('üîê DEBUG isTokenExpired:');
      console.log('üîê Token exp:', new Date(payload.exp * 1000));
      console.log('üîê Current time:', new Date());
      console.log('üîê Is expired:', isExpired);
      return isExpired;
    } catch (error) {
      console.log('üîê DEBUG isTokenExpired: Error parsing token:', error);
      return true;
    }
  };

  // =============================================================================
  // ‚úÖ AUTHENTICATION ACTIONS - CORRIGIDO CONFORME O GUIA COM DEBUG
  // =============================================================================
  const login = async (credentials: LoginRequest): Promise<boolean> => {
    console.log('üîê DEBUG login: Starting login process');
    console.log('üîê Credentials email:', credentials.email);
    setIsLoading(true);

    // ‚úÖ CORRIGIDO: A chamada de servi√ßo agora NUNCA vai dar "throw" por um erro 401
    const response = await authService.login(credentials);

    console.log('üîê DEBUG login response:');
    console.log('üîê Success:', response.success);
    console.log('üîê Has data:', !!response.data);
    console.log('üîê Error:', response.error);

    setIsLoading(false);

    if (response.success && response.data) {
      console.log('üîê Login successful, processing tokens and user...');
      console.log('üîê User received:', response.data.user?.username);
      console.log('üîê Tokens received:', {
        accessToken: !!response.data.tokens?.accessToken,
        refreshToken: !!response.data.tokens?.refreshToken
      });

      // L√≥gica de sucesso...
      setUser(response.data.user);
      setTokens(response.data.tokens);
      toast.success(`Bem-vindo de volta, ${response.data.user.username}! üê∫`);
      return true;
    } else {
      // L√≥gica de falha...
      console.log('üîê Login failed:', response.error || response.message);
      const errorMessage = response.message || response.error || 'Ocorreu uma falha.';
      toast.error(errorMessage);
      return false;
    }
  };

  const register = async (data: RegisterRequest): Promise<boolean> => {
    console.log('üîê DEBUG register: Starting registration process');
    console.log('üîê Username:', data.username);
    console.log('üîê Email:', data.email);
    setIsLoading(true);

    // ‚úÖ CORRIGIDO: A chamada de servi√ßo agora NUNCA vai dar "throw" por um erro 409
    const response = await authService.register(data);

    console.log('üîê DEBUG register response:');
    console.log('üîê Success:', response.success);
    console.log('üîê Has data:', !!response.data);
    console.log('üîê Error:', response.error);

    setIsLoading(false);

    if (response.success && response.data) {
      console.log('üîê Registration successful, processing tokens and user...');
      // L√≥gica de sucesso...
      setUser(response.data.user);
      setTokens(response.data.tokens);
      toast.success(`Conta criada com sucesso! Bem-vindo, ${data.username}! üéÆ`);
      return true;
    } else {
      // L√≥gica de falha...
      console.log('üîê Registration failed:', response.error || response.message);
      const errorMessage = response.message || response.error || 'Erro ao criar conta';
      toast.error(errorMessage);
      return false;
    }
  };

  const logout = () => {
    console.log('üîê DEBUG logout: Logging out user');
    setUser(null);
    clearTokens();
    toast.success('Logout realizado com sucesso!');

    // Redirect to home page
    if (typeof window !== 'undefined') {
      window.location.href = '/';
    }
  };

  const refreshToken = async (): Promise<boolean> => {
    console.log('üîê DEBUG refreshToken: Attempting to refresh token');
    try {
      const refreshTokenValue = Cookies.get('refresh_token');
      console.log('üîê Refresh token exists:', !!refreshTokenValue);

      if (!refreshTokenValue) {
        console.log('üîê No refresh token found');
        return false;
      }

      const response = await authService.refreshToken(refreshTokenValue);

      console.log('üîê Refresh token response:');
      console.log('üîê Success:', response.success);
      console.log('üîê Has data:', !!response.data);

      if (response.success && response.data) {
        console.log('üîê Token refreshed successfully');
        setTokens(response.data.tokens);
        return true;
      }

      console.log('üîê Token refresh failed');
      return false;
    } catch (error) {
      console.error('üîê Refresh token error:', error);
      return false;
    }
  };

  const updateUser = (updates: Partial<User>) => {
    console.log('üîê DEBUG updateUser:', updates);
    if (user) {
      setUser({ ...user, ...updates });
    }
  };

  // =============================================================================
  // ‚úÖ INITIALIZATION - MELHORADO COM MELHOR CONTROLE DE LOADING E DEBUG
  // =============================================================================
  useEffect(() => {
    const initializeAuth = async () => {
      console.log('üîê DEBUG initializeAuth: Starting auth initialization');
      try {
        setIsLoading(true);
        const token = getToken();

        if (!token || isTokenExpired()) {
          console.log('üîê Token missing or expired, trying to refresh...');
          // Try to refresh token
          const refreshed = await refreshToken();
          if (!refreshed) {
            console.log('üîê Could not refresh token, user not authenticated');
            setIsLoading(false);
            return;
          }
        }

        console.log('üîê Getting user profile...');
        // Get user profile
        const profileResponse = await authService.getProfile();

        console.log('üîê Profile response:');
        console.log('üîê Success:', profileResponse.success);
        console.log('üîê Has data:', !!profileResponse.data);

        if (profileResponse.success && profileResponse.data) {
          console.log('üîê User profile loaded:', profileResponse.data.username);
          setUser(profileResponse.data);
        } else {
          // Token is invalid, clear it
          console.log('üîê Profile fetch failed, clearing tokens');
          clearTokens();
        }
      } catch (error) {
        console.error('üîê Auth initialization error:', error);
        clearTokens();
      } finally {
        console.log('üîê Auth initialization completed');
        setIsLoading(false);
      }
    };

    initializeAuth();
  }, []);

  // =============================================================================
  // TOKEN REFRESH SCHEDULER COM DEBUG
  // =============================================================================
  useEffect(() => {
    if (!isAuthenticated) {
      console.log('üîê DEBUG: User not authenticated, skipping token refresh scheduler');
      return;
    }

    console.log('üîê DEBUG: Setting up token refresh scheduler');

    // Refresh token every 30 minutes if user is active
    const interval = setInterval(async () => {
      console.log('üîê Scheduled token check...');
      if (!isTokenExpired()) {
        console.log('üîê Token still valid, no refresh needed');
        return;
      }

      console.log('üîê Token expired, attempting refresh...');
      const refreshed = await refreshToken();
      if (!refreshed) {
        console.log('üîê Token refresh failed, logging out user');
        logout();
      }
    }, 30 * 60 * 1000); // 30 minutes

    return () => {
      console.log('üîê Clearing token refresh scheduler');
      clearInterval(interval);
    };
  }, [isAuthenticated]);

  // =============================================================================
  // ‚úÖ CONTEXT VALUE - MEMOIZADO PARA EVITAR RE-RENDERS DESNECESS√ÅRIOS
  // =============================================================================
  const contextValue = useMemo<AuthContextType>(() => {
    console.log('üîê DEBUG: Context value memoization');
    console.log('üîê Current state - User:', !!user, 'IsAuth:', isAuthenticated, 'Loading:', isLoading);

    return {
      // State
      user,
      isAuthenticated,
      isLoading,

      // Actions
      login,
      register,
      logout,
      refreshToken,
      updateUser,

      // Utils
      getToken,
      isTokenExpired,
    };
  }, [user, isAuthenticated, isLoading]);

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
}

// =============================================================================
// HOOK
// =============================================================================
export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// =============================================================================
// HOC FOR PROTECTED ROUTES
// =============================================================================
export function withAuth<P extends object>(Component: React.ComponentType<P>) {
  return function AuthenticatedComponent(props: P) {
    const { isAuthenticated, isLoading } = useAuth();

    console.log('üîê DEBUG withAuth HOC:');
    console.log('üîê isAuthenticated:', isAuthenticated);
    console.log('üîê isLoading:', isLoading);

    if (isLoading) {
      console.log('üîê Showing loading screen');
      return (
        <div className="min-h-screen flex items-center justify-center bg-medieval-900">
          <div className="text-white text-xl font-medieval">
            üê∫ Carregando...
          </div>
        </div>
      );
    }

    if (!isAuthenticated) {
      console.log('üîê User not authenticated, redirecting to login');
      if (typeof window !== 'undefined') {
        window.location.href = '/auth/login';
      }
      return null;
    }

    console.log('üîê User authenticated, rendering component');
    return <Component {...props} />;
  };
}
</file>

<file path="frontend/src/context/GameContext.tsx">
'use client';

import React, { createContext, useContext, useReducer, useEffect, useMemo } from 'react';
import { useAuth } from './AuthContext';
import type { GameState, Player, GamePhase } from '@/types';

// =============================================================================
// TYPES & INTERFACES
// =============================================================================
interface ChatMessage {
  id: string;
  userId: string;
  username: string;
  message: string;
  channel: 'public' | 'werewolf' | 'dead' | 'system';
  timestamp: string;
  filtered?: boolean;
}

interface GameContextState {
  gameState: GameState | null;
  isLoading: boolean;
  error: string | null;
  connectionStatus: 'disconnected' | 'connecting' | 'connected' | 'error';
  chatMessages: ChatMessage[];
}

interface GameContextValue extends GameContextState {
  // Dados derivados
  me: Player | null;
  alivePlayers: Player[];
  deadPlayers: Player[];
  isMyTurn: boolean;
  canVote: boolean;
  canAct: boolean;

  // Actions
  refreshGame: () => void;
  clearError: () => void;
}

// =============================================================================
// REDUCER
// =============================================================================
type GameAction =
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_CONNECTION_STATUS'; payload: GameContextState['connectionStatus'] }
  | { type: 'SET_GAME_STATE'; payload: GameState }
  | { type: 'UPDATE_PHASE'; payload: { phase: GamePhase; timeLeft: number; day: number } }
  | { type: 'UPDATE_VOTING'; payload: { votes: Record<string, string>; counts: Record<string, number> } }
  | { type: 'PLAYER_DIED'; payload: { playerId: string; role?: string; cause: string } }
  | { type: 'ADD_CHAT_MESSAGE'; payload: ChatMessage }
  | { type: 'CLEAR_GAME' };

const initialState: GameContextState = {
  gameState: null,
  isLoading: false,
  error: null,
  connectionStatus: 'disconnected',
  chatMessages: [],
};

// ‚úÖ REDUCER CORRIGIDO - Vers√£o Segura e Funcional
function gameReducer(state: GameContextState, action: GameAction): GameContextState {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };

    case 'SET_ERROR':
      return { ...state, error: action.payload, isLoading: false };

    case 'SET_CONNECTION_STATUS':
      return { ...state, connectionStatus: action.payload };

    case 'SET_GAME_STATE':
      return {
        ...state,
        gameState: action.payload,
        isLoading: false,
        error: null,
        connectionStatus: 'connected',
      };

    // ‚úÖ CORRE√á√ÉO: Agrupamento seguro dos cases que dependem de gameState
    case 'UPDATE_PHASE':
    case 'UPDATE_VOTING':
    case 'PLAYER_DIED': {
      // Se n√£o h√° estado de jogo, n√£o faz nada
      if (!state.gameState) {
        return state;
      }

      // Cria uma c√≥pia do estado do jogo
      let newGameState = { ...state.gameState };

      // Aplica as mudan√ßas baseadas no tipo da a√ß√£o
      if (action.type === 'UPDATE_PHASE') {
        newGameState.phase = action.payload.phase;
        newGameState.timeLeft = action.payload.timeLeft;
        newGameState.day = action.payload.day;
      }

      if (action.type === 'UPDATE_VOTING') {
        newGameState.votes = action.payload.votes;
      }

      if (action.type === 'PLAYER_DIED') {
        newGameState.players = newGameState.players.map(p =>
          p.id === action.payload.playerId
            ? { ...p, isAlive: false, eliminationReason: action.payload.cause as any }
            : p
        );
      }

      // Retorna o novo estado
      return { ...state, gameState: newGameState };
    }

    case 'ADD_CHAT_MESSAGE':
      console.log('üî• REDUCER: Before add:', state.chatMessages.length);
      console.log('üî• REDUCER: Adding message:', action.payload.message);

      // Evitar duplicatas
      if (state.chatMessages.some(msg => msg.id === action.payload.id)) {
        console.log('üî• REDUCER: Duplicate found, returning same state');
        return state;
      }

      const newState = {
        ...state,
        chatMessages: [...state.chatMessages, action.payload],
      };

      console.log('üî• REDUCER: After add:', newState.chatMessages.length);
      return newState;

    case 'CLEAR_GAME':
      return initialState;

    default:
      return state;
  }
}

// =============================================================================
// CONTEXT
// =============================================================================
const GameContext = createContext<GameContextValue | undefined>(undefined);

// =============================================================================
// PROVIDER
// =============================================================================
interface GameProviderProps {
  children: React.ReactNode;
  gameId: string;
}

export function GameProvider({ children, gameId }: GameProviderProps) {
  const [state, dispatch] = useReducer(gameReducer, initialState);
  const { user } = useAuth();

  // =============================================================================
  // WEBSOCKET MESSAGE HANDLING
  // =============================================================================
  useEffect(() => {
    const handleWebSocketMessage = (event: CustomEvent) => {
      const message = event.detail;
      console.log('üî• FRONTEND: WebSocket message received!', {
        type: event.detail?.type,
        hasData: !!event.detail?.data,
        timestamp: new Date().toISOString()
      });


      if (!message?.type) return;

      try {
        console.log('üéÆ GameContext received message:', message.type, message.data);

        switch (message.type) {
          case 'game-state':
            if (message.data?.gameId === gameId) {
              dispatch({ type: 'SET_GAME_STATE', payload: message.data });
            }
            break;

          case 'phase-changed':
            if (message.data?.gameId === gameId) {
              dispatch({
                type: 'UPDATE_PHASE',
                payload: {
                  phase: message.data.phase,
                  timeLeft: message.data.timeLeft,
                  day: message.data.day,
                },
              });

              // Mensagem de sistema para mudan√ßa de fase
              let phaseMessage = '';
              switch (message.data.phase) {
                case 'DAY':
                  phaseMessage = `üåÖ Dia ${message.data.day || '?'} come√ßou! Hora de discutir.`;
                  break;
                case 'VOTING':
                  phaseMessage = `üó≥Ô∏è Hora da vota√ß√£o! Escolham quem ser√° executado.`;
                  break;
                case 'NIGHT':
                  phaseMessage = `üåô Noite chegou... Os poderes especiais acordam.`;
                  break;
                default:
                  phaseMessage = `‚è∞ Fase mudou para ${message.data.phase}`;
              }

              const systemMessage: ChatMessage = {
                id: `system-phase-${Date.now()}`,
                userId: 'system',
                username: 'Sistema',
                message: phaseMessage,
                channel: 'system',
                timestamp: new Date().toISOString(),
              };

              dispatch({ type: 'ADD_CHAT_MESSAGE', payload: systemMessage });
            }
            break;

          case 'voting-update':
          case 'vote-cast':
          case 'vote-removed':
            if (message.data?.gameId === gameId) {
              dispatch({
                type: 'UPDATE_VOTING',
                payload: {
                  votes: message.data.votes || {},
                  counts: message.data.counts || {},
                },
              });
            }
            break;

          case 'player-died':
          case 'night-results':
            if (message.data?.gameId === gameId) {
              // Handle player deaths from night results
              if (message.data.deaths && Array.isArray(message.data.deaths)) {
                message.data.deaths.forEach((death: any) => {
                  dispatch({
                    type: 'PLAYER_DIED',
                    payload: {
                      playerId: death.playerId,
                      role: death.role,
                      cause: death.cause,
                    },
                  });
                });
              }

              // Mensagem de sistema para mortes
              let deathMessage = '';
              if (message.data.playerName) {
                deathMessage = `üíÄ ${message.data.playerName} foi eliminado!`;
              } else if (message.data.deaths && Array.isArray(message.data.deaths)) {
                const deathNames = message.data.deaths.map((d: any) => d.playerName || 'Algu√©m').join(', ');
                deathMessage = `üíÄ ${deathNames} foram eliminados!`;
              } else {
                deathMessage = 'üíÄ Algu√©m foi eliminado!';
              }

              const systemMessage: ChatMessage = {
                id: `system-death-${Date.now()}`,
                userId: 'system',
                username: 'Sistema',
                message: deathMessage,
                channel: 'system',
                timestamp: new Date().toISOString(),
              };

              dispatch({ type: 'ADD_CHAT_MESSAGE', payload: systemMessage });
            }
            break;

          case 'game-ended':
            if (message.data?.gameId === gameId) {
              dispatch({ type: 'SET_GAME_STATE', payload: message.data });

              // Mensagem de fim de jogo
              if (message.data?.winningFaction) {
                let winMessage = '';
                switch (message.data.winningFaction) {
                  case 'TOWN':
                    winMessage = 'üèÜ A VILA VENCEU! Todos os lobisomens foram eliminados!';
                    break;
                  case 'WEREWOLF':
                    winMessage = 'üê∫ OS LOBISOMENS VENCERAM! Eles dominaram a vila!';
                    break;
                  default:
                    winMessage = 'üé≠ VIT√ìRIA ESPECIAL! Jogo finalizado!';
                }

                const systemMessage: ChatMessage = {
                  id: `system-victory-${Date.now()}`,
                  userId: 'system',
                  username: 'Sistema',
                  message: winMessage,
                  channel: 'system',
                  timestamp: new Date().toISOString(),
                };

                dispatch({ type: 'ADD_CHAT_MESSAGE', payload: systemMessage });
              }
            }
            break;

          case 'chat-message':
            if (message.data?.message) {
              const receivedMessage = message.data.message;
              console.log('üì¨ GameContext: Processing chat message:', {
                messageId: receivedMessage.id,
                username: receivedMessage.username,
                channel: receivedMessage.channel,
                messagePreview: receivedMessage.message?.substring(0, 50),
              });

              const newMessage: ChatMessage = {
                id: receivedMessage.id || `msg-${Date.now()}`,
                userId: receivedMessage.userId || 'unknown',
                username: receivedMessage.username || 'Usu√°rio',
                message: receivedMessage.message || '',
                channel: receivedMessage.channel || 'public',
                timestamp: receivedMessage.timestamp || new Date().toISOString(),
                filtered: receivedMessage.filtered || false,
              };

              dispatch({ type: 'ADD_CHAT_MESSAGE', payload: newMessage });
            }
            break;

          case 'action-feedback':
            if (message.data?.message) {
              console.log('‚ÑπÔ∏è GameContext: Action feedback received:', message.data.message);
              // Aqui voc√™ pode adicionar um toast/notifica√ß√£o se quiser
              // toast.info(message.data.message, { icon: '‚ÑπÔ∏è' });
            }
            break;

          case 'error':
            dispatch({ type: 'SET_ERROR', payload: message.data?.message || 'Erro desconhecido' });

            // Mostrar erros como mensagens de sistema
            if (message.data?.message) {
              const errorMessage: ChatMessage = {
                id: `system-error-${Date.now()}`,
                userId: 'system',
                username: 'Sistema',
                message: `‚ùå Erro: ${message.data.message}`,
                channel: 'system',
                timestamp: new Date().toISOString(),
              };

              dispatch({ type: 'ADD_CHAT_MESSAGE', payload: errorMessage });
            }
            break;

          default:
            // Log unknown message types for debugging
            console.log('üîç Unknown game message type:', message.type);
        }
      } catch (error) {
        console.error('‚ùå Error handling WebSocket message:', error);
        dispatch({ type: 'SET_ERROR', payload: 'Erro ao processar mensagem do servidor' });
      }
    };

    // Listen to WebSocket messages
    window.addEventListener('websocket-message', handleWebSocketMessage as EventListener);

    return () => {
      window.removeEventListener('websocket-message', handleWebSocketMessage as EventListener);
    };
  }, [gameId]);

  // =============================================================================
  // DERIVED DATA (MEMOIZED)
  // =============================================================================
  const me = useMemo((): Player | null => {
    if (!state.gameState || !user?.id) return null;
    return state.gameState.players.find(p => p.userId === user.id) || null;
  }, [state.gameState, user?.id]);

  const alivePlayers = useMemo((): Player[] => {
    if (!state.gameState) return [];
    return state.gameState.players.filter(p => p.isAlive && !p.isSpectator);
  }, [state.gameState]);

  const deadPlayers = useMemo((): Player[] => {
    if (!state.gameState) return [];
    return state.gameState.players.filter(p => !p.isAlive && !p.isSpectator);
  }, [state.gameState]);

  const isMyTurn = useMemo((): boolean => {
    if (!me || !state.gameState) return false;

    // Durante a noite, verificar se √© a vez da role do jogador agir
    if (state.gameState.phase === 'NIGHT') {
      return Boolean(me?.isAlive && !me?.hasActed && (me.role === 'SHERIFF' || me.role === 'DOCTOR' || me.role === 'VIGILANTE' || me.role === 'WEREWOLF'));
    }

    // Durante vota√ß√£o, todos podem votar
    if (state.gameState.phase === 'VOTING') {
      return Boolean(me?.isAlive && !me?.hasVoted);
    }

    return false;
  }, [me, state.gameState]);

  const canVote = useMemo((): boolean => {
    return Boolean(
      me &&
      state.gameState &&
      state.gameState.phase === 'VOTING' &&
      me.isAlive &&
      !me.hasVoted
    );
  }, [me, state.gameState]);

  const canAct = useMemo((): boolean => {
    return Boolean(
      me &&
      state.gameState &&
      state.gameState.phase === 'NIGHT' &&
      me.isAlive &&
      !me.hasActed &&
      (me.role === 'SHERIFF' || me.role === 'DOCTOR' || me.role === 'VIGILANTE' || me.role === 'WEREWOLF')
    );
  }, [me, state.gameState]);

  // =============================================================================
  // ACTIONS
  // =============================================================================
  const refreshGame = () => {
    dispatch({ type: 'SET_LOADING', payload: true });
    // Trigger game state refresh - could send a message to backend
    // For now, just clear loading state after a timeout
    setTimeout(() => {
      dispatch({ type: 'SET_LOADING', payload: false });
    }, 1000);
  };

  const clearError = () => {
    dispatch({ type: 'SET_ERROR', payload: null });
  };

  // =============================================================================
  // CONTEXT VALUE - ‚úÖ CORRE√á√ÉO: Dependencies do useMemo CORRIGIDAS
  // =============================================================================
  const contextValue: GameContextValue = useMemo(() => ({
    // State
    ...state,

    // Derived data
    me,
    alivePlayers,
    deadPlayers,
    isMyTurn,
    canVote,
    canAct,

    // Actions
    refreshGame,
    clearError,
  }), [
    state.gameState,
    state.isLoading,
    state.error,
    state.connectionStatus,
    state.chatMessages, // ‚úÖ MUDAN√áA CR√çTICA: array completo, n√£o s√≥ o length
    me,
    alivePlayers,
    deadPlayers,
    isMyTurn,
    canVote,
    canAct,
  ]);

  return (
    <GameContext.Provider value={contextValue}>
      {children}
    </GameContext.Provider>
  );
}

// =============================================================================
// HOOK
// =============================================================================
export function useGame(): GameContextValue {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
}

// =============================================================================
// EXPORT
// =============================================================================
export default GameContext;
</file>

<file path="frontend/src/hooks/index.ts">
// üê∫ LOBISOMEM ONLINE - Custom Hooks
// Reusable hooks for common functionality

import { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { toast } from 'react-hot-toast';

// =============================================================================
// TIPOS AUXILIARES PARA HOOKS
// =============================================================================
export interface WebSocketHookOptions {
  autoConnect?: boolean;
  heartbeatInterval?: number;
  maxReconnectAttempts?: number;
  reconnectBackoff?: 'linear' | 'exponential';
}

export interface UseWebSocketReturn {
  socket: WebSocket | null;
  status: 'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'error';
  isConnected: boolean;
  pingLatency: number;
  reconnectAttempts: number;
  connect: () => void;
  disconnect: () => void;
  sendMessage: (type: string, data?: any) => boolean;
}

// =============================================================================
// ‚úÖ WEBSOCKET HOOK COM HEARTBEAT - CORRIGIDO
// =============================================================================
export function useWebSocket(
  url: string,
  options: WebSocketHookOptions = {}
): UseWebSocketReturn {
  const {
    autoConnect = true,
    heartbeatInterval = 30000, // 30 segundos
    maxReconnectAttempts = 5,
    reconnectBackoff = 'exponential'
  } = options;

  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [status, setStatus] = useState<'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'error'>('disconnected');
  const [pingLatency, setPingLatency] = useState<number>(0);
  const [reconnectAttempts, setReconnectAttempts] = useState<number>(0);

  const heartbeatRef = useRef<NodeJS.Timeout | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const pingStartTimeRef = useRef<number>(0);
  const shouldReconnectRef = useRef<boolean>(true);

  const clearHeartbeat = useCallback(() => {
    if (heartbeatRef.current) {
      clearInterval(heartbeatRef.current);
      heartbeatRef.current = null;
    }
  }, []);

  const clearReconnectTimeout = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
  }, []);

  const startHeartbeat = useCallback(() => {
    clearHeartbeat();

    heartbeatRef.current = setInterval(() => {
      if (socket && socket.readyState === WebSocket.OPEN) {
        pingStartTimeRef.current = Date.now();
        socket.send(JSON.stringify({ type: 'ping' }));
      }
    }, heartbeatInterval);
  }, [socket, heartbeatInterval, clearHeartbeat]);

  const calculateReconnectDelay = useCallback((attempts: number) => {
    if (reconnectBackoff === 'linear') {
      return Math.min(1000 * attempts, 30000); // Max 30 segundos
    } else {
      return Math.min(1000 * Math.pow(2, attempts), 30000); // Exponencial, max 30 segundos
    }
  }, [reconnectBackoff]);

  const connect = useCallback(() => {
    // ‚úÖ CORRE√á√ÉO: Validar URL antes de conectar
    if (!url || url === '') {
      console.warn('‚ùå Cannot connect: URL is empty');
      return;
    }

    if (socket && socket.readyState === WebSocket.OPEN) {
      console.log('‚úÖ WebSocket already connected, skipping...');
      return;
    }

    setStatus('connecting');
    shouldReconnectRef.current = true;

    try {
      console.log('üîå Connecting to WebSocket:', url);
      const ws = new WebSocket(url);
      setSocket(ws);

      ws.onopen = () => {
        console.log('‚úÖ WebSocket conectado');
        setStatus('connected');
        setReconnectAttempts(0);
        startHeartbeat();
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);

          // Responder ao ping com pong
          if (message.type === 'ping') {
            ws.send(JSON.stringify({ type: 'pong' }));
          }

          // Calcular lat√™ncia do ping
          if (message.type === 'pong') {
            const latency = Date.now() - pingStartTimeRef.current;
            setPingLatency(latency);
          }

          // Dispatchar evento customizado para outros componentes
          const customEvent = new CustomEvent('websocket-message', {
            detail: message
          });
          window.dispatchEvent(customEvent);
        } catch (error) {
          console.error('Erro ao processar mensagem WebSocket:', error);
        }
      };

      ws.onclose = (event) => {
        console.log('WebSocket fechado:', event.code, event.reason);
        setSocket(null);
        clearHeartbeat();

        if (shouldReconnectRef.current && reconnectAttempts < maxReconnectAttempts) {
          setStatus('reconnecting');
          const delay = calculateReconnectDelay(reconnectAttempts);

          reconnectTimeoutRef.current = setTimeout(() => {
            setReconnectAttempts(prev => prev + 1);
            connect();
          }, delay);
        } else {
          setStatus('disconnected');
        }
      };

      ws.onerror = (error) => {
        console.error('Erro WebSocket:', error);
        setStatus('error');
      };

    } catch (error) {
      console.error('Erro ao criar WebSocket:', error);
      setStatus('error');
    }
  }, [url, startHeartbeat, reconnectAttempts, maxReconnectAttempts, calculateReconnectDelay]);

  const disconnect = useCallback(() => {
    shouldReconnectRef.current = false;
    clearHeartbeat();
    clearReconnectTimeout();

    if (socket) {
      socket.close();
      setSocket(null);
    }

    setStatus('disconnected');
    setReconnectAttempts(0);
  }, [socket, clearHeartbeat, clearReconnectTimeout]);

  const sendMessage = useCallback((type: string, data?: any): boolean => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      try {
        socket.send(JSON.stringify({ type, data }));
        return true;
      } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
        return false;
      }
    }
    return false;
  }, [socket]);

  // ‚úÖ CORRE√á√ÉO: useEffect para autoConnect sem depend√™ncias problem√°ticas
  useEffect(() => {
    if (autoConnect && url && url !== '') {
      connect();
    }

    return () => {
      disconnect();
    };
  }, [autoConnect, url]); // ‚úÖ REMOVIDO: connect e disconnect das depend√™ncias para evitar loop

  return {
    socket,
    status,
    isConnected: status === 'connected',
    pingLatency,
    reconnectAttempts,
    connect,
    disconnect,
    sendMessage,
  };
}

// =============================================================================
// LOCAL STORAGE HOOK
// =============================================================================
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  // State to store our value
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);

      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}

// =============================================================================
// DEBOUNCE HOOK
// =============================================================================
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// =============================================================================
// ASYNC OPERATION HOOK
// =============================================================================
export function useAsync<T, E = string>(
  asyncFunction: () => Promise<T>,
  immediate = true
) {
  const [status, setStatus] = useState<'idle' | 'pending' | 'success' | 'error'>('idle');
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<E | null>(null);

  const execute = useCallback(async () => {
    setStatus('pending');
    setData(null);
    setError(null);

    try {
      const response = await asyncFunction();
      setData(response);
      setStatus('success');
      return response;
    } catch (error) {
      setError(error as E);
      setStatus('error');
      throw error;
    }
  }, [asyncFunction]);

  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return {
    execute,
    status,
    data,
    error,
    isLoading: status === 'pending',
    isError: status === 'error',
    isSuccess: status === 'success',
    isIdle: status === 'idle',
  };
}

// =============================================================================
// FORM HOOK
// =============================================================================
export function useForm<T extends Record<string, any>>(
  initialValues: T,
  onSubmit: (values: T) => void | Promise<void>
) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [touched, setTouchedState] = useState<Partial<Record<keyof T, boolean>>>({});

  const setValue = useCallback((name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));

    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: undefined }));
    }
  }, [errors]);

  const setError = useCallback((name: keyof T, error: string) => {
    setErrors(prev => ({ ...prev, [name]: error }));
  }, []);

  const setTouched = useCallback((name: keyof T, isTouched = true) => {
    setTouchedState(prev => ({ ...prev, [name]: isTouched }));
  }, []);

  const handleChange = useCallback((name: keyof T) => (
    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    setValue(name, event.target.value);
  }, [setValue]);

  const handleSubmit = useCallback(async (event?: React.FormEvent) => {
    if (event) {
      event.preventDefault();
    }

    setIsSubmitting(true);

    try {
      await onSubmit(values);
    } catch (error) {
      console.error('Form submission error:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [values, onSubmit]);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouchedState({});
    setIsSubmitting(false);
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    setValue,
    setError,
    setTouched,
    handleChange,
    handleSubmit,
    reset,
    hasErrors: Object.keys(errors).length > 0,
  };
}

// =============================================================================
// COUNTDOWN HOOK
// =============================================================================
export function useCountdown(initialTime: number) {
  const [timeLeft, setTimeLeft] = useState(initialTime);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const start = useCallback(() => {
    if (!isRunning) {
      setIsRunning(true);
    }
  }, [isRunning]);

  const pause = useCallback(() => {
    setIsRunning(false);
  }, []);

  const reset = useCallback((newTime?: number) => {
    setIsRunning(false);
    setTimeLeft(newTime ?? initialTime);
  }, [initialTime]);

  const stop = useCallback(() => {
    setIsRunning(false);
    setTimeLeft(0);
  }, []);

  useEffect(() => {
    if (isRunning && timeLeft > 0) {
      intervalRef.current = setInterval(() => {
        setTimeLeft(prev => {
          if (prev <= 1) {
            setIsRunning(false);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    } else {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [isRunning, timeLeft]);

  const formatTime = useCallback((seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  }, []);

  return {
    timeLeft,
    isRunning,
    start,
    pause,
    reset,
    stop,
    formatTime: formatTime(timeLeft),
    isFinished: timeLeft === 0,
  };
}

// =============================================================================
// KEYBOARD HOOK
// =============================================================================
export function useKeyboard(key: string, callback: () => void, deps: any[] = []) {
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.key === key) {
        callback();
      }
    };

    document.addEventListener('keydown', handleKeyPress);
    return () => document.removeEventListener('keydown', handleKeyPress);
  }, [key, callback, ...deps]);
}

// =============================================================================
// ONLINE STATUS HOOK
// =============================================================================
export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );

  useEffect(() => {
    const setOnline = () => setIsOnline(true);
    const setOffline = () => setIsOnline(false);

    window.addEventListener('online', setOnline);
    window.addEventListener('offline', setOffline);

    return () => {
      window.removeEventListener('online', setOnline);
      window.removeEventListener('offline', setOffline);
    };
  }, []);

  return isOnline;
}

// =============================================================================
// COPY TO CLIPBOARD HOOK
// =============================================================================
export function useCopyToClipboard() {
  const [copiedText, setCopiedText] = useState<string | null>(null);

  const copy = useCallback(async (text: string) => {
    if (!navigator?.clipboard) {
      console.warn('Clipboard not supported');
      return false;
    }

    try {
      await navigator.clipboard.writeText(text);
      setCopiedText(text);
      toast.success('Copiado para a √°rea de transfer√™ncia!');

      // Clear copied text after 3 seconds
      setTimeout(() => setCopiedText(null), 3000);

      return true;
    } catch (error) {
      console.warn('Copy failed', error);
      toast.error('Falha ao copiar');
      setCopiedText(null);
      return false;
    }
  }, []);

  return { copy, copiedText };
}

// =============================================================================
// INTERSECTION OBSERVER HOOK
// =============================================================================
export function useIntersectionObserver(
  elementRef: React.RefObject<Element>,
  options?: IntersectionObserverInit
) {
  const [isIntersecting, setIsIntersecting] = useState(false);

  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => setIsIntersecting(entry?.isIntersecting || false),
      options
    );

    observer.observe(element);
    return () => observer.unobserve(element);
  }, [elementRef, options]);

  return isIntersecting;
}

// =============================================================================
// PREVIOUS VALUE HOOK
// =============================================================================
export function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T>();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

// =============================================================================
// WINDOW SIZE HOOK
// =============================================================================
export function useWindowSize() {
  const [windowSize, setWindowSize] = useState<{
    width: number | undefined;
    height: number | undefined;
  }>({
    width: undefined,
    height: undefined,
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener('resize', handleResize);
    handleResize(); // Set initial size

    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return windowSize;
}

// =============================================================================
// ROUTE PROTECTION HOOK
// =============================================================================
export function useProtectedRoute(redirectTo = '/auth/login') {
  const router = useRouter();

  // This would typically use your auth context
  // For now, just a placeholder
  const isAuthenticated = false; // Replace with actual auth check

  useEffect(() => {
    if (!isAuthenticated) {
      router.push(redirectTo);
    }
  }, [isAuthenticated, router, redirectTo]);

  return isAuthenticated;
}
</file>

<file path="frontend/src/pages/auth/login.tsx">
// üê∫ WEREWOLF - Login Page
// Werewolf inspired login interface with Magic Login

import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import Link from 'next/link';
import { motion } from 'framer-motion';
import { Eye, EyeOff, Mail, Lock, LogIn, AlertCircle } from 'lucide-react';
import { toast } from 'react-hot-toast';

import { useAuth } from '@/context/AuthContext';
import { useTheme } from '@/context/ThemeContext';
import { useForm } from '@/hooks';
import { LoginRequest } from '@/types';
import Layout from '@/components/common/Layout';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// LOGIN PAGE COMPONENT
// =============================================================================
export default function LoginPage() {
  const router = useRouter();
  const { login, isAuthenticated, isLoading } = useAuth();
  const { playSound } = useTheme();
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  // ‚úÖ NOVO: Gerar credenciais de dev uma √∫nica vez por renderiza√ß√£o
  // Usamos useState para que o valor n√£o mude a cada re-render do componente
  const [devCredentials] = useState(() => {
    if (process.env.NODE_ENV === 'development') {
      const randomId = Math.floor(Math.random() * 1000);
      const userTypes = ['player', 'admin', 'test', 'demo', 'dev'];
      const randomType = userTypes[Math.floor(Math.random() * userTypes.length)];

      return {
        email: `${randomType}_${randomId}@dev.test`,
        password: 'password123', // A senha pode ser fixa, pois ser√° ignorada pelo backend
      };
    }
    return null;
  });

  // Form management
  const {
    values,
    errors,
    touched,
    handleChange,
    handleSubmit,
    setError: setFieldError,
    setTouched,
    setValue, // ‚úÖ Adicionar setValue para preencher campos programaticamente
  } = useForm<LoginRequest>(
    {
      email: '',
      password: '',
    },
    async (formData) => {
      if (!validateForm(formData)) return;

      setIsSubmitting(true);
      setError('');

      try {
        await login(formData);
        // Se chegou aqui, o login foi bem-sucedido
        toast.success('Login realizado com sucesso!');
      } catch (loginError: any) {
        // Captura erros espec√≠ficos do login
        const errorMessage = loginError?.message || 'Erro no login. Tente novamente.';
        setError(errorMessage);
        toast.error(errorMessage);
      } finally {
        setIsSubmitting(false);
      }
    }
  );

  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated && !isLoading) {
      const redirectTo = router.query.redirect as string || '/lobby';
      router.push(redirectTo);
    }
  }, [isAuthenticated, isLoading, router]);

  // Form validation
  const validateForm = (data: LoginRequest): boolean => {
    let isValid = true;
    setError('');

    // Email validation
    if (!data.email) {
      setFieldError('email', 'Email √© obrigat√≥rio');
      isValid = false;
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
      setFieldError('email', 'Email inv√°lido');
      isValid = false;
    }

    // Password validation
    if (!data.password) {
      setFieldError('password', 'Senha √© obrigat√≥ria');
      isValid = false;
    } else if (data.password.length < 6) {
      setFieldError('password', 'Senha deve ter pelo menos 6 caracteres');
      isValid = false;
    }

    return isValid;
  };

  // ‚úÖ Fun√ß√£o para preencher credenciais de desenvolvimento
  const fillDevCredentials = () => {
    if (devCredentials) {
      setValue('email', devCredentials.email);
      setValue('password', devCredentials.password);
      playSound('button_click');
      toast.success('Credenciais de desenvolvimento preenchidas!');
    }
  };

  // Show loading if checking authentication
  if (isLoading) {
    return <LoadingSpinner variant="medieval" size="xl" text="Verificando autentica√ß√£o..." />;
  }

  return (
    <>
      <Head>
        <title>Login - Werewolf</title>
        <meta name="description" content="Fa√ßa login na sua conta do Werewolf" />
      </Head>

      <Layout variant="auth">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="card-medieval p-8"
        >
          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: 'spring' }}
              className="text-6xl mb-4"
            >
              üê∫
            </motion.div>
            <h1 className="text-2xl font-medieval text-glow mb-2">
              Entrar na Vila
            </h1>
            <p className="text-white/70">
              Fa√ßa login para come√ßar a jogar
            </p>
          </div>

          {/* Display de erro geral */}
          {error && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              className="mb-6 p-4 bg-red-900/30 border border-red-500/50 rounded-lg flex items-center gap-3"
            >
              <AlertCircle className="w-5 h-5 text-red-400 flex-shrink-0" />
              <p className="text-red-300 text-sm">{error}</p>
            </motion.div>
          )}

          {/* Google Login Button */}
          <Button
            variant="ghost"
            size="lg"
            onClick={() => {
              playSound('button_click');
              console.log('Google login clicked');
              toast('Login com Google ser√° implementado em breve');
              // TODO: Implementar login com Google
            }}
            className="w-full border border-white/20 hover:border-white/40 mb-6"
            disabled={isSubmitting}
          >
            <svg className="w-5 h-5 mr-3" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
              />
              <path
                fill="currentColor"
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
              />
              <path
                fill="currentColor"
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
              />
              <path
                fill="currentColor"
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
              />
            </svg>
            Continuar com Google
          </Button>

          {/* Divider */}
          <div className="my-6 flex items-center">
            <div className="flex-1 border-t border-medieval-600"></div>
            <span className="px-4 text-white/50 text-sm">ou</span>
            <div className="flex-1 border-t border-medieval-600"></div>
          </div>

          {/* Login Form */}
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Email Field */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Email
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Mail className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="email"
                  type="email"
                  value={values.email}
                  onChange={handleChange('email')}
                  onBlur={() => setTouched('email')}
                  className={`
                    w-full pl-10 pr-4 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.email && touched.email
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="seu@email.com"
                  disabled={isSubmitting}
                />
              </div>
              {errors.email && touched.email && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.email}
                </motion.p>
              )}
            </div>

            {/* Password Field */}
            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-white/90 mb-2"
              >
                Senha
              </label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Lock className="h-5 w-5 text-white/40" />
                </div>
                <input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  value={values.password}
                  onChange={handleChange('password')}
                  onBlur={() => setTouched('password')}
                  className={`
                    w-full pl-10 pr-12 py-3 bg-medieval-800/50 border rounded-lg
                    text-white placeholder-white/50 transition-colors
                    focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent
                    ${errors.password && touched.password
                      ? 'border-red-500 focus:ring-red-500'
                      : 'border-medieval-600 hover:border-salem-500'
                    }
                  `}
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  disabled={isSubmitting}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-white/40 hover:text-white/70 transition-colors"
                  disabled={isSubmitting}
                >
                  {showPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>
              {errors.password && touched.password && (
                <motion.p
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="mt-2 text-sm text-red-400"
                >
                  {errors.password}
                </motion.p>
              )}
            </div>

            {/* Forgot Password Link */}
            <div className="text-right">
              <Link
                href="/auth/forgot-password"
                className="text-sm text-salem-400 hover:text-salem-300 transition-colors"
              >
                Esqueceu sua senha?
              </Link>
            </div>

            {/* Submit Button */}
            <Button
              type="submit"
              variant="medieval"
              size="lg"
              disabled={isSubmitting}
              loading={isSubmitting}
              className="w-full"
            >
              <LogIn className="w-5 h-5 mr-2" />
              {isSubmitting ? 'Entrando...' : 'Entrar'}
            </Button>
          </form>

          {/* Register Link */}
          <div className="text-center mt-8">
            <p className="text-white/70 mb-4">
              Ainda n√£o tem uma conta?
            </p>
            <Button
              variant="ghost"
              onClick={() => router.push('/auth/register')}
              className="w-full"
              disabled={isSubmitting}
            >
              Criar Conta Gratuita
            </Button>
          </div>

          {/* ‚úÖ‚úÖ‚úÖ NOVO BLOCO DE DESENVOLVIMENTO COM CREDENCIAIS DIN√ÇMICAS ‚úÖ‚úÖ‚úÖ */}
          {devCredentials && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 1 }}
              className="mt-8 p-4 bg-gradient-to-r from-blue-900/20 to-purple-900/20 border border-blue-500/30 rounded-lg"
            >
              <div className="flex items-center gap-2 mb-3">
                <span className="text-lg">üß™</span>
                <h4 className="text-sm font-semibold text-blue-300">
                  Modo Desenvolvimento - Magic Login
                </h4>
              </div>

              <p className="text-xs text-blue-200/70 mb-3">
                Credenciais de teste geradas automaticamente:
              </p>

              <div className="bg-black/20 rounded p-3 mb-3">
                <div className="text-xs font-mono text-blue-200">
                  <div className="flex justify-between items-center mb-1">
                    <span>Email:</span>
                    <span className="text-green-300">{devCredentials.email}</span>
                  </div>
                  <div className="flex justify-between items-center">
                    <span>Senha:</span>
                    <span className="text-green-300">{devCredentials.password}</span>
                  </div>
                </div>
              </div>

              <div className="text-xs text-blue-200/60 mb-3">
                ‚ÑπÔ∏è Este email ser√° aceito automaticamente pelo backend (bypassa valida√ß√£o de senha)
              </div>

              <div className="flex gap-2">
                <Button
                  variant="ghost"
                  size="sm"
                  className="flex-1 text-xs border border-blue-500/30 hover:border-blue-400/50"
                  onClick={fillDevCredentials}
                  disabled={isSubmitting}
                >
                  üöÄ Preencher Automaticamente
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  className="text-xs text-blue-300/70"
                  onClick={() => window.location.reload()}
                  disabled={isSubmitting}
                >
                  üîÑ Gerar Novos
                </Button>
              </div>

              <div className="mt-3 pt-3 border-t border-blue-500/20">
                <div className="text-xs text-blue-200/50">
                  <strong>Como funciona:</strong> Emails terminados em <code className="bg-black/30 px-1 rounded">@dev.test</code> s√£o automaticamente aceitos em desenvolvimento, criando usu√°rios na hora se necess√°rio.
                </div>
              </div>
            </motion.div>
          )}
          {/* ‚úÖ‚úÖ‚úÖ FIM DO NOVO BLOCO DE DESENVOLVIMENTO ‚úÖ‚úÖ‚úÖ */}
        </motion.div>

        {/* Background Elements */}
        <div className="fixed inset-0 overflow-hidden pointer-events-none z-[-1]">
          {[...Array(3)].map((_, i) => (
            <motion.div
              key={i}
              className="absolute text-8xl opacity-5"
              style={{
                top: `${20 + i * 30}%`,
                left: `${10 + i * 30}%`,
              }}
              animate={{
                y: [0, -20, 0],
                rotate: [0, 5, -5, 0],
              }}
              transition={{
                duration: 6 + i * 2,
                repeat: Infinity,
                ease: 'easeInOut',
              }}
            >
              üê∫
            </motion.div>
          ))}
        </div>
      </Layout>
    </>
  );
}
</file>

<file path="frontend/src/pages/game/[gameId].tsx">
import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import { GameProvider } from '@/context/GameContext';
import { useSocket } from '@/context/SocketContext';
import { useAuth } from '@/context/AuthContext';
import GameBoard from '@/components/game/GameBoard';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import ErrorBoundary from '@/components/common/ErrorBoundary';

// =============================================================================
// GAME PAGE COMPONENT
// =============================================================================
export default function GamePage() {
  const router = useRouter();
  const { gameId } = router.query;
  const { user, isAuthenticated, getToken } = useAuth();
  const { isConnected, connect, disconnect, sendMessage } = useSocket();

  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasRequestedGameState, setHasRequestedGameState] = useState(false);

  // =============================================================================
  // AUTHENTICATION CHECK
  // =============================================================================
  useEffect(() => {
    if (!router.isReady) return;

    if (!isAuthenticated) {
      router.push('/auth/login');
      return;
    }

    if (!gameId || typeof gameId !== 'string') {
      setError('ID do jogo inv√°lido');
      setIsLoading(false);
      return;
    }

    setIsLoading(false);
  }, [router.isReady, isAuthenticated, gameId, router]);

  // =============================================================================
  // WEBSOCKET CONNECTION - CONEX√ÉO PARA O JOGO (CORRIGIDA)
  // =============================================================================
  useEffect(() => {
    if (!router.isReady || !isAuthenticated || !gameId || typeof gameId !== 'string') return;

    const token = getToken();
    if (!token) {
      router.push('/auth/login');
      return;
    }

    // ‚úÖ IMPORTANTE: A URL agora √© do JOGO, n√£o mais da SALA
    const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001'}/ws/${gameId}?token=${encodeURIComponent(token)}`;

    // Conecta se n√£o estiver conectado
    if (!isConnected) {
      console.log('üîå Connecting to game WebSocket:', wsUrl);
      connect(wsUrl);
    }

    // Cleanup na desmontagem do componente
    return () => {
      if (isConnected) {
        console.log('üîå Disconnecting from game WebSocket');
        disconnect();
      }
    };
  }, [router.isReady, gameId, isAuthenticated, isConnected, connect, disconnect, getToken, router]);

  // =============================================================================
  // REQUEST INITIAL GAME STATE (CORRIGIDO)
  // =============================================================================
  useEffect(() => {
    if (!isConnected || !gameId || hasRequestedGameState) return;

    // ‚úÖ Assim que estiver conectado, pede o estado do jogo
    console.log(`üöÄ Requesting initial game state for game: ${gameId}`);

    const success = sendMessage('get-game-state', { gameId });
    if (success) {
      setHasRequestedGameState(true);
    }
  }, [isConnected, gameId, hasRequestedGameState, sendMessage]);

  // =============================================================================
  // ERROR HANDLING
  // =============================================================================
  const handleBackToLobby = () => {
    // Desconecta antes de voltar ao lobby
    if (isConnected) {
      disconnect();
    }
    router.push('/lobby');
  };

  const handleRetry = () => {
    setError(null);
    setHasRequestedGameState(false);

    if (gameId && user) {
      const token = getToken();
      if (token) {
        const wsUrl = `${process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001'}/ws/${gameId}?token=${encodeURIComponent(token)}`;
        connect(wsUrl);
      }
    }
  };

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="xl" />
          <p className="text-gray-300 mt-4">Carregando jogo...</p>
        </div>
      </div>
    );
  }

  // =============================================================================
  // ERROR STATE
  // =============================================================================
  if (error) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center max-w-md mx-auto p-6">
          <div className="text-red-400 text-6xl mb-4">‚ö†Ô∏è</div>
          <h1 className="text-2xl font-bold text-white mb-4">Erro ao Carregar Jogo</h1>
          <p className="text-gray-300 mb-6">{error}</p>

          <div className="space-y-3">
            <button
              onClick={handleRetry}
              className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition-colors"
            >
              Tentar Novamente
            </button>

            <button
              onClick={handleBackToLobby}
              className="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition-colors"
            >
              Voltar ao Lobby
            </button>
          </div>
        </div>
      </div>
    );
  }

  // =============================================================================
  // CONNECTION STATE
  // =============================================================================
  if (!isConnected) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-pulse">
            <div className="text-yellow-400 text-6xl mb-4">üåô</div>
          </div>
          <h2 className="text-xl font-bold text-white mb-2">Conectando ao Jogo</h2>
          <p className="text-gray-300">Estabelecendo conex√£o...</p>

          <button
            onClick={handleBackToLobby}
            className="mt-6 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
          >
            Cancelar
          </button>
        </div>
      </div>
    );
  }

  // =============================================================================
  // MAIN GAME RENDER
  // =============================================================================
  return (
    <ErrorBoundary>
      <GameProvider gameId={gameId as string}>
        <div className="min-h-screen bg-gray-900">
          {/* Game Header */}
          <div className="bg-gray-800 border-b border-gray-700 px-4 py-2">
            <div className="max-w-7xl mx-auto flex items-center justify-between">
              <div className="flex items-center space-x-4">
                <h1 className="text-xl font-bold text-white">
                  üê∫ Lobisomem Online
                </h1>
                <div className="text-sm text-gray-400">
                  Jogo: {gameId}
                </div>
              </div>

              <div className="flex items-center space-x-4">
                {/* Connection Status */}
                <div className="flex items-center space-x-2">
                  <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-400' : 'bg-red-400'}`} />
                  <span className="text-sm text-gray-400">
                    {isConnected ? 'Conectado' : 'Desconectado'}
                  </span>
                </div>

                {/* User Info */}
                {user && (
                  <div className="flex items-center space-x-2">
                    <div className="w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center">
                      üë§
                    </div>
                    <span className="text-sm text-white">{user.username}</span>
                  </div>
                )}

                {/* Back Button */}
                <button
                  onClick={handleBackToLobby}
                  className="bg-gray-700 hover:bg-gray-600 text-white text-sm py-2 px-4 rounded-lg transition-colors"
                >
                  ‚Üê Lobby
                </button>
              </div>
            </div>
          </div>

          {/* Game Board */}
          <GameBoard />
        </div>
      </GameProvider>
    </ErrorBoundary>
  );
}
</file>

<file path="package.json">
{
  "name": "werewolf-online",
  "version": "1.0.0",
  "description": "üê∫ Lobisomem Online - Plataforma de Jogos Multiplayer em Tempo Real",
  "private": true,
  "workspaces": [
    "backend",
    "frontend"
  ],
  "scripts": {
    "//": "--- DOCKER COMMANDS (for complete environment) ---",
    "dev:docker": "docker-compose -f docker-compose.dev.yml up --build",
    "dev:down": "docker-compose -f docker-compose.dev.yml down",
    "dev:clean": "docker-compose -f docker-compose.dev.yml down --volumes --remove-orphans",
    "dev:logs": "docker-compose -f docker-compose.dev.yml logs -f",
    "dev:logs:backend": "docker-compose -f docker-compose.dev.yml logs -f backend",
    "// ": "--- LOCAL DEVELOPMENT (run services individually without Docker) ---",
    "dev:backend": "npm run dev --workspace=backend",
    "dev:frontend": "npm run dev --workspace=frontend",
    "// ": "--- MONOREPO UTILITIES ---",
    "install:all": "npm install",
    "build:all": "npm run build --workspaces",
    "lint:all": "npm run lint --workspaces --if-present",
    "test:all": "npm run test --workspaces --if-present"
  },
  "keywords": [
    "werewolf",
    "game",
    "multiplayer",
    "websocket",
    "realtime",
    "typescript",
    "monorepo"
  ],
  "author": "Werewolf Team",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.9.0"
  }
}
</file>

<file path="backend/src/controllers/roomController.ts">
import { Request, Response } from 'express';
import { pool } from '@/config/database';
import { generateRoomCode } from '@/utils/helper';
import { logger } from '@/utils/logger';
import { ERROR_MESSAGES, GAME_LIMITS } from '@/utils/constants';
import { validateCreateRoomRequest, validateRoomCode } from '@/utils/simpleValidators';
import type { ApiResponse } from '@/types';
import type { Room, RoomStatus } from '@/types';

export const listRooms = async (req: Request, res: Response): Promise<void> => {
  try {
    logger.info('Listing public rooms', { userId: req.userId });

    const roomsQuery = `
            SELECT 
                r.id, r.name, r."isPrivate", r."maxPlayers", r."maxSpectators", 
                r.status, r."createdAt", u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r."isPrivate" = false AND r.status IN ('WAITING', 'PLAYING')
            ORDER BY r."createdAt" DESC
            LIMIT 50
        `;
    const roomsResult = await pool.query(roomsQuery);

    const channelManager = req.app.locals.channelManager;

    const roomsMetadata = roomsResult.rows.map((room: any) => {
      const stats = channelManager ? channelManager.getRoomStats(room.id) : null;

      return {
        id: room.id,
        name: room.name,
        isPrivate: room.isPrivate,
        currentPlayers: stats?.playersCount || 0,
        maxPlayers: room.maxPlayers,
        currentSpectators: stats?.spectatorsCount || 0,
        maxSpectators: room.maxSpectators,
        status: room.status as RoomStatus,
        hostUsername: room.hostUsername,
        createdAt: room.createdAt,
        canJoin: room.status === 'WAITING' && (stats?.playersCount || 0) < room.maxPlayers,
        isFull: (stats?.playersCount || 0) >= room.maxPlayers
      };
    });

    res.json({
      success: true,
      data: {
        rooms: roomsMetadata,
        total: roomsMetadata.length
      },
      message: 'Salas p√∫blicas listadas com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to list rooms', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const createRoom = async (req: Request, res: Response): Promise<void> => {
  try {
    const validation = validateCreateRoomRequest(req.body);
    if (!validation.success) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: validation.error,
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { name, isPrivate, maxPlayers, maxSpectators } = validation.data!;

    const existingRoomQuery = `
            SELECT id, name, status FROM rooms 
            WHERE "hostId" = $1 AND status IN ('WAITING', 'PLAYING')
        `;
    const existingRoomResult = await pool.query(existingRoomQuery, [req.userId]);

    if (existingRoomResult.rows.length > 0) {
      logger.warn('User creating room while having active room', {
        userId: req.userId,
        username: req.username,
        existingRooms: existingRoomResult.rows,
        action: 'creating_new_room_anyway'
      });

      try {
        await pool.query(`DELETE FROM rooms WHERE "hostId" = $1 AND status IN ('WAITING', 'PLAYING')`, [req.userId]);
        logger.info('Cleaned up orphaned rooms for user', {
          userId: req.userId,
          cleanedRooms: existingRoomResult.rows.length
        });
      } catch (cleanupError) {
        logger.error('Failed to cleanup orphaned rooms', cleanupError instanceof Error ? cleanupError : new Error('Unknown cleanup error'), {
          userId: req.userId
        });
      }
    }

    let roomCode: string | undefined;
    if (isPrivate) {
      let attempts = 0;
      do {
        roomCode = generateRoomCode();
        const existingCodeQuery = `SELECT id FROM rooms WHERE code = $1`;
        const existingCodeResult = await pool.query(existingCodeQuery, [roomCode]);
        if (existingCodeResult.rows.length === 0) break;
        attempts++;
      } while (attempts < 10);

      if (attempts >= 10) {
        res.status(500).json({
          success: false,
          error: ERROR_MESSAGES.SERVER_ERROR,
          message: 'N√£o foi poss√≠vel gerar c√≥digo √∫nico',
          timestamp: new Date().toISOString(),
        } as ApiResponse);
        return;
      }
    }

    const createRoomQuery = `
            INSERT INTO rooms (name, code, "isPrivate", "maxPlayers", "maxSpectators", "hostId", status, "serverId", "createdAt", "updatedAt")
            VALUES ($1, $2, $3, $4, $5, $6, 'WAITING', 'local-server', NOW(), NOW())
            RETURNING *
        `;
    const roomResult = await pool.query(createRoomQuery, [
      name,
      roomCode,
      isPrivate || false,
      maxPlayers || GAME_LIMITS.MAX_PLAYERS,
      maxSpectators || GAME_LIMITS.MAX_SPECTATORS,
      req.userId
    ]);
    const room = roomResult.rows[0];

    logger.info('Room created successfully', {
      roomId: room.id,
      hostId: req.userId,
      code: roomCode,
      isPrivate,
      hadOrphanedRooms: existingRoomResult.rows.length > 0
    });

    const wsUrl = `ws://localhost:3001/ws/room/${room.id}`;

    res.status(201).json({
      success: true,
      data: {
        room: {
          id: room.id,
          name: room.name,
          code: room.code,
          isPrivate: room.isPrivate,
          maxPlayers: room.maxPlayers,
          maxSpectators: room.maxSpectators,
          status: room.status,
          hostId: room.hostId,
          hostUsername: req.username,
          currentPlayers: 0,
          currentSpectators: 0,
          serverId: room.serverId,
          createdAt: room.createdAt,
          updatedAt: room.updatedAt
        },
        wsUrl,
        joinUrl: wsUrl,
        code: room.code
      },
      message: 'Sala criada com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to create room', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      username: req.username,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const joinRoom = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id: roomId } = req.params;
    const { asSpectator = false } = req.body;

    const roomQuery = `
            SELECT r.*, u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r.id = $1
        `;
    const roomResult = await pool.query(roomQuery, [roomId]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    if (room.status !== 'WAITING') {
      res.status(409).json({
        success: false,
        error: 'ROOM_NOT_JOINABLE',
        message: 'A sala n√£o est√° aceitando novos jogadores',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, username, avatar FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [req.userId]);

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'USER_NOT_FOUND',
        message: 'Usu√°rio n√£o encontrado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];

    const player = {
      id: `${roomId}-${user.id}`,
      userId: user.id,
      username: user.username,
      avatar: user.avatar,
      isHost: room.hostId === user.id,
      isReady: false,
      isSpectator: asSpectator,
      isConnected: false,
      joinedAt: new Date(),
      lastSeen: new Date()
    };

    const wsUrl = `ws://localhost:3001/ws/room/${roomId}`;

    res.json({
      success: true,
      data: {
        room: {
          id: room.id,
          name: room.name,
          code: room.code,
          isPrivate: room.isPrivate,
          maxPlayers: room.maxPlayers,
          maxSpectators: room.maxSpectators,
          status: room.status,
          hostId: room.hostId,
          hostUsername: room.hostUsername,
          currentPlayers: 0,
          currentSpectators: 0,
          serverId: room.serverId,
          createdAt: room.createdAt,
          updatedAt: room.updatedAt
        },
        player,
        wsUrl,
        joinUrl: wsUrl,
        yourRole: player.isHost ? 'HOST' : (player.isSpectator ? 'SPECTATOR' : 'PLAYER')
      },
      message: 'Entrou na sala com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to join room', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      username: req.username,
      roomId: req.params.id,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const joinRoomByCode = async (req: Request, res: Response): Promise<void> => {
  try {
    const { code } = req.body;

    if (!code || !validateRoomCode(code)) {
      res.status(400).json({
        success: false,
        error: ERROR_MESSAGES.VALIDATION_FAILED,
        message: 'C√≥digo inv√°lido - deve ter 6 d√≠gitos',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const { asSpectator = false } = req.body;

    const roomQuery = `
            SELECT r.*, u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r.code = $1
        `;
    const roomResult = await pool.query(roomQuery, [code]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada com este c√≥digo',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    if (room.status !== 'WAITING') {
      res.status(409).json({
        success: false,
        error: 'ROOM_NOT_JOINABLE',
        message: 'A sala n√£o est√° aceitando novos jogadores',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const userQuery = `SELECT id, username, avatar FROM users WHERE id = $1`;
    const userResult = await pool.query(userQuery, [req.userId]);

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'USER_NOT_FOUND',
        message: 'Usu√°rio n√£o encontrado',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const user = userResult.rows[0];

    const player = {
      id: `${room.id}-${user.id}`,
      userId: user.id,
      username: user.username,
      avatar: user.avatar,
      isHost: room.hostId === user.id,
      isReady: false,
      isSpectator: asSpectator,
      isConnected: false,
      joinedAt: new Date(),
      lastSeen: new Date()
    };

    const wsUrl = `ws://localhost:3001/ws/room/${room.id}`;

    res.json({
      success: true,
      data: {
        room: {
          id: room.id,
          name: room.name,
          code: room.code,
          isPrivate: room.isPrivate,
          maxPlayers: room.maxPlayers,
          maxSpectators: room.maxSpectators,
          status: room.status,
          hostId: room.hostId,
          hostUsername: room.hostUsername,
          currentPlayers: 0,
          currentSpectators: 0,
          serverId: room.serverId,
          createdAt: room.createdAt,
          updatedAt: room.updatedAt
        },
        player,
        wsUrl,
        joinUrl: wsUrl,
        yourRole: player.isHost ? 'HOST' : (player.isSpectator ? 'SPECTATOR' : 'PLAYER')
      },
      message: 'Entrou na sala com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to join room by code', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      username: req.username,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const getRoomDetails = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id: roomId } = req.params;

    const roomQuery = `
            SELECT r.*, u.username as "hostUsername"
            FROM rooms r
            JOIN users u ON r."hostId" = u.id
            WHERE r.id = $1
        `;
    const roomResult = await pool.query(roomQuery, [roomId]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    res.json({
      success: true,
      data: {
        id: room.id,
        name: room.name,
        code: room.code,
        isPrivate: room.isPrivate,
        maxPlayers: room.maxPlayers,
        maxSpectators: room.maxSpectators,
        status: room.status,
        hostId: room.hostId,
        hostUsername: room.hostUsername,
        currentPlayers: 0,
        currentSpectators: 0,
        serverId: room.serverId,
        createdAt: room.createdAt,
        updatedAt: room.updatedAt
      },
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to get room details', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      roomId: req.params.id
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};

export const deleteRoom = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id: roomId } = req.params;

    const roomQuery = `SELECT id, "hostId" FROM rooms WHERE id = $1`;
    const roomResult = await pool.query(roomQuery, [roomId]);

    if (roomResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        error: 'ROOM_NOT_FOUND',
        message: 'Sala n√£o encontrada',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    const room = roomResult.rows[0];

    if (room.hostId !== req.userId) {
      res.status(403).json({
        success: false,
        error: ERROR_MESSAGES.FORBIDDEN,
        message: 'Apenas o host pode deletar a sala',
        timestamp: new Date().toISOString(),
      } as ApiResponse);
      return;
    }

    await pool.query(`DELETE FROM rooms WHERE id = $1`, [roomId]);

    logger.info('Room deleted via HTTP API', {
      roomId,
      hostId: req.userId,
      username: req.username
    });

    res.json({
      success: true,
      message: 'Sala deletada com sucesso',
      timestamp: new Date().toISOString(),
    } as ApiResponse);

  } catch (error) {
    logger.error('Failed to delete room', error instanceof Error ? error : new Error('Unknown error'), {
      userId: req.userId,
      roomId: req.params.id
    });

    res.status(500).json({
      success: false,
      error: ERROR_MESSAGES.SERVER_ERROR,
      timestamp: new Date().toISOString(),
    } as ApiResponse);
  }
};
</file>

<file path="backend/src/websocket/WebSocketManager.ts">
// üê∫ LOBISOMEM ONLINE - WebSocket Manager (VERS√ÉO FINAL CORRIGIDA)
import http from 'http';
import { WebSocketServer } from 'ws';
import { verifyAccessToken, extractTokenFromWebSocketRequest } from '@/config/jwt';
import { parseWebSocketURL, extractConnectionMetadata } from '@/config/websocket';
import { wsLogger } from '@/utils/logger';
import { ConnectionManager } from './ConnectionManager';
import { ChannelManager } from './ChannelManager';
import { MessageRouter } from './MessageRouter';
import { GameEngine } from '@/game/GameEngine';
import { HeartbeatManager } from './HeartbeatManager';
import type { IEventBus, ConnectionContext } from '@/types';
import type { Config } from '@/config/environment';

export class WebSocketManager {
  public wss: WebSocketServer | null = null;
  private connectionManager: ConnectionManager;

  // ‚úÖ EXPOSI√á√ÉO P√öBLICA DO CHANNELMANAGER
  public channelManager: ChannelManager;

  private messageRouter: MessageRouter;
  private gameEngine: GameEngine;
  private heartbeatManager: HeartbeatManager;

  constructor(
    private eventBus: IEventBus,
    private config: Config
  ) {
    this.connectionManager = new ConnectionManager();
    this.channelManager = new ChannelManager(this.connectionManager);
    this.heartbeatManager = new HeartbeatManager(this.connectionManager);
    this.gameEngine = new GameEngine();

    this.messageRouter = new MessageRouter(
      this.connectionManager,
      this.channelManager,
      this.gameEngine,
      this.eventBus
    );

    this.messageRouter.setBroadcastMethods(
      this.broadcastToRoom.bind(this),
      this.sendToUser.bind(this)
    );
    this.gameEngine.setSendToUserMethod(this.sendToUser.bind(this));

    wsLogger.info('WebSocketManager initialized with GameEngine integration');
  }

  public setupWebSocketServer(server: http.Server): void {
    this.wss = new WebSocketServer({ noServer: true });

    server.on('upgrade', (request, socket, head) => {
      // ‚úÖ ACEITA QUALQUER CAMINHO QUE COMECE COM /ws
      if (request.url?.startsWith('/ws')) {
        this.wss!.handleUpgrade(request, socket, head, (ws) => {
          this.wss!.emit('connection', ws, request);
        });
      } else {
        wsLogger.warn('WebSocket upgrade rejected for invalid path', { path: request.url });
        socket.destroy();
      }
    });

    this.wss.on('connection', this.handleConnection.bind(this));
    this.heartbeatManager.start();
    wsLogger.info('WebSocket server attached to HTTP upgrade event.');
  }

  private async handleConnection(ws: any, request: any): Promise<void> {
    let connectionId: string | undefined;

    try {
      const urlInfo = parseWebSocketURL(request.url || '');
      const token = extractTokenFromWebSocketRequest(request);

      if (!token) {
        wsLogger.warn('Connection rejected: No authentication token', {
          url: request.url,
          userAgent: request.headers['user-agent'],
        });
        return ws.close(1008, 'Authentication token required');
      }

      const jwtPayload = verifyAccessToken(token);

      // ‚úÖ L√ìGICA DE DIFERENCIA√á√ÉO SALA vs JOGO
      let roomIdFromUrl = urlInfo.roomId;
      let isGameConnection = false;

      if (roomIdFromUrl && roomIdFromUrl.startsWith('game-')) {
        isGameConnection = true;
        // Extrai o roomId real de um gameId, ex: "game-abc" -> "abc"
        roomIdFromUrl = roomIdFromUrl.substring(5);
      }

      const context: ConnectionContext = {
        userId: jwtPayload.userId,
        username: jwtPayload.username,
        serverId: this.config.SERVICE_ID,
        isSpectator: false,
        roomId: roomIdFromUrl, // Armazena o roomId limpo
      };

      const metadata = extractConnectionMetadata(request);
      connectionId = `${context.userId}-${Date.now()}`;

      this.connectionManager.addConnection(connectionId, ws, context, metadata);

      // Setup event handlers
      ws.on('message', (data: Buffer) => {
        try {
          const message = JSON.parse(data.toString());
          this.messageRouter.handleMessage(connectionId!, message);
        } catch (error) {
          wsLogger.error('Failed to parse message', error as Error, { connectionId });
        }
      });

      ws.on('pong', () => this.heartbeatManager.handlePong(connectionId!));

      ws.on('close', (code: number, reason: Buffer) => {
        this.handleDisconnection(connectionId!, code, reason.toString());
      });

      ws.on('error', (error: Error) => {
        wsLogger.error('WS Connection Error', error, { connectionId });
      });

      // Send connection confirmation
      this.sendToConnection(connectionId, 'connected', {
        userId: context.userId,
        username: context.username,
        serverId: context.serverId,
      });

      // ‚úÖ AQUI EST√Å A MUDAN√áA CR√çTICA DE FLUXO
      if (isGameConnection) {
        // Se √© uma conex√£o de JOGO, apenas pe√ßa o estado do jogo.
        // O frontend na p√°gina do jogo √© quem vai enviar esta mensagem.
        wsLogger.info('Game connection established, waiting for get-game-state', {
          connectionId,
          gameId: urlInfo.roomId,
          roomId: roomIdFromUrl
        });
      } else if (context.roomId) {
        // Se √© uma conex√£o de SALA, acione o `join-room`.
        await this.messageRouter.handleMessage(connectionId, {
          type: 'join-room',
          data: { roomId: context.roomId }
        });
      }

      wsLogger.info('WebSocket connection established', {
        connectionId,
        userId: context.userId,
        username: context.username,
        roomId: context.roomId,
        isGameConnection,
        originalUrl: urlInfo.roomId,
        userAgent: metadata.userAgent,
        ip: metadata.ip,
      });

    } catch (error) {
      wsLogger.error('Connection failed during handshake', error as Error, {
        url: request.url,
        connectionId,
      });
      ws.close(1008, 'Authentication failed');
    }
  }

  private handleDisconnection(connectionId: string, code: number, reason: string): void {
    const connection = this.connectionManager.getConnection(connectionId);

    if (connection) {
      wsLogger.info('WebSocket connection closed', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId: connection.context.roomId,
        code,
        reason,
      });

      // Leave room if connected
      if (connection.context.roomId) {
        this.channelManager.leaveRoom(connection.context.roomId, connectionId);
      }

      // ‚úÖ VERIFICA√á√ÉO DE SEGURAN√áA ANTES DE USAR O EVENTBUS
      if (this.eventBus && typeof this.eventBus.publish === 'function') {
        this.eventBus.publish('connection:disconnected', {
          connectionId,
          userId: connection.context.userId,
          username: connection.context.username,
          roomId: connection.context.roomId,
          code,
          reason,
          timestamp: new Date().toISOString(),
        });
      } else {
        wsLogger.warn('EventBus not available for disconnection event', { connectionId });
      }
    }

    this.connectionManager.removeConnection(connectionId);
  }

  public sendToConnection = (connectionId: string, type: string, data?: any): boolean => {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || connection.ws.readyState !== connection.ws.OPEN) {
      return false;
    }

    try {
      const message = {
        type,
        data,
        timestamp: new Date().toISOString(),
      };

      connection.ws.send(JSON.stringify(message));
      return true;
    } catch (error) {
      wsLogger.error('Failed to send message to connection', error as Error, {
        connectionId,
        type,
      });
      return false;
    }
  };

  public sendToUser = (userId: string, type: string, data?: any): boolean => {
    const connection = this.connectionManager.findConnectionByUserId(userId);
    if (!connection) {
      wsLogger.debug('No active connection found for user', { userId, type });
      return false;
    }

    return this.sendToConnection(connection.id, type, data);
  };

  // ‚úÖ M√âTODO COM LOGS DETALHADOS PARA DEBUG
  public broadcastToRoom = (roomId: string, type: string, data?: any, excludeConnectionId?: string): number => {
    console.log('üî• BROADCAST: Tentando fazer broadcast', {
      roomId,
      type,
      hasData: !!data,
      excludeConnectionId,
      timestamp: new Date().toISOString()
    });

    const roomConnections = this.channelManager.getRoomConnections(roomId);

    console.log('üî• BROADCAST: Conex√µes na sala', {
      roomId,
      totalConnections: roomConnections.size,
      connections: Array.from(roomConnections),
      timestamp: new Date().toISOString()
    });

    let sentCount = 0;

    for (const connectionId of roomConnections) {
      if (excludeConnectionId && connectionId === excludeConnectionId) {
        console.log('üî• BROADCAST: Pulando conex√£o exclu√≠da', { connectionId });
        continue;
      }

      const success = this.sendToConnection(connectionId, type, data);

      console.log('üî• BROADCAST: Tentativa de envio', {
        connectionId,
        success,
        type,
        timestamp: new Date().toISOString()
      });

      if (success) {
        sentCount++;
      }
    }

    console.log('üî• BROADCAST: Broadcast realizado', {
      roomId,
      type,
      totalConnections: roomConnections.size,
      sentCount,
      timestamp: new Date().toISOString()
    });

    wsLogger.debug('Broadcast to room completed', {
      roomId,
      type,
      totalConnections: roomConnections.size,
      sentCount,
      excludedConnection: excludeConnectionId,
    });

    return sentCount;
  };

  public broadcastToAll = (type: string, data?: any): number => {
    const allConnections = this.connectionManager.getAllConnections();
    let sentCount = 0;

    for (const [connectionId] of allConnections) {
      if (this.sendToConnection(connectionId, type, data)) {
        sentCount++;
      }
    }

    wsLogger.debug('Broadcast to all completed', {
      type,
      totalConnections: allConnections.size,
      sentCount,
    });

    return sentCount;
  };

  public getStats(): any {
    const connectionStats = this.connectionManager.getStats();
    const channelStats = this.channelManager.getStats();

    return {
      connections: connectionStats,
      channels: channelStats,
      games: {
        activeGames: this.gameEngine.getActiveGamesCount(),
        totalGames: this.gameEngine.getAllGames().length,
      },
      server: {
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        serverId: this.config.SERVICE_ID,
      },
    };
  }

  public async forceDisconnectUser(userId: string): Promise<boolean> {
    const connection = this.connectionManager.findConnectionByUserId(userId);
    if (!connection) {
      return false;
    }

    try {
      connection.ws.close(1000, 'Forced disconnect by admin');
      return true;
    } catch (error) {
      wsLogger.error('Failed to force disconnect user', error as Error, { userId });
      return false;
    }
  }

  public async cleanup(): Promise<void> {
    wsLogger.info('Starting WebSocket cleanup...');

    this.heartbeatManager.stop();

    const allConnections = this.connectionManager.getAllConnections();
    for (const [connectionId, connection] of allConnections) {
      try {
        connection.ws.close(1001, 'Server shutdown');
      } catch (error) {
        wsLogger.error('Error closing connection during cleanup', error as Error, { connectionId });
      }
    }

    this.connectionManager.cleanup();
    this.channelManager.cleanup();
    await this.gameEngine.cleanup();

    if (this.wss) {
      this.wss.close();
      this.wss = null;
    }

    wsLogger.info('WebSocket cleanup completed');
  }
}
</file>

<file path="frontend/src/components/game/ChatGigante.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { useGame } from '@/context/GameContext';
import { useSocket } from '@/context/SocketContext';
import LoadingSpinner from '@/components/common/LoadingSpinner';

// =============================================================================
// TYPES
// =============================================================================
interface ChatMessage {
  id: string;
  userId: string;
  username: string;
  message: string;
  channel: 'public' | 'werewolf' | 'dead' | 'system';
  timestamp: string;
  filtered?: boolean;
}

type ChatTab = 'public' | 'werewolf' | 'dead' | 'system';

// =============================================================================
// CHAT GIGANTE COMPONENT - VERS√ÉO CORRIGIDA USANDO ESTADO CENTRAL
// =============================================================================
export default function ChatGigante() {
  const { gameState, me, chatMessages } = useGame(); // ‚úÖ CORRIGIDO: Usar chatMessages do estado central
  const { sendMessage } = useSocket();


  console.log('üéØ CHAT RENDER TRIGGERED:', {
    timestamp: Date.now(),
    chatMessagesLength: chatMessages.length,
    chatMessagesRef: chatMessages
  });
  console.log('üéØ CHAT RENDER: chatMessages count:', chatMessages.length);
  console.log('üéØ CHAT RENDER: last 3 messages:', chatMessages.slice(-3).map(m => `${m.username}: ${m.message}`));

  const [activeTab, setActiveTab] = useState<ChatTab>('public');
  const [message, setMessage] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // =============================================================================
  // AUTO SCROLL TO BOTTOM
  // =============================================================================
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [chatMessages]); // ‚úÖ CORRIGIDO: Usar chatMessages do estado central

  // ‚úÖ REMOVIDO: O useEffect que ouvia websocket-message foi removido
  // O GameContext agora √© o √∫nico respons√°vel por processar mensagens

  // =============================================================================
  // LOADING STATE
  // =============================================================================
  if (!gameState || !me) {
    return (
      <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex items-center justify-center">
        <LoadingSpinner text="Carregando chat..." />
      </div>
    );
  }

  // =============================================================================
  // DETERMINE AVAILABLE TABS
  // =============================================================================
  const getAvailableTabs = (): ChatTab[] => {
    const tabs: ChatTab[] = ['public'];

    if (me?.role === 'WEREWOLF' || me?.role === 'WEREWOLF_KING') {
      tabs.push('werewolf');
    }

    if (!me?.isAlive) {
      tabs.push('dead');
    }

    tabs.push('system');

    return tabs;
  };

  const availableTabs = getAvailableTabs();

  // =============================================================================
  // FILTER MESSAGES BY TAB
  // =============================================================================
  const getMessagesForTab = (tab: ChatTab): ChatMessage[] => {
    const filteredMessages = chatMessages.filter(msg => { // ‚úÖ CORRIGIDO: Usar chatMessages do estado central
      switch (tab) {
        case 'public':
          return msg.channel === 'public';
        case 'werewolf':
          return msg.channel === 'werewolf';
        case 'dead':
          return msg.channel === 'dead';
        case 'system':
          return msg.channel === 'system';
        default:
          return false;
      }
    });

    // ‚úÖ LOG DETALHADO: Quantas mensagens temos por aba
    console.log(`üìä ChatGigante: Messages for tab "${tab}":`, {
      total: filteredMessages.length,
      messageIds: filteredMessages.map(m => m.id),
      channels: filteredMessages.map(m => m.channel)
    });

    return filteredMessages;
  };

  // =============================================================================
  // ‚úÖ BUG FIX: CHECK CHAT RESTRICTIONS MELHORADO COM LOGS
  // =============================================================================
  const canSendMessage = () => {
    // Se est√° morto, s√≥ pode falar no chat dos mortos
    if (!me.isAlive && activeTab !== 'dead') {
      console.log('üö´ ChatGigante: Dead player can only use dead chat', {
        userAlive: me.isAlive,
        activeTab
      });
      return false;
    }

    // N√£o pode enviar no canal do sistema
    if (activeTab === 'system') {
      console.log('üö´ ChatGigante: Cannot send to system channel');
      return false;
    }

    // Chat de lobisomens s√≥ para lobisomens
    if (activeTab === 'werewolf' && me.role !== 'WEREWOLF' && me.role !== 'WEREWOLF_KING') {
      console.log('üö´ ChatGigante: Not a werewolf - cannot use werewolf chat', {
        userRole: me.role,
        activeTab
      });
      return false;
    }

    // ‚úÖ BUG FIX: Durante a noite, s√≥ lobisomens podem falar no p√∫blico
    if (gameState.phase === 'NIGHT' && activeTab === 'public' &&
      me.role !== 'WEREWOLF' && me.role !== 'WEREWOLF_KING') {
      console.log('üö´ ChatGigante: Night phase - only werewolves can use public chat', {
        gamePhase: gameState.phase,
        userRole: me.role,
        activeTab
      });
      return false;
    }

    console.log('‚úÖ ChatGigante: Can send message', {
      activeTab,
      userAlive: me.isAlive,
      userRole: me.role,
      gamePhase: gameState?.phase
    });
    return true;
  };

  // =============================================================================
  // ‚úÖ BUG FIX: SEND MESSAGE COM DEBUG DETALHADO E VERIFICA√á√ïES
  // =============================================================================
  const handleSendMessage = async () => {
    if (!message.trim() || !gameState || isSubmitting) {
      console.log('‚ùå ChatGigante: Cannot send message:', {
        hasMessage: !!message.trim(),
        hasGameState: !!gameState,
        isSubmitting,
        messageLength: message.length
      });
      return;
    }

    // ‚úÖ VERIFICAR RESTRI√á√ïES ANTES DE ENVIAR
    if (!canSendMessage()) {
      console.log('‚ùå ChatGigante: Cannot send message - restrictions apply:', {
        activeTab,
        userAlive: me?.isAlive,
        userRole: me?.role,
        gamePhase: gameState?.phase
      });
      return;
    }

    setIsSubmitting(true);

    // ‚úÖ LOG DETALHADO: Tentativa de envio
    console.log('üì§ ChatGigante: Attempting to send message:', {
      message: message.trim(),
      channel: activeTab,
      gameState: !!gameState,
      userId: me?.userId,
      username: me?.username,
      gamePhase: gameState?.phase,
      timestamp: new Date().toISOString()
    });

    try {
      const success = sendMessage('chat-message', {
        message: message.trim(),
        channel: activeTab,
      });

      console.log('üì§ ChatGigante: Message send result:', {
        success,
        message: message.trim(),
        channel: activeTab,
        socketConnected: !!sendMessage
      });

      if (success) {
        setMessage('');
        console.log('‚úÖ ChatGigante: Message sent successfully, input cleared');
      } else {
        console.error('‚ùå ChatGigante: Failed to send message - sendMessage returned false');
      }
    } catch (error) {
      console.error('‚ùå ChatGigante: Error sending message:', error);
    } finally {
      setTimeout(() => {
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  // =============================================================================
  // TAB CONFIGURATION
  // =============================================================================
  const getTabConfig = (tab: ChatTab) => {
    switch (tab) {
      case 'public':
        return {
          name: 'P√∫blico',
          icon: 'üó£Ô∏è',
          color: 'text-white',
          bgColor: 'bg-blue-600',
          available: true,
        };
      case 'werewolf':
        return {
          name: 'Lobisomens',
          icon: 'üê∫',
          color: 'text-red-400',
          bgColor: 'bg-red-600',
          available: me?.role === 'WEREWOLF' || me?.role === 'WEREWOLF_KING',
        };
      case 'dead':
        return {
          name: 'Mortos',
          icon: 'üëª',
          color: 'text-gray-400',
          bgColor: 'bg-gray-600',
          available: !me?.isAlive,
        };
      case 'system':
        return {
          name: 'Sistema',
          icon: '‚öôÔ∏è',
          color: 'text-amber-400',
          bgColor: 'bg-amber-600',
          available: true,
        };
    }
  };

  // =============================================================================
  // MESSAGE COMPONENT
  // =============================================================================
  const ChatMessageComponent = ({ msg }: { msg: ChatMessage }) => {
    const isMe = msg.userId === me?.userId;
    const isSystem = msg.channel === 'system';

    return (
      <div className={`p-2 border-b border-medieval-600/30 ${isMe ? 'bg-blue-900/20' : ''}`}>
        <div className="flex items-start space-x-2">
          {/* Avatar */}
          <div className="flex-shrink-0 w-8 h-8 rounded-full bg-medieval-700 flex items-center justify-center">
            {isSystem ? 'ü§ñ' : isMe ? 'üë§' : 'üßë'}
          </div>

          {/* Message Content */}
          <div className="flex-1 min-w-0">
            <div className="flex items-center space-x-2 mb-1">
              <span className={`font-semibold text-sm ${isMe ? 'text-blue-300' : isSystem ? 'text-amber-300' : 'text-white'}`}>
                {msg.username}
              </span>
              <span className="text-xs text-white/50">
                {new Date(msg.timestamp).toLocaleTimeString('pt-BR', {
                  hour: '2-digit',
                  minute: '2-digit'
                })}
              </span>
              {isSystem && (
                <span className="text-xs bg-amber-600 text-white px-1 rounded">
                  SISTEMA
                </span>
              )}
            </div>

            <div className={`text-sm break-words ${isSystem ? 'text-amber-100' : 'text-white/90'}`}>
              {msg.message}
            </div>
          </div>
        </div>
      </div>
    );
  };

  // ‚úÖ LOG do estado atual do chat
  useEffect(() => {
    console.log('üìä ChatGigante: Current state summary:', {
      totalMessages: chatMessages.length, // ‚úÖ CORRIGIDO: Usar chatMessages do estado central
      activeTab,
      gamePhase: gameState?.phase,
      userAlive: me?.isAlive,
      availableTabs,
      canSend: canSendMessage()
    });
  }, [chatMessages.length, activeTab, gameState?.phase, me?.isAlive]); // ‚úÖ CORRIGIDO: Usar chatMessages

  return (
    <div className="h-full bg-medieval-800/30 border border-medieval-600 rounded-lg flex flex-col">

      {/* Chat Header */}
      <div className="flex-shrink-0 border-b border-medieval-600 p-4">
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-bold text-white flex items-center space-x-2">
            <span>üí¨</span>
            <span>Chat do Jogo</span>
          </h2>

          {gameState && (
            <div className="text-xs text-white/50">
              Dia {gameState.day} - {gameState.phase}
            </div>
          )}
        </div>

        {/* Chat Tabs */}
        <div className="flex space-x-1">
          {availableTabs.map((tab) => {
            const config = getTabConfig(tab);
            const tabMessages = getMessagesForTab(tab);
            const unreadCount = tab !== activeTab ? tabMessages.length : 0;

            return (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                className={`
                  px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 relative
                  ${activeTab === tab
                    ? `${config.bgColor} text-white`
                    : 'bg-medieval-700/50 text-white/70 hover:bg-medieval-700'
                  }
                `}
              >
                <div className="flex items-center space-x-1">
                  <span>{config.icon}</span>
                  <span>{config.name}</span>
                  <span className="text-xs">({tabMessages.length})</span>
                </div>

                {/* Unread Badge */}
                {tab !== activeTab && unreadCount > 0 && (
                  <div className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
                    {unreadCount > 99 ? '99+' : unreadCount}
                  </div>
                )}
              </button>
            );
          })}
        </div>
      </div>

      {/* Chat Messages Area */}
      <div className="flex-1 overflow-y-auto bg-medieval-900/20">
        {getMessagesForTab(activeTab).length === 0 ? (
          <div className="h-full flex items-center justify-center">
            <div className="text-center text-white/50">
              <div className="text-4xl mb-2">{getTabConfig(activeTab).icon}</div>
              <p>Nenhuma mensagem ainda...</p>
              <p className="text-xs mt-1">
                {activeTab === 'public' && 'Seja o primeiro a falar!'}
                {activeTab === 'werewolf' && 'Coordenem seus ataques...'}
                {activeTab === 'dead' && 'O al√©m est√° silencioso...'}
                {activeTab === 'system' && 'Aguardando eventos...'}
              </p>
              {/* ‚úÖ DEBUG: Mostrar contador total de mensagens */}
              <p className="text-xs mt-2 text-white/30">
                Debug: {chatMessages.length} mensagens total {/* ‚úÖ CORRIGIDO */}
              </p>
            </div>
          </div>
        ) : (
          <div>
            {getMessagesForTab(activeTab).map((msg) => (
              <ChatMessageComponent key={msg.id} msg={msg} />
            ))}
            <div ref={messagesEndRef} />
          </div>
        )}
      </div>

      {/* Chat Input */}
      <div className="flex-shrink-0 border-t border-medieval-600 p-4">
        {/* Phase restriction info */}
        {gameState?.phase === 'NIGHT' && activeTab === 'public' && me?.role !== 'WEREWOLF' && me?.role !== 'WEREWOLF_KING' && (
          <div className="mb-2 text-xs text-amber-400 text-center">
            üåô Durante a noite, apenas Lobisomens podem conversar no chat p√∫blico
          </div>
        )}

        <div className="flex space-x-2">
          <input
            type="text"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder={
              !canSendMessage() ? 'Voc√™ n√£o pode falar neste canal agora' :
                activeTab === 'public' ? 'Digite sua mensagem...' :
                  activeTab === 'werewolf' ? 'Coordenem seus ataques...' :
                    activeTab === 'dead' ? 'Fale com outros mortos...' :
                      'Mensagem do sistema...'
            }
            disabled={!canSendMessage() || isSubmitting}
            className="flex-1 bg-medieval-700 border border-medieval-600 rounded-lg px-3 py-2 text-white placeholder-white/50 focus:outline-none focus:border-amber-400 disabled:opacity-50 disabled:cursor-not-allowed"
          />

          <button
            onClick={handleSendMessage}
            disabled={!message.trim() || !canSendMessage() || isSubmitting}
            className="bg-gradient-to-r from-blue-500 to-blue-700 hover:from-blue-600 hover:to-blue-800 disabled:from-gray-600 disabled:to-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200 disabled:cursor-not-allowed"
          >
            {isSubmitting ? '...' : 'Enviar'}
          </button>
        </div>

        {/* Help text */}
        <div className="mt-2 text-xs text-white/50 text-center">
          üí° Use Enter para enviar ‚Ä¢ Shift+Enter para quebrar linha
        </div>

        {/* ‚úÖ DEBUG INFO */}
        {process.env.NODE_ENV === 'development' && (
          <div className="mt-2 text-xs text-white/30 text-center">
            Debug: {chatMessages.length} msgs total | Aba: {activeTab} ({getMessagesForTab(activeTab).length}) | {/* ‚úÖ CORRIGIDO */}
            Pode enviar: {canSendMessage() ? 'Sim' : 'N√£o'} | Fase: {gameState?.phase}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/room/WaitingRoom.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import { ArrowLeft, Crown, Share } from 'lucide-react';
import { Player, Room, ChatMessage } from '@/types';

import PlayerList from './PlayerList';
import RoomChat from './RoomChat';
import ActionButtons from './ActionButtons';
import { ConfirmModal } from '@/components/common/Modal';

interface WaitingRoomProps {
  // Dados
  roomId: string;
  room: Room | null;
  players: Player[];
  spectators: Player[];
  messages: ChatMessage[];

  // Estados
  currentUserId: string;
  isHost: boolean;
  isReady: boolean;
  canStartGame: boolean;
  isConnected: boolean;
  showLeaveModal: boolean;
  setShowLeaveModal: (show: boolean) => void;

  // Handlers
  onToggleReady: () => void;
  onStartGame: () => void;
  onKickPlayer: (playerId: string) => void;
  onSendChatMessage: (message: string) => void;
  onShareRoom: () => void;
  onLeaveRoom: () => void;
  onConfirmLeaveAsHost: () => void;
}

export default function WaitingRoom({
  roomId,
  room,
  players,
  spectators,
  messages,
  currentUserId,
  isHost,
  isReady,
  canStartGame,
  isConnected,
  showLeaveModal,
  setShowLeaveModal,
  onToggleReady,
  onStartGame,
  onKickPlayer,
  onSendChatMessage,
  onShareRoom,
  onLeaveRoom,
  onConfirmLeaveAsHost
}: WaitingRoomProps) {

  // Se n√£o tiver dados da sala, n√£o deve renderizar (isso √© controlado pelo componente pai)
  if (!room) {
    return null;
  }

  return (
    <>
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white">
        {/* Header */}
        <div className="bg-slate-800/80 border-b border-slate-700 p-6">
          <div className="max-w-7xl mx-auto">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-4">
                <button
                  onClick={onLeaveRoom}
                  className="p-2 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors"
                >
                  <ArrowLeft className="w-5 h-5" />
                </button>

                <div className="text-3xl">üê∫</div>

                <div>
                  <h1 className="text-2xl font-bold">{room.name}</h1>
                  <div className="flex items-center gap-4 text-sm text-slate-400">
                    <span>C√≥digo: {room.code}</span>
                    <span>‚Ä¢</span>
                    <span className="flex items-center gap-1">
                      <Crown className="w-4 h-4" />
                      Host: {room.hostUsername}
                    </span>
                    <span>‚Ä¢</span>
                    <span className="flex items-center gap-1">
                      {isConnected ? (
                        <span className="text-green-400">üü¢ Conectado</span>
                      ) : (
                        <span className="text-red-400">üî¥ Desconectado</span>
                      )}
                    </span>
                  </div>
                </div>
              </div>

              <div className="flex items-center gap-4">
                <button
                  onClick={onShareRoom}
                  className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors flex items-center gap-2"
                >
                  <Share className="w-4 h-4" />
                  Compartilhar
                </button>

                <div className="text-right">
                  <div className="text-sm text-slate-400">Jogadores Prontos</div>
                  <div className="text-lg font-bold">
                    {players.filter(p => p.isReady).length}/{players.length}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Main Content */}
        <div className="max-w-7xl mx-auto p-6">
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Players List */}
            <div className="lg:col-span-2">
              <PlayerList
                players={players}
                spectators={spectators}
                currentUserId={currentUserId}
                isHost={isHost}
                onKickPlayer={onKickPlayer}
                maxPlayers={room.maxPlayers}
                maxSpectators={room.maxSpectators}
              />
            </div>

            {/* Actions and Chat */}
            <div className="space-y-6">
              <ActionButtons
                isHost={isHost}
                isReady={isReady}
                canStartGame={canStartGame}
                isConnected={isConnected}
                onToggleReady={onToggleReady}
                onStartGame={onStartGame}
              />

              <RoomChat
                messages={messages}
                onSendMessage={onSendChatMessage}
                currentUserId={currentUserId}
                isConnected={isConnected}
              />
            </div>
          </div>
        </div>
      </div>

      {/* Modal de confirma√ß√£o para host sair */}
      <ConfirmModal
        isOpen={showLeaveModal}
        onClose={() => setShowLeaveModal(false)}
        onConfirm={onConfirmLeaveAsHost}
        title="Encerrar Sala"
        message="Voc√™ √© o host desta sala. Ao sair, a sala ser√° encerrada e todos os jogadores ser√£o removidos. Deseja continuar?"
        confirmText="Sim, Encerrar Sala"
        cancelText="Cancelar"
        variant="warning"
      />
    </>
  );
}
</file>

<file path="frontend/src/context/SocketContext.tsx">
'use client';

import { createContext, useContext, ReactNode, useCallback, useRef, useState } from 'react';

// Tipos simplificados
export interface WebSocketContextType {
  socket: WebSocket | null;
  isConnected: boolean;
  connect: (url: string) => void;
  disconnect: () => void;
  sendMessage: (type: string, data?: any) => boolean;
}

const SocketContext = createContext<WebSocketContextType | undefined>(undefined);

export function SocketProvider({ children }: { children: ReactNode }) {
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const socketRef = useRef<WebSocket | null>(null);

  const connect = useCallback((url: string) => {
    // Valida√ß√£o b√°sica
    if (!url || url.includes('undefined')) {
      console.error('‚ùå Invalid WebSocket URL:', url);
      return;
    }

    // ‚úÖ CORRIGIDO: Verificar se j√° est√° conectado na mesma URL com readyState
    if (socketRef.current?.url === url && socketRef.current.readyState === WebSocket.OPEN) {
      console.log('‚úÖ Already connected to', url);
      return;
    }

    // ‚úÖ CORRIGIDO: Verificar se h√° conex√£o pendente para a mesma URL
    if (socketRef.current?.url === url && socketRef.current.readyState === WebSocket.CONNECTING) {
      console.log('‚è≥ Connection already in progress for', url);
      return;
    }

    // Desconecta conex√£o anterior se existir
    if (socketRef.current) {
      console.log('üîÑ Closing previous connection');
      socketRef.current.close();
    }

    console.log('üîå Connecting to WebSocket:', url);

    try {
      const ws = new WebSocket(url);
      socketRef.current = ws;

      ws.onopen = () => {
        console.log('‚úÖ WebSocket connected');
        setSocket(ws);
        setIsConnected(true);
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          // Dispara evento customizado para componentes ouvirem
          window.dispatchEvent(new CustomEvent('websocket-message', { detail: message }));
        } catch (error) {
          console.error('‚ùå Error parsing message:', error);
        }
      };

      ws.onclose = (event) => {
        console.log('üîå WebSocket disconnected', {
          code: event.code,
          reason: event.reason || 'No reason provided',
          wasClean: event.wasClean
        });
        setSocket(null);
        setIsConnected(false);

        // ‚úÖ CORRIGIDO: S√≥ limpar ref se for a conex√£o atual
        if (socketRef.current === ws) {
          socketRef.current = null;
        }
      };

      ws.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
        // ‚úÖ ADICIONADO: Atualizar estado em caso de erro
        setSocket(null);
        setIsConnected(false);
      };

    } catch (error) {
      console.error('‚ùå Failed to create WebSocket:', error);
      setSocket(null);
      setIsConnected(false);
    }
  }, []);

  const disconnect = useCallback(() => {
    if (socketRef.current) {
      console.log('üîå Disconnecting WebSocket');

      // ‚úÖ CORRIGIDO: Verificar estado antes de fechar
      if (socketRef.current.readyState === WebSocket.OPEN ||
        socketRef.current.readyState === WebSocket.CONNECTING) {
        socketRef.current.close();
      }

      socketRef.current = null;
      setSocket(null);
      setIsConnected(false);
    }
  }, []);

  // ‚úÖ CORRIGIDO: Usar readyState real do socket em vez do estado React
  const sendMessage = useCallback((type: string, data?: any): boolean => {
    // ‚úÖ Verificar estado real do WebSocket
    if (socketRef.current?.readyState === WebSocket.OPEN) {
      try {
        const message = {
          type,
          data,
          timestamp: new Date().toISOString(),
        };
        socketRef.current.send(JSON.stringify(message));
        console.log('üì§ Message sent:', type, data);
        return true;
      } catch (error) {
        console.error('‚ùå Error sending message:', error);
        return false;
      }
    }

    // ‚úÖ MELHOR: Log mais informativo sobre o estado atual
    const currentState = socketRef.current?.readyState;
    const stateNames: Record<number, string> = {
      [WebSocket.CONNECTING]: 'CONNECTING',
      [WebSocket.OPEN]: 'OPEN',
      [WebSocket.CLOSING]: 'CLOSING',
      [WebSocket.CLOSED]: 'CLOSED'
    };

    console.warn('‚ö†Ô∏è Cannot send message - WebSocket state:',
      currentState !== undefined ? stateNames[currentState] : 'NULL');
    return false;
  }, []);

  const value: WebSocketContextType = {
    socket,
    isConnected,
    connect,
    disconnect,
    sendMessage,
  };

  return (
    <SocketContext.Provider value={value}>
      {children}
    </SocketContext.Provider>
  );
}

export function useSocket(): WebSocketContextType {
  const context = useContext(SocketContext);
  if (!context) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
}
</file>

<file path="frontend/src/types/index.ts">
// üê∫ LOBISOMEM ONLINE - Tipos Centralizados (REFATORADO + NOVOS TIPOS)
import type WebSocket from 'ws';

// =============================================================================
// IMPORT ENUMS FROM CONSTANTS (√öNICA FONTE) - ‚úÖ CORRIGIDO
// =============================================================================
// ‚úÖ FIX: Comentar imports que est√£o causando erro at√© criar o arquivo constants.ts
// export { Role, Faction, GamePhase } from '@/utils/constants';
// import { Role, Faction, GamePhase } from '@/utils/constants';

// ‚úÖ TEMP: Definir diretamente aqui at√© resolver o constants.ts
export enum Role {
  WEREWOLF = 'WEREWOLF',
  WEREWOLF_KING = 'WEREWOLF_KING',
  JESTER = 'JESTER', // ‚úÖ ADICIONADO: Resolve erros de ActionPanel e ChatGigante
  SHERIFF = 'SHERIFF',
  DOCTOR = 'DOCTOR',
  VIGILANTE = 'VIGILANTE',
  SERIAL_KILLER = 'SERIAL_KILLER',
  VILLAGER = 'VILLAGER'
}

export enum Faction {
  TOWN = 'TOWN',
  WEREWOLF = 'WEREWOLF',
  NEUTRAL = 'NEUTRAL'
}

export enum GamePhase {
  LOBBY = 'LOBBY',
  NIGHT = 'NIGHT',
  DAY = 'DAY',
  VOTING = 'VOTING'
}

// =============================================================================
// ‚úÖ EXPORTS FALTANDO PARA AuthContext
// =============================================================================
export interface User {
  id: string;
  username: string;
  email: string;
  avatar?: string;
  level?: number;
  totalGames?: number; // ‚úÖ ADICIONADO: Resolve erros em Layout.tsx e index.tsx
  createdAt?: string;
  updatedAt?: string;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken?: string;
  expiresIn?: number;
}

export interface LoginRequest {
  email: string;
  password: string;
  rememberMe?: boolean;
}

export interface RegisterRequest {
  username: string;
  email: string;
  password: string;
  confirmPassword?: string;
  acceptTerms?: boolean;
}

export interface AuthResponse {
  success: boolean;
  user: User;
  tokens: AuthTokens;
  message?: string;
}

// =============================================================================
// API & HTTP
// =============================================================================
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
  timestamp: string;
  statusCode?: number; // ‚úÖ ADICIONADO para resolver erro na api.ts
}

// =============================================================================
// JWT & AUTENTICA√á√ÉO
// =============================================================================
export interface JWTPayload {
  userId: string;
  username: string;
  email: string;
  avatar?: string;
  iat?: number;
  exp?: number;
}

export interface TokenPair {
  accessToken: string;
  refreshToken?: string;
}

// =============================================================================
// WEBSOCKET & CONEX√ÉO
// =============================================================================
export interface ConnectionContext {
  userId: string;
  username: string;
  serverId: string;
  isSpectator: boolean;
  roomId?: string;
}

export interface ConnectionMetadata {
  connectedAt: Date;
  userAgent?: string;
  ip?: string;
  origin?: string;
}

export interface WebSocketConnection {
  id: string;
  ws: WebSocket;
  context: ConnectionContext;
  metadata: ConnectionMetadata;
  isAlive: boolean;
  lastPing: number;
  reconnectAttempts: number;
}

export interface WebSocketMessage {
  type: string;
  timestamp: string;
  data?: any;
  messageId?: string;
}

export interface URLParseResult {
  isValid: boolean;
  path: string;
  roomId?: string;
  serverId?: string;
}

export interface MessageValidationResult {
  isValid: boolean;
  message?: WebSocketMessage;
  error?: string;
}

// ‚úÖ ATUALIZADO: Adicionados novos c√≥digos de erro
export type WebSocketErrorCode =
  | 'INVALID_TOKEN' | 'ROOM_NOT_FOUND' | 'ROOM_FULL' | 'NOT_IN_ROOM'
  | 'NOT_HOST' | 'GAME_ALREADY_STARTED' | 'INVALID_ACTION'
  | 'PLAYER_NOT_FOUND' | 'RATE_LIMITED' | 'INVALID_MESSAGE'
  | 'UNKNOWN_MESSAGE_TYPE' | 'HANDLER_ERROR' | 'MISSING_ROOM_ID'
  | 'JOIN_ROOM_FAILED' | 'LEAVE_ROOM_FAILED' | 'READY_UPDATE_FAILED'
  | 'START_GAME_FAILED' | 'KICK_PLAYER_FAILED' | 'NOT_IMPLEMENTED'
  | 'DELETE_ROOM_FAILED' | 'CHAT_FAILED';

// =============================================================================
// GAME TYPES (COMPAT√çVEIS COM CLASSES REAIS)
// =============================================================================
export type RoomStatus = 'WAITING' | 'PLAYING' | 'FINISHED';
export type GameStatus = 'WAITING' | 'STARTING' | 'PLAYING' | 'FINISHED' | 'CANCELLED';

export interface Room {
  id: string;
  name: string;
  isPrivate: boolean;
  maxPlayers: number;
  maxSpectators: number;
  status: RoomStatus;
  hostId: string;
  hostUsername: string;
  currentPlayers: number;
  currentSpectators: number;
  createdAt: Date;
  updatedAt: Date;
  code?: string;
  serverId?: string;
}

export interface GameConfig {
  roomId: string;
  maxPlayers: number;
  maxSpectators: number;
  nightDuration: number; // milliseconds
  dayDuration: number; // milliseconds
  votingDuration: number; // milliseconds
  allowReconnection: boolean;
  reconnectionTimeout: number; // milliseconds
}

// =============================================================================
// PLAYER INTERFACE (COMPAT√çVEL COM CLASSE Player)
// =============================================================================
export interface Player {
  id: string;
  userId: string;
  username: string;
  isHost: boolean;
  isReady: boolean;
  isSpectator: boolean;
  isConnected: boolean;
  joinedAt: Date;
  lastSeen: Date;
  avatar?: string;

  // Game-specific properties
  role?: Role;
  faction?: Faction;
  isAlive?: boolean;
  isProtected?: boolean;
  hasActed?: boolean;
  hasVoted?: boolean;
  votedFor?: string;
  actionsUsed?: number;
  maxActions?: number;
  lastAction?: string;
  eliminationReason?: 'NIGHT_KILL' | 'EXECUTION' | 'VIGILANTE' | 'SERIAL_KILLER';
  killedBy?: string;
}

// =============================================================================
// GAME STATE INTERFACE (COMPAT√çVEL COM CLASSE GameState)
// ‚úÖ MUDAN√áA CHAVE: Usar estruturas que a classe realmente usa
// =============================================================================
export interface GameState {
  gameId: string;
  roomId: string;
  status: GameStatus;
  phase: GamePhase;
  day: number;
  phaseStartTime: Date;
  phaseEndTime: Date;
  timeLeft: number;

  // ‚úÖ IMPORTANTE: Compat√≠vel com a classe real que usa Map
  players: Player[]; // Para serializa√ß√£o JSON
  spectators: string[]; // IDs dos espectadores  
  eliminatedPlayers: Player[];

  hostId: string;
  events: GameEvent[];
  votes: Record<string, string>; // Para serializa√ß√£o JSON - voterId -> targetId
  nightActions: NightAction[];
  config: GameConfig;
  createdAt: Date;
  updatedAt: Date;
  startedAt?: Date;
  finishedAt?: Date;
  winningFaction?: Faction;
  winningPlayers?: string[];
}

export interface GameEvent {
  id: string;
  type: string;
  phase: GamePhase;
  day: number;
  timestamp: Date;
  data: any;
  visibleTo?: string[]; // If undefined, visible to all
}

export interface NightAction {
  playerId: string;
  type: string;
  targetId?: string;
  data?: any;
  priority: number;
}

// =============================================================================
// ‚úÖ CHAT TYPES (MELHORADOS)
// =============================================================================
export interface ChatMessage {
  id: string;
  userId: string;
  username: string;
  message: string;
  channel: 'public' | 'werewolf' | 'spectator' | 'system' | 'dead';
  timestamp: string;
  filtered?: boolean;

  // ‚úÖ ADICIONADO: Metadata para chat
  isWhisper?: boolean;
  targetUserId?: string;
  edited?: boolean;
  editedAt?: string;
}

// =============================================================================
// GAME ENGINE INTERFACES
// =============================================================================
export interface IGameEngine {
  // Game lifecycle
  createGame(hostId: string, config: GameConfig): Promise<GameState>;
  startGame(gameId: string): Promise<boolean>;
  endGame(gameId: string, reason?: string): Promise<void>;

  // Player management
  addPlayer(gameId: string, player: Player): Promise<boolean>;
  removePlayer(gameId: string, playerId: string): Promise<boolean>;

  // Game state
  getGameState(gameId: string): Promise<GameState | null>;
  updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;

  // Actions
  performPlayerAction(gameId: string, playerId: string, action: any): Promise<boolean>;

  // Phase management
  nextPhase(gameId: string): Promise<void>;

  // Events
  onGameEvent(gameId: string, event: string, handler: (data: any) => void): void;

  // Voting
  castVote?(gameId: string, voterId: string, targetId: string): Promise<boolean>;
  removeVote?(gameId: string, voterId: string): Promise<boolean>;

  // Administrative
  getActiveGamesCount?(): number;
  getAllGames?(): GameState[];
  getGamesByRoom?(roomId: string): Promise<GameState[]>;
  forceEndGame?(gameId: string, reason: string): Promise<boolean>;
  getGameStats?(gameId: string): any;
  cleanup?(): Promise<void>;
}

// =============================================================================
// ROLE SYSTEM TYPES (IMPORTADOS DE RoleSystem.ts)
// =============================================================================
export interface RoleConfiguration {
  role: Role;
  faction: Faction;
  name: string;
  description: string;
  abilities: string[];
  goalDescription: string;
  canAct: boolean;
  actsDuring: string[];
  hasNightChat: boolean;
  immuneToInvestigation: boolean;
  maxActions?: number;
  priority: number;
}

export type RoleDistribution = Record<Role, number>;

// =============================================================================
// ACTION SYSTEM TYPES
// =============================================================================
export interface GameAction {
  id: string;
  playerId: string;
  type: string;
  targetId?: string;
  data?: any;
  timestamp: Date;
  phase: string;
  day: number;
  priority: number;
  isValid: boolean;
  processed: boolean;
}

export interface ActionResult {
  success: boolean;
  actionId: string;
  message?: string;
  data?: any;
  errors?: string[];
}

// =============================================================================
// TIMER SYSTEM TYPES
// =============================================================================
export interface GameTimer {
  id: string;
  type: 'PHASE' | 'WARNING' | 'CUSTOM';
  startTime: number;
  duration: number;
  remaining: number;
  isActive: boolean;
  callback?: () => void;
  timeout?: NodeJS.Timeout; // ‚úÖ Nome correto
}

// =============================================================================
// SERVICE INTERFACES (CORRIGIDOS)
// =============================================================================
export interface ServiceMetadata {
  id: string;
  type: 'lobby' | 'game' | 'chat' | 'monolith';
  host: string;
  port: number;
  capabilities: string[];
  status: 'healthy' | 'unhealthy';
  lastHeartbeat: Date;
  maxRooms?: number;
  currentRooms?: number;
}

export interface IEventBus {
  publish<T>(channel: string, event: T): Promise<void>;
  subscribe<T>(channel: string, handler: (event: T) => void): Promise<void>;
  unsubscribe(channel: string, handler?: Function): Promise<void>;
  healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

export interface IServiceRegistry {
  registerService(serviceId: string, metadata: ServiceMetadata): Promise<void>;
  getAvailableServices(serviceType: string): Promise<string[]>;
  unregisterService(serviceId: string): Promise<void>;
  getServiceMetadata(serviceId: string): Promise<ServiceMetadata | null>;
  healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// ‚úÖ INTERFACE CORRIGIDA - Agora retorna GameState em vez de Game inexistente
export interface IGameStateService {
  createGame(hostId: string, config: GameConfig): Promise<GameState>;
  getGame(gameId: string): Promise<GameState | null>;
  updateGameState(gameId: string, updates: Partial<GameState>): Promise<void>;
  deleteGame(gameId: string): Promise<void>;
  addPlayer(gameId: string, player: Player): Promise<void>;
  removePlayer(gameId: string, playerId: string): Promise<void>;
  updatePlayer(gameId: string, playerId: string, updates: Partial<Player>): Promise<void>;
  getGameState(gameId: string): Promise<GameState | null>;
  getPlayer(gameId: string, playerId: string): Promise<Player | null>;
  getAllPlayers(gameId: string): Promise<Player[]>;
  getGamesByRoom(roomId: string): Promise<GameState[]>;
  getActiveGamesCount(): Promise<number>;
  cleanup?(): number;
  healthCheck?(): Promise<{ status: 'healthy' | 'unhealthy'; message: string }>;
}

// =============================================================================
// WIN CONDITION TYPES
// =============================================================================
export interface WinCondition {
  hasWinner: boolean;
  winningFaction?: Faction;
  winningPlayers?: string[];
  reason?: string;
}

// =============================================================================
// GAME STATISTICS TYPES
// =============================================================================
export interface GameStats {
  gameId: string;
  status: GameStatus;
  phase: GamePhase;
  day: number;
  playerCount: number;
  aliveCount: number;
  spectatorCount: number;
  timeLeft: number;
  events: number;
}

export interface GameResults {
  gameId: string;
  roomId: string;
  duration: number;
  totalDays: number;
  winningFaction?: Faction;
  winningPlayers: string[];
  players: PlayerResult[];
  events: GameEvent[];
}

export interface PlayerResult {
  id: string;
  userId: string;
  username: string;
  role?: Role;
  faction?: Faction;
  survived: boolean;
  won: boolean;
  eliminationReason?: string;
  killedBy?: string;
}

// =============================================================================
// PHASE MANAGER TYPES
// =============================================================================
export interface PhaseTransition {
  from: GamePhase;
  to: GamePhase;
  duration: number;
  reason?: string;
}

export interface NightResults {
  protections: string[];
  investigations: Array<{
    investigatorId: string;
    targetId: string;
    result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS';
  }>;
  attacks: Array<{
    attackerId: string;
    targetId: string;
    successful: boolean;
  }>;
  deaths: Array<{
    playerId: string;
    cause: string;
    killedBy?: string;
  }>;
}

// =============================================================================
// ‚úÖ WEBSOCKET EVENT TYPES (ATUALIZADOS)
// =============================================================================
export interface GameWebSocketEvents {
  // Game lifecycle events
  'game:created': { gameId: string; hostId: string; config: GameConfig };
  'game:started': { gameId: string; players: Player[]; distribution: RoleDistribution };
  'game:ended': { gameId: string; results: GameResults };

  // Phase events
  'phase:changed': { gameId: string; phase: GamePhase; duration: number; timeLeft: number };
  'phase:warning': { gameId: string; phase: GamePhase; timeLeft: number };

  // Player events
  'player:joined': { gameId: string; player: Player };
  'player:left': { gameId: string; playerId: string; username: string };
  'player:died': { gameId: string; playerId: string; role: Role; cause: string };
  'player:executed': { gameId: string; playerId: string; role: Role; votes: number };

  // Action events
  'action:submitted': { gameId: string; playerId: string; actionType: string };
  'action:result': { gameId: string; playerId: string; result: ActionResult };

  // Voting events
  'vote:cast': { gameId: string; voterId: string; targetId: string; voteCounts: Record<string, number> };
  'vote:removed': { gameId: string; voterId: string; voteCounts: Record<string, number> };

  // ‚úÖ NOVOS: Room events
  'room:deleted': { roomId: string; reason: string; timestamp: string };
  'room:player-joined': { roomId: string; userId: string; username: string; asSpectator: boolean; timestamp: string };
  'room:player-left': { roomId: string; userId: string; username: string; timestamp: string };
  'room:player-ready': { roomId: string; userId: string; username: string; ready: boolean; timestamp: string };
  'room:game-started': { roomId: string; hostId: string; timestamp: string };
}

// =============================================================================
// ‚úÖ WEBSOCKET MESSAGE TYPES (ATUALIZADOS)
// =============================================================================
export interface ClientToServerEvents {
  // Room events
  'join-room': { roomId: string; asSpectator?: boolean };
  'leave-room': { roomId?: string };
  'delete-room': { roomId?: string }; // ‚úÖ NOVO
  'player-ready': { ready: boolean };
  'start-game': {};

  // Game actions
  'game-action': { type: string; targetId?: string; data?: any };
  'vote': { targetId: string };
  'unvote': {};

  // Chat events
  'chat-message': { message: string; channel?: string };

  // Werewolf coordination
  'werewolf-kill-vote': { targetId: string };

  // Admin events
  'kick-player': { playerId: string };
  'force-phase': {};
  'extend-time': { additionalTime: number };
}

export interface ServerToClientEvents {
  // Connection events
  'connected': { userId: string };
  'error': { code: WebSocketErrorCode; message: string };

  // Room events
  'room-joined': { room: Room; player: Player; yourRole: string };
  'room-left': { roomId: string };
  'room-deleted': { roomId: string; reason: string; timestamp: string }; // ‚úÖ NOVO
  'player-joined': { player: Player };
  'player-left': { userId: string; username: string };
  'player-ready': { userId: string; username: string; ready: boolean };

  // Game events
  'game-starting': { countdown: number };
  'game-started': { gameId: string; players: Player[]; spectators: Player[] };
  'game-state': GameState;
  'game-ended': { results: GameResults };

  // Phase events
  'phase-changed': { phase: GamePhase; timeLeft: number; day: number };
  'phase-warning': { timeLeft: number };

  // Action events
  'action-confirmed': { actionType: string; message: string };
  'action-failed': { actionType: string; error: string };

  // Voting events
  'voting-update': { votes: Record<string, string>; counts: Record<string, number> };
  'execution-result': { executedId?: string; executedName?: string; executedRole?: Role };

  // Night events
  'night-results': { deaths: any[]; messages: string[] };
  'investigation-result': { targetName: string; result: 'SUSPICIOUS' | 'NOT_SUSPICIOUS' };

  // Chat events
  'chat-message': { userId: string; username: string; message: string; channel: string; timestamp: string };

  // Role-specific events
  'role-assigned': { role: Role; faction: Faction; abilities: string[] };
  'werewolf-chat': { senderId: string; senderName: string; message: string };
}

// =============================================================================
// ‚úÖ UI TYPES - EXPANDIDOS
// =============================================================================
export interface ThemeConfig {
  isDark: boolean;
  currentPhase: GamePhase;
  soundEnabled: boolean;
  musicVolume: number;
  sfxVolume: number;

  // ‚úÖ ADICIONADO: Configura√ß√µes visuais
  animationsEnabled: boolean;
  highContrast: boolean;
  fontSize: 'small' | 'medium' | 'large';
  colorBlindMode: boolean;
}

export interface NotificationConfig {
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
  duration?: number;
  persistent?: boolean;
  action?: {
    label: string;
    onClick: () => void;
  };

  // ‚úÖ ADICIONADO: Notifica√ß√£o avan√ßada
  sound?: boolean;
  icon?: string;
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
}

// =============================================================================
// ‚úÖ API RESPONSE TYPES - MELHORADOS
// =============================================================================
export interface PaginatedResponse<T> {
  items: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // ‚úÖ ADICIONADO: Filtros aplicados
  filters?: Record<string, any>;
  sort?: {
    field: string;
    direction: 'asc' | 'desc';
  };
}

// =============================================================================
// LEADERBOARD TYPES
// =============================================================================
export interface LeaderboardEntry {
  rank: number;
  user: {
    id: string;
    username: string;
    avatar?: string;
    level: number;
    country?: string;
  };
  points: number;
  totalGames: number;
  winRate: number;
  favoriteRole?: Role;

  // ‚úÖ ADICIONADO: Estat√≠sticas extras
  currentStreak: number;
  longestStreak: number;
  lastGameAt?: string;
}

// =============================================================================
// ‚úÖ STATISTICS TYPES - EXPANDIDOS
// =============================================================================
export interface UserStatistics {
  totalGames: number;
  totalWins: number;
  totalLosses: number;
  winRate: number;
  level: number;
  favoriteRole?: Role;
  longestWinStreak: number;
  currentStreak: number;
  roleStats: RoleStatistics[];
  recentGames: GameSummary[];

  // ‚úÖ ADICIONADO: Estat√≠sticas avan√ßadas
  averageGameDuration: number;
  survivalRate: number;
  eliminationRate: number;
  mvpCount: number;
  perfectGames: number;
  comebackWins: number;
}

export interface RoleStatistics {
  role: Role;
  gamesPlayed: number;
  wins: number;
  winRate: number;

  // ‚úÖ ADICIONADO: Stats espec√≠ficos por role
  averageSurvivalTime: number;
  successfulActions: number;
  totalActions: number;
  mvpCount: number;
}

export interface GameSummary {
  gameId: string;
  role: Role;
  faction: Faction;
  won: boolean;
  survived: boolean;
  playedAt: string;
  duration: number;

  // ‚úÖ ADICIONADO: Detalhes do jogo
  totalPlayers: number;
  daysSurvived: number;
  actionsPerformed: number;
  mvp: boolean;
  eliminatedBy?: string;
  finalPosition: number;
}

// =============================================================================
// ‚úÖ COMPONENT PROP TYPES - MELHORADOS
// =============================================================================
export interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger' | 'medieval' | 'ghost' | 'outline'; // ‚úÖ CORRIGIDO: Adicionado 'outline'
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl'; // ‚úÖ CORRIGIDO: Adicionado 'xs'
  disabled?: boolean;
  loading?: boolean;
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  className?: string;
  type?: 'button' | 'submit' | 'reset';

  // ‚úÖ ADICIONADO: Props extras
  fullWidth?: boolean;
  icon?: React.ReactNode;
  iconPosition?: 'left' | 'right';
  tooltip?: string;
  ariaLabel?: string;
}

export interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  className?: string;
  closeOnOverlayClick?: boolean;

  // ‚úÖ ADICIONADO: Props extras
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  variant?: 'default' | 'medieval' | 'dark' | 'error' | 'warning' | 'game'; // ‚úÖ CORRIGIDO: Adicionado 'game'
  showCloseButton?: boolean;
  preventScroll?: boolean;
  zIndex?: number;
}

// ‚úÖ CORRIGIDO: LoadingSpinner props
export interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg' | 'xl'; // ‚úÖ REMOVIDO 'large', s√≥ aceita essas 4 op√ß√µes
  className?: string;
  color?: string;
}

// =============================================================================
// ‚úÖ CONTEXT TYPES - CORRIGIDOS COM BASE NOS ARQUIVOS REAIS
// =============================================================================
export interface ThemeContextType {
  theme: 'werewolf' | 'medieval' | 'modern';
  setTheme: (theme: 'werewolf' | 'medieval' | 'modern') => void;
  playSound: (soundId: string) => void;
  playMusic: (musicId: string) => void;
  stopMusic: () => void;
  setMusicVolume: (volume: number) => void;
  setSoundVolume: (volume: number) => void;
  musicVolume: number;
  soundVolume: number;
  isMusicPlaying: boolean;
  isAudioUnblocked: boolean;
  getPhaseColors: () => {
    background: string;
    text: string;
    accent: string;
    border: string;
  };
  getThemeClass: () => string;
  audioConfig: {
    musicVolume: number;
    sfxVolume: number;
    enabled: boolean;
  };
  updateAudioConfig: (config: Partial<{
    musicVolume: number;
    sfxVolume: number;
    enabled: boolean;
  }>) => void;
}

export interface WebSocketContextType {
  socket: WebSocket | null;
  isConnected: boolean;
  connect: (url: string) => void;
  disconnect: () => void;
  sendMessage: (type: string, data?: any) => boolean;
}

// =============================================================================
// ‚úÖ FORM TYPES - EXPANDIDOS
// =============================================================================
export interface FormError {
  field: string;
  message: string;
  code?: string;
}

export interface ValidationResult {
  isValid: boolean;
  errors: string[]; // ‚úÖ CORRIGIDO: array simples de strings para compatibilidade
  warnings?: FormError[];
}

// ‚úÖ ADICIONADO: Tipos para formul√°rios complexos
export interface FormField<T = any> {
  name: string;
  label: string;
  type: 'text' | 'email' | 'password' | 'number' | 'select' | 'checkbox' | 'radio' | 'textarea';
  value: T;
  required?: boolean;
  disabled?: boolean;
  placeholder?: string;
  options?: Array<{ label: string; value: any }>;
  validation?: (value: T) => ValidationResult;
}

export interface FormState<T = Record<string, any>> {
  values: T;
  errors: Record<keyof T, string>;
  touched: Record<keyof T, boolean>;
  isSubmitting: boolean;
  isValid: boolean;
}

// =============================================================================
// ‚úÖ ROOM SETTINGS TYPES
// =============================================================================
export interface RoomSettings {
  gameMode: 'CLASSIC' | 'RANKED' | 'CUSTOM';
  timeDay: number; // segundos
  timeNight: number; // segundos
  timeVoting: number; // segundos
  allowSpectators: boolean;
  autoStart: boolean;
  customRoles?: Role[];
  bannedPlayers?: string[];
}

// =============================================================================
// ‚úÖ UTILITY TYPES
// =============================================================================
export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type RequiredKeys<T, K extends keyof T> = T & Required<Pick<T, K>>;
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};
export type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
};

// =============================================================================
// ‚úÖ BRAND TYPES FOR TYPE SAFETY
// =============================================================================
export type UserId = string & { readonly __brand: unique symbol };
export type RoomId = string & { readonly __brand: unique symbol };
export type GameId = string & { readonly __brand: unique symbol };
export type SessionId = string & { readonly __brand: unique symbol };
export type TokenId = string & { readonly __brand: unique symbol };

// =============================================================================
// ‚úÖ ENVIRONMENT TYPES
// =============================================================================
export interface EnvironmentConfig {
  NODE_ENV: 'development' | 'production' | 'test';
  API_URL: string;
  WS_URL: string;
  VERSION: string;
  BUILD_TIME: string;
  SENTRY_DSN?: string;
  ANALYTICS_ID?: string;
}

// =============================================================================
// ‚úÖ FEATURE FLAGS
// =============================================================================
export interface FeatureFlags {
  enableNewLobby: boolean;
  enableVoiceChat: boolean;
  enableRankedMode: boolean;
  enableCustomRoles: boolean;
  enableSpectatorMode: boolean;
  enableReplaySystem: boolean;
  enableAchievements: boolean;
  enableDarkMode: boolean;
  enableBetaFeatures: boolean;
}

// =============================================================================
// ‚úÖ EXPORT HELPERS
// =============================================================================

// Type guards
export function isUser(obj: any): obj is Player {
  return obj && typeof obj.id === 'string' && typeof obj.username === 'string';
}

export function isApiResponse<T>(obj: any): obj is ApiResponse<T> {
  return obj && typeof obj.success === 'boolean' && typeof obj.timestamp === 'string';
}

export function isWebSocketMessage(obj: any): obj is WebSocketMessage {
  return obj && typeof obj.type === 'string';
}

// Utility functions for types
export function createUserId(id: string): UserId {
  return id as UserId;
}

export function createRoomId(id: string): RoomId {
  return id as RoomId;
}

export function createGameId(id: string): GameId {
  return id as GameId;
}

// ‚úÖ DEFAULT VALUES (ATUALIZADOS)
export const DEFAULT_USER_STATS: UserStatistics = {
  totalGames: 0,
  totalWins: 0,
  totalLosses: 0,
  winRate: 0,
  level: 1,
  longestWinStreak: 0,
  currentStreak: 0,
  roleStats: [],
  recentGames: [],
  averageGameDuration: 0,
  survivalRate: 0,
  eliminationRate: 0,
  mvpCount: 0,
  perfectGames: 0,
  comebackWins: 0,
};

export const DEFAULT_THEME_CONFIG: ThemeConfig = {
  isDark: true,
  currentPhase: GamePhase.LOBBY,
  soundEnabled: true,
  musicVolume: 0.7,
  sfxVolume: 0.8,
  animationsEnabled: true,
  highContrast: false,
  fontSize: 'medium',
  colorBlindMode: false,
};

export const DEFAULT_ROOM_SETTINGS: RoomSettings = {
  gameMode: 'CLASSIC',
  timeDay: 300, // 5 minutos
  timeNight: 120, // 2 minutos
  timeVoting: 60, // 1 minuto
  allowSpectators: true,
  autoStart: false,
  customRoles: [],
  bannedPlayers: [],
};
</file>

<file path="backend/src/websocket/MessageRouter.ts">
// üê∫ LOBISOMEM ONLINE - Message Router (CORRIGIDO - CHAT + A√á√ïES + LOGS)
import { wsLogger } from '@/utils/logger';
import { validateWebSocketMessage } from '@/config/websocket';
import { pool } from '@/config/database';
import { GAME_LIMITS } from '@/utils/constants';
//import { getGameDurations } from '@/utils/constants';
import type { ConnectionManager } from './ConnectionManager';
import type { ChannelManager } from './ChannelManager';
import type { GameEngine } from '@/game/GameEngine';
import type { IEventBus, WebSocketErrorCode } from '@/types';
import { Player } from '@/game/Game';

//====================================================================
// MESSAGE HANDLER TYPE
//====================================================================
type MessageHandler = (connectionId: string, data: any) => Promise<void>;

//====================================================================
// MESSAGE ROUTER CLASS - VERS√ÉO CORRIGIDA
//====================================================================
export class MessageRouter {
  private handlers = new Map<string, MessageHandler>();
  private broadcastToRoom?: (roomId: string, type: string, data?: any, excludeConnectionId?: string) => number;
  private sendToUser?: (userId: string, type: string, data?: any) => boolean;

  constructor(
    private connectionManager: ConnectionManager,
    private channelManager: ChannelManager,
    private gameEngine: GameEngine,
    private eventBus: IEventBus
  ) {
    this.setupHandlers();
  }

  //====================================================================
  // SETUP MESSAGE HANDLERS
  //====================================================================
  private setupHandlers(): void {
    // Connection management
    this.handlers.set('ping', this.handlePing.bind(this));
    this.handlers.set('pong', this.handlePong.bind(this));
    this.handlers.set('heartbeat', this.handleHeartbeat.bind(this));

    // Room management (Required events)
    this.handlers.set('join-room', this.handleJoinRoom.bind(this));
    this.handlers.set('leave-room', this.handleLeaveRoom.bind(this));
    this.handlers.set('player-ready', this.handlePlayerReady.bind(this));
    this.handlers.set('start-game', this.handleStartGame.bind(this));

    // Room admin
    this.handlers.set('delete-room', this.handleDeleteRoom.bind(this));
    this.handlers.set('kick-player', this.handleKickPlayer.bind(this));
    this.handlers.set('chat-message', this.handleChatMessage.bind(this));
    this.handlers.set('spectate-room', this.handleSpectateRoom.bind(this));
    this.handlers.set('stop-spectating', this.handleStopSpectating.bind(this));

    // Game handlers
    this.handlers.set('get-game-state', this.handleGetGameState.bind(this));
    this.handlers.set('game-action', this.handleGameAction.bind(this));
    this.handlers.set('vote', this.handleVote.bind(this));
    this.handlers.set('unvote', this.handleUnvote.bind(this));

    wsLogger.debug('Message handlers setup completed', {
      handlerCount: this.handlers.size,
      handlers: Array.from(this.handlers.keys()),
    });
  }

  //====================================================================
  // SET BROADCAST METHODS (Called by WebSocketManager)
  //====================================================================
  setBroadcastMethods(
    broadcastToRoom: (roomId: string, type: string, data?: any, excludeConnectionId?: string) => number,
    sendToUser: (userId: string, type: string, data?: any) => boolean
  ): void {
    this.broadcastToRoom = broadcastToRoom;
    this.sendToUser = sendToUser;
  }

  //====================================================================
  // MAIN MESSAGE HANDLER - CORRIGIDO
  //====================================================================
  async handleMessage(connectionId: string, message: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) {
      wsLogger.warn('Message received for non-existent connection', { connectionId });
      return;
    }

    try {
      // Validate message format
      const validation = validateWebSocketMessage(message);
      if (!validation.isValid || !validation.message) {
        await this.sendError(connectionId, 'INVALID_MESSAGE', validation.error || 'Invalid message format');
        return;
      }

      const validMessage = validation.message;

      wsLogger.debug('Message received', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        type: validMessage.type,
        roomId: connection.context.roomId,
      });

      // Get and execute handler
      const handler = this.handlers.get(validMessage.type);
      if (!handler) {
        await this.sendError(connectionId, 'UNKNOWN_MESSAGE_TYPE', `Unknown message type: ${validMessage.type}`);
        return;
      }

      await handler(connectionId, validMessage.data || {});

    } catch (error) {
      wsLogger.error('Error handling message', error instanceof Error ? error : new Error('Unknown message error'), {
        connectionId,
        userId: connection.context.userId,
        messageType: message?.type,
      });

      await this.sendError(connectionId, 'HANDLER_ERROR', 'Internal error processing message');
    }
  }

  //====================================================================
  // CONNECTION HANDLERS
  //====================================================================
  private async handlePing(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    try {
      connection.ws.send(JSON.stringify({
        type: 'pong',
        data: { timestamp: Date.now() },
        timestamp: new Date().toISOString(),
      }));
    } catch (error) {
      wsLogger.error('Failed to send pong', error instanceof Error ? error : new Error('Unknown pong error'), { connectionId });
    }
  }

  private async handlePong(connectionId: string, data: any): Promise<void> {
    this.connectionManager.markAlive(connectionId);
  }

  private async handleHeartbeat(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    this.connectionManager.markAlive(connectionId);

    try {
      connection.ws.send(JSON.stringify({
        type: 'heartbeat',
        data: { timestamp: Date.now() },
        timestamp: new Date().toISOString(),
      }));
    } catch (error) {
      wsLogger.error('Failed to send heartbeat response', error instanceof Error ? error : new Error('Unknown heartbeat error'), { connectionId });
    }
  }

  //====================================================================
  // ROOM HANDLERS
  //====================================================================
  private async handleJoinRoom(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const { roomId, asSpectator = false } = data;

    if (!roomId || typeof roomId !== 'string') {
      await this.sendError(connectionId, 'MISSING_ROOM_ID', 'Room ID is required and must be a string');
      return;
    }

    try {
      // Buscar dados reais da sala no banco de dados
      const roomQuery = `
        SELECT r.*, u.username as "hostUsername"
        FROM rooms r
        JOIN users u ON r."hostId" = u.id
        WHERE r.id = $1
      `;
      const roomResult = await pool.query(roomQuery, [roomId]);

      if (roomResult.rows.length === 0) {
        await this.sendError(connectionId, 'ROOM_NOT_FOUND', 'Room not found');
        return;
      }

      const roomData = roomResult.rows[0];

      // Verificar se a sala est√° dispon√≠vel
      if (roomData.status !== 'WAITING') {
        await this.sendError(connectionId, 'ROOM_NOT_JOINABLE', 'Room is not accepting new players');
        return;
      }

      // Join the room channel
      const success = this.channelManager.joinRoom(roomId, connectionId, asSpectator);
      if (!success) {
        await this.sendError(connectionId, 'JOIN_ROOM_FAILED', 'Failed to join room');
        return;
      }

      // Update connection context
      this.connectionManager.updateConnectionContext(connectionId, {
        roomId,
        isSpectator: asSpectator,
      });

      // Get room connections for player list
      const roomConnections = this.channelManager.getRoomPlayerConnections(roomId);
      const spectatorConnections = this.channelManager.getRoomSpectatorConnections(roomId);

      const players: any[] = [];
      const spectators: any[] = [];

      // Build player list com dados reais
      for (const connId of roomConnections) {
        const conn = this.connectionManager.getConnection(connId);
        if (conn) {
          players.push({
            id: `${roomId}-${conn.context.userId}`,
            userId: conn.context.userId,
            username: conn.context.username,
            avatar: null,
            isHost: roomData.hostId === conn.context.userId,
            isReady: this.channelManager.isPlayerReady(roomId, connId),
            isSpectator: false,
            isConnected: true,
            joinedAt: new Date().toISOString(),
          });
        }
      }

      // Build spectator list
      for (const connId of spectatorConnections) {
        const conn = this.connectionManager.getConnection(connId);
        if (conn) {
          spectators.push({
            id: `${roomId}-${conn.context.userId}`,
            userId: conn.context.userId,
            username: conn.context.username,
            avatar: null,
            isSpectator: true,
            isConnected: true,
            joinedAt: new Date().toISOString(),
          });
        }
      }

      // Criar objeto para o jogador que est√° entrando
      const playerForSelf = {
        id: `${roomId}-${connection.context.userId}`,
        userId: connection.context.userId,
        username: connection.context.username,
        avatar: null,
        isHost: roomData.hostId === connection.context.userId,
        isReady: this.channelManager.isPlayerReady(roomId, connectionId),
        isSpectator: asSpectator,
        isConnected: true,
        joinedAt: new Date().toISOString(),
      };

      // Send room-joined event com dados reais do banco
      await this.sendToConnection(connectionId, 'room-joined', {
        room: {
          id: roomData.id,
          name: roomData.name,
          code: roomData.code,
          isPrivate: roomData.isPrivate,
          maxPlayers: roomData.maxPlayers,
          maxSpectators: roomData.maxSpectators,
          status: roomData.status,
          hostId: roomData.hostId,
          hostUsername: roomData.hostUsername,
          currentPlayers: players.length,
          currentSpectators: spectators.length,
          serverId: roomData.serverId,
          createdAt: roomData.createdAt,
          updatedAt: roomData.updatedAt,
        },
        players,
        spectators,
        player: playerForSelf,
        yourRole: asSpectator ? 'SPECTATOR' : (playerForSelf.isHost ? 'HOST' : 'PLAYER'),
      });

      // Broadcast player-joined to other room members
      if (this.broadcastToRoom) {
        this.broadcastToRoom(roomId, 'player-joined', { player: playerForSelf }, connectionId);
      }

      // Publish event to event bus
      await this.eventBus.publish('room:player-joined', {
        roomId,
        userId: connection.context.userId,
        username: connection.context.username,
        asSpectator,
        timestamp: new Date().toISOString(),
      });

      wsLogger.info('Player joined room with real data', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId,
        roomName: roomData.name,
        hostId: roomData.hostId,
        isHost: playerForSelf.isHost,
        asSpectator,
      });

    } catch (error) {
      wsLogger.error('Error joining room', error instanceof Error ? error : new Error('Unknown join room error'), {
        connectionId,
        roomId,
        asSpectator,
      });

      await this.sendError(connectionId, 'JOIN_ROOM_FAILED', 'Internal error joining room');
    }
  }

  private async handleLeaveRoom(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const roomId: string | undefined = data?.roomId || connection.context.roomId;
    if (!roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Not currently in a room');
      return;
    }

    try {
      // Leave the room channel
      const success = this.channelManager.leaveRoom(roomId, connectionId);
      if (!success) {
        await this.sendError(connectionId, 'LEAVE_ROOM_FAILED', 'Failed to leave room');
        return;
      }

      // Update connection context
      this.connectionManager.updateConnectionContext(connectionId, {
        roomId: undefined,
        isSpectator: false,
      });

      // Send room-left confirmation
      await this.sendToConnection(connectionId, 'room-left', { roomId });

      // Broadcast player-left to remaining room members
      if (this.broadcastToRoom) {
        this.broadcastToRoom(roomId, 'player-left', {
          userId: connection.context.userId,
          username: connection.context.username,
        }, connectionId);
      }

      // Publish event to event bus
      await this.eventBus.publish('room:player-left', {
        roomId,
        userId: connection.context.userId,
        username: connection.context.username,
        timestamp: new Date().toISOString(),
      });

      wsLogger.info('Player left room', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId,
      });

    } catch (error) {
      wsLogger.error('Error leaving room', error instanceof Error ? error : new Error('Unknown leave room error'), {
        connectionId,
        roomId,
      });

      await this.sendError(connectionId, 'LEAVE_ROOM_FAILED', 'Internal error leaving room');
    }
  }

  private async handlePlayerReady(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to set ready status');
      return;
    }

    const { ready } = data;
    if (typeof ready !== 'boolean') {
      await this.sendError(connectionId, 'INVALID_MESSAGE', 'Ready status must be boolean');
      return;
    }

    try {
      const roomId = connection.context.roomId;

      this.channelManager.setPlayerReadyStatus(roomId, connectionId, ready);

      // Broadcast ready status to room
      if (this.broadcastToRoom) {
        this.broadcastToRoom(roomId, 'player-ready', {
          userId: connection.context.userId,
          username: connection.context.username,
          ready,
        });
      }

      // Publish event to event bus
      await this.eventBus.publish('room:player-ready', {
        roomId,
        userId: connection.context.userId,
        username: connection.context.username,
        ready,
        timestamp: new Date().toISOString(),
      });

      wsLogger.info('Player ready status changed', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId,
        ready,
      });

    } catch (error) {
      wsLogger.error('Error updating ready status', error instanceof Error ? error : new Error('Unknown ready status error'), {
        connectionId,
        ready,
      });

      await this.sendError(connectionId, 'READY_UPDATE_FAILED', 'Failed to update ready status');
    }
  }

  // ‚úÖ CORRE√á√ÉO: handleStartGame usando configura√ß√µes centralizadas
  private async handleStartGame(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to start game');
      return;
    }

    const roomId = connection.context.roomId;
    const gameId = `game-${roomId}`;

    try {
      wsLogger.info('Starting game process', {
        connectionId,
        roomId,
        gameId,
        hostId: connection.context.userId
      });

      // Verificar se √© o host
      const roomQuery = await pool.query(`SELECT * FROM rooms WHERE id = $1`, [roomId]);
      if (roomQuery.rows.length === 0) {
        await this.sendError(connectionId, 'ROOM_NOT_FOUND', 'Room not found');
        return;
      }

      const roomData = roomQuery.rows[0];
      if (roomData.hostId !== connection.context.userId) {
        await this.sendError(connectionId, 'NOT_HOST', 'Only the host can start the game');
        return;
      }

      // Verificar se jogo j√° existe
      let gameState = await this.gameEngine.getGameState(gameId);

      if (!gameState) {
        wsLogger.info('Creating game with centralized configuration', {
          gameId,
          roomId
        });

        // ‚úÖ CORRE√á√ÉO: Usar configura√ß√µes centralizadas do constants.ts
        // O GameEngine vai ler as dura√ß√µes do constants.ts automaticamente
        const gameConfig = {
          roomId: roomId,
          maxPlayers: roomData.maxPlayers,
          maxSpectators: roomData.maxSpectators,
          // ‚úÖ Importar dura√ß√µes do constants.ts
          nightDuration: GAME_LIMITS.NIGHT_DURATION,
          dayDuration: GAME_LIMITS.DAY_DURATION,
          votingDuration: GAME_LIMITS.VOTING_DURATION,
          allowReconnection: true,
          reconnectionTimeout: 120000,
        };

        gameState = await this.gameEngine.createGame(connection.context.userId, gameConfig);

        wsLogger.info('Game created with centralized durations', {
          gameId: gameState.gameId,
          roomId,
          hostId: connection.context.userId,
          nightDuration: `${gameConfig.nightDuration / 1000}s`,
          dayDuration: `${gameConfig.dayDuration / 1000}s`,
          votingDuration: `${gameConfig.votingDuration / 1000}s`
        });
      }

      // Adicionar jogadores...
      const roomConnections = this.channelManager.getRoomPlayerConnections(roomId);

      for (const connId of roomConnections) {
        const conn = this.connectionManager.getConnection(connId);
        if (conn && !conn.context.isSpectator) {
          const player = new Player({
            id: `${roomId}-${conn.context.userId}`,
            userId: conn.context.userId,
            username: conn.context.username,
            avatar: undefined,
            isHost: roomData.hostId === conn.context.userId,
            isReady: this.channelManager.isPlayerReady(roomId, connId),
            isSpectator: false,
            isConnected: true,
            joinedAt: new Date(),
            lastSeen: new Date(),
          });

          await this.gameEngine.addPlayer(gameId, player);
        }
      }

      // Iniciar o jogo
      const success = await this.gameEngine.startGame(gameId);

      if (!success) {
        const currentState = await this.gameEngine.getGameState(gameId);
        let errorDetails = 'Unknown error';

        if (currentState) {
          const alivePlayers = currentState.getAlivePlayers();
          const hostPlayer = alivePlayers.find(p => p.isHost);
          const nonHostPlayers = alivePlayers.filter(p => !p.isHost);
          const notReadyPlayers = nonHostPlayers.filter(p => !p.isReady);

          errorDetails = `Status: ${currentState.status}, Players: ${alivePlayers.length}, Host: ${hostPlayer ? 'Found' : 'Missing'}, Not Ready: ${notReadyPlayers.map(p => p.username).join(', ')}`;
        }

        wsLogger.error('Failed to start game', {
          gameId,
          roomId,
          errorDetails
        });

        await this.sendError(connectionId, 'START_GAME_FAILED',
          `Failed to start game. ${errorDetails}`
        );
        return;
      }

      wsLogger.info('Game started successfully with centralized configuration', {
        gameId,
        roomId,
        hostId: connection.context.userId
      });

    } catch (error) {
      wsLogger.error('Error starting game', error instanceof Error ? error : new Error('Unknown start game error'), {
        connectionId,
        gameId,
        roomId,
      });

      await this.sendError(connectionId, 'START_GAME_FAILED', 'Internal error starting game');
    }
  }

  //====================================================================
  // GAME HANDLERS
  //====================================================================
  private async handleGetGameState(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const { gameId } = data;
    if (!gameId) {
      await this.sendError(connectionId, 'MISSING_GAME_ID', 'Game ID is required');
      return;
    }

    try {
      const gameState = await this.gameEngine.getGameState(gameId);

      if (!gameState) {
        await this.sendError(connectionId, 'GAME_NOT_FOUND', 'Game not found');
        return;
      }

      const personalizedState = this.getPersonalizedGameState(gameState, connection.context.userId);

      await this.sendToConnection(connectionId, 'game-state', personalizedState);

      wsLogger.info('Game state sent to player', {
        connectionId,
        userId: connection.context.userId,
        gameId,
      });

    } catch (error) {
      wsLogger.error('Error getting game state', error instanceof Error ? error : new Error('Unknown error'), {
        connectionId,
        gameId,
      });

      await this.sendError(connectionId, 'GET_GAME_STATE_FAILED', 'Failed to get game state');
    }
  }

  // ‚úÖ CORRIGIDO: handleGameAction com logs detalhados
  private async handleGameAction(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to perform game actions');
      return;
    }

    const { type, targetId } = data;
    const gameId = `game-${connection.context.roomId}`;

    // ‚úÖ LOGS DETALHADOS para debug das a√ß√µes
    wsLogger.info('Handling game action - DETAILED', {
      connectionId,
      userId: connection.context.userId,
      username: connection.context.username,
      roomId: connection.context.roomId,
      gameId,
      actionType: type,
      targetId,
      timestamp: new Date().toISOString()
    });

    try {
      const gameState = await this.gameEngine.getGameState(gameId);
      if (!gameState) {
        wsLogger.warn('Game action on non-existent game', {
          gameId,
          userId: connection.context.userId,
          actionType: type
        });
        await this.sendError(connectionId, 'GAME_NOT_FOUND', 'Jogo n√£o encontrado');
        return;
      }

      // ‚úÖ LOG do estado do jogo antes da a√ß√£o
      wsLogger.info('Game state before action', {
        gameId,
        phase: gameState.phase,
        day: gameState.day,
        playersCount: gameState.players.length,
        nightActionsCount: gameState.nightActions.length
      });

      const success = await this.gameEngine.performPlayerAction(
        gameId,
        connection.context.userId,
        { type, targetId }
      );

      if (success) {
        wsLogger.info('Game action processed successfully', {
          connectionId,
          gameId,
          userId: connection.context.userId,
          actionType: type,
          targetId,
          result: 'SUCCESS'
        });
      } else {
        wsLogger.warn('Game action failed in GameEngine', {
          connectionId,
          gameId,
          userId: connection.context.userId,
          actionType: type,
          targetId,
          result: 'FAILED'
        });

        await this.sendToConnection(connectionId, 'action-failed', {
          actionType: type,
          error: 'Falha ao executar a√ß√£o'
        });
      }

    } catch (error) {
      wsLogger.error('Error performing game action', error instanceof Error ? error : new Error('Unknown action error'), {
        connectionId,
        action: type,
        targetId,
        gameId
      });
      await this.sendError(connectionId, 'ACTION_FAILED', 'Erro interno ao executar a√ß√£o');
    }
  }

  private async handleVote(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to vote');
      return;
    }

    const { targetId } = data;
    const gameId = `game-${connection.context.roomId}`;

    try {
      const gameState = await this.gameEngine.getGameState(gameId);
      if (!gameState) {
        await this.sendError(connectionId, 'GAME_NOT_FOUND', 'Jogo n√£o encontrado');
        return;
      }

      if (gameState.phase !== 'VOTING') {
        await this.sendError(connectionId, 'INVALID_PHASE', 'Vota√ß√£o s√≥ √© permitida durante a fase de vota√ß√£o');
        return;
      }

      const success = await this.gameEngine.castVote(
        gameId,
        connection.context.userId,
        targetId
      );

      if (success) {
        await this.sendToConnection(connectionId, 'vote-confirmed', {
          message: 'Voto registrado',
          targetId
        });

        // Broadcast vote update to all players in room
        if (this.broadcastToRoom) {
          const voteCounts = Object.fromEntries(gameState.getVoteCounts());
          this.broadcastToRoom(connection.context.roomId, 'voting-update', {
            votes: gameState.votes,
            counts: voteCounts
          });
        }
      } else {
        await this.sendError(connectionId, 'VOTE_FAILED', 'Falha ao registrar voto');
      }

    } catch (error) {
      wsLogger.error('Error casting vote', error instanceof Error ? error : new Error('Unknown vote error'), {
        connectionId,
        targetId,
        gameId
      });
      await this.sendError(connectionId, 'VOTE_FAILED', 'Erro interno ao votar');
    }
  }

  private async handleUnvote(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || !connection.context.roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to unvote');
      return;
    }

    const gameId = `game-${connection.context.roomId}`;

    try {
      const success = await this.gameEngine.removeVote(
        gameId,
        connection.context.userId
      );

      if (success) {
        await this.sendToConnection(connectionId, 'unvote-confirmed', {
          message: 'Voto removido'
        });
      } else {
        await this.sendError(connectionId, 'UNVOTE_FAILED', 'Falha ao remover voto');
      }

    } catch (error) {
      wsLogger.error('Error removing vote', error instanceof Error ? error : new Error('Unknown unvote error'), {
        connectionId,
      });
      await this.sendError(connectionId, 'UNVOTE_FAILED', 'Erro interno ao remover voto');
    }
  }

  //====================================================================
  // PERSONALIZED GAME STATE
  //====================================================================
  private getPersonalizedGameState(gameState: any, userId: string): any {
    const currentPlayer = gameState.players.find((p: any) => p.userId === userId);
    const personalizedState = JSON.parse(JSON.stringify(gameState));

    personalizedState.players = personalizedState.players.map((player: any) => {
      if (player.userId === userId) {
        return player;
      } else if (!player.isAlive) {
        return player;
      } else {
        const { role, faction, ...publicData } = player;
        return publicData;
      }
    });

    if (currentPlayer) {
      personalizedState.me = {
        id: currentPlayer.id,
        userId: currentPlayer.userId,
        username: currentPlayer.username,
        role: currentPlayer.role,
        faction: currentPlayer.faction,
        isAlive: currentPlayer.isAlive,
        isProtected: currentPlayer.isProtected,
        hasActed: currentPlayer.hasActed,
        hasVoted: currentPlayer.hasVoted,
        votedFor: currentPlayer.votedFor,
        actionsUsed: currentPlayer.actionsUsed,
        maxActions: currentPlayer.maxActions,
      };
    }

    return personalizedState;
  }

  //====================================================================
  // ADDITIONAL HANDLERS
  //====================================================================
  private async handleDeleteRoom(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const roomId: string | undefined = data?.roomId || connection.context.roomId;
    if (!roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Not currently in a room');
      return;
    }

    try {
      const roomQuery = `SELECT id, "hostId" FROM rooms WHERE id = $1`;
      const roomResult = await pool.query(roomQuery, [roomId]);

      if (roomResult.rows.length === 0) {
        await this.sendError(connectionId, 'ROOM_NOT_FOUND', 'Room not found');
        return;
      }

      const room = roomResult.rows[0];
      if (room.hostId !== connection.context.userId) {
        await this.sendError(connectionId, 'NOT_HOST', 'Only the host can delete the room');
        return;
      }

      const allRoomConnections = this.channelManager.getRoomConnections(roomId);

      if (this.broadcastToRoom) {
        this.broadcastToRoom(roomId, 'room-deleted', {
          roomId,
          reason: 'Host ended the room',
          timestamp: new Date().toISOString(),
        });
      }

      for (const connId of allRoomConnections) {
        this.channelManager.leaveRoom(roomId, connId);
        this.connectionManager.updateConnectionContext(connId, {
          roomId: undefined,
          isSpectator: false,
        });
      }

      await pool.query(`DELETE FROM rooms WHERE id = $1`, [roomId]);

      await this.eventBus.publish('room:deleted', {
        roomId,
        hostId: connection.context.userId,
        timestamp: new Date().toISOString(),
      });

      wsLogger.info('Room deleted by host', {
        connectionId,
        hostId: connection.context.userId,
        roomId,
        affectedConnections: allRoomConnections.size,
      });

    } catch (error) {
      wsLogger.error('Error deleting room', error instanceof Error ? error : new Error('Unknown delete room error'), {
        connectionId,
        roomId,
      });

      await this.sendError(connectionId, 'DELETE_ROOM_FAILED', 'Internal error deleting room');
    }
  }

  private async handleKickPlayer(connectionId: string, data: any): Promise<void> {
    await this.sendError(connectionId, 'NOT_IMPLEMENTED', 'Kick player not yet implemented');
  }

  // ‚úÖ CORRE√á√ÉO FINAL DO CHAT: handleChatMessage com solu√ß√£o cir√∫rgica
  private async handleChatMessage(connectionId: string, data: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection) return;

    const { message, channel = 'public' } = data;
    const roomId = connection.context.roomId;

    wsLogger.info('Handling chat message - DETAILED', {
      connectionId,
      userId: connection.context.userId,
      username: connection.context.username,
      roomId,
      messageLength: message?.length || 0,
      channel,
      hasRoomId: !!roomId,
      timestamp: new Date().toISOString()
    });

    if (!message || typeof message !== 'string') {
      await this.sendError(connectionId, 'INVALID_MESSAGE', 'Message is required and must be a string');
      return;
    }

    if (!roomId) {
      await this.sendError(connectionId, 'NOT_IN_ROOM', 'Must be in a room to send chat messages');
      return;
    }

    try {
      const chatMessage = {
        id: Date.now().toString(),
        userId: connection.context.userId,
        username: connection.context.username,
        message: message.trim(),
        channel,
        timestamp: new Date().toISOString(),
      };

      wsLogger.info('Chat message created', {
        messageId: chatMessage.id,
        fromUser: chatMessage.username,
        toRoom: roomId,
        channel: chatMessage.channel,
        messagePreview: chatMessage.message.substring(0, 50)
      });

      // ‚úÖ CORRE√á√ÉO CIR√öRGICA: Verificar se √© um jogo em andamento
      const gameId = `game-${roomId}`;
      const gameState = await this.gameEngine.getGameState(gameId);

      if (!gameState) {
        // ‚úÖ SALA DE ESPERA: Usa broadcast normal (J√Å FUNCIONA)
        if (this.broadcastToRoom) {
          const broadcastCount = this.broadcastToRoom(roomId, 'chat-message', { message: chatMessage });
          wsLogger.info('Chat message broadcast to room', {
            messageId: chatMessage.id,
            roomId,
            recipientCount: broadcastCount
          });
        }
      } else {
        // ‚úÖ DURANTE O JOGO: Usa sendToUser para cada jogador (J√Å FUNCIONA)
        let sentCount = 0;
        for (const player of gameState.players) {
          if (this.sendToUser && this.sendToUser(player.userId, 'chat-message', { message: chatMessage })) {
            sentCount++;
          }
        }
        wsLogger.info('Chat message sent to game players', {
          messageId: chatMessage.id,
          gameId,
          sentCount,
          totalPlayers: gameState.players.length
        });
      }

      wsLogger.info('Chat message processed successfully', {
        connectionId,
        userId: connection.context.userId,
        username: connection.context.username,
        roomId,
        messageLength: message.length,
        channel,
      });

    } catch (error) {
      wsLogger.error('Error sending chat message', error instanceof Error ? error : new Error('Unknown chat error'), {
        connectionId,
        roomId,
        message: message.substring(0, 50),
      });

      await this.sendError(connectionId, 'CHAT_FAILED', 'Failed to send chat message');
    }
  }

  private async handleSpectateRoom(connectionId: string, data: any): Promise<void> {
    await this.handleJoinRoom(connectionId, { ...data, asSpectator: true });
  }

  private async handleStopSpectating(connectionId: string, data: any): Promise<void> {
    await this.handleLeaveRoom(connectionId, data);
  }

  //====================================================================
  // UTILITY METHODS
  //====================================================================
  private async sendToConnection(connectionId: string, type: string, data?: any): Promise<void> {
    const connection = this.connectionManager.getConnection(connectionId);
    if (!connection || connection.ws.readyState !== connection.ws.OPEN) {
      return;
    }

    try {
      const message = {
        type,
        data,
        timestamp: new Date().toISOString(),
      };

      connection.ws.send(JSON.stringify(message));
    } catch (error) {
      wsLogger.error('Failed to send message to connection', error instanceof Error ? error : new Error('Unknown send error'), {
        connectionId,
        type,
      });
    }
  }

  private async sendError(connectionId: string, code: WebSocketErrorCode, message: string): Promise<void> {
    await this.sendToConnection(connectionId, 'error', {
      code,
      message,
    });
  }

  //====================================================================
  // HANDLER REGISTRATION (for extensibility)
  //====================================================================
  registerHandler(type: string, handler: MessageHandler): void {
    if (this.handlers.has(type)) {
      wsLogger.warn('Overriding existing message handler', { type });
    }

    this.handlers.set(type, handler);
    wsLogger.debug('Message handler registered', { type });
  }

  unregisterHandler(type: string): boolean {
    const existed = this.handlers.delete(type);
    if (existed) {
      wsLogger.debug('Message handler unregistered', { type });
    }
    return existed;
  }

  getRegisteredHandlers(): string[] {
    return Array.from(this.handlers.keys());
  }
}
</file>

<file path="backend/src/app.ts">
// üê∫ LOBISOMEM ONLINE - App.ts (CORRE√á√ÉO DA INICIALIZA√á√ÉO)
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import morgan from 'morgan';
import http from 'http';
import { config } from '@/config/environment';
import { checkDatabaseHealth } from '@/config/database';
import { checkRedisHealth } from '@/config/redis';
import { ServiceFactory } from '@/websocket/ServiceFactory';
import { WebSocketManager } from '@/websocket/WebSocketManager';
import authRoutes from '@/routes/auth';
import roomRoutes from '@/routes/rooms';

const app = express();

// ‚úÖ CONFIGURA√á√ÉO DE MIDDLEWARES (mantida igual)
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "ws:", "wss:"],
    },
  },
  crossOriginEmbedderPolicy: false,
}));

app.use(cors({
  origin: function (origin, callback) {
    if (!origin) return callback(null, true);

    const allowedOrigins = [
      'http://localhost:3000',
      'http://localhost:3001',
      'https://localhost:3000',
      'https://localhost:3001',
      'https://equipe04.alphaedtech.org.br'
    ];

    if (config.IS_PRODUCTION) {
      allowedOrigins.push('https://equipe04.alphaedtech.org.br');
    }

    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'X-Request-Time',
    'X-Request-ID'
  ],
}));

app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

if (config.IS_DEVELOPMENT) {
  app.use(morgan('dev'));
} else {
  app.use(morgan('combined'));
}

// ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA DA INICIALIZA√á√ÉO ‚úÖ‚úÖ‚úÖ
const httpServer = http.createServer(app);
let wsManager: WebSocketManager;

if (config.IS_MONOLITH || config.IS_GAME_SERVICE) {
  try {
    const gameStateService = ServiceFactory.getGameStateService();
    const eventBus = ServiceFactory.getEventBus();

    // ‚ùå ERRO ANTERIOR:
    // wsManager = new WebSocketManager(gameStateService, eventBus, config);

    // ‚úÖ CORRE√á√ÉO: Ordem correta dos par√¢metros
    wsManager = new WebSocketManager(eventBus, config);
    wsManager.setupWebSocketServer(httpServer);

    // ‚úÖ CORRE√á√ÉO: Inje√ß√£o do channelManager
    app.locals.channelManager = wsManager.channelManager;
    console.log('‚úÖ ChannelManager successfully injected into app.locals');

    // ‚úÖ NOVO: Exportar wsManager para shutdown
    (httpServer as any).wsManager = wsManager;

  } catch (error) {
    console.error('‚ùå Failed to initialize WebSocket:', error);
    throw error;
  }
} else {
  console.log('‚ÑπÔ∏è WebSocket not initialized (not MONOLITH or GAME_SERVICE)');
}

// ‚úÖ ROTAS S√ÉO CARREGADAS DEPOIS
app.use('/api/auth', authRoutes);
app.use('/api/rooms', roomRoutes);

// ‚úÖ HEALTH CHECKS (mantidos iguais)
app.get('/health', async (req, res) => {
  try {
    const dbHealth = await checkDatabaseHealth();
    const redisHealth = await checkRedisHealth();
    const servicesHealth = await ServiceFactory.getServicesHealth();
    const servicesStats = ServiceFactory.getServicesStats();

    const health = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      service: {
        id: config.SERVICE_ID,
        type: config.SERVICE_TYPE,
        mode: config.DISTRIBUTED_MODE ? 'distributed' : 'monolithic',
      },
      database: dbHealth,
      redis: redisHealth,
      services: servicesHealth,
      stats: servicesStats,
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      websocket: {
        initialized: !!wsManager,
        channelManagerInjected: !!app.locals.channelManager,
      },
    };

    let hasUnhealthyService = false;

    if (config.DISTRIBUTED_MODE) {
      hasUnhealthyService = Object.values(servicesHealth).some(
        (service: any) => service.status === 'unhealthy'
      );
    } else {
      const criticalServices = ['gameState'];
      hasUnhealthyService = criticalServices.some(serviceName => {
        const service = servicesHealth[serviceName];
        return service && service.status === 'unhealthy';
      });
    }

    const isSystemHealthy =
      dbHealth.status === 'healthy' &&
      (!config.SHOULD_USE_REDIS || redisHealth.status === 'healthy') &&
      !hasUnhealthyService;

    if (!isSystemHealthy) {
      res.status(503).json(health);
      return;
    }

    res.json(health);
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

app.get('/health/ready', (req, res) => {
  res.json({
    status: 'ready',
    timestamp: new Date().toISOString(),
    service: config.SERVICE_ID,
    websocket: !!wsManager,
  });
});

app.get('/health/live', (req, res) => {
  res.json({
    status: 'alive',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
  });
});

app.get('/health/websocket', async (req, res) => {
  try {
    const servicesHealth = await ServiceFactory.getServicesHealth();
    const servicesStats = ServiceFactory.getServicesStats();

    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: servicesHealth,
      stats: servicesStats,
      wsManager: !!wsManager,
      channelManager: !!app.locals.channelManager,
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'WebSocket health check failed',
    });
  }
});

// ‚úÖ ROOT ENDPOINT (mantido igual)
app.get('/', (req, res) => {
  res.json({
    message: 'üê∫ Werewolf Online API',
    version: '1.0.0',
    phase: config.DISTRIBUTED_MODE ? 'Phase 2 (Distributed)' : 'Phase 1 (Monolithic)',
    service: config.SERVICE_TYPE,
    timestamp: new Date().toISOString(),
    websocket: {
      enabled: config.IS_MONOLITH || config.IS_GAME_SERVICE,
      initialized: !!wsManager,
      path: config.WS_BASE_PATH,
      url: `ws://localhost:${config.PORT}${config.WS_BASE_PATH}`,
    },
    endpoints: {
      health: '/health',
      websocketHealth: '/health/websocket',
      ready: '/health/ready',
      live: '/health/live',
      auth: {
        register: 'POST /api/auth/register',
        login: 'POST /api/auth/login',
        forgotPassword: 'POST /api/auth/forgot-password',
        resetPassword: 'POST /api/auth/reset-password',
        profile: 'GET /api/auth/profile',
        logout: 'POST /api/auth/logout',
      },
      rooms: {
        list: 'GET /api/rooms',
        create: 'POST /api/rooms',
        details: 'GET /api/rooms/:id',
        join: 'POST /api/rooms/:id/join',
        joinByCode: 'POST /api/rooms/join-by-code',
        delete: 'DELETE /api/rooms/:id',
      },
      websocket: {
        connect: `WS ${config.WS_BASE_PATH}`,
        events: [
          'join-room', 'leave-room', 'player-ready', 'start-game',
          'chat-message', 'game-action', 'vote', 'kick-player'
        ],
      },
    },
  });
});

// ‚úÖ ERROR HANDLERS (mantidos iguais)
app.use((req, res, next) => {
  res.status(404).json({
    error: 'Not Found',
    message: `Route ${req.method} ${req.path} not found`,
    timestamp: new Date().toISOString(),
  });
});

app.use((error: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('‚ùå Express Error:', error);

  const isDev = config.IS_DEVELOPMENT;
  res.status(500).json({
    error: 'Internal Server Error',
    message: isDev ? error.message : 'Something went wrong',
    timestamp: new Date().toISOString(),
    ...(isDev && { stack: error.stack }),
  });
});

app.use('/api/rooms', (req, res, next) => {
  console.log('\nüîç DEBUG MIDDLEWARE - ROTA /api/rooms');
  console.log('üìç Timestamp:', new Date().toISOString());
  console.log('üìç Method:', req.method);
  console.log('üìç URL:', req.url);
  console.log('üìç Headers:', JSON.stringify(req.headers, null, 2));
  console.log('üìç Body:', JSON.stringify(req.body, null, 2));
  console.log('üìç ChannelManager Available:', !!req.app.locals.channelManager);

  // Timeout de seguran√ßa para detectar travamentos
  const timeout = setTimeout(() => {
    console.log('‚ùå TIMEOUT: Middleware ou rota travou ap√≥s 10 segundos');
    console.log('‚ùå Request ainda processando:', req.method, req.url);
  }, 10000);

  // Interceptar a resposta para saber quando terminou
  const originalSend = res.send;
  res.send = function (data) {
    clearTimeout(timeout);
    console.log('‚úÖ RESPONSE SENT - Status:', res.statusCode);
    console.log('‚úÖ Response Data Length:', JSON.stringify(data).length);
    return originalSend.call(this, data);
  };

  console.log('üîÑ Passando para pr√≥ximo middleware...\n');
  next();
});

export default httpServer;
</file>

<file path="frontend/src/pages/lobby.tsx">
import { useState, useEffect, useCallback } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/router';
import { motion } from 'framer-motion';

import { useAuth } from '@/context/AuthContext';
import { useSocket } from '@/context/SocketContext';
import { useTheme } from '@/context/ThemeContext';
import Button from '@/components/common/Button';
import LoadingSpinner from '@/components/common/LoadingSpinner';

import CreateRoomModal from '@/components/lobby/CreateRoomModal';
import JoinRoomModal from '@/components/lobby/JoinRoomModal';

import { roomService, RoomListItem } from '@/services/roomService';

// ‚úÖ CORRE√á√ÉO: SafeNumberDisplay √† prova de hidrata√ß√£o
interface SafeNumberDisplayProps {
  value: number;
  className?: string;
}

function SafeNumberDisplay({ value, className = "" }: SafeNumberDisplayProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <span className={className}>{value}</span>;
  }

  return (
    <span className={className}>
      {value.toLocaleString('pt-BR')}
    </span>
  );
}

// ‚úÖ CORRE√á√ÉO: Componente para data/hora seguro
interface SafeDateDisplayProps {
  date: string | Date;
  className?: string;
}

function SafeDateDisplay({ date, className = "" }: SafeDateDisplayProps) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <span className={className}>--:--</span>;
  }

  return (
    <span className={className}>
      {new Date(date).toLocaleTimeString('pt-BR', {
        hour: '2-digit',
        minute: '2-digit'
      })}
    </span>
  );
}

// √çcones SVG
const PlusIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
  </svg>
);

const SearchIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
  </svg>
);

const RefreshIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
  </svg>
);

const UsersIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a4 4 0 11-8 0 4 4 0 018 0z" />
  </svg>
);

const EyeIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
  </svg>
);

const PlayIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.586a1 1 0 01.707.293l2.414 2.414a1 1 0 00.707.293H15M9 10v4a4 4 0 008 0v-4M9 10V9a4 4 0 118 0v1M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
  </svg>
);

const ClockIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const HashIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14" />
  </svg>
);

const LogoutIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
  </svg>
);

const VolumeIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 14.142M8.586 6L5 10H3a1 1 0 00-1 1v2a1 1 0 001 1h2l3.586 4a1 1 0 001.414-1.414L8.586 6z" />
  </svg>
);

const VolumeOffIcon = () => (
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.586 5.586L12 12m0 0l6.414 6.414M12 12L5.586 18.414M12 12l6.414-6.414M8.586 6L5 10H3a1 1 0 00-1 1v2a1 1 0 001 1h2l3.586 4a1 1 0 001.414-1.414L8.586 6z" />
  </svg>
);

function LobbyPage() {
  const router = useRouter();
  const { user, isAuthenticated, isLoading: isAuthLoading, logout } = useAuth();
  const { isConnected } = useSocket();
  const { playSound, playMusic, stopMusic, getPhaseColors, getThemeClass } = useTheme();

  // ‚úÖ Aplicar cores din√¢micas do tema
  const phaseColors = getPhaseColors();

  const [rooms, setRooms] = useState<RoomListItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterStatus, setFilterStatus] = useState<'ALL' | 'WAITING' | 'PLAYING'>('ALL');
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showJoinCodeModal, setShowJoinCodeModal] = useState(false);
  const [musicStarted, setMusicStarted] = useState(false);
  const [isMusicPlaying, setIsMusicPlaying] = useState(false);

  useEffect(() => {
    if (!isAuthLoading && !isAuthenticated) {
      router.push('/auth/login');
      return;
    }
  }, [isAuthLoading, isAuthenticated, router]);

  useEffect(() => {
    if (!isAuthLoading && isAuthenticated && !musicStarted) {
      console.log('üéµ Iniciando m√∫sica do lobby...');
      const musicOptions = ['medieval_tavern01', 'medieval_tavern02', 'medieval_tavern03'];
      const randomMusic = musicOptions[Math.floor(Math.random() * musicOptions.length)];
      if (randomMusic) {
        playMusic(randomMusic);
        setIsMusicPlaying(true);
      }
      setMusicStarted(true);
    }
  }, [isAuthLoading, isAuthenticated, musicStarted, playMusic]);

  useEffect(() => {
    return () => {
      if (musicStarted) {
        console.log('üéµ Parando m√∫sica do lobby...');
        stopMusic();
      }
    };
  }, [musicStarted, stopMusic]);

  const fetchRooms = useCallback(async () => {
    try {
      setLoading(true);
      const roomsList = await roomService.listPublicRooms();
      setRooms(roomsList);
    } catch (error) {
      console.error('Failed to fetch rooms:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    if (isAuthLoading || !isAuthenticated) return;
    fetchRooms();
  }, [isAuthLoading, isAuthenticated, fetchRooms]);

  useEffect(() => {
    if (isAuthLoading || !isAuthenticated) return;

    const interval = setInterval(() => {
      fetchRooms();
    }, 5000);

    return () => clearInterval(interval);
  }, [isAuthLoading, isAuthenticated, fetchRooms]);

  const filteredRooms = rooms.filter(room => {
    const matchesSearch = room.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      room.hostUsername.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = filterStatus === 'ALL' || room.status === filterStatus;
    return matchesSearch && matchesFilter && !room.isPrivate;
  });

  const handleJoinRoom = useCallback((roomId: string) => {
    console.log('üö™ Joining room:', roomId);
    playSound('button_click');
    router.push(`/room/${roomId}`);
  }, [router, playSound]);

  const handleSpectateRoom = useCallback((roomId: string) => {
    console.log('üëÅÔ∏è Spectating room:', roomId);
    playSound('button_click');
    router.push(`/room/${roomId}?spectate=true`);
  }, [router, playSound]);

  const handleCreateRoom = useCallback(() => {
    console.log('üèóÔ∏è Opening create room modal');
    playSound('button_click');
    setShowCreateModal(true);
  }, [playSound]);

  const handleJoinByCode = useCallback(() => {
    console.log('üîë Opening join by code modal');
    playSound('button_click');
    setShowJoinCodeModal(true);
  }, [playSound]);

  const handleRefresh = useCallback(() => {
    console.log('üîÑ Refreshing room list');
    playSound('button_click');
    fetchRooms();
  }, [playSound, fetchRooms]);

  const handleLogout = useCallback(() => {
    console.log('üö™ Logging out...');
    playSound('button_click');
    logout();
    router.push('/auth/login');
  }, [logout, router, playSound]);

  const toggleMusic = useCallback(() => {
    if (isMusicPlaying) {
      stopMusic();
      setIsMusicPlaying(false);
    } else {
      const musicOptions = ['medieval_tavern01', 'medieval_tavern02', 'medieval_tavern03'];
      const randomMusic = musicOptions[Math.floor(Math.random() * musicOptions.length)];
      if (randomMusic) {
        playMusic(randomMusic);
        setIsMusicPlaying(true);
      }
    }
    playSound('button_click');
  }, [isMusicPlaying, stopMusic, playMusic, playSound]);

  if (isAuthLoading) {
    return (
      <>
        <Head>
          <title>Lobby - Lobisomem Online</title>
        </Head>
        <div className={`min-h-screen transition-all duration-300 bg-gradient-to-br ${phaseColors.background} ${getThemeClass()}`}>
          <div className="flex justify-center items-center min-h-screen">
            <LoadingSpinner
              variant="medieval"
              size="xl"
              text="Verificando autentica√ß√£o..."
            />
          </div>
        </div>
      </>
    );
  }

  if (!isAuthenticated) {
    return null;
  }

  return (
    <>
      <Head>
        <title>Lobby - Werewolf</title>
        <meta name="description" content="Encontre e participe de partidas de Werewolf" />
      </Head>

      <div className={`min-h-screen transition-all duration-300 bg-gradient-to-br ${phaseColors.background} ${getThemeClass()}`}>
        {/* Header Simplificado */}
        <header className="bg-medieval-800/50 border-b border-medieval-600 backdrop-blur-sm">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="flex items-center justify-between h-16">
              {/* Logo/Brand */}
              <div className="flex items-center">
                <h1 className="text-2xl font-medieval text-glow">
                  üê∫ Werewolf Online
                </h1>
              </div>

              {/* User Info + Actions */}
              <div className="flex items-center gap-4">
                {/* User Info */}
                <div className="flex items-center gap-3 bg-medieval-700/50 rounded-lg px-4 py-2 border border-medieval-600">
                  <div className="w-8 h-8 bg-salem-500 rounded-full flex items-center justify-center text-white font-bold">
                    {user?.username?.[0]?.toUpperCase() || 'U'}
                  </div>
                  <span className="text-white font-medium">
                    {user?.username || 'Jogador'}
                  </span>
                </div>

                {/* Music Toggle */}
                <Button
                  variant="ghost"
                  size="md"
                  onClick={toggleMusic}
                  className="text-white hover:text-salem-400"
                  {...{ title: isMusicPlaying ? 'Desligar m√∫sica' : 'Ligar m√∫sica' } as any}
                >
                  {isMusicPlaying ? <VolumeIcon /> : <VolumeOffIcon />}
                </Button>

                {/* Logout */}
                <Button
                  variant="secondary"
                  size="md"
                  onClick={handleLogout}
                  className="flex items-center gap-2"
                >
                  <LogoutIcon />
                  <span>Sair</span>
                </Button>
              </div>
            </div>
          </div>
        </header>

        {/* Main Content */}
        <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="space-y-6">
            {/* Welcome Section */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              className="text-center"
            >
              <h2 className="text-3xl font-medieval text-glow mb-4">
                üèòÔ∏è Lobby Principal
              </h2>
              <p className="text-white/70 text-lg">
                Bem-vindo de volta, {user?.username || 'Jogador'}! Encontre uma partida ou crie sua pr√≥pria sala.
              </p>
            </motion.div>

            {/* Action Buttons */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.1 }}
              className="flex flex-wrap justify-center gap-4"
            >
              <Button
                variant="medieval"
                size="lg"
                onClick={handleCreateRoom}
                className="min-w-[200px]"
              >
                <PlusIcon />
                <span>Criar Sala</span>
              </Button>

              <Button
                variant="secondary"
                size="lg"
                onClick={handleJoinByCode}
                className="min-w-[200px]"
              >
                <HashIcon />
                <span>Entrar por C√≥digo</span>
              </Button>

              <Button
                variant="ghost"
                size="lg"
                onClick={handleRefresh}
                disabled={loading}
              >
                <RefreshIcon />
              </Button>
            </motion.div>

            {/* Search and Filters */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
              className="flex flex-col sm:flex-row gap-4 max-w-4xl mx-auto"
            >
              <div className="flex-1 relative">
                <div className="absolute left-3 top-1/2 transform -translate-y-1/2 text-white/50">
                  <SearchIcon />
                </div>
                <input
                  type="text"
                  placeholder="Buscar salas..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="w-full pl-10 pr-4 py-3 bg-medieval-800/50 border border-medieval-600 rounded-lg text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-salem-400 focus:border-transparent"
                />
              </div>

              <div className="flex gap-2">
                {(['ALL', 'WAITING', 'PLAYING'] as const).map((filter) => (
                  <Button
                    key={filter}
                    variant={filterStatus === filter ? 'primary' : 'ghost'}
                    size="md"
                    onClick={() => setFilterStatus(filter)}
                  >
                    {filter === 'ALL' ? 'Todas' : filter === 'WAITING' ? 'Aguardando' : 'Em Jogo'}
                  </Button>
                ))}
              </div>
            </motion.div>

            {/* Rooms List */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.3 }}
              className="max-w-6xl mx-auto"
            >
              {loading ? (
                <div className="flex justify-center py-12">
                  <LoadingSpinner variant="medieval" size="lg" text="Carregando salas..." />
                </div>
              ) : (
                <div className="grid gap-4">
                  {filteredRooms.length > 0 ? (
                    filteredRooms.map((room, index) => (
                      <RoomCard
                        key={room.id}
                        room={room}
                        onJoin={() => handleJoinRoom(room.id)}
                        onSpectate={() => handleSpectateRoom(room.id)}
                        delay={index * 0.05}
                      />
                    ))
                  ) : (
                    <motion.div
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      className="text-center py-12 text-white/60"
                    >
                      <div className="text-6xl mb-4">üèöÔ∏è</div>
                      <h3 className="text-xl font-semibold mb-2">Nenhuma sala encontrada</h3>
                      <p>Tente ajustar os filtros ou criar uma nova sala.</p>
                    </motion.div>
                  )}
                </div>
              )}
            </motion.div>
          </div>
        </main>

        {/* Modals */}
        <CreateRoomModal
          isOpen={showCreateModal}
          onClose={() => setShowCreateModal(false)}
        />

        <JoinRoomModal
          isOpen={showJoinCodeModal}
          onClose={() => setShowJoinCodeModal(false)}
        />
      </div>
    </>
  );
}

// Room Card Component
interface RoomCardProps {
  room: RoomListItem;
  onJoin: () => void;
  onSpectate: () => void;
  delay?: number;
}

function RoomCard({ room, onJoin, onSpectate, delay = 0 }: RoomCardProps) {
  const canJoin = room.status === 'WAITING' && room.currentPlayers < room.maxPlayers;
  const canSpectate = room.currentSpectators < room.maxSpectators;

  const getStatusColor = () => {
    switch (room.status) {
      case 'WAITING': return 'text-green-400 bg-green-900/30 border-green-500/30';
      case 'PLAYING': return 'text-yellow-400 bg-yellow-900/30 border-yellow-500/30';
      case 'FINISHED': return 'text-gray-400 bg-gray-900/30 border-gray-500/30';
    }
  };

  const getStatusText = () => {
    switch (room.status) {
      case 'WAITING': return 'Aguardando';
      case 'PLAYING': return 'Em Jogo';
      case 'FINISHED': return 'Finalizada';
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay }}
      whileHover={{ scale: 1.02 }}
      className="bg-medieval-800/30 border border-medieval-600 rounded-lg p-4 hover:border-salem-500/50 transition-all"
    >
      <div className="flex items-center justify-between">
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-3 mb-2">
            <h3 className="font-semibold text-white truncate">{room.name}</h3>

            {room.isPrivate && (
              <span className="text-yellow-400">üîí</span>
            )}

            <div className={`px-2 py-1 rounded text-xs border ${getStatusColor()}`}>
              {getStatusText()}
            </div>
          </div>

          <div className="flex items-center flex-wrap gap-x-4 gap-y-1 text-sm text-white/70">
            <div className="flex items-center gap-1">
              <UsersIcon />
              <span>
                <SafeNumberDisplay value={room.currentPlayers} />
                /
                <SafeNumberDisplay value={room.maxPlayers} />
              </span>
            </div>

            <div className="flex items-center gap-1">
              <EyeIcon />
              <span>
                <SafeNumberDisplay value={room.currentSpectators} />
                /
                <SafeNumberDisplay value={room.maxSpectators} />
              </span>
            </div>

            <div className="flex items-center gap-1">
              <span>Host: {room.hostUsername}</span>
            </div>

            <div className="flex items-center gap-1">
              <ClockIcon />
              <SafeDateDisplay date={room.createdAt} />
            </div>
          </div>
        </div>

        <div className="flex gap-2 ml-4">
          {canSpectate && (
            <Button
              variant="ghost"
              size="sm"
              onClick={onSpectate}
            >
              <EyeIcon />
            </Button>
          )}

          <Button
            variant={canJoin ? 'primary' : 'secondary'}
            size="sm"
            onClick={onJoin}
            disabled={!canJoin && !canSpectate}
          >
            <PlayIcon />
            <span>
              {canJoin ? 'Entrar' : room.status === 'PLAYING' ? 'Assistir' : 'Lotada'}
            </span>
          </Button>
        </div>
      </div>
    </motion.div>
  );
}

export default LobbyPage;
</file>

</files>
